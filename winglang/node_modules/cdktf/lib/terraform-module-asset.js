"use strict";
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.findLowestCommonPath = exports.TerraformModuleAsset = void 0;
const constructs_1 = require("constructs");
const path = require("path");
const os = require("os");
const fs = require("fs");
const terraform_stack_1 = require("./terraform-stack");
const terraform_asset_1 = require("./terraform-asset");
const fs_1 = require("./private/fs");
const TERRAFORM_MODULE_ASSET_SYMBOL = Symbol.for("cdktf.TerraformModuleAsset");
/**
 * This Construct is being created as a singleton whenever the first
 * TerraformModule with a local source is created in a stack.
 *
 * When Terraform modules depend on local modules, the local modules
 * they depend on need to have the correct relative path to the module
 * in the asset. This only works if all modules are in one asset.
 *
 * (We could theoretically detect if a module uses relative path references, but this is easier)
 * @internal
 */
class TerraformModuleAsset extends constructs_1.Construct {
    constructor(scope, id) {
        super(scope, id);
        const relativeModules = this.node.tryGetContext("cdktfRelativeModules");
        const staticModuleAssetHash = this.node.tryGetContext("cdktfStaticModuleAssetHash");
        if (!relativeModules) {
            throw new Error("You are trying to use a local module with a relative path, but the cdktfRelativeModules context is not set. It is expected to be an array of strings containing the relative paths to the relative modules your app is using. You either need to supply it in the Apps constructor via the context option or invoke the synthesis through the CLI. We need this information so that assets with relative paths are properly handled when used with assets, so you can also set the skipAssetCreationFromLocalModules to true on your relative modules.");
        }
        const moduleSources = relativeModules.map((module) => typeof module === "string" ? module : module.source);
        const relativeAssetPath = findLowestCommonPath(moduleSources);
        if (!relativeAssetPath) {
            throw new Error("Could not find lowest common path for relative modules. This should not happen, you might be overwriting the cdktfRelativeModules value of the context with something unexpected. We expect an array of string or objects with a source attribute where the string or the source attribute reference a relative path to a module. The context can be set in the context option of the App Constructor Options.");
        }
        this.relativeAssetPath = relativeAssetPath;
        // Create a tmp dir for the asset
        const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), "cdktf-module-asset-"));
        // Copy all modules into the tmp dir
        for (const module of moduleSources) {
            const target = path.join(tmpDir, this.relativeModulePath(module));
            copySync(module, target);
        }
        // Create asset based on tmp dir
        this.asset = new terraform_asset_1.TerraformAsset(this, "asset", {
            path: tmpDir,
            type: terraform_asset_1.AssetType.DIRECTORY,
            assetHash: staticModuleAssetHash ?? (0, fs_1.hashPath)(relativeAssetPath),
        });
    }
    static of(construct) {
        const stack = terraform_stack_1.TerraformStack.of(construct);
        let asset = stack[TERRAFORM_MODULE_ASSET_SYMBOL];
        if (!asset) {
            asset = new TerraformModuleAsset(stack, "__cdktf_module_asset");
            Object.defineProperty(stack, TERRAFORM_MODULE_ASSET_SYMBOL, {
                value: asset,
                configurable: false,
                enumerable: false,
            });
        }
        return asset;
    }
    /**
     * The input source is relative to cwd, but we want the value relative
     * to the assets target, so the common path prefix
     */
    relativeModulePath(source) {
        const absoluteSourcePath = path.resolve(source);
        const absoluteAssetPath = path.resolve(this.relativeAssetPath);
        return path.relative(absoluteAssetPath, absoluteSourcePath);
    }
    getAssetPathForModule(source) {
        return `./${path.join(this.asset.path, this.relativeModulePath(source))}`;
    }
}
exports.TerraformModuleAsset = TerraformModuleAsset;
/**
 * Finds the lowest common path of all relaticve paths in the given array
 */
function findLowestCommonPath(paths) {
    if (paths.length === 0) {
        return undefined;
    }
    // We first need to make the paths absolute so that we can compare them
    const absolutePaths = paths.map((p) => path.resolve(p));
    // We take the first path as the base and then remove parts from the end until we find the lowest common path
    let absolutePathPrefix = absolutePaths[0];
    while (!absolutePaths.every((p) => p.startsWith(absolutePathPrefix)) &&
        absolutePathPrefix !== "/") {
        absolutePathPrefix = path.dirname(absolutePathPrefix);
    }
    const relativePath = path.relative(process.cwd(), absolutePathPrefix);
    return relativePath === "" ? "." : relativePath;
}
exports.findLowestCommonPath = findLowestCommonPath;
/**
 * Copies a file or directory recursively
 * @param from
 * @param to
 */
function copySync(from, to) {
    if (fs.lstatSync(from).isDirectory()) {
        fs.mkdirSync(to, { recursive: true });
        for (const file of fs.readdirSync(from)) {
            copySync(path.join(from, file), path.join(to, file));
        }
    }
    else {
        fs.copyFileSync(from, to);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVycmFmb3JtLW1vZHVsZS1hc3NldC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInRlcnJhZm9ybS1tb2R1bGUtYXNzZXQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7R0FHRzs7O0FBRUgsMkNBQXVDO0FBQ3ZDLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLHVEQUFtRDtBQUNuRCx1REFBOEQ7QUFDOUQscUNBQXdDO0FBRXhDLE1BQU0sNkJBQTZCLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDO0FBRS9FOzs7Ozs7Ozs7O0dBVUc7QUFDSCxNQUFhLG9CQUFxQixTQUFRLHNCQUFTO0lBR2pELFlBQVksS0FBZ0IsRUFBRSxFQUFVO1FBQ3RDLEtBQUssQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFFakIsTUFBTSxlQUFlLEdBQ25CLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLHNCQUFzQixDQUFDLENBQUM7UUFDbEQsTUFBTSxxQkFBcUIsR0FBdUIsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQ3ZFLDRCQUE0QixDQUM3QixDQUFDO1FBRUYsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO1lBQ3JCLE1BQU0sSUFBSSxLQUFLLENBQ2Isd2hCQUF3aEIsQ0FDemhCLENBQUM7UUFDSixDQUFDO1FBRUQsTUFBTSxhQUFhLEdBQUcsZUFBZSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQ25ELE9BQU8sTUFBTSxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUNwRCxDQUFDO1FBRUYsTUFBTSxpQkFBaUIsR0FBRyxvQkFBb0IsQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUM5RCxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztZQUN2QixNQUFNLElBQUksS0FBSyxDQUNiLGdaQUFnWixD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QixDQUFDO1FBQ0Qsa0JBQWtCLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0lBQ3hELENBQUM7SUFFRCxNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsRUFBRSxrQkFBa0IsQ0FBQyxDQUFDO0lBQ3RFLE9BQU8sWUFBWSxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUM7QUFDbEQsQ0FBQztBQW5CRCxvREFtQkM7QUFFRDs7OztHQUlHO0FBQ0gsU0FBUyxRQUFRLENBQUMsSUFBWSxFQUFFLEVBQVU7SUFDeEMsSUFBSSxFQUFFLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLFdBQVcsRUFBRSxFQUFFLENBQUM7UUFDckMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztRQUN0QyxLQUFLLE1BQU0sSUFBSSxJQUFJLEVBQUUsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQztZQUN4QyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUN2RCxDQUFDO0lBQ0gsQ0FBQztTQUFNLENBQUM7UUFDTixFQUFFLENBQUMsWUFBWSxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQztJQUM1QixDQUFDO0FBQ0gsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBIYXNoaUNvcnAsIEluYy5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNUEwtMi4wXG4gKi9cblxuaW1wb3J0IHsgQ29uc3RydWN0IH0gZnJvbSBcImNvbnN0cnVjdHNcIjtcbmltcG9ydCAqIGFzIHBhdGggZnJvbSBcInBhdGhcIjtcbmltcG9ydCAqIGFzIG9zIGZyb20gXCJvc1wiO1xuaW1wb3J0ICogYXMgZnMgZnJvbSBcImZzXCI7XG5pbXBvcnQgeyBUZXJyYWZvcm1TdGFjayB9IGZyb20gXCIuL3RlcnJhZm9ybS1zdGFja1wiO1xuaW1wb3J0IHsgQXNzZXRUeXBlLCBUZXJyYWZvcm1Bc3NldCB9IGZyb20gXCIuL3RlcnJhZm9ybS1hc3NldFwiO1xuaW1wb3J0IHsgaGFzaFBhdGggfSBmcm9tIFwiLi9wcml2YXRlL2ZzXCI7XG5cbmNvbnN0IFRFUlJBRk9STV9NT0RVTEVfQVNTRVRfU1lNQk9MID0gU3ltYm9sLmZvcihcImNka3RmLlRlcnJhZm9ybU1vZHVsZUFzc2V0XCIpO1xuXG4vKipcbiAqIFRoaXMgQ29uc3RydWN0IGlzIGJlaW5nIGNyZWF0ZWQgYXMgYSBzaW5nbGV0b24gd2hlbmV2ZXIgdGhlIGZpcnN0XG4gKiBUZXJyYWZvcm1Nb2R1bGUgd2l0aCBhIGxvY2FsIHNvdXJjZSBpcyBjcmVhdGVkIGluIGEgc3RhY2suXG4gKlxuICogV2hlbiBUZXJyYWZvcm0gbW9kdWxlcyBkZXBlbmQgb24gbG9jYWwgbW9kdWxlcywgdGhlIGxvY2FsIG1vZHVsZXNcbiAqIHRoZXkgZGVwZW5kIG9uIG5lZWQgdG8gaGF2ZSB0aGUgY29ycmVjdCByZWxhdGl2ZSBwYXRoIHRvIHRoZSBtb2R1bGVcbiAqIGluIHRoZSBhc3NldC4gVGhpcyBvbmx5IHdvcmtzIGlmIGFsbCBtb2R1bGVzIGFyZSBpbiBvbmUgYXNzZXQuXG4gKlxuICogKFdlIGNvdWxkIHRoZW9yZXRpY2FsbHkgZGV0ZWN0IGlmIGEgbW9kdWxlIHVzZXMgcmVsYXRpdmUgcGF0aCByZWZlcmVuY2VzLCBidXQgdGhpcyBpcyBlYXNpZXIpXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNsYXNzIFRlcnJhZm9ybU1vZHVsZUFzc2V0IGV4dGVuZHMgQ29uc3RydWN0IHtcbiAgcHJpdmF0ZSByZWFkb25seSByZWxhdGl2ZUFzc2V0UGF0aDogc3RyaW5nO1xuICBwcml2YXRlIHJlYWRvbmx5IGFzc2V0OiBUZXJyYWZvcm1Bc3NldDtcbiAgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZykge1xuICAgIHN1cGVyKHNjb3BlLCBpZCk7XG5cbiAgICBjb25zdCByZWxhdGl2ZU1vZHVsZXM6IEFycmF5PHN0cmluZyB8IHsgc291cmNlOiBzdHJpbmcgfT4gfCB1bmRlZmluZWQgPVxuICAgICAgdGhpcy5ub2RlLnRyeUdldENvbnRleHQoXCJjZGt0ZlJlbGF0aXZlTW9kdWxlc1wiKTtcbiAgICBjb25zdCBzdGF0aWNNb2R1bGVBc3NldEhhc2g6IHN0cmluZyB8IHVuZGVmaW5lZCA9IHRoaXMubm9kZS50cnlHZXRDb250ZXh0KFxuICAgICAgXCJjZGt0ZlN0YXRpY01vZHVsZUFzc2V0SGFzaFwiXG4gICAgKTtcblxuICAgIGlmICghcmVsYXRpdmVNb2R1bGVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiWW91IGFyZSB0cnlpbmcgdG8gdXNlIGEgbG9jYWwgbW9kdWxlIHdpdGggYSByZWxhdGl2ZSBwYXRoLCBidXQgdGhlIGNka3RmUmVsYXRpdmVNb2R1bGVzIGNvbnRleHQgaXMgbm90IHNldC4gSXQgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXkgb2Ygc3RyaW5ncyBjb250YWluaW5nIHRoZSByZWxhdGl2ZSBwYXRocyB0byB0aGUgcmVsYXRpdmUgbW9kdWxlcyB5b3VyIGFwcCBpcyB1c2luZy4gWW91IGVpdGhlciBuZWVkIHRvIHN1cHBseSBpdCBpbiB0aGUgQXBwcyBjb25zdHJ1Y3RvciB2aWEgdGhlIGNvbnRleHQgb3B0aW9uIG9yIGludm9rZSB0aGUgc3ludGhlc2lzIHRocm91Z2ggdGhlIENMSS4gV2UgbmVlZCB0aGlzIGluZm9ybWF0aW9uIHNvIHRoYXQgYXNzZXRzIHdpdGggcmVsYXRpdmUgcGF0aHMgYXJlIHByb3Blcmx5IGhhbmRsZWQgd2hlbiB1c2VkIHdpdGggYXNzZXRzLCBzbyB5b3UgY2FuIGFsc28gc2V0IHRoZSBza2lwQXNzZXRDcmVhdGlvbkZyb21Mb2NhbE1vZHVsZXMgdG8gdHJ1ZSBvbiB5b3VyIHJlbGF0aXZlIG1vZHVsZXMuXCJcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgbW9kdWxlU291cmNlcyA9IHJlbGF0aXZlTW9kdWxlcy5tYXAoKG1vZHVsZSkgPT5cbiAgICAgIHR5cGVvZiBtb2R1bGUgPT09IFwic3RyaW5nXCIgPyBtb2R1bGUgOiBtb2R1bGUuc291cmNlXG4gICAgKTtcblxuICAgIGNvbnN0IHJlbGF0aXZlQXNzZXRQYXRoID0gZmluZExvd2VzdENvbW1vblBhdGgobW9kdWxlU291cmNlcyk7XG4gICAgaWYgKCFyZWxhdGl2ZUFzc2V0UGF0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkNvdWxkIG5vdCBmaW5kIGxvd2VzdCBjb21tb24gcGF0aCBmb3IgcmVsYXRpdmUgbW9kdWxlcy4gVGhpcyBzaG91bGQgbm90IGhhcHBlbiwgeW91IG1pZ2h0IGJlIG92ZXJ3cml0aW5nIHRoZSBjZGt0ZlJlbGF0aXZlTW9kdWxlcyB2YWx1ZSBvZiB0aGUgY29udGV4dCB3aXRoIHNvbWV0aGluZyB1bmV4cGVjdGVkLiBXZSBleHBlY3QgYW4gYXJyYXkgb2Ygc3RyaW5nIG9yIG9iamVjdHMgd2l0aCBhIHNvdXJjZSBhdHRyaWJ1dGUgd2hlcmUgdGhlIHN0cmluZyBvciB0aGUgc291cmNlIGF0dHJpYnV0ZSByZWZlcmVuY2UgYSByZWxhdGl2ZSBwYXRoIHRvIGEgbW9kdWxlLiBUaGUgY29udGV4dCBjYW4gYmUgc2V0IGluIHRoZSBjb250ZXh0IG9wdGlvbiBvZiB0aGUgQXBwIENvbnN0cnVjdG9yIE9wdGlvbnMuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMucmVsYXRpdmVBc3NldFBhdGggPSByZWxhdGl2ZUFzc2V0UGF0aDtcblxuICAgIC8vIENyZWF0ZSBhIHRtcCBkaXIgZm9yIHRoZSBhc3NldFxuICAgIGNvbnN0IHRtcERpciA9IGZzLm1rZHRlbXBTeW5jKFxuICAgICAgcGF0aC5qb2luKG9zLnRtcGRpcigpLCBcImNka3RmLW1vZHVsZS1hc3NldC1cIilcbiAgICApO1xuXG4gICAgLy8gQ29weSBhbGwgbW9kdWxlcyBpbnRvIHRoZSB0bXAgZGlyXG4gICAgZm9yIChjb25zdCBtb2R1bGUgb2YgbW9kdWxlU291cmNlcykge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gcGF0aC5qb2luKHRtcERpciwgdGhpcy5yZWxhdGl2ZU1vZHVsZVBhdGgobW9kdWxlKSk7XG4gICAgICBjb3B5U3luYyhtb2R1bGUsIHRhcmdldCk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGFzc2V0IGJhc2VkIG9uIHRtcCBkaXJcbiAgICB0aGlzLmFzc2V0ID0gbmV3IFRlcnJhZm9ybUFzc2V0KHRoaXMsIFwiYXNzZXRcIiwge1xuICAgICAgcGF0aDogdG1wRGlyLFxuICAgICAgdHlwZTogQXNzZXRUeXBlLkRJUkVDVE9SWSxcbiAgICAgIGFzc2V0SGFzaDogc3RhdGljTW9kdWxlQXNzZXRIYXNoID8/IGhhc2hQYXRoKHJlbGF0aXZlQXNzZXRQYXRoKSxcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgb2YoY29uc3RydWN0OiBDb25zdHJ1Y3QpOiBUZXJyYWZvcm1Nb2R1bGVBc3NldCB7XG4gICAgY29uc3Qgc3RhY2sgPSBUZXJyYWZvcm1TdGFjay5vZihjb25zdHJ1Y3QpO1xuXG4gICAgbGV0IGFzc2V0ID0gKHN0YWNrIGFzIGFueSlbVEVSUkFGT1JNX01PRFVMRV9BU1NFVF9TWU1CT0xdO1xuICAgIGlmICghYXNzZXQpIHtcbiAgICAgIGFzc2V0ID0gbmV3IFRlcnJhZm9ybU1vZHVsZUFzc2V0KHN0YWNrLCBcIl9fY2RrdGZfbW9kdWxlX2Fzc2V0XCIpO1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3RhY2ssIFRFUlJBRk9STV9NT0RVTEVfQVNTRVRfU1lNQk9MLCB7XG4gICAgICAgIHZhbHVlOiBhc3NldCxcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFzc2V0O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBpbnB1dCBzb3VyY2UgaXMgcmVsYXRpdmUgdG8gY3dkLCBidXQgd2Ugd2FudCB0aGUgdmFsdWUgcmVsYXRpdmVcbiAgICogdG8gdGhlIGFzc2V0cyB0YXJnZXQsIHNvIHRoZSBjb21tb24gcGF0aCBwcmVmaXhcbiAgICovXG4gIHByaXZhdGUgcmVsYXRpdmVNb2R1bGVQYXRoKHNvdXJjZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCBhYnNvbHV0ZVNvdXJjZVBhdGggPSBwYXRoLnJlc29sdmUoc291cmNlKTtcbiAgICBjb25zdCBhYnNvbHV0ZUFzc2V0UGF0aCA9IHBhdGgucmVzb2x2ZSh0aGlzLnJlbGF0aXZlQXNzZXRQYXRoKTtcbiAgICByZXR1cm4gcGF0aC5yZWxhdGl2ZShhYnNvbHV0ZUFzc2V0UGF0aCwgYWJzb2x1dGVTb3VyY2VQYXRoKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRBc3NldFBhdGhGb3JNb2R1bGUoc291cmNlOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBgLi8ke3BhdGguam9pbih0aGlzLmFzc2V0LnBhdGgsIHRoaXMucmVsYXRpdmVNb2R1bGVQYXRoKHNvdXJjZSkpfWA7XG4gIH1cbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgbG93ZXN0IGNvbW1vbiBwYXRoIG9mIGFsbCByZWxhdGljdmUgcGF0aHMgaW4gdGhlIGdpdmVuIGFycmF5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kTG93ZXN0Q29tbW9uUGF0aChwYXRoczogc3RyaW5nW10pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICBpZiAocGF0aHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8vIFdlIGZpcnN0IG5lZWQgdG8gbWFrZSB0aGUgcGF0aHMgYWJzb2x1dGUgc28gdGhhdCB3ZSBjYW4gY29tcGFyZSB0aGVtXG4gIGNvbnN0IGFic29sdXRlUGF0aHMgPSBwYXRocy5tYXAoKHApID0+IHBhdGgucmVzb2x2ZShwKSk7XG5cbiAgLy8gV2UgdGFrZSB0aGUgZmlyc3QgcGF0aCBhcyB0aGUgYmFzZSBhbmQgdGhlbiByZW1vdmUgcGFydHMgZnJvbSB0aGUgZW5kIHVudGlsIHdlIGZpbmQgdGhlIGxvd2VzdCBjb21tb24gcGF0aFxuICBsZXQgYWJzb2x1dGVQYXRoUHJlZml4ID0gYWJzb2x1dGVQYXRoc1swXTtcbiAgd2hpbGUgKFxuICAgICFhYnNvbHV0ZVBhdGhzLmV2ZXJ5KChwKSA9PiBwLnN0YXJ0c1dpdGgoYWJzb2x1dGVQYXRoUHJlZml4KSkgJiZcbiAgICBhYnNvbHV0ZVBhdGhQcmVmaXggIT09IFwiL1wiXG4gICkge1xuICAgIGFic29sdXRlUGF0aFByZWZpeCA9IHBhdGguZGlybmFtZShhYnNvbHV0ZVBhdGhQcmVmaXgpO1xuICB9XG5cbiAgY29uc3QgcmVsYXRpdmVQYXRoID0gcGF0aC5yZWxhdGl2ZShwcm9jZXNzLmN3ZCgpLCBhYnNvbHV0ZVBhdGhQcmVmaXgpO1xuICByZXR1cm4gcmVsYXRpdmVQYXRoID09PSBcIlwiID8gXCIuXCIgOiByZWxhdGl2ZVBhdGg7XG59XG5cbi8qKlxuICogQ29waWVzIGEgZmlsZSBvciBkaXJlY3RvcnkgcmVjdXJzaXZlbHlcbiAqIEBwYXJhbSBmcm9tXG4gKiBAcGFyYW0gdG9cbiAqL1xuZnVuY3Rpb24gY29weVN5bmMoZnJvbTogc3RyaW5nLCB0bzogc3RyaW5nKSB7XG4gIGlmIChmcy5sc3RhdFN5bmMoZnJvbSkuaXNEaXJlY3RvcnkoKSkge1xuICAgIGZzLm1rZGlyU3luYyh0bywgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgZm9yIChjb25zdCBmaWxlIG9mIGZzLnJlYWRkaXJTeW5jKGZyb20pKSB7XG4gICAgICBjb3B5U3luYyhwYXRoLmpvaW4oZnJvbSwgZmlsZSksIHBhdGguam9pbih0bywgZmlsZSkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmcy5jb3B5RmlsZVN5bmMoZnJvbSwgdG8pO1xuICB9XG59XG4iXX0=