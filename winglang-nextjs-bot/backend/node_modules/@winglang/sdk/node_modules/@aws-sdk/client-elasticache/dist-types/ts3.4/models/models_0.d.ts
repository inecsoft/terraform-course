import { ExceptionOptionType as __ExceptionOptionType } from "@smithy/smithy-client";
import { ElastiCacheServiceException as __BaseException } from "./ElastiCacheServiceException";
export interface Tag {
  Key?: string;
  Value?: string;
}
export interface AddTagsToResourceMessage {
  ResourceName: string | undefined;
  Tags: Tag[] | undefined;
}
export declare class CacheClusterNotFoundFault extends __BaseException {
  readonly name: "CacheClusterNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<CacheClusterNotFoundFault, __BaseException>
  );
}
export declare class CacheParameterGroupNotFoundFault extends __BaseException {
  readonly name: "CacheParameterGroupNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      CacheParameterGroupNotFoundFault,
      __BaseException
    >
  );
}
export declare class CacheSecurityGroupNotFoundFault extends __BaseException {
  readonly name: "CacheSecurityGroupNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      CacheSecurityGroupNotFoundFault,
      __BaseException
    >
  );
}
export declare class CacheSubnetGroupNotFoundFault extends __BaseException {
  readonly name: "CacheSubnetGroupNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<CacheSubnetGroupNotFoundFault, __BaseException>
  );
}
export declare class InvalidARNFault extends __BaseException {
  readonly name: "InvalidARNFault";
  readonly $fault: "client";
  constructor(opts: __ExceptionOptionType<InvalidARNFault, __BaseException>);
}
export declare class InvalidReplicationGroupStateFault extends __BaseException {
  readonly name: "InvalidReplicationGroupStateFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      InvalidReplicationGroupStateFault,
      __BaseException
    >
  );
}
export declare class InvalidServerlessCacheSnapshotStateFault extends __BaseException {
  readonly name: "InvalidServerlessCacheSnapshotStateFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      InvalidServerlessCacheSnapshotStateFault,
      __BaseException
    >
  );
}
export declare class InvalidServerlessCacheStateFault extends __BaseException {
  readonly name: "InvalidServerlessCacheStateFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      InvalidServerlessCacheStateFault,
      __BaseException
    >
  );
}
export declare class ReplicationGroupNotFoundFault extends __BaseException {
  readonly name: "ReplicationGroupNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ReplicationGroupNotFoundFault, __BaseException>
  );
}
export declare class ReservedCacheNodeNotFoundFault extends __BaseException {
  readonly name: "ReservedCacheNodeNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ReservedCacheNodeNotFoundFault, __BaseException>
  );
}
export declare class ServerlessCacheNotFoundFault extends __BaseException {
  readonly name: "ServerlessCacheNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ServerlessCacheNotFoundFault, __BaseException>
  );
}
export declare class ServerlessCacheSnapshotNotFoundFault extends __BaseException {
  readonly name: "ServerlessCacheSnapshotNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      ServerlessCacheSnapshotNotFoundFault,
      __BaseException
    >
  );
}
export declare class SnapshotNotFoundFault extends __BaseException {
  readonly name: "SnapshotNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<SnapshotNotFoundFault, __BaseException>
  );
}
export interface TagListMessage {
  TagList?: Tag[];
}
export declare class TagQuotaPerResourceExceeded extends __BaseException {
  readonly name: "TagQuotaPerResourceExceeded";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<TagQuotaPerResourceExceeded, __BaseException>
  );
}
export declare class UserGroupNotFoundFault extends __BaseException {
  readonly name: "UserGroupNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<UserGroupNotFoundFault, __BaseException>
  );
}
export declare class UserNotFoundFault extends __BaseException {
  readonly name: "UserNotFoundFault";
  readonly $fault: "client";
  constructor(opts: __ExceptionOptionType<UserNotFoundFault, __BaseException>);
}
export interface AllowedNodeTypeModificationsMessage {
  ScaleUpModifications?: string[];
  ScaleDownModifications?: string[];
}
export declare class AuthorizationAlreadyExistsFault extends __BaseException {
  readonly name: "AuthorizationAlreadyExistsFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      AuthorizationAlreadyExistsFault,
      __BaseException
    >
  );
}
export interface AuthorizeCacheSecurityGroupIngressMessage {
  CacheSecurityGroupName: string | undefined;
  EC2SecurityGroupName: string | undefined;
  EC2SecurityGroupOwnerId: string | undefined;
}
export interface EC2SecurityGroup {
  Status?: string;
  EC2SecurityGroupName?: string;
  EC2SecurityGroupOwnerId?: string;
}
export interface CacheSecurityGroup {
  OwnerId?: string;
  CacheSecurityGroupName?: string;
  Description?: string;
  EC2SecurityGroups?: EC2SecurityGroup[];
  ARN?: string;
}
export interface AuthorizeCacheSecurityGroupIngressResult {
  CacheSecurityGroup?: CacheSecurityGroup;
}
export declare class InvalidCacheSecurityGroupStateFault extends __BaseException {
  readonly name: "InvalidCacheSecurityGroupStateFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      InvalidCacheSecurityGroupStateFault,
      __BaseException
    >
  );
}
export declare class InvalidParameterCombinationException extends __BaseException {
  readonly name: "InvalidParameterCombinationException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      InvalidParameterCombinationException,
      __BaseException
    >
  );
}
export declare class InvalidParameterValueException extends __BaseException {
  readonly name: "InvalidParameterValueException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidParameterValueException, __BaseException>
  );
}
export interface BatchApplyUpdateActionMessage {
  ReplicationGroupIds?: string[];
  CacheClusterIds?: string[];
  ServiceUpdateName: string | undefined;
}
export declare class ServiceUpdateNotFoundFault extends __BaseException {
  readonly name: "ServiceUpdateNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ServiceUpdateNotFoundFault, __BaseException>
  );
}
export declare const UpdateActionStatus: {
  readonly COMPLETE: "complete";
  readonly IN_PROGRESS: "in-progress";
  readonly NOT_APPLICABLE: "not-applicable";
  readonly NOT_APPLIED: "not-applied";
  readonly SCHEDULED: "scheduled";
  readonly SCHEDULING: "scheduling";
  readonly STOPPED: "stopped";
  readonly STOPPING: "stopping";
  readonly WAITING_TO_START: "waiting-to-start";
};
export type UpdateActionStatus =
  (typeof UpdateActionStatus)[keyof typeof UpdateActionStatus];
export interface ProcessedUpdateAction {
  ReplicationGroupId?: string;
  CacheClusterId?: string;
  ServiceUpdateName?: string;
  UpdateActionStatus?: UpdateActionStatus;
}
export interface UnprocessedUpdateAction {
  ReplicationGroupId?: string;
  CacheClusterId?: string;
  ServiceUpdateName?: string;
  ErrorType?: string;
  ErrorMessage?: string;
}
export interface UpdateActionResultsMessage {
  ProcessedUpdateActions?: ProcessedUpdateAction[];
  UnprocessedUpdateActions?: UnprocessedUpdateAction[];
}
export interface BatchStopUpdateActionMessage {
  ReplicationGroupIds?: string[];
  CacheClusterIds?: string[];
  ServiceUpdateName: string | undefined;
}
export interface CompleteMigrationMessage {
  ReplicationGroupId: string | undefined;
  Force?: boolean;
}
export declare const AutomaticFailoverStatus: {
  readonly DISABLED: "disabled";
  readonly DISABLING: "disabling";
  readonly ENABLED: "enabled";
  readonly ENABLING: "enabling";
};
export type AutomaticFailoverStatus =
  (typeof AutomaticFailoverStatus)[keyof typeof AutomaticFailoverStatus];
export declare const ClusterMode: {
  readonly COMPATIBLE: "compatible";
  readonly DISABLED: "disabled";
  readonly ENABLED: "enabled";
};
export type ClusterMode = (typeof ClusterMode)[keyof typeof ClusterMode];
export interface Endpoint {
  Address?: string;
  Port?: number;
}
export declare const DataTieringStatus: {
  readonly DISABLED: "disabled";
  readonly ENABLED: "enabled";
};
export type DataTieringStatus =
  (typeof DataTieringStatus)[keyof typeof DataTieringStatus];
export interface GlobalReplicationGroupInfo {
  GlobalReplicationGroupId?: string;
  GlobalReplicationGroupMemberRole?: string;
}
export declare const IpDiscovery: {
  readonly IPV4: "ipv4";
  readonly IPV6: "ipv6";
};
export type IpDiscovery = (typeof IpDiscovery)[keyof typeof IpDiscovery];
export interface CloudWatchLogsDestinationDetails {
  LogGroup?: string;
}
export interface KinesisFirehoseDestinationDetails {
  DeliveryStream?: string;
}
export interface DestinationDetails {
  CloudWatchLogsDetails?: CloudWatchLogsDestinationDetails;
  KinesisFirehoseDetails?: KinesisFirehoseDestinationDetails;
}
export declare const DestinationType: {
  readonly CloudWatchLogs: "cloudwatch-logs";
  readonly KinesisFirehose: "kinesis-firehose";
};
export type DestinationType =
  (typeof DestinationType)[keyof typeof DestinationType];
export declare const LogFormat: {
  readonly JSON: "json";
  readonly TEXT: "text";
};
export type LogFormat = (typeof LogFormat)[keyof typeof LogFormat];
export declare const LogType: {
  readonly ENGINE_LOG: "engine-log";
  readonly SLOW_LOG: "slow-log";
};
export type LogType = (typeof LogType)[keyof typeof LogType];
export declare const LogDeliveryConfigurationStatus: {
  readonly ACTIVE: "active";
  readonly DISABLING: "disabling";
  readonly ENABLING: "enabling";
  readonly ERROR: "error";
  readonly MODIFYING: "modifying";
};
export type LogDeliveryConfigurationStatus =
  (typeof LogDeliveryConfigurationStatus)[keyof typeof LogDeliveryConfigurationStatus];
export interface LogDeliveryConfiguration {
  LogType?: LogType;
  DestinationType?: DestinationType;
  DestinationDetails?: DestinationDetails;
  LogFormat?: LogFormat;
  Status?: LogDeliveryConfigurationStatus;
  Message?: string;
}
export declare const MultiAZStatus: {
  readonly DISABLED: "disabled";
  readonly ENABLED: "enabled";
};
export type MultiAZStatus = (typeof MultiAZStatus)[keyof typeof MultiAZStatus];
export declare const NetworkType: {
  readonly DUAL_STACK: "dual_stack";
  readonly IPV4: "ipv4";
  readonly IPV6: "ipv6";
};
export type NetworkType = (typeof NetworkType)[keyof typeof NetworkType];
export interface NodeGroupMember {
  CacheClusterId?: string;
  CacheNodeId?: string;
  ReadEndpoint?: Endpoint;
  PreferredAvailabilityZone?: string;
  PreferredOutpostArn?: string;
  CurrentRole?: string;
}
export interface NodeGroup {
  NodeGroupId?: string;
  Status?: string;
  PrimaryEndpoint?: Endpoint;
  ReaderEndpoint?: Endpoint;
  Slots?: string;
  NodeGroupMembers?: NodeGroupMember[];
}
export declare const AuthTokenUpdateStatus: {
  readonly ROTATING: "ROTATING";
  readonly SETTING: "SETTING";
};
export type AuthTokenUpdateStatus =
  (typeof AuthTokenUpdateStatus)[keyof typeof AuthTokenUpdateStatus];
export declare const PendingAutomaticFailoverStatus: {
  readonly DISABLED: "disabled";
  readonly ENABLED: "enabled";
};
export type PendingAutomaticFailoverStatus =
  (typeof PendingAutomaticFailoverStatus)[keyof typeof PendingAutomaticFailoverStatus];
export interface PendingLogDeliveryConfiguration {
  LogType?: LogType;
  DestinationType?: DestinationType;
  DestinationDetails?: DestinationDetails;
  LogFormat?: LogFormat;
}
export interface SlotMigration {
  ProgressPercentage?: number;
}
export interface ReshardingStatus {
  SlotMigration?: SlotMigration;
}
export declare const TransitEncryptionMode: {
  readonly PREFERRED: "preferred";
  readonly REQUIRED: "required";
};
export type TransitEncryptionMode =
  (typeof TransitEncryptionMode)[keyof typeof TransitEncryptionMode];
export interface UserGroupsUpdateStatus {
  UserGroupIdsToAdd?: string[];
  UserGroupIdsToRemove?: string[];
}
export interface ReplicationGroupPendingModifiedValues {
  PrimaryClusterId?: string;
  AutomaticFailoverStatus?: PendingAutomaticFailoverStatus;
  Resharding?: ReshardingStatus;
  AuthTokenStatus?: AuthTokenUpdateStatus;
  UserGroups?: UserGroupsUpdateStatus;
  LogDeliveryConfigurations?: PendingLogDeliveryConfiguration[];
  TransitEncryptionEnabled?: boolean;
  TransitEncryptionMode?: TransitEncryptionMode;
  ClusterMode?: ClusterMode;
}
export interface ReplicationGroup {
  ReplicationGroupId?: string;
  Description?: string;
  GlobalReplicationGroupInfo?: GlobalReplicationGroupInfo;
  Status?: string;
  PendingModifiedValues?: ReplicationGroupPendingModifiedValues;
  MemberClusters?: string[];
  NodeGroups?: NodeGroup[];
  SnapshottingClusterId?: string;
  AutomaticFailover?: AutomaticFailoverStatus;
  MultiAZ?: MultiAZStatus;
  ConfigurationEndpoint?: Endpoint;
  SnapshotRetentionLimit?: number;
  SnapshotWindow?: string;
  ClusterEnabled?: boolean;
  CacheNodeType?: string;
  AuthTokenEnabled?: boolean;
  AuthTokenLastModifiedDate?: Date;
  TransitEncryptionEnabled?: boolean;
  AtRestEncryptionEnabled?: boolean;
  MemberClustersOutpostArns?: string[];
  KmsKeyId?: string;
  ARN?: string;
  UserGroupIds?: string[];
  LogDeliveryConfigurations?: LogDeliveryConfiguration[];
  ReplicationGroupCreateTime?: Date;
  DataTiering?: DataTieringStatus;
  AutoMinorVersionUpgrade?: boolean;
  NetworkType?: NetworkType;
  IpDiscovery?: IpDiscovery;
  TransitEncryptionMode?: TransitEncryptionMode;
  ClusterMode?: ClusterMode;
}
export interface CompleteMigrationResponse {
  ReplicationGroup?: ReplicationGroup;
}
export declare class ReplicationGroupNotUnderMigrationFault extends __BaseException {
  readonly name: "ReplicationGroupNotUnderMigrationFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      ReplicationGroupNotUnderMigrationFault,
      __BaseException
    >
  );
}
export interface CopyServerlessCacheSnapshotRequest {
  SourceServerlessCacheSnapshotName: string | undefined;
  TargetServerlessCacheSnapshotName: string | undefined;
  KmsKeyId?: string;
  Tags?: Tag[];
}
export interface ServerlessCacheConfiguration {
  ServerlessCacheName?: string;
  Engine?: string;
  MajorEngineVersion?: string;
}
export interface ServerlessCacheSnapshot {
  ServerlessCacheSnapshotName?: string;
  ARN?: string;
  KmsKeyId?: string;
  SnapshotType?: string;
  Status?: string;
  CreateTime?: Date;
  ExpiryTime?: Date;
  BytesUsedForCache?: string;
  ServerlessCacheConfiguration?: ServerlessCacheConfiguration;
}
export interface CopyServerlessCacheSnapshotResponse {
  ServerlessCacheSnapshot?: ServerlessCacheSnapshot;
}
export declare class ServerlessCacheSnapshotAlreadyExistsFault extends __BaseException {
  readonly name: "ServerlessCacheSnapshotAlreadyExistsFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      ServerlessCacheSnapshotAlreadyExistsFault,
      __BaseException
    >
  );
}
export declare class ServerlessCacheSnapshotQuotaExceededFault extends __BaseException {
  readonly name: "ServerlessCacheSnapshotQuotaExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      ServerlessCacheSnapshotQuotaExceededFault,
      __BaseException
    >
  );
}
export declare class ServiceLinkedRoleNotFoundFault extends __BaseException {
  readonly name: "ServiceLinkedRoleNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ServiceLinkedRoleNotFoundFault, __BaseException>
  );
}
export interface CopySnapshotMessage {
  SourceSnapshotName: string | undefined;
  TargetSnapshotName: string | undefined;
  TargetBucket?: string;
  KmsKeyId?: string;
  Tags?: Tag[];
}
export interface NodeGroupConfiguration {
  NodeGroupId?: string;
  Slots?: string;
  ReplicaCount?: number;
  PrimaryAvailabilityZone?: string;
  ReplicaAvailabilityZones?: string[];
  PrimaryOutpostArn?: string;
  ReplicaOutpostArns?: string[];
}
export interface NodeSnapshot {
  CacheClusterId?: string;
  NodeGroupId?: string;
  CacheNodeId?: string;
  NodeGroupConfiguration?: NodeGroupConfiguration;
  CacheSize?: string;
  CacheNodeCreateTime?: Date;
  SnapshotCreateTime?: Date;
}
export interface Snapshot {
  SnapshotName?: string;
  ReplicationGroupId?: string;
  ReplicationGroupDescription?: string;
  CacheClusterId?: string;
  SnapshotStatus?: string;
  SnapshotSource?: string;
  CacheNodeType?: string;
  Engine?: string;
  EngineVersion?: string;
  NumCacheNodes?: number;
  PreferredAvailabilityZone?: string;
  PreferredOutpostArn?: string;
  CacheClusterCreateTime?: Date;
  PreferredMaintenanceWindow?: string;
  TopicArn?: string;
  Port?: number;
  CacheParameterGroupName?: string;
  CacheSubnetGroupName?: string;
  VpcId?: string;
  AutoMinorVersionUpgrade?: boolean;
  SnapshotRetentionLimit?: number;
  SnapshotWindow?: string;
  NumNodeGroups?: number;
  AutomaticFailover?: AutomaticFailoverStatus;
  NodeSnapshots?: NodeSnapshot[];
  KmsKeyId?: string;
  ARN?: string;
  DataTiering?: DataTieringStatus;
}
export interface CopySnapshotResult {
  Snapshot?: Snapshot;
}
export declare class InvalidSnapshotStateFault extends __BaseException {
  readonly name: "InvalidSnapshotStateFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidSnapshotStateFault, __BaseException>
  );
}
export declare class SnapshotAlreadyExistsFault extends __BaseException {
  readonly name: "SnapshotAlreadyExistsFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<SnapshotAlreadyExistsFault, __BaseException>
  );
}
export declare class SnapshotQuotaExceededFault extends __BaseException {
  readonly name: "SnapshotQuotaExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<SnapshotQuotaExceededFault, __BaseException>
  );
}
export declare class CacheClusterAlreadyExistsFault extends __BaseException {
  readonly name: "CacheClusterAlreadyExistsFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<CacheClusterAlreadyExistsFault, __BaseException>
  );
}
export declare class ClusterQuotaForCustomerExceededFault extends __BaseException {
  readonly name: "ClusterQuotaForCustomerExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      ClusterQuotaForCustomerExceededFault,
      __BaseException
    >
  );
}
export declare const AZMode: {
  readonly CROSS_AZ: "cross-az";
  readonly SINGLE_AZ: "single-az";
};
export type AZMode = (typeof AZMode)[keyof typeof AZMode];
export interface LogDeliveryConfigurationRequest {
  LogType?: LogType;
  DestinationType?: DestinationType;
  DestinationDetails?: DestinationDetails;
  LogFormat?: LogFormat;
  Enabled?: boolean;
}
export declare const OutpostMode: {
  readonly CROSS_OUTPOST: "cross-outpost";
  readonly SINGLE_OUTPOST: "single-outpost";
};
export type OutpostMode = (typeof OutpostMode)[keyof typeof OutpostMode];
export interface CreateCacheClusterMessage {
  CacheClusterId: string | undefined;
  ReplicationGroupId?: string;
  AZMode?: AZMode;
  PreferredAvailabilityZone?: string;
  PreferredAvailabilityZones?: string[];
  NumCacheNodes?: number;
  CacheNodeType?: string;
  Engine?: string;
  EngineVersion?: string;
  CacheParameterGroupName?: string;
  CacheSubnetGroupName?: string;
  CacheSecurityGroupNames?: string[];
  SecurityGroupIds?: string[];
  Tags?: Tag[];
  SnapshotArns?: string[];
  SnapshotName?: string;
  PreferredMaintenanceWindow?: string;
  Port?: number;
  NotificationTopicArn?: string;
  AutoMinorVersionUpgrade?: boolean;
  SnapshotRetentionLimit?: number;
  SnapshotWindow?: string;
  AuthToken?: string;
  OutpostMode?: OutpostMode;
  PreferredOutpostArn?: string;
  PreferredOutpostArns?: string[];
  LogDeliveryConfigurations?: LogDeliveryConfigurationRequest[];
  TransitEncryptionEnabled?: boolean;
  NetworkType?: NetworkType;
  IpDiscovery?: IpDiscovery;
}
export interface CacheNode {
  CacheNodeId?: string;
  CacheNodeStatus?: string;
  CacheNodeCreateTime?: Date;
  Endpoint?: Endpoint;
  ParameterGroupStatus?: string;
  SourceCacheNodeId?: string;
  CustomerAvailabilityZone?: string;
  CustomerOutpostArn?: string;
}
export interface CacheParameterGroupStatus {
  CacheParameterGroupName?: string;
  ParameterApplyStatus?: string;
  CacheNodeIdsToReboot?: string[];
}
export interface CacheSecurityGroupMembership {
  CacheSecurityGroupName?: string;
  Status?: string;
}
export interface NotificationConfiguration {
  TopicArn?: string;
  TopicStatus?: string;
}
export interface PendingModifiedValues {
  NumCacheNodes?: number;
  CacheNodeIdsToRemove?: string[];
  EngineVersion?: string;
  CacheNodeType?: string;
  AuthTokenStatus?: AuthTokenUpdateStatus;
  LogDeliveryConfigurations?: PendingLogDeliveryConfiguration[];
  TransitEncryptionEnabled?: boolean;
  TransitEncryptionMode?: TransitEncryptionMode;
}
export interface SecurityGroupMembership {
  SecurityGroupId?: string;
  Status?: string;
}
export interface CacheCluster {
  CacheClusterId?: string;
  ConfigurationEndpoint?: Endpoint;
  ClientDownloadLandingPage?: string;
  CacheNodeType?: string;
  Engine?: string;
  EngineVersion?: string;
  CacheClusterStatus?: string;
  NumCacheNodes?: number;
  PreferredAvailabilityZone?: string;
  PreferredOutpostArn?: string;
  CacheClusterCreateTime?: Date;
  PreferredMaintenanceWindow?: string;
  PendingModifiedValues?: PendingModifiedValues;
  NotificationConfiguration?: NotificationConfiguration;
  CacheSecurityGroups?: CacheSecurityGroupMembership[];
  CacheParameterGroup?: CacheParameterGroupStatus;
  CacheSubnetGroupName?: string;
  CacheNodes?: CacheNode[];
  AutoMinorVersionUpgrade?: boolean;
  SecurityGroups?: SecurityGroupMembership[];
  ReplicationGroupId?: string;
  SnapshotRetentionLimit?: number;
  SnapshotWindow?: string;
  AuthTokenEnabled?: boolean;
  AuthTokenLastModifiedDate?: Date;
  TransitEncryptionEnabled?: boolean;
  AtRestEncryptionEnabled?: boolean;
  ARN?: string;
  ReplicationGroupLogDeliveryEnabled?: boolean;
  LogDeliveryConfigurations?: LogDeliveryConfiguration[];
  NetworkType?: NetworkType;
  IpDiscovery?: IpDiscovery;
  TransitEncryptionMode?: TransitEncryptionMode;
}
export interface CreateCacheClusterResult {
  CacheCluster?: CacheCluster;
}
export declare class InsufficientCacheClusterCapacityFault extends __BaseException {
  readonly name: "InsufficientCacheClusterCapacityFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      InsufficientCacheClusterCapacityFault,
      __BaseException
    >
  );
}
export declare class InvalidVPCNetworkStateFault extends __BaseException {
  readonly name: "InvalidVPCNetworkStateFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidVPCNetworkStateFault, __BaseException>
  );
}
export declare class NodeQuotaForClusterExceededFault extends __BaseException {
  readonly name: "NodeQuotaForClusterExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      NodeQuotaForClusterExceededFault,
      __BaseException
    >
  );
}
export declare class NodeQuotaForCustomerExceededFault extends __BaseException {
  readonly name: "NodeQuotaForCustomerExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      NodeQuotaForCustomerExceededFault,
      __BaseException
    >
  );
}
export declare class CacheParameterGroupAlreadyExistsFault extends __BaseException {
  readonly name: "CacheParameterGroupAlreadyExistsFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      CacheParameterGroupAlreadyExistsFault,
      __BaseException
    >
  );
}
export declare class CacheParameterGroupQuotaExceededFault extends __BaseException {
  readonly name: "CacheParameterGroupQuotaExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      CacheParameterGroupQuotaExceededFault,
      __BaseException
    >
  );
}
export interface CreateCacheParameterGroupMessage {
  CacheParameterGroupName: string | undefined;
  CacheParameterGroupFamily: string | undefined;
  Description: string | undefined;
  Tags?: Tag[];
}
export interface CacheParameterGroup {
  CacheParameterGroupName?: string;
  CacheParameterGroupFamily?: string;
  Description?: string;
  IsGlobal?: boolean;
  ARN?: string;
}
export interface CreateCacheParameterGroupResult {
  CacheParameterGroup?: CacheParameterGroup;
}
export declare class InvalidCacheParameterGroupStateFault extends __BaseException {
  readonly name: "InvalidCacheParameterGroupStateFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      InvalidCacheParameterGroupStateFault,
      __BaseException
    >
  );
}
export declare class CacheSecurityGroupAlreadyExistsFault extends __BaseException {
  readonly name: "CacheSecurityGroupAlreadyExistsFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      CacheSecurityGroupAlreadyExistsFault,
      __BaseException
    >
  );
}
export declare class CacheSecurityGroupQuotaExceededFault extends __BaseException {
  readonly name: "CacheSecurityGroupQuotaExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      CacheSecurityGroupQuotaExceededFault,
      __BaseException
    >
  );
}
export interface CreateCacheSecurityGroupMessage {
  CacheSecurityGroupName: string | undefined;
  Description: string | undefined;
  Tags?: Tag[];
}
export interface CreateCacheSecurityGroupResult {
  CacheSecurityGroup?: CacheSecurityGroup;
}
export declare class CacheSubnetGroupAlreadyExistsFault extends __BaseException {
  readonly name: "CacheSubnetGroupAlreadyExistsFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      CacheSubnetGroupAlreadyExistsFault,
      __BaseException
    >
  );
}
export declare class CacheSubnetGroupQuotaExceededFault extends __BaseException {
  readonly name: "CacheSubnetGroupQuotaExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      CacheSubnetGroupQuotaExceededFault,
      __BaseException
    >
  );
}
export declare class CacheSubnetQuotaExceededFault extends __BaseException {
  readonly name: "CacheSubnetQuotaExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<CacheSubnetQuotaExceededFault, __BaseException>
  );
}
export interface CreateCacheSubnetGroupMessage {
  CacheSubnetGroupName: string | undefined;
  CacheSubnetGroupDescription: string | undefined;
  SubnetIds: string[] | undefined;
  Tags?: Tag[];
}
export interface AvailabilityZone {
  Name?: string;
}
export interface SubnetOutpost {
  SubnetOutpostArn?: string;
}
export interface Subnet {
  SubnetIdentifier?: string;
  SubnetAvailabilityZone?: AvailabilityZone;
  SubnetOutpost?: SubnetOutpost;
  SupportedNetworkTypes?: NetworkType[];
}
export interface CacheSubnetGroup {
  CacheSubnetGroupName?: string;
  CacheSubnetGroupDescription?: string;
  VpcId?: string;
  Subnets?: Subnet[];
  ARN?: string;
  SupportedNetworkTypes?: NetworkType[];
}
export interface CreateCacheSubnetGroupResult {
  CacheSubnetGroup?: CacheSubnetGroup;
}
export declare class InvalidSubnet extends __BaseException {
  readonly name: "InvalidSubnet";
  readonly $fault: "client";
  constructor(opts: __ExceptionOptionType<InvalidSubnet, __BaseException>);
}
export declare class SubnetNotAllowedFault extends __BaseException {
  readonly name: "SubnetNotAllowedFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<SubnetNotAllowedFault, __BaseException>
  );
}
export interface CreateGlobalReplicationGroupMessage {
  GlobalReplicationGroupIdSuffix: string | undefined;
  GlobalReplicationGroupDescription?: string;
  PrimaryReplicationGroupId: string | undefined;
}
export interface GlobalNodeGroup {
  GlobalNodeGroupId?: string;
  Slots?: string;
}
export interface GlobalReplicationGroupMember {
  ReplicationGroupId?: string;
  ReplicationGroupRegion?: string;
  Role?: string;
  AutomaticFailover?: AutomaticFailoverStatus;
  Status?: string;
}
export interface GlobalReplicationGroup {
  GlobalReplicationGroupId?: string;
  GlobalReplicationGroupDescription?: string;
  Status?: string;
  CacheNodeType?: string;
  Engine?: string;
  EngineVersion?: string;
  Members?: GlobalReplicationGroupMember[];
  ClusterEnabled?: boolean;
  GlobalNodeGroups?: GlobalNodeGroup[];
  AuthTokenEnabled?: boolean;
  TransitEncryptionEnabled?: boolean;
  AtRestEncryptionEnabled?: boolean;
  ARN?: string;
}
export interface CreateGlobalReplicationGroupResult {
  GlobalReplicationGroup?: GlobalReplicationGroup;
}
export declare class GlobalReplicationGroupAlreadyExistsFault extends __BaseException {
  readonly name: "GlobalReplicationGroupAlreadyExistsFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      GlobalReplicationGroupAlreadyExistsFault,
      __BaseException
    >
  );
}
export interface CreateReplicationGroupMessage {
  ReplicationGroupId: string | undefined;
  ReplicationGroupDescription: string | undefined;
  GlobalReplicationGroupId?: string;
  PrimaryClusterId?: string;
  AutomaticFailoverEnabled?: boolean;
  MultiAZEnabled?: boolean;
  NumCacheClusters?: number;
  PreferredCacheClusterAZs?: string[];
  NumNodeGroups?: number;
  ReplicasPerNodeGroup?: number;
  NodeGroupConfiguration?: NodeGroupConfiguration[];
  CacheNodeType?: string;
  Engine?: string;
  EngineVersion?: string;
  CacheParameterGroupName?: string;
  CacheSubnetGroupName?: string;
  CacheSecurityGroupNames?: string[];
  SecurityGroupIds?: string[];
  Tags?: Tag[];
  SnapshotArns?: string[];
  SnapshotName?: string;
  PreferredMaintenanceWindow?: string;
  Port?: number;
  NotificationTopicArn?: string;
  AutoMinorVersionUpgrade?: boolean;
  SnapshotRetentionLimit?: number;
  SnapshotWindow?: string;
  AuthToken?: string;
  TransitEncryptionEnabled?: boolean;
  AtRestEncryptionEnabled?: boolean;
  KmsKeyId?: string;
  UserGroupIds?: string[];
  LogDeliveryConfigurations?: LogDeliveryConfigurationRequest[];
  DataTieringEnabled?: boolean;
  NetworkType?: NetworkType;
  IpDiscovery?: IpDiscovery;
  TransitEncryptionMode?: TransitEncryptionMode;
  ClusterMode?: ClusterMode;
  ServerlessCacheSnapshotName?: string;
}
export interface CreateReplicationGroupResult {
  ReplicationGroup?: ReplicationGroup;
}
export declare class GlobalReplicationGroupNotFoundFault extends __BaseException {
  readonly name: "GlobalReplicationGroupNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      GlobalReplicationGroupNotFoundFault,
      __BaseException
    >
  );
}
export declare class InvalidCacheClusterStateFault extends __BaseException {
  readonly name: "InvalidCacheClusterStateFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidCacheClusterStateFault, __BaseException>
  );
}
export declare class InvalidGlobalReplicationGroupStateFault extends __BaseException {
  readonly name: "InvalidGlobalReplicationGroupStateFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      InvalidGlobalReplicationGroupStateFault,
      __BaseException
    >
  );
}
export declare class InvalidUserGroupStateFault extends __BaseException {
  readonly name: "InvalidUserGroupStateFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidUserGroupStateFault, __BaseException>
  );
}
export declare class NodeGroupsPerReplicationGroupQuotaExceededFault extends __BaseException {
  readonly name: "NodeGroupsPerReplicationGroupQuotaExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      NodeGroupsPerReplicationGroupQuotaExceededFault,
      __BaseException
    >
  );
}
export declare class ReplicationGroupAlreadyExistsFault extends __BaseException {
  readonly name: "ReplicationGroupAlreadyExistsFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      ReplicationGroupAlreadyExistsFault,
      __BaseException
    >
  );
}
export declare const DataStorageUnit: {
  readonly GB: "GB";
};
export type DataStorageUnit =
  (typeof DataStorageUnit)[keyof typeof DataStorageUnit];
export interface DataStorage {
  Maximum?: number;
  Minimum?: number;
  Unit: DataStorageUnit | undefined;
}
export interface ECPUPerSecond {
  Maximum?: number;
  Minimum?: number;
}
export interface CacheUsageLimits {
  DataStorage?: DataStorage;
  ECPUPerSecond?: ECPUPerSecond;
}
export interface CreateServerlessCacheRequest {
  ServerlessCacheName: string | undefined;
  Description?: string;
  Engine: string | undefined;
  MajorEngineVersion?: string;
  CacheUsageLimits?: CacheUsageLimits;
  KmsKeyId?: string;
  SecurityGroupIds?: string[];
  SnapshotArnsToRestore?: string[];
  Tags?: Tag[];
  UserGroupId?: string;
  SubnetIds?: string[];
  SnapshotRetentionLimit?: number;
  DailySnapshotTime?: string;
}
export interface ServerlessCache {
  ServerlessCacheName?: string;
  Description?: string;
  CreateTime?: Date;
  Status?: string;
  Engine?: string;
  MajorEngineVersion?: string;
  FullEngineVersion?: string;
  CacheUsageLimits?: CacheUsageLimits;
  KmsKeyId?: string;
  SecurityGroupIds?: string[];
  Endpoint?: Endpoint;
  ReaderEndpoint?: Endpoint;
  ARN?: string;
  UserGroupId?: string;
  SubnetIds?: string[];
  SnapshotRetentionLimit?: number;
  DailySnapshotTime?: string;
}
export interface CreateServerlessCacheResponse {
  ServerlessCache?: ServerlessCache;
}
export declare class InvalidCredentialsException extends __BaseException {
  readonly name: "InvalidCredentialsException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidCredentialsException, __BaseException>
  );
}
export declare class ServerlessCacheAlreadyExistsFault extends __BaseException {
  readonly name: "ServerlessCacheAlreadyExistsFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      ServerlessCacheAlreadyExistsFault,
      __BaseException
    >
  );
}
export declare class ServerlessCacheQuotaForCustomerExceededFault extends __BaseException {
  readonly name: "ServerlessCacheQuotaForCustomerExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      ServerlessCacheQuotaForCustomerExceededFault,
      __BaseException
    >
  );
}
export interface CreateServerlessCacheSnapshotRequest {
  ServerlessCacheSnapshotName: string | undefined;
  ServerlessCacheName: string | undefined;
  KmsKeyId?: string;
  Tags?: Tag[];
}
export interface CreateServerlessCacheSnapshotResponse {
  ServerlessCacheSnapshot?: ServerlessCacheSnapshot;
}
export interface CreateSnapshotMessage {
  ReplicationGroupId?: string;
  CacheClusterId?: string;
  SnapshotName: string | undefined;
  KmsKeyId?: string;
  Tags?: Tag[];
}
export interface CreateSnapshotResult {
  Snapshot?: Snapshot;
}
export declare class SnapshotFeatureNotSupportedFault extends __BaseException {
  readonly name: "SnapshotFeatureNotSupportedFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      SnapshotFeatureNotSupportedFault,
      __BaseException
    >
  );
}
export declare const InputAuthenticationType: {
  readonly IAM: "iam";
  readonly NO_PASSWORD: "no-password-required";
  readonly PASSWORD: "password";
};
export type InputAuthenticationType =
  (typeof InputAuthenticationType)[keyof typeof InputAuthenticationType];
export interface AuthenticationMode {
  Type?: InputAuthenticationType;
  Passwords?: string[];
}
export interface CreateUserMessage {
  UserId: string | undefined;
  UserName: string | undefined;
  Engine: string | undefined;
  Passwords?: string[];
  AccessString: string | undefined;
  NoPasswordRequired?: boolean;
  Tags?: Tag[];
  AuthenticationMode?: AuthenticationMode;
}
export declare class DuplicateUserNameFault extends __BaseException {
  readonly name: "DuplicateUserNameFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<DuplicateUserNameFault, __BaseException>
  );
}
export declare const AuthenticationType: {
  readonly IAM: "iam";
  readonly NO_PASSWORD: "no-password";
  readonly PASSWORD: "password";
};
export type AuthenticationType =
  (typeof AuthenticationType)[keyof typeof AuthenticationType];
export interface Authentication {
  Type?: AuthenticationType;
  PasswordCount?: number;
}
export interface User {
  UserId?: string;
  UserName?: string;
  Status?: string;
  Engine?: string;
  MinimumEngineVersion?: string;
  AccessString?: string;
  UserGroupIds?: string[];
  Authentication?: Authentication;
  ARN?: string;
}
export declare class UserAlreadyExistsFault extends __BaseException {
  readonly name: "UserAlreadyExistsFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<UserAlreadyExistsFault, __BaseException>
  );
}
export declare class UserQuotaExceededFault extends __BaseException {
  readonly name: "UserQuotaExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<UserQuotaExceededFault, __BaseException>
  );
}
export interface CreateUserGroupMessage {
  UserGroupId: string | undefined;
  Engine: string | undefined;
  UserIds?: string[];
  Tags?: Tag[];
}
export declare class DefaultUserRequired extends __BaseException {
  readonly name: "DefaultUserRequired";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<DefaultUserRequired, __BaseException>
  );
}
export interface UserGroupPendingChanges {
  UserIdsToRemove?: string[];
  UserIdsToAdd?: string[];
}
export interface UserGroup {
  UserGroupId?: string;
  Status?: string;
  Engine?: string;
  UserIds?: string[];
  MinimumEngineVersion?: string;
  PendingChanges?: UserGroupPendingChanges;
  ReplicationGroups?: string[];
  ServerlessCaches?: string[];
  ARN?: string;
}
export declare class UserGroupAlreadyExistsFault extends __BaseException {
  readonly name: "UserGroupAlreadyExistsFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<UserGroupAlreadyExistsFault, __BaseException>
  );
}
export declare class UserGroupQuotaExceededFault extends __BaseException {
  readonly name: "UserGroupQuotaExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<UserGroupQuotaExceededFault, __BaseException>
  );
}
export interface DecreaseNodeGroupsInGlobalReplicationGroupMessage {
  GlobalReplicationGroupId: string | undefined;
  NodeGroupCount: number | undefined;
  GlobalNodeGroupsToRemove?: string[];
  GlobalNodeGroupsToRetain?: string[];
  ApplyImmediately: boolean | undefined;
}
export interface DecreaseNodeGroupsInGlobalReplicationGroupResult {
  GlobalReplicationGroup?: GlobalReplicationGroup;
}
export interface ConfigureShard {
  NodeGroupId: string | undefined;
  NewReplicaCount: number | undefined;
  PreferredAvailabilityZones?: string[];
  PreferredOutpostArns?: string[];
}
export interface DecreaseReplicaCountMessage {
  ReplicationGroupId: string | undefined;
  NewReplicaCount?: number;
  ReplicaConfiguration?: ConfigureShard[];
  ReplicasToRemove?: string[];
  ApplyImmediately: boolean | undefined;
}
export interface DecreaseReplicaCountResult {
  ReplicationGroup?: ReplicationGroup;
}
export declare class NoOperationFault extends __BaseException {
  readonly name: "NoOperationFault";
  readonly $fault: "client";
  constructor(opts: __ExceptionOptionType<NoOperationFault, __BaseException>);
}
export interface DeleteCacheClusterMessage {
  CacheClusterId: string | undefined;
  FinalSnapshotIdentifier?: string;
}
export interface DeleteCacheClusterResult {
  CacheCluster?: CacheCluster;
}
export interface DeleteCacheParameterGroupMessage {
  CacheParameterGroupName: string | undefined;
}
export interface DeleteCacheSecurityGroupMessage {
  CacheSecurityGroupName: string | undefined;
}
export declare class CacheSubnetGroupInUse extends __BaseException {
  readonly name: "CacheSubnetGroupInUse";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<CacheSubnetGroupInUse, __BaseException>
  );
}
export interface DeleteCacheSubnetGroupMessage {
  CacheSubnetGroupName: string | undefined;
}
export interface DeleteGlobalReplicationGroupMessage {
  GlobalReplicationGroupId: string | undefined;
  RetainPrimaryReplicationGroup: boolean | undefined;
}
export interface DeleteGlobalReplicationGroupResult {
  GlobalReplicationGroup?: GlobalReplicationGroup;
}
export interface DeleteReplicationGroupMessage {
  ReplicationGroupId: string | undefined;
  RetainPrimaryCluster?: boolean;
  FinalSnapshotIdentifier?: string;
}
export interface DeleteReplicationGroupResult {
  ReplicationGroup?: ReplicationGroup;
}
export interface DeleteServerlessCacheRequest {
  ServerlessCacheName: string | undefined;
  FinalSnapshotName?: string;
}
export interface DeleteServerlessCacheResponse {
  ServerlessCache?: ServerlessCache;
}
export interface DeleteServerlessCacheSnapshotRequest {
  ServerlessCacheSnapshotName: string | undefined;
}
export interface DeleteServerlessCacheSnapshotResponse {
  ServerlessCacheSnapshot?: ServerlessCacheSnapshot;
}
export interface DeleteSnapshotMessage {
  SnapshotName: string | undefined;
}
export interface DeleteSnapshotResult {
  Snapshot?: Snapshot;
}
export declare class DefaultUserAssociatedToUserGroupFault extends __BaseException {
  readonly name: "DefaultUserAssociatedToUserGroupFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      DefaultUserAssociatedToUserGroupFault,
      __BaseException
    >
  );
}
export interface DeleteUserMessage {
  UserId: string | undefined;
}
export declare class InvalidUserStateFault extends __BaseException {
  readonly name: "InvalidUserStateFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidUserStateFault, __BaseException>
  );
}
export interface DeleteUserGroupMessage {
  UserGroupId: string | undefined;
}
export interface CacheClusterMessage {
  Marker?: string;
  CacheClusters?: CacheCluster[];
}
export interface DescribeCacheClustersMessage {
  CacheClusterId?: string;
  MaxRecords?: number;
  Marker?: string;
  ShowCacheNodeInfo?: boolean;
  ShowCacheClustersNotInReplicationGroups?: boolean;
}
export interface CacheEngineVersion {
  Engine?: string;
  EngineVersion?: string;
  CacheParameterGroupFamily?: string;
  CacheEngineDescription?: string;
  CacheEngineVersionDescription?: string;
}
export interface CacheEngineVersionMessage {
  Marker?: string;
  CacheEngineVersions?: CacheEngineVersion[];
}
export interface DescribeCacheEngineVersionsMessage {
  Engine?: string;
  EngineVersion?: string;
  CacheParameterGroupFamily?: string;
  MaxRecords?: number;
  Marker?: string;
  DefaultOnly?: boolean;
}
export interface CacheParameterGroupsMessage {
  Marker?: string;
  CacheParameterGroups?: CacheParameterGroup[];
}
export interface DescribeCacheParameterGroupsMessage {
  CacheParameterGroupName?: string;
  MaxRecords?: number;
  Marker?: string;
}
export interface CacheNodeTypeSpecificValue {
  CacheNodeType?: string;
  Value?: string;
}
export declare const ChangeType: {
  readonly immediate: "immediate";
  readonly requires_reboot: "requires-reboot";
};
export type ChangeType = (typeof ChangeType)[keyof typeof ChangeType];
export interface CacheNodeTypeSpecificParameter {
  ParameterName?: string;
  Description?: string;
  Source?: string;
  DataType?: string;
  AllowedValues?: string;
  IsModifiable?: boolean;
  MinimumEngineVersion?: string;
  CacheNodeTypeSpecificValues?: CacheNodeTypeSpecificValue[];
  ChangeType?: ChangeType;
}
export interface Parameter {
  ParameterName?: string;
  ParameterValue?: string;
  Description?: string;
  Source?: string;
  DataType?: string;
  AllowedValues?: string;
  IsModifiable?: boolean;
  MinimumEngineVersion?: string;
  ChangeType?: ChangeType;
}
export interface CacheParameterGroupDetails {
  Marker?: string;
  Parameters?: Parameter[];
  CacheNodeTypeSpecificParameters?: CacheNodeTypeSpecificParameter[];
}
export interface DescribeCacheParametersMessage {
  CacheParameterGroupName: string | undefined;
  Source?: string;
  MaxRecords?: number;
  Marker?: string;
}
export interface CacheSecurityGroupMessage {
  Marker?: string;
  CacheSecurityGroups?: CacheSecurityGroup[];
}
export interface DescribeCacheSecurityGroupsMessage {
  CacheSecurityGroupName?: string;
  MaxRecords?: number;
  Marker?: string;
}
export interface CacheSubnetGroupMessage {
  Marker?: string;
  CacheSubnetGroups?: CacheSubnetGroup[];
}
export interface DescribeCacheSubnetGroupsMessage {
  CacheSubnetGroupName?: string;
  MaxRecords?: number;
  Marker?: string;
}
export interface DescribeEngineDefaultParametersMessage {
  CacheParameterGroupFamily: string | undefined;
  MaxRecords?: number;
  Marker?: string;
}
export interface EngineDefaults {
  CacheParameterGroupFamily?: string;
  Marker?: string;
  Parameters?: Parameter[];
  CacheNodeTypeSpecificParameters?: CacheNodeTypeSpecificParameter[];
}
export interface DescribeEngineDefaultParametersResult {
  EngineDefaults?: EngineDefaults;
}
export declare const SourceType: {
  readonly cache_cluster: "cache-cluster";
  readonly cache_parameter_group: "cache-parameter-group";
  readonly cache_security_group: "cache-security-group";
  readonly cache_subnet_group: "cache-subnet-group";
  readonly replication_group: "replication-group";
  readonly serverless_cache: "serverless-cache";
  readonly serverless_cache_snapshot: "serverless-cache-snapshot";
  readonly user: "user";
  readonly user_group: "user-group";
};
export type SourceType = (typeof SourceType)[keyof typeof SourceType];
export interface DescribeEventsMessage {
  SourceIdentifier?: string;
  SourceType?: SourceType;
  StartTime?: Date;
  EndTime?: Date;
  Duration?: number;
  MaxRecords?: number;
  Marker?: string;
}
export interface Event {
  SourceIdentifier?: string;
  SourceType?: SourceType;
  Message?: string;
  Date?: Date;
}
export interface EventsMessage {
  Marker?: string;
  Events?: Event[];
}
export interface DescribeGlobalReplicationGroupsMessage {
  GlobalReplicationGroupId?: string;
  MaxRecords?: number;
  Marker?: string;
  ShowMemberInfo?: boolean;
}
export interface DescribeGlobalReplicationGroupsResult {
  Marker?: string;
  GlobalReplicationGroups?: GlobalReplicationGroup[];
}
export interface DescribeReplicationGroupsMessage {
  ReplicationGroupId?: string;
  MaxRecords?: number;
  Marker?: string;
}
export interface ReplicationGroupMessage {
  Marker?: string;
  ReplicationGroups?: ReplicationGroup[];
}
export interface DescribeReservedCacheNodesMessage {
  ReservedCacheNodeId?: string;
  ReservedCacheNodesOfferingId?: string;
  CacheNodeType?: string;
  Duration?: string;
  ProductDescription?: string;
  OfferingType?: string;
  MaxRecords?: number;
  Marker?: string;
}
export interface RecurringCharge {
  RecurringChargeAmount?: number;
  RecurringChargeFrequency?: string;
}
export interface ReservedCacheNode {
  ReservedCacheNodeId?: string;
  ReservedCacheNodesOfferingId?: string;
  CacheNodeType?: string;
  StartTime?: Date;
  Duration?: number;
  FixedPrice?: number;
  UsagePrice?: number;
  CacheNodeCount?: number;
  ProductDescription?: string;
  OfferingType?: string;
  State?: string;
  RecurringCharges?: RecurringCharge[];
  ReservationARN?: string;
}
export interface ReservedCacheNodeMessage {
  Marker?: string;
  ReservedCacheNodes?: ReservedCacheNode[];
}
export interface DescribeReservedCacheNodesOfferingsMessage {
  ReservedCacheNodesOfferingId?: string;
  CacheNodeType?: string;
  Duration?: string;
  ProductDescription?: string;
  OfferingType?: string;
  MaxRecords?: number;
  Marker?: string;
}
export interface ReservedCacheNodesOffering {
  ReservedCacheNodesOfferingId?: string;
  CacheNodeType?: string;
  Duration?: number;
  FixedPrice?: number;
  UsagePrice?: number;
  ProductDescription?: string;
  OfferingType?: string;
  RecurringCharges?: RecurringCharge[];
}
export interface ReservedCacheNodesOfferingMessage {
  Marker?: string;
  ReservedCacheNodesOfferings?: ReservedCacheNodesOffering[];
}
export declare class ReservedCacheNodesOfferingNotFoundFault extends __BaseException {
  readonly name: "ReservedCacheNodesOfferingNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      ReservedCacheNodesOfferingNotFoundFault,
      __BaseException
    >
  );
}
export interface DescribeServerlessCachesRequest {
  ServerlessCacheName?: string;
  MaxResults?: number;
  NextToken?: string;
}
export interface DescribeServerlessCachesResponse {
  NextToken?: string;
  ServerlessCaches?: ServerlessCache[];
}
export interface DescribeServerlessCacheSnapshotsRequest {
  ServerlessCacheName?: string;
  ServerlessCacheSnapshotName?: string;
  SnapshotType?: string;
  NextToken?: string;
  MaxResults?: number;
}
export interface DescribeServerlessCacheSnapshotsResponse {
  NextToken?: string;
  ServerlessCacheSnapshots?: ServerlessCacheSnapshot[];
}
export declare const ServiceUpdateStatus: {
  readonly AVAILABLE: "available";
  readonly CANCELLED: "cancelled";
  readonly EXPIRED: "expired";
};
export type ServiceUpdateStatus =
  (typeof ServiceUpdateStatus)[keyof typeof ServiceUpdateStatus];
export interface DescribeServiceUpdatesMessage {
  ServiceUpdateName?: string;
  ServiceUpdateStatus?: ServiceUpdateStatus[];
  MaxRecords?: number;
  Marker?: string;
}
export declare const ServiceUpdateSeverity: {
  readonly CRITICAL: "critical";
  readonly IMPORTANT: "important";
  readonly LOW: "low";
  readonly MEDIUM: "medium";
};
export type ServiceUpdateSeverity =
  (typeof ServiceUpdateSeverity)[keyof typeof ServiceUpdateSeverity];
export declare const ServiceUpdateType: {
  readonly SECURITY_UPDATE: "security-update";
};
export type ServiceUpdateType =
  (typeof ServiceUpdateType)[keyof typeof ServiceUpdateType];
export interface ServiceUpdate {
  ServiceUpdateName?: string;
  ServiceUpdateReleaseDate?: Date;
  ServiceUpdateEndDate?: Date;
  ServiceUpdateSeverity?: ServiceUpdateSeverity;
  ServiceUpdateRecommendedApplyByDate?: Date;
  ServiceUpdateStatus?: ServiceUpdateStatus;
  ServiceUpdateDescription?: string;
  ServiceUpdateType?: ServiceUpdateType;
  Engine?: string;
  EngineVersion?: string;
  AutoUpdateAfterRecommendedApplyByDate?: boolean;
  EstimatedUpdateTime?: string;
}
export interface ServiceUpdatesMessage {
  Marker?: string;
  ServiceUpdates?: ServiceUpdate[];
}
export interface DescribeSnapshotsListMessage {
  Marker?: string;
  Snapshots?: Snapshot[];
}
export interface DescribeSnapshotsMessage {
  ReplicationGroupId?: string;
  CacheClusterId?: string;
  SnapshotName?: string;
  SnapshotSource?: string;
  Marker?: string;
  MaxRecords?: number;
  ShowNodeGroupConfig?: boolean;
}
export interface TimeRangeFilter {
  StartTime?: Date;
  EndTime?: Date;
}
export interface DescribeUpdateActionsMessage {
  ServiceUpdateName?: string;
  ReplicationGroupIds?: string[];
  CacheClusterIds?: string[];
  Engine?: string;
  ServiceUpdateStatus?: ServiceUpdateStatus[];
  ServiceUpdateTimeRange?: TimeRangeFilter;
  UpdateActionStatus?: UpdateActionStatus[];
  ShowNodeLevelUpdateStatus?: boolean;
  MaxRecords?: number;
  Marker?: string;
}
export declare const NodeUpdateInitiatedBy: {
  readonly CUSTOMER: "customer";
  readonly SYSTEM: "system";
};
export type NodeUpdateInitiatedBy =
  (typeof NodeUpdateInitiatedBy)[keyof typeof NodeUpdateInitiatedBy];
export declare const NodeUpdateStatus: {
  readonly COMPLETE: "complete";
  readonly IN_PROGRESS: "in-progress";
  readonly NOT_APPLIED: "not-applied";
  readonly STOPPED: "stopped";
  readonly STOPPING: "stopping";
  readonly WAITING_TO_START: "waiting-to-start";
};
export type NodeUpdateStatus =
  (typeof NodeUpdateStatus)[keyof typeof NodeUpdateStatus];
export interface CacheNodeUpdateStatus {
  CacheNodeId?: string;
  NodeUpdateStatus?: NodeUpdateStatus;
  NodeDeletionDate?: Date;
  NodeUpdateStartDate?: Date;
  NodeUpdateEndDate?: Date;
  NodeUpdateInitiatedBy?: NodeUpdateInitiatedBy;
  NodeUpdateInitiatedDate?: Date;
  NodeUpdateStatusModifiedDate?: Date;
}
export interface NodeGroupMemberUpdateStatus {
  CacheClusterId?: string;
  CacheNodeId?: string;
  NodeUpdateStatus?: NodeUpdateStatus;
  NodeDeletionDate?: Date;
  NodeUpdateStartDate?: Date;
  NodeUpdateEndDate?: Date;
  NodeUpdateInitiatedBy?: NodeUpdateInitiatedBy;
  NodeUpdateInitiatedDate?: Date;
  NodeUpdateStatusModifiedDate?: Date;
}
export interface NodeGroupUpdateStatus {
  NodeGroupId?: string;
  NodeGroupMemberUpdateStatus?: NodeGroupMemberUpdateStatus[];
}
export declare const SlaMet: {
  readonly NA: "n/a";
  readonly NO: "no";
  readonly YES: "yes";
};
export type SlaMet = (typeof SlaMet)[keyof typeof SlaMet];
export interface UpdateAction {
  ReplicationGroupId?: string;
  CacheClusterId?: string;
  ServiceUpdateName?: string;
  ServiceUpdateReleaseDate?: Date;
  ServiceUpdateSeverity?: ServiceUpdateSeverity;
  ServiceUpdateStatus?: ServiceUpdateStatus;
  ServiceUpdateRecommendedApplyByDate?: Date;
  ServiceUpdateType?: ServiceUpdateType;
  UpdateActionAvailableDate?: Date;
  UpdateActionStatus?: UpdateActionStatus;
  NodesUpdated?: string;
  UpdateActionStatusModifiedDate?: Date;
  SlaMet?: SlaMet;
  NodeGroupUpdateStatus?: NodeGroupUpdateStatus[];
  CacheNodeUpdateStatus?: CacheNodeUpdateStatus[];
  EstimatedUpdateTime?: string;
  Engine?: string;
}
export interface UpdateActionsMessage {
  Marker?: string;
  UpdateActions?: UpdateAction[];
}
export interface DescribeUserGroupsMessage {
  UserGroupId?: string;
  MaxRecords?: number;
  Marker?: string;
}
export interface DescribeUserGroupsResult {
  UserGroups?: UserGroup[];
  Marker?: string;
}
export interface Filter {
  Name: string | undefined;
  Values: string[] | undefined;
}
export interface DescribeUsersMessage {
  Engine?: string;
  UserId?: string;
  Filters?: Filter[];
  MaxRecords?: number;
  Marker?: string;
}
export interface DescribeUsersResult {
  Users?: User[];
  Marker?: string;
}
export interface DisassociateGlobalReplicationGroupMessage {
  GlobalReplicationGroupId: string | undefined;
  ReplicationGroupId: string | undefined;
  ReplicationGroupRegion: string | undefined;
}
export interface DisassociateGlobalReplicationGroupResult {
  GlobalReplicationGroup?: GlobalReplicationGroup;
}
export interface ExportServerlessCacheSnapshotRequest {
  ServerlessCacheSnapshotName: string | undefined;
  S3BucketName: string | undefined;
}
export interface ExportServerlessCacheSnapshotResponse {
  ServerlessCacheSnapshot?: ServerlessCacheSnapshot;
}
export interface FailoverGlobalReplicationGroupMessage {
  GlobalReplicationGroupId: string | undefined;
  PrimaryRegion: string | undefined;
  PrimaryReplicationGroupId: string | undefined;
}
export interface FailoverGlobalReplicationGroupResult {
  GlobalReplicationGroup?: GlobalReplicationGroup;
}
export interface ReshardingConfiguration {
  NodeGroupId?: string;
  PreferredAvailabilityZones?: string[];
}
export interface RegionalConfiguration {
  ReplicationGroupId: string | undefined;
  ReplicationGroupRegion: string | undefined;
  ReshardingConfiguration: ReshardingConfiguration[] | undefined;
}
export interface IncreaseNodeGroupsInGlobalReplicationGroupMessage {
  GlobalReplicationGroupId: string | undefined;
  NodeGroupCount: number | undefined;
  RegionalConfigurations?: RegionalConfiguration[];
  ApplyImmediately: boolean | undefined;
}
export interface IncreaseNodeGroupsInGlobalReplicationGroupResult {
  GlobalReplicationGroup?: GlobalReplicationGroup;
}
export interface IncreaseReplicaCountMessage {
  ReplicationGroupId: string | undefined;
  NewReplicaCount?: number;
  ReplicaConfiguration?: ConfigureShard[];
  ApplyImmediately: boolean | undefined;
}
export interface IncreaseReplicaCountResult {
  ReplicationGroup?: ReplicationGroup;
}
export declare class InvalidKMSKeyFault extends __BaseException {
  readonly name: "InvalidKMSKeyFault";
  readonly $fault: "client";
  constructor(opts: __ExceptionOptionType<InvalidKMSKeyFault, __BaseException>);
}
export interface ListAllowedNodeTypeModificationsMessage {
  CacheClusterId?: string;
  ReplicationGroupId?: string;
}
export interface ListTagsForResourceMessage {
  ResourceName: string | undefined;
}
export declare const AuthTokenUpdateStrategyType: {
  readonly DELETE: "DELETE";
  readonly ROTATE: "ROTATE";
  readonly SET: "SET";
};
export type AuthTokenUpdateStrategyType =
  (typeof AuthTokenUpdateStrategyType)[keyof typeof AuthTokenUpdateStrategyType];
export interface ModifyCacheClusterMessage {
  CacheClusterId: string | undefined;
  NumCacheNodes?: number;
  CacheNodeIdsToRemove?: string[];
  AZMode?: AZMode;
  NewAvailabilityZones?: string[];
  CacheSecurityGroupNames?: string[];
  SecurityGroupIds?: string[];
  PreferredMaintenanceWindow?: string;
  NotificationTopicArn?: string;
  CacheParameterGroupName?: string;
  NotificationTopicStatus?: string;
  ApplyImmediately?: boolean;
  EngineVersion?: string;
  AutoMinorVersionUpgrade?: boolean;
  SnapshotRetentionLimit?: number;
  SnapshotWindow?: string;
  CacheNodeType?: string;
  AuthToken?: string;
  AuthTokenUpdateStrategy?: AuthTokenUpdateStrategyType;
  LogDeliveryConfigurations?: LogDeliveryConfigurationRequest[];
  IpDiscovery?: IpDiscovery;
}
export interface ModifyCacheClusterResult {
  CacheCluster?: CacheCluster;
}
export interface CacheParameterGroupNameMessage {
  CacheParameterGroupName?: string;
}
export interface ParameterNameValue {
  ParameterName?: string;
  ParameterValue?: string;
}
export interface ModifyCacheParameterGroupMessage {
  CacheParameterGroupName: string | undefined;
  ParameterNameValues: ParameterNameValue[] | undefined;
}
export interface ModifyCacheSubnetGroupMessage {
  CacheSubnetGroupName: string | undefined;
  CacheSubnetGroupDescription?: string;
  SubnetIds?: string[];
}
export interface ModifyCacheSubnetGroupResult {
  CacheSubnetGroup?: CacheSubnetGroup;
}
export declare class SubnetInUse extends __BaseException {
  readonly name: "SubnetInUse";
  readonly $fault: "client";
  constructor(opts: __ExceptionOptionType<SubnetInUse, __BaseException>);
}
export interface ModifyGlobalReplicationGroupMessage {
  GlobalReplicationGroupId: string | undefined;
  ApplyImmediately: boolean | undefined;
  CacheNodeType?: string;
  EngineVersion?: string;
  CacheParameterGroupName?: string;
  GlobalReplicationGroupDescription?: string;
  AutomaticFailoverEnabled?: boolean;
}
export interface ModifyGlobalReplicationGroupResult {
  GlobalReplicationGroup?: GlobalReplicationGroup;
}
export interface ModifyReplicationGroupMessage {
  ReplicationGroupId: string | undefined;
  ReplicationGroupDescription?: string;
  PrimaryClusterId?: string;
  SnapshottingClusterId?: string;
  AutomaticFailoverEnabled?: boolean;
  MultiAZEnabled?: boolean;
  NodeGroupId?: string;
  CacheSecurityGroupNames?: string[];
  SecurityGroupIds?: string[];
  PreferredMaintenanceWindow?: string;
  NotificationTopicArn?: string;
  CacheParameterGroupName?: string;
  NotificationTopicStatus?: string;
  ApplyImmediately?: boolean;
  EngineVersion?: string;
  AutoMinorVersionUpgrade?: boolean;
  SnapshotRetentionLimit?: number;
  SnapshotWindow?: string;
  CacheNodeType?: string;
  AuthToken?: string;
  AuthTokenUpdateStrategy?: AuthTokenUpdateStrategyType;
  UserGroupIdsToAdd?: string[];
  UserGroupIdsToRemove?: string[];
  RemoveUserGroups?: boolean;
  LogDeliveryConfigurations?: LogDeliveryConfigurationRequest[];
  IpDiscovery?: IpDiscovery;
  TransitEncryptionEnabled?: boolean;
  TransitEncryptionMode?: TransitEncryptionMode;
  ClusterMode?: ClusterMode;
}
export interface ModifyReplicationGroupResult {
  ReplicationGroup?: ReplicationGroup;
}
export interface ModifyReplicationGroupShardConfigurationMessage {
  ReplicationGroupId: string | undefined;
  NodeGroupCount: number | undefined;
  ApplyImmediately: boolean | undefined;
  ReshardingConfiguration?: ReshardingConfiguration[];
  NodeGroupsToRemove?: string[];
  NodeGroupsToRetain?: string[];
}
export interface ModifyReplicationGroupShardConfigurationResult {
  ReplicationGroup?: ReplicationGroup;
}
export interface ModifyServerlessCacheRequest {
  ServerlessCacheName: string | undefined;
  Description?: string;
  CacheUsageLimits?: CacheUsageLimits;
  RemoveUserGroup?: boolean;
  UserGroupId?: string;
  SecurityGroupIds?: string[];
  SnapshotRetentionLimit?: number;
  DailySnapshotTime?: string;
}
export interface ModifyServerlessCacheResponse {
  ServerlessCache?: ServerlessCache;
}
export interface ModifyUserMessage {
  UserId: string | undefined;
  AccessString?: string;
  AppendAccessString?: string;
  Passwords?: string[];
  NoPasswordRequired?: boolean;
  AuthenticationMode?: AuthenticationMode;
}
export interface ModifyUserGroupMessage {
  UserGroupId: string | undefined;
  UserIdsToAdd?: string[];
  UserIdsToRemove?: string[];
}
export interface PurchaseReservedCacheNodesOfferingMessage {
  ReservedCacheNodesOfferingId: string | undefined;
  ReservedCacheNodeId?: string;
  CacheNodeCount?: number;
  Tags?: Tag[];
}
export interface PurchaseReservedCacheNodesOfferingResult {
  ReservedCacheNode?: ReservedCacheNode;
}
export declare class ReservedCacheNodeAlreadyExistsFault extends __BaseException {
  readonly name: "ReservedCacheNodeAlreadyExistsFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      ReservedCacheNodeAlreadyExistsFault,
      __BaseException
    >
  );
}
export declare class ReservedCacheNodeQuotaExceededFault extends __BaseException {
  readonly name: "ReservedCacheNodeQuotaExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      ReservedCacheNodeQuotaExceededFault,
      __BaseException
    >
  );
}
export interface RebalanceSlotsInGlobalReplicationGroupMessage {
  GlobalReplicationGroupId: string | undefined;
  ApplyImmediately: boolean | undefined;
}
export interface RebalanceSlotsInGlobalReplicationGroupResult {
  GlobalReplicationGroup?: GlobalReplicationGroup;
}
export interface RebootCacheClusterMessage {
  CacheClusterId: string | undefined;
  CacheNodeIdsToReboot: string[] | undefined;
}
export interface RebootCacheClusterResult {
  CacheCluster?: CacheCluster;
}
export interface RemoveTagsFromResourceMessage {
  ResourceName: string | undefined;
  TagKeys: string[] | undefined;
}
export declare class TagNotFoundFault extends __BaseException {
  readonly name: "TagNotFoundFault";
  readonly $fault: "client";
  constructor(opts: __ExceptionOptionType<TagNotFoundFault, __BaseException>);
}
export interface ResetCacheParameterGroupMessage {
  CacheParameterGroupName: string | undefined;
  ResetAllParameters?: boolean;
  ParameterNameValues?: ParameterNameValue[];
}
export declare class AuthorizationNotFoundFault extends __BaseException {
  readonly name: "AuthorizationNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<AuthorizationNotFoundFault, __BaseException>
  );
}
export interface RevokeCacheSecurityGroupIngressMessage {
  CacheSecurityGroupName: string | undefined;
  EC2SecurityGroupName: string | undefined;
  EC2SecurityGroupOwnerId: string | undefined;
}
export interface RevokeCacheSecurityGroupIngressResult {
  CacheSecurityGroup?: CacheSecurityGroup;
}
