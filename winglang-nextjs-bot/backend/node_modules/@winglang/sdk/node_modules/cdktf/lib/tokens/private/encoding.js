"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractTokenDouble = exports.createTokenDouble = exports.unresolved = exports.containsComplexElement = exports.isComplexElement = exports.containsMapToken = exports.containsNumberListTokenElement = exports.containsStringListTokenElement = exports.NullConcat = exports.regexQuote = exports.TokenString = exports.VALID_KEY_CHARS = exports.END_TOKEN_MARKER = exports.BEGIN_MAP_TOKEN_MARKER = exports.BEGIN_LIST_TOKEN_MARKER = exports.BEGIN_STRING_TOKEN_MARKER = void 0;
// Copyright (c) HashiCorp, Inc
// SPDX-License-Identifier: MPL-2.0
// copied from https://github.com/aws/constructs/blob/e01e47f78ef1e9b600efcd23ff7705aa8d384017/lib/private/encoding.ts
const errors_1 = require("../../errors");
const string_fragments_1 = require("../string-fragments");
const token_1 = require("../token");
// Details for encoding and decoding Tokens into native types; should not be exported
exports.BEGIN_STRING_TOKEN_MARKER = "${TfToken[";
exports.BEGIN_LIST_TOKEN_MARKER = "#{TfToken[";
exports.BEGIN_MAP_TOKEN_MARKER = "&{TfToken[";
exports.END_TOKEN_MARKER = "]}";
exports.VALID_KEY_CHARS = "a-zA-Z0-9:._-";
const QUOTED_BEGIN_STRING_TOKEN_MARKER = regexQuote(exports.BEGIN_STRING_TOKEN_MARKER);
const QUOTED_BEGIN_LIST_TOKEN_MARKER = regexQuote(exports.BEGIN_LIST_TOKEN_MARKER);
const QUOTED_BEGIN_MAP_TOKEN_MARKER = regexQuote(exports.BEGIN_MAP_TOKEN_MARKER);
const QUOTED_END_TOKEN_MARKER = regexQuote(exports.END_TOKEN_MARKER);
const STRING_TOKEN_REGEX = new RegExp(`${QUOTED_BEGIN_STRING_TOKEN_MARKER}([${exports.VALID_KEY_CHARS}]+)${QUOTED_END_TOKEN_MARKER}`, "g");
const LIST_TOKEN_REGEX = new RegExp(`${QUOTED_BEGIN_LIST_TOKEN_MARKER}([${exports.VALID_KEY_CHARS}]+)${QUOTED_END_TOKEN_MARKER}`, "g");
const MAP_TOKEN_REGEX = new RegExp(`${QUOTED_BEGIN_MAP_TOKEN_MARKER}([${exports.VALID_KEY_CHARS}]+)${QUOTED_END_TOKEN_MARKER}`, "g");
const NUMBER_TOKEN_REGEX = new RegExp("[-|\\d|.\\+]+(e[-|\\d|.|e|E|\\+]+)", "g");
const ESCAPE_TOKEN_BEGIN_REGEX = /\$\{(?!TfToken\[)/g;
const ESCAPE_TOKEN_END_REGEX = /\}/g;
/**
 * A string with markers in it that can be resolved to external values
 */
class TokenString {
    /**
     * Returns a `TokenString` for this string.
     *
     * @param s The string to tokenize
     * @param includeEscapeSequences Whether to include escape sequences in the tokenization
     * @param warnIfEscapeSequences Whether to warn if escape sequences are found
     */
    static forString(s, includeEscapeSequences = false, warnIfEscapeSequences = false) {
        return new TokenString(s, STRING_TOKEN_REGEX, 1, includeEscapeSequences, warnIfEscapeSequences);
    }
    /**
     * Returns a `TokenString` for this string (must be the first string element of the list)
     */
    static forListToken(s) {
        return new TokenString(s, LIST_TOKEN_REGEX);
    }
    /**
     * Returns a `TokenString` for this string that handles encoded numbers
     */
    static forNumbers(s) {
        return new TokenString(s, NUMBER_TOKEN_REGEX, 0);
    }
    /**
     * Returns a `TokenString` for this string that handles encoded maps
     */
    static forMapToken(s) {
        return new TokenString(s, MAP_TOKEN_REGEX);
    }
    constructor(str, re, regexMatchIndex = 1, includeEscapeSequences = false, warnIfEscapeSequences = false) {
        this.str = str;
        this.re = re;
        this.regexMatchIndex = regexMatchIndex;
        this.includeEscapeSequences = includeEscapeSequences;
        this.warnIfEscapeSequences = warnIfEscapeSequences;
    }
    testForEscapeTokens(startIndex, maxIndex) {
        ESCAPE_TOKEN_BEGIN_REGEX.lastIndex = startIndex;
        let startMatch = ESCAPE_TOKEN_BEGIN_REGEX.exec(this.str);
        if (startMatch && startMatch.index >= maxIndex) {
            startMatch = null;
        }
        return !!startMatch;
    }
    nextEscapeToken(fragments, startIndex, escapeDepth, maxIndex) {
        ESCAPE_TOKEN_BEGIN_REGEX.lastIndex = startIndex;
        ESCAPE_TOKEN_END_REGEX.lastIndex = startIndex;
        let startMatch = ESCAPE_TOKEN_BEGIN_REGEX.exec(this.str);
        let endMatch = ESCAPE_TOKEN_END_REGEX.exec(this.str);
        if (startMatch && startMatch.index >= maxIndex) {
            startMatch = null;
        }
        if (endMatch && endMatch.index >= maxIndex) {
            endMatch = null;
        }
        if (!startMatch && !endMatch) {
            return {
                index: -1,
                escapeDepth: escapeDepth,
            };
        }
        if (startMatch && endMatch) {
            if (startMatch.index > startIndex && startMatch.index > startIndex) {
                const lede = this.str.substring(startIndex, Math.min(startMatch.index, endMatch.index));
                fragments.addLiteral(lede);
            }
            if (startMatch.index < endMatch.index) {
                fragments.addEscape("open");
                return {
                    index: ESCAPE_TOKEN_BEGIN_REGEX.lastIndex,
                    escapeDepth: escapeDepth + 1,
                };
            }
            fragments.addEscape("close");
            return {
                index: ESCAPE_TOKEN_END_REGEX.lastIndex,
                escapeDepth: escapeDepth - 1,
            };
        }
        if (startMatch) {
            if (startMatch.index > startIndex) {
                const lede = this.str.substring(startIndex, startMatch.index);
                fragments.addLiteral(lede);
            }
            fragments.addEscape("open");
            return {
                index: ESCAPE_TOKEN_BEGIN_REGEX.lastIndex,
                escapeDepth: escapeDepth + 1,
            };
        }
        if (endMatch) {
            if (endMatch.index > startIndex) {
                const lede = this.str.substring(startIndex, endMatch.index);
                fragments.addLiteral(lede);
            }
            fragments.addEscape("close");
            return {
                index: ESCAPE_TOKEN_END_REGEX.lastIndex,
                escapeDepth: escapeDepth - 1,
            };
        }
        return {
            index: -1,
            escapeDepth: escapeDepth,
        };
    }
    tokenizeNext(lookup, fragments, startIndex, escapeDepth) {
        this.re.lastIndex = startIndex;
        if (startIndex >= this.str.length) {
            return {
                index: -1,
                escapeDepth,
            };
        }
        const match = this.re.exec(this.str);
        if (!match) {
            if (this.includeEscapeSequences) {
                const next = this.nextEscapeToken(fragments, startIndex, escapeDepth, this.str.length);
                if (next.index === -1) {
                    fragments.addLiteral(this.str.substring(startIndex));
                    return {
                        index: -1,
                        escapeDepth,
                    };
                }
                else {
                    return next;
                }
            }
            fragments.addLiteral(this.str.substring(startIndex));
            return {
                index: -1,
                escapeDepth: escapeDepth,
            };
        }
        if (match.index > startIndex) {
            if (this.includeEscapeSequences) {
                const next = this.nextEscapeToken(fragments, startIndex, escapeDepth, match.index);
                if (next.index === -1) {
                    fragments.addLiteral(this.str.substring(startIndex, match.index));
                    return {
                        index: match.index,
                        escapeDepth: escapeDepth,
                    };
                }
                else {
                    return next;
                }
            }
            const lede = this.str.substring(startIndex, match.index);
            fragments.addLiteral(lede);
            return {
                index: match.index,
                escapeDepth,
            };
        }
        const token = lookup(match[this.regexMatchIndex]);
        if (token) {
            fragments.addToken(token);
        }
        else {
            fragments.addLiteral(this.str.substring(match.index, this.re.lastIndex));
        }
        const nextIndex = this.re.lastIndex;
        return {
            index: nextIndex,
            escapeDepth,
        };
    }
    /**
     * Split string on markers, substituting markers with Tokens
     */
    split(lookup) {
        const ret = new string_fragments_1.TokenizedStringFragments();
        let index = 0;
        let escapeDepth = 0;
        if (this.warnIfEscapeSequences &&
            this.testForEscapeTokens(0, this.str.length)) {
            // Only print warning and act as if escape sequences are ignored
            console.warn("You're using escape sequences (${...}) with CDKTF Built-in functions. This is not supported yet, and the output may be incorrect.");
            console.warn(this.str);
        }
        while (index >= 0) {
            const iter = this.tokenizeNext(lookup, ret, index, escapeDepth);
            index = iter.index;
            escapeDepth = iter.escapeDepth;
        }
        return ret;
    }
    /**
     * Indicates if this string includes tokens.
     */
    test() {
        this.re.lastIndex = 0; // Reset
        return this.re.test(this.str);
    }
}
exports.TokenString = TokenString;
/**
 * Quote a string for use in a regex
 */
function regexQuote(s) {
    return s.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
exports.regexQuote = regexQuote;
/**
 * Concatenator that disregards the input
 *
 * Can be used when traversing the tokens is important, but the
 * result isn't.
 */
class NullConcat {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    join(_left, _right) {
        return undefined;
    }
}
exports.NullConcat = NullConcat;
/**
 * Returns true if argument contains a string list token
 */
function containsStringListTokenElement(xs) {
    return xs.some((x) => typeof x === "string" && TokenString.forListToken(x).test());
}
exports.containsStringListTokenElement = containsStringListTokenElement;
/**
 * Returns true if argument contains a number list token
 */
function containsNumberListTokenElement(xs) {
    return xs.some((x) => typeof x === "number" && extractTokenDouble(x, true) !== undefined);
}
exports.containsNumberListTokenElement = containsNumberListTokenElement;
/**
 * Returns true if argument contains a string map token
 */
function containsMapToken(xs) {
    return Object.keys(xs).some((x) => typeof x === "string" && TokenString.forMapToken(x).test());
}
exports.containsMapToken = containsMapToken;
/**
 * Returns true if argument is a complex element
 */
function isComplexElement(xs) {
    return (typeof xs === "object" &&
        xs !== null &&
        "withinArray" in xs &&
        "interpolationAsList" in xs);
}
exports.isComplexElement = isComplexElement;
/**
 * Returns true if list contains a complex element
 */
function containsComplexElement(xs) {
    return xs.length > 0 && isComplexElement(xs[0]);
}
exports.containsComplexElement = containsComplexElement;
/**
 * Returns true if obj is a token (i.e. has the resolve() method or is a string
 * that includes token markers), or it's a listifictaion of a Token string.
 *
 * @param obj The object to test.
 */
function unresolved(obj) {
    if (typeof obj === "string") {
        return TokenString.forString(obj).test();
    }
    else if (typeof obj === "number") {
        return extractTokenDouble(obj, false) !== undefined;
    }
    else if (Array.isArray(obj) && obj.length === 1) {
        return ((typeof obj[0] === "string" && TokenString.forListToken(obj[0]).test()) ||
            (typeof obj[0] === "number" &&
                extractTokenDouble(obj[0], true) !== undefined));
    }
    else if (obj != null && containsMapToken(obj)) {
        return true;
    }
    else {
        return token_1.Tokenization.isResolvable(obj);
    }
}
exports.unresolved = unresolved;
/**
 * Bit pattern in the top 16 bits of a double to indicate a Token
 *
 * An IEEE double in LE memory order looks like this (grouped
 * into octets, then grouped into 32-bit words):
 *
 * mmmmmmmm.mmmmmmmm.mmmmmmmm.mmmmmmmm | mmmmmmmm.mmmmmmmm.EEEEmmmm.sEEEEEEE
 *
 * - m: mantissa (52 bits)
 * - E: exponent (11 bits)
 * - s: sign (1 bit)
 *
 * We put the following marker into the top 16 bits (exponent and sign), and
 * use the mantissa part to encode the token index. To save some bit twiddling
 * we use all top 16 bits for the tag. That loses us 4 mantissa bits to store
 * information in but we still have 48, which is going to be plenty for any
 * number of tokens to be created during the lifetime of any CDK application.
 *
 * Can't have all bits set because that makes a NaN, so unset the least
 * significant exponent bit.
 *
 * Currently not supporting BE architectures.
 */
// tslint:disable-next-line:no-bitwise
const DOUBLE_TOKEN_MARKER_BITS = 0xfdff << 16;
// tslint:disable-next-line:no-bitwise
const DOUBLE_LIST_TOKEN_MARKER_BITS = 0xfbff << 16;
/**
 * Highest encodable number
 */
const MAX_ENCODABLE_INTEGER = Math.pow(2, 48) - 1;
/**
 * Get 2^32 as a number, so we can do multiplication and div instead of bit shifting
 *
 * Necessary because in JavaScript, bit operations implicitly convert
 * to int32 and we need them to work on "int64"s.
 *
 * So instead of x >> 32, we do Math.floor(x / 2^32), and vice versa.
 */
const BITS32 = Math.pow(2, 32);
/**
 * Return a special Double value that encodes the given nonnegative integer
 *
 * We use this to encode Token ordinals.
 */
function createTokenDouble(x, list) {
    if (Math.floor(x) !== x || x < 0) {
        throw (0, errors_1.canOnlyEncodePositiveIntegers)();
    }
    if (x > MAX_ENCODABLE_INTEGER) {
        throw (0, errors_1.indexTooLargeToEncode)(x);
    }
    const buf = new ArrayBuffer(8);
    const ints = new Uint32Array(buf);
    // tslint:disable:no-bitwise
    ints[0] = x & 0x0000ffffffff; // Bottom 32 bits of number
    // This needs an "x >> 32" but that will make it a 32-bit number instead
    // of a 64-bit number.
    ints[1] =
        (shr32(x) & 0xffff) |
            (list ? DOUBLE_LIST_TOKEN_MARKER_BITS : DOUBLE_TOKEN_MARKER_BITS); // Top 16 bits of number and the mask
    // tslint:enable:no-bitwise
    return new Float64Array(buf)[0];
}
exports.createTokenDouble = createTokenDouble;
/**
 * Shift a 64-bit int right 32 bits
 */
function shr32(x) {
    return Math.floor(x / BITS32);
}
/**
 * Shift a 64-bit left 32 bits
 */
function shl32(x) {
    return x * BITS32;
}
/**
 * Extract the encoded integer out of the special Double value
 *
 * Returns undefined if the float is a not an encoded token.
 */
function extractTokenDouble(encoded, list) {
    const buf = new ArrayBuffer(8);
    new Float64Array(buf)[0] = encoded;
    const ints = new Uint32Array(buf);
    // tslint:disable:no-bitwise
    if ((ints[1] & 0xffff0000) !==
        (list ? DOUBLE_LIST_TOKEN_MARKER_BITS : DOUBLE_TOKEN_MARKER_BITS)) {
        return undefined;
    }
    // Must use + instead of | here (bitwise operations
    // will force 32-bits integer arithmetic, + will not).
    return ints[0] + shl32(ints[1] & 0xffff);
    // tslint:enable:no-bitwise
}
exports.extractTokenDouble = extractTokenDouble;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW5jb2RpbmcuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJlbmNvZGluZy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSwrQkFBK0I7QUFDL0IsbUNBQW1DO0FBQ25DLHNIQUFzSDtBQUN0SCx5Q0FHc0I7QUFFdEIsMERBQStEO0FBQy9ELG9DQUF3QztBQUl4QyxxRkFBcUY7QUFFeEUsUUFBQSx5QkFBeUIsR0FBRyxZQUFZLENBQUM7QUFDekMsUUFBQSx1QkFBdUIsR0FBRyxZQUFZLENBQUM7QUFDdkMsUUFBQSxzQkFBc0IsR0FBRyxZQUFZLENBQUM7QUFDdEMsUUFBQSxnQkFBZ0IsR0FBRyxJQUFJLENBQUM7QUFFeEIsUUFBQSxlQUFlLEdBQUcsZUFBZSxDQUFDO0FBRS9DLE1BQU0sZ0NBQWdDLEdBQUcsVUFBVSxDQUFDLGlDQUF5QixDQUFDLENBQUM7QUFDL0UsTUFBTSw4QkFBOEIsR0FBRyxVQUFVLENBQUMsK0JBQXVCLENBQUMsQ0FBQztBQUMzRSxNQUFNLDZCQUE2QixHQUFHLFVBQVUsQ0FBQyw4QkFBc0IsQ0FBQyxDQUFDO0FBQ3pFLE1BQU0sdUJBQXVCLEdBQUcsVUFBVSxDQUFDLHdCQUFnQixDQUFDLENBQUM7QUFFN0QsTUFBTSxrQkFBa0IsR0FBRyxJQUFJLE1BQU0sQ0FDbkMsR0FBRyxnQ0FBZ0MsS0FBSyx1QkFBZSxNQUFNLHVCQUF1QixFQUFFLEVBQ3RGLEdBQUcsQ0FDSixDQUFDO0FBQ0YsTUFBTSxnQkFBZ0IsR0FBRyxJQUFJLE1BQU0sQ0FDakMsR0FBRyw4QkFBOEIsS0FBSyx1QkFBZSxNQUFNLHVCQUF1QixFQUFFLEVBQ3BGLEdBQUcsQ0FDSixDQUFDO0FBQ0YsTUFBTSxlQUFlLEdBQUcsSUFBSSxNQUFNLENBQ2hDLEdBQUcsNkJBQTZCLEtBQUssdUJBQWUsTUFBTSx1QkFBdUIsRUFBRSxFQUNuRixHQUFHLENBQ0osQ0FBQztBQUVGLE1BQU0sa0JBQWtCLEdBQUcsSUFBSSxNQUFNLENBQ25DLG9DQUFvQyxFQUNw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Ozs7O0dBSUc7QUFDSCxTQUFnQixrQkFBa0IsQ0FDaEMsT0FBZSxFQUNmLElBQWE7SUFFYixNQUFNLEdBQUcsR0FBRyxJQUFJLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMvQixJQUFJLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUM7SUFFbkMsTUFBTSxJQUFJLEdBQUcsSUFBSSxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUM7SUFFbEMsNEJBQTRCO0lBQzVCLElBQ0UsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDO1FBQ3RCLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyw2QkFBNkIsQ0FBQyxDQUFDLENBQUMsd0JBQXdCLENBQUMsRUFDakUsQ0FBQztRQUNELE9BQU8sU0FBUyxDQUFDO0lBQ25CLENBQUM7SUFFRCxtREFBbUQ7SUFDbkQsc0RBQXNEO0lBQ3RELE9BQU8sSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUM7SUFDekMsMkJBQTJCO0FBQzdCLENBQUM7QUFyQkQsZ0RBcUJDIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSBIYXNoaUNvcnAsIEluY1xuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1QTC0yLjBcbi8vIGNvcGllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvY29uc3RydWN0cy9ibG9iL2UwMWU0N2Y3OGVmMWU5YjYwMGVmY2QyM2ZmNzcwNWFhOGQzODQwMTcvbGliL3ByaXZhdGUvZW5jb2RpbmcudHNcbmltcG9ydCB7XG4gIGNhbk9ubHlFbmNvZGVQb3NpdGl2ZUludGVnZXJzLFxuICBpbmRleFRvb0xhcmdlVG9FbmNvZGUsXG59IGZyb20gXCIuLi8uLi9lcnJvcnNcIjtcbmltcG9ydCB7IElGcmFnbWVudENvbmNhdGVuYXRvciwgSVJlc29sdmFibGUgfSBmcm9tIFwiLi4vcmVzb2x2YWJsZVwiO1xuaW1wb3J0IHsgVG9rZW5pemVkU3RyaW5nRnJhZ21lbnRzIH0gZnJvbSBcIi4uL3N0cmluZy1mcmFnbWVudHNcIjtcbmltcG9ydCB7IFRva2VuaXphdGlvbiB9IGZyb20gXCIuLi90b2tlblwiO1xuXG50eXBlIExvb2t1cEZ1bmN0aW9uID0gKGlkOiBzdHJpbmcpID0+IElSZXNvbHZhYmxlIHwgdW5kZWZpbmVkO1xuXG4vLyBEZXRhaWxzIGZvciBlbmNvZGluZyBhbmQgZGVjb2RpbmcgVG9rZW5zIGludG8gbmF0aXZlIHR5cGVzOyBzaG91bGQgbm90IGJlIGV4cG9ydGVkXG5cbmV4cG9ydCBjb25zdCBCRUdJTl9TVFJJTkdfVE9LRU5fTUFSS0VSID0gXCIke1RmVG9rZW5bXCI7XG5leHBvcnQgY29uc3QgQkVHSU5fTElTVF9UT0tFTl9NQVJLRVIgPSBcIiN7VGZUb2tlbltcIjtcbmV4cG9ydCBjb25zdCBCRUdJTl9NQVBfVE9LRU5fTUFSS0VSID0gXCIme1RmVG9rZW5bXCI7XG5leHBvcnQgY29uc3QgRU5EX1RPS0VOX01BUktFUiA9IFwiXX1cIjtcblxuZXhwb3J0IGNvbnN0IFZBTElEX0tFWV9DSEFSUyA9IFwiYS16QS1aMC05Oi5fLVwiO1xuXG5jb25zdCBRVU9URURfQkVHSU5fU1RSSU5HX1RPS0VOX01BUktFUiA9IHJlZ2V4UXVvdGUoQkVHSU5fU1RSSU5HX1RPS0VOX01BUktFUik7XG5jb25zdCBRVU9URURfQkVHSU5fTElTVF9UT0tFTl9NQVJLRVIgPSByZWdleFF1b3RlKEJFR0lOX0xJU1RfVE9LRU5fTUFSS0VSKTtcbmNvbnN0IFFVT1RFRF9CRUdJTl9NQVBfVE9LRU5fTUFSS0VSID0gcmVnZXhRdW90ZShCRUdJTl9NQVBfVE9LRU5fTUFSS0VSKTtcbmNvbnN0IFFVT1RFRF9FTkRfVE9LRU5fTUFSS0VSID0gcmVnZXhRdW90ZShFTkRfVE9LRU5fTUFSS0VSKTtcblxuY29uc3QgU1RSSU5HX1RPS0VOX1JFR0VYID0gbmV3IFJlZ0V4cChcbiAgYCR7UVVPVEVEX0JFR0lOX1NUUklOR19UT0tFTl9NQVJLRVJ9KFske1ZBTElEX0tFWV9DSEFSU31dKykke1FVT1RFRF9FTkRfVE9LRU5fTUFSS0VSfWAsXG4gIFwiZ1wiXG4pO1xuY29uc3QgTElTVF9UT0tFTl9SRUdFWCA9IG5ldyBSZWdFeHAoXG4gIGAke1FVT1RFRF9CRUdJTl9MSVNUX1RPS0VOX01BUktFUn0oWyR7VkFMSURfS0VZX0NIQVJTfV0rKSR7UVVPVEVEX0VORF9UT0tFTl9NQVJLRVJ9YCxcbiAgXCJnXCJcbik7XG5jb25zdCBNQVBfVE9LRU5fUkVHRVggPSBuZXcgUmVnRXhwKFxuICBgJHtRVU9URURfQkVHSU5fTUFQX1RPS0VOX01BUktFUn0oWyR7VkFMSURfS0VZX0NIQVJTfV0rKSR7UVVPVEVEX0VORF9UT0tFTl9NQVJLRVJ9YCxcbiAgXCJnXCJcbik7XG5cbmNvbnN0IE5VTUJFUl9UT0tFTl9SRUdFWCA9IG5ldyBSZWdFeHAoXG4gIFwiWy18XFxcXGR8LlxcXFwrXSsoZVstfFxcXFxkfC58ZXxFfFxcXFwrXSspXCIsXG4gIFwiZ1wiXG4pO1xuXG5jb25zdCBFU0NBUEVfVE9LRU5fQkVHSU5fUkVHRVggPSAvXFwkXFx7KD8hVGZUb2tlblxcWykvZztcbmNvbnN0IEVTQ0FQRV9UT0tFTl9FTkRfUkVHRVggPSAvXFx9L2c7XG5cbi8qKlxuICogQSBzdHJpbmcgd2l0aCBtYXJrZXJzIGluIGl0IHRoYXQgY2FuIGJlIHJlc29sdmVkIHRvIGV4dGVybmFsIHZhbHVlc1xuICovXG5leHBvcnQgY2xhc3MgVG9rZW5TdHJpbmcge1xuICAvKipcbiAgICogUmV0dXJucyBhIGBUb2tlblN0cmluZ2AgZm9yIHRoaXMgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0gcyBUaGUgc3RyaW5nIHRvIHRva2VuaXplXG4gICAqIEBwYXJhbSBpbmNsdWRlRXNjYXBlU2VxdWVuY2VzIFdoZXRoZXIgdG8gaW5jbHVkZSBlc2NhcGUgc2VxdWVuY2VzIGluIHRoZSB0b2tlbml6YXRpb25cbiAgICogQHBhcmFtIHdhcm5JZkVzY2FwZVNlcXVlbmNlcyBXaGV0aGVyIHRvIHdhcm4gaWYgZXNjYXBlIHNlcXVlbmNlcyBhcmUgZm91bmRcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZm9yU3RyaW5nKFxuICAgIHM6IHN0cmluZyxcbiAgICBpbmNsdWRlRXNjYXBlU2VxdWVuY2VzID0gZmFsc2UsXG4gICAgd2FybklmRXNjYXBlU2VxdWVuY2VzID0gZmFsc2VcbiAgKSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlblN0cmluZyhcbiAgICAgIHMsXG4gICAgICBTVFJJTkdfVE9LRU5fUkVHRVgsXG4gICAgICAxLFxuICAgICAgaW5jbHVkZUVzY2FwZVNlcXVlbmNlcyxcbiAgICAgIHdhcm5JZkVzY2FwZVNlcXVlbmNlc1xuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGBUb2tlblN0cmluZ2AgZm9yIHRoaXMgc3RyaW5nIChtdXN0IGJlIHRoZSBmaXJzdCBzdHJpbmcgZWxlbWVudCBvZiB0aGUgbGlzdClcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZm9yTGlzdFRva2VuKHM6IHN0cmluZykge1xuICAgIHJldHVybiBuZXcgVG9rZW5TdHJpbmcocywgTElTVF9UT0tFTl9SRUdFWCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGBUb2tlblN0cmluZ2AgZm9yIHRoaXMgc3RyaW5nIHRoYXQgaGFuZGxlcyBlbmNvZGVkIG51bWJlcnNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZm9yTnVtYmVycyhzOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gbmV3IFRva2VuU3RyaW5nKHMsIE5VTUJFUl9UT0tFTl9SRUdFWCwgMCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGBUb2tlblN0cmluZ2AgZm9yIHRoaXMgc3RyaW5nIHRoYXQgaGFuZGxlcyBlbmNvZGVkIG1hcHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZm9yTWFwVG9rZW4oczogc3RyaW5nKSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlblN0cmluZyhzLCBNQVBfVE9LRU5fUkVHRVgpO1xuICB9XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBzdHI6IHN0cmluZyxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHJlOiBSZWdFeHAsXG4gICAgcHJpdmF0ZSByZWFkb25seSByZWdleE1hdGNoSW5kZXg6IG51bWJlciA9IDEsXG4gICAgcHJpdmF0ZSByZWFkb25seSBpbmNsdWRlRXNjYXBlU2VxdWVuY2VzOiBib29sZWFuID0gZmFsc2UsXG4gICAgcHJpdmF0ZSByZWFkb25seSB3YXJuSWZFc2NhcGVTZXF1ZW5jZXM6IGJvb2xlYW4gPSBmYWxzZVxuICApIHt9XG5cbiAgcHJpdmF0ZSB0ZXN0Rm9yRXNjYXBlVG9rZW5zKHN0YXJ0SW5kZXg6IG51bWJlciwgbWF4SW5kZXg6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIEVTQ0FQRV9UT0tFTl9CRUdJTl9SRUdFWC5sYXN0SW5kZXggPSBzdGFydEluZGV4O1xuICAgIGxldCBzdGFydE1hdGNoID0gRVNDQVBFX1RPS0VOX0JFR0lOX1JFR0VYLmV4ZWModGhpcy5zdHIpO1xuXG4gICAgaWYgKHN0YXJ0TWF0Y2ggJiYgc3RhcnRNYXRjaC5pbmRleCA+PSBtYXhJbmRleCkge1xuICAgICAgc3RhcnRNYXRjaCA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuICEhc3RhcnRNYXRjaDtcbiAgfVxuXG4gIHByaXZhdGUgbmV4dEVzY2FwZVRva2VuKFxuICAgIGZyYWdtZW50czogVG9rZW5pemVkU3RyaW5nRnJhZ21lbnRzLFxuICAgIHN0YXJ0SW5kZXg6IG51bWJlcixcbiAgICBlc2NhcGVEZXB0aDogbnVtYmVyLFxuICAgIG1heEluZGV4OiBudW1iZXJcbiAgKSB7XG4gICAgRVNDQVBFX1RPS0VOX0JFR0lOX1JFR0VYLmxhc3RJbmRleCA9IHN0YXJ0SW5kZXg7XG4gICAgRVNDQVBFX1RPS0VOX0VORF9SRUdFWC5sYXN0SW5kZXggPSBzdGFydEluZGV4O1xuICAgIGxldCBzdGFydE1hdGNoID0gRVNDQVBFX1RPS0VOX0JFR0lOX1JFR0VYLmV4ZWModGhpcy5zdHIpO1xuICAgIGxldCBlbmRNYXRjaCA9IEVTQ0FQRV9UT0tFTl9FTkRfUkVHRVguZXhlYyh0aGlzLnN0cik7XG5cbiAgICBpZiAoc3RhcnRNYXRjaCAmJiBzdGFydE1hdGNoLmluZGV4ID49IG1heEluZGV4KSB7XG4gICAgICBzdGFydE1hdGNoID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGVuZE1hdGNoICYmIGVuZE1hdGNoLmluZGV4ID49IG1heEluZGV4KSB7XG4gICAgICBlbmRNYXRjaCA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCFzdGFydE1hdGNoICYmICFlbmRNYXRjaCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5kZXg6IC0xLFxuICAgICAgICBlc2NhcGVEZXB0aDogZXNjYXBlRGVwdGgsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChzdGFydE1hdGNoICYmIGVuZE1hdGNoKSB7XG4gICAgICBpZiAoc3RhcnRNYXRjaC5pbmRleCA+IHN0YXJ0SW5kZXggJiYgc3RhcnRNYXRjaC5pbmRleCA+IHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgY29uc3QgbGVkZSA9IHRoaXMuc3RyLnN1YnN0cmluZyhcbiAgICAgICAgICBzdGFydEluZGV4LFxuICAgICAgICAgIE1hdGgubWluKHN0YXJ0TWF0Y2guaW5kZXgsIGVuZE1hdGNoLmluZGV4KVxuICAgICAgICApO1xuICAgICAgICBmcmFnbWVudHMuYWRkTGl0ZXJhbChsZWRlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXJ0TWF0Y2guaW5kZXggPCBlbmRNYXRjaC5pbmRleCkge1xuICAgICAgICBmcmFnbWVudHMuYWRkRXNjYXBlKFwib3BlblwiKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGluZGV4OiBFU0NBUEVfVE9LRU5fQkVHSU5fUkVHRVgubGFzdEluZGV4LFxuICAgICAgICAgIGVzY2FwZURlcHRoOiBlc2NhcGVEZXB0aCArIDEsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGZyYWdtZW50cy5hZGRFc2NhcGUoXCJjbG9zZVwiKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluZGV4OiBFU0NBUEVfVE9LRU5fRU5EX1JFR0VYLmxhc3RJbmRleCxcbiAgICAgICAgZXNjYXBlRGVwdGg6IGVzY2FwZURlcHRoIC0gMSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0TWF0Y2gpIHtcbiAgICAgIGlmIChzdGFydE1hdGNoLmluZGV4ID4gc3RhcnRJbmRleCkge1xuICAgICAgICBjb25zdCBsZWRlID0gdGhpcy5zdHIuc3Vic3RyaW5nKHN0YXJ0SW5kZXgsIHN0YXJ0TWF0Y2guaW5kZXgpO1xuICAgICAgICBmcmFnbWVudHMuYWRkTGl0ZXJhbChsZWRlKTtcbiAgICAgIH1cblxuICAgICAgZnJhZ21lbnRzLmFkZEVzY2FwZShcIm9wZW5cIik7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluZGV4OiBFU0NBUEVfVE9LRU5fQkVHSU5fUkVHRVgubGFzdEluZGV4LFxuICAgICAgICBlc2NhcGVEZXB0aDogZXNjYXBlRGVwdGggKyAxLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoZW5kTWF0Y2gpIHtcbiAgICAgIGlmIChlbmRNYXRjaC5pbmRleCA+IHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgY29uc3QgbGVkZSA9IHRoaXMuc3RyLnN1YnN0cmluZyhzdGFydEluZGV4LCBlbmRNYXRjaC5pbmRleCk7XG4gICAgICAgIGZyYWdtZW50cy5hZGRMaXRlcmFsKGxlZGUpO1xuICAgICAgfVxuXG4gICAgICBmcmFnbWVudHMuYWRkRXNjYXBlKFwiY2xvc2VcIik7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluZGV4OiBFU0NBUEVfVE9LRU5fRU5EX1JFR0VYLmxhc3RJbmRleCxcbiAgICAgICAgZXNjYXBlRGVwdGg6IGVzY2FwZURlcHRoIC0gMSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGluZGV4OiAtMSxcbiAgICAgIGVzY2FwZURlcHRoOiBlc2NhcGVEZXB0aCxcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSB0b2tlbml6ZU5leHQoXG4gICAgbG9va3VwOiBMb29rdXBGdW5jdGlvbixcbiAgICBmcmFnbWVudHM6IFRva2VuaXplZFN0cmluZ0ZyYWdtZW50cyxcbiAgICBzdGFydEluZGV4OiBudW1iZXIsXG4gICAgZXNjYXBlRGVwdGg6IG51bWJlclxuICApOiB7IGluZGV4OiBudW1iZXI7IGVzY2FwZURlcHRoOiBudW1iZXIgfSB7XG4gICAgdGhpcy5yZS5sYXN0SW5kZXggPSBzdGFydEluZGV4O1xuICAgIGlmIChzdGFydEluZGV4ID49IHRoaXMuc3RyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5kZXg6IC0xLFxuICAgICAgICBlc2NhcGVEZXB0aCxcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IG1hdGNoID0gdGhpcy5yZS5leGVjKHRoaXMuc3RyKTtcblxuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIGlmICh0aGlzLmluY2x1ZGVFc2NhcGVTZXF1ZW5jZXMpIHtcbiAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMubmV4dEVzY2FwZVRva2VuKFxuICAgICAgICAgIGZyYWdtZW50cyxcbiAgICAgICAgICBzdGFydEluZGV4LFxuICAgICAgICAgIGVzY2FwZURlcHRoLFxuICAgICAgICAgIHRoaXMuc3RyLmxlbmd0aFxuICAgICAgICApO1xuICAgICAgICBpZiAobmV4dC5pbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICBmcmFnbWVudHMuYWRkTGl0ZXJhbCh0aGlzLnN0ci5zdWJzdHJpbmcoc3RhcnRJbmRleCkpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbmRleDogLTEsXG4gICAgICAgICAgICBlc2NhcGVEZXB0aCxcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZyYWdtZW50cy5hZGRMaXRlcmFsKHRoaXMuc3RyLnN1YnN0cmluZyhzdGFydEluZGV4KSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbmRleDogLTEsXG4gICAgICAgIGVzY2FwZURlcHRoOiBlc2NhcGVEZXB0aCxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKG1hdGNoLmluZGV4ID4gc3RhcnRJbmRleCkge1xuICAgICAgaWYgKHRoaXMuaW5jbHVkZUVzY2FwZVNlcXVlbmNlcykge1xuICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy5uZXh0RXNjYXBlVG9rZW4oXG4gICAgICAgICAgZnJhZ21lbnRzLFxuICAgICAgICAgIHN0YXJ0SW5kZXgsXG4gICAgICAgICAgZXNjYXBlRGVwdGgsXG4gICAgICAgICAgbWF0Y2guaW5kZXhcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKG5leHQuaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgZnJhZ21lbnRzLmFkZExpdGVyYWwodGhpcy5zdHIuc3Vic3RyaW5nKHN0YXJ0SW5kZXgsIG1hdGNoLmluZGV4KSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGluZGV4OiBtYXRjaC5pbmRleCxcbiAgICAgICAgICAgIGVzY2FwZURlcHRoOiBlc2NhcGVEZXB0aCxcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxlZGUgPSB0aGlzLnN0ci5zdWJzdHJpbmcoc3RhcnRJbmRleCwgbWF0Y2guaW5kZXgpO1xuICAgICAgZnJhZ21lbnRzLmFkZExpdGVyYWwobGVkZSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluZGV4OiBtYXRjaC5pbmRleCxcbiAgICAgICAgZXNjYXBlRGVwdGgsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IHRva2VuID0gbG9va3VwKG1hdGNoW3RoaXMucmVnZXhNYXRjaEluZGV4XSk7XG4gICAgaWYgKHRva2VuKSB7XG4gICAgICBmcmFnbWVudHMuYWRkVG9rZW4odG9rZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmcmFnbWVudHMuYWRkTGl0ZXJhbCh0aGlzLnN0ci5zdWJzdHJpbmcobWF0Y2guaW5kZXgsIHRoaXMucmUubGFzdEluZGV4KSk7XG4gICAgfVxuXG4gICAgY29uc3QgbmV4dEluZGV4ID0gdGhpcy5yZS5sYXN0SW5kZXg7XG5cbiAgICByZXR1cm4ge1xuICAgICAgaW5kZXg6IG5leHRJbmRleCxcbiAgICAgIGVzY2FwZURlcHRoLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogU3BsaXQgc3RyaW5nIG9uIG1hcmtlcnMsIHN1YnN0aXR1dGluZyBtYXJrZXJzIHdpdGggVG9rZW5zXG4gICAqL1xuICBwdWJsaWMgc3BsaXQobG9va3VwOiBMb29rdXBGdW5jdGlvbik6IFRva2VuaXplZFN0cmluZ0ZyYWdtZW50cyB7XG4gICAgY29uc3QgcmV0ID0gbmV3IFRva2VuaXplZFN0cmluZ0ZyYWdtZW50cygpO1xuXG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBsZXQgZXNjYXBlRGVwdGggPSAwO1xuICAgIGlmIChcbiAgICAgIHRoaXMud2FybklmRXNjYXBlU2VxdWVuY2VzICYmXG4gICAgICB0aGlzLnRlc3RGb3JFc2NhcGVUb2tlbnMoMCwgdGhpcy5zdHIubGVuZ3RoKVxuICAgICkge1xuICAgICAgLy8gT25seSBwcmludCB3YXJuaW5nIGFuZCBhY3QgYXMgaWYgZXNjYXBlIHNlcXVlbmNlcyBhcmUgaWdub3JlZFxuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBcIllvdSdyZSB1c2luZyBlc2NhcGUgc2VxdWVuY2VzICgkey4uLn0pIHdpdGggQ0RLVEYgQnVpbHQtaW4gZnVuY3Rpb25zLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgeWV0LCBhbmQgdGhlIG91dHB1dCBtYXkgYmUgaW5jb3JyZWN0LlwiXG4gICAgICApO1xuICAgICAgY29uc29sZS53YXJuKHRoaXMuc3RyKTtcbiAgICB9XG4gICAgd2hpbGUgKGluZGV4ID49IDApIHtcbiAgICAgIGNvbnN0IGl0ZXIgPSB0aGlzLnRva2VuaXplTmV4dChsb29rdXAsIHJldCwgaW5kZXgsIGVzY2FwZURlcHRoKTtcbiAgICAgIGluZGV4ID0gaXRlci5pbmRleDtcbiAgICAgIGVzY2FwZURlcHRoID0gaXRlci5lc2NhcGVEZXB0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyBpZiB0aGlzIHN0cmluZyBpbmNsdWRlcyB0b2tlbnMuXG4gICAqL1xuICBwdWJsaWMgdGVzdCgpOiBib29sZWFuIHtcbiAgICB0aGlzLnJlLmxhc3RJbmRleCA9IDA7IC8vIFJlc2V0XG4gICAgcmV0dXJuIHRoaXMucmUudGVzdCh0aGlzLnN0cik7XG4gIH1cbn1cblxuLyoqXG4gKiBRdW90ZSBhIHN0cmluZyBmb3IgdXNlIGluIGEgcmVnZXhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlZ2V4UXVvdGUoczogc3RyaW5nKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoL1suPyorXiRbXFxdXFxcXCgpe318LV0vZywgXCJcXFxcJCZcIik7XG59XG5cbi8qKlxuICogQ29uY2F0ZW5hdG9yIHRoYXQgZGlzcmVnYXJkcyB0aGUgaW5wdXRcbiAqXG4gKiBDYW4gYmUgdXNlZCB3aGVuIHRyYXZlcnNpbmcgdGhlIHRva2VucyBpcyBpbXBvcnRhbnQsIGJ1dCB0aGVcbiAqIHJlc3VsdCBpc24ndC5cbiAqL1xuZXhwb3J0IGNsYXNzIE51bGxDb25jYXQgaW1wbGVtZW50cyBJRnJhZ21lbnRDb25jYXRlbmF0b3Ige1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIHB1YmxpYyBqb2luKF9sZWZ0OiBhbnkgfCB1bmRlZmluZWQsIF9yaWdodDogYW55IHwgdW5kZWZpbmVkKTogYW55IHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGFyZ3VtZW50IGNvbnRhaW5zIGEgc3RyaW5nIGxpc3QgdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnRhaW5zU3RyaW5nTGlzdFRva2VuRWxlbWVudCh4czogYW55W10pIHtcbiAgcmV0dXJuIHhzLnNvbWUoXG4gICAgKHgpID0+IHR5cGVvZiB4ID09PSBcInN0cmluZ1wiICYmIFRva2VuU3RyaW5nLmZvckxpc3RUb2tlbih4KS50ZXN0KClcbiAgKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYXJndW1lbnQgY29udGFpbnMgYSBudW1iZXIgbGlzdCB0b2tlblxuICovXG5leHBvcnQgZnVuY3Rpb24gY29udGFpbnNOdW1iZXJMaXN0VG9rZW5FbGVtZW50KHhzOiBhbnlbXSkge1xuICByZXR1cm4geHMuc29tZShcbiAgICAoeCkgPT4gdHlwZW9mIHggPT09IFwibnVtYmVyXCIgJiYgZXh0cmFjdFRva2VuRG91YmxlKHgsIHRydWUpICE9PSB1bmRlZmluZWRcbiAgKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYXJndW1lbnQgY29udGFpbnMgYSBzdHJpbmcgbWFwIHRva2VuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb250YWluc01hcFRva2VuKHhzOiB7IFtrZXk6IHN0cmluZ106IGFueSB9KSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyh4cykuc29tZShcbiAgICAoeCkgPT4gdHlwZW9mIHggPT09IFwic3RyaW5nXCIgJiYgVG9rZW5TdHJpbmcuZm9yTWFwVG9rZW4oeCkudGVzdCgpXG4gICk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGFyZ3VtZW50IGlzIGEgY29tcGxleCBlbGVtZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0NvbXBsZXhFbGVtZW50KHhzOiBhbnkpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgeHMgPT09IFwib2JqZWN0XCIgJiZcbiAgICB4cyAhPT0gbnVsbCAmJlxuICAgIFwid2l0aGluQXJyYXlcIiBpbiB4cyAmJlxuICAgIFwiaW50ZXJwb2xhdGlvbkFzTGlzdFwiIGluIHhzXG4gICk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGxpc3QgY29udGFpbnMgYSBjb21wbGV4IGVsZW1lbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnRhaW5zQ29tcGxleEVsZW1lbnQoeHM6IGFueSkge1xuICByZXR1cm4geHMubGVuZ3RoID4gMCAmJiBpc0NvbXBsZXhFbGVtZW50KHhzWzBdKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgb2JqIGlzIGEgdG9rZW4gKGkuZS4gaGFzIHRoZSByZXNvbHZlKCkgbWV0aG9kIG9yIGlzIGEgc3RyaW5nXG4gKiB0aGF0IGluY2x1ZGVzIHRva2VuIG1hcmtlcnMpLCBvciBpdCdzIGEgbGlzdGlmaWN0YWlvbiBvZiBhIFRva2VuIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gb2JqIFRoZSBvYmplY3QgdG8gdGVzdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVucmVzb2x2ZWQob2JqOiBhbnkpOiBib29sZWFuIHtcbiAgaWYgKHR5cGVvZiBvYmogPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gVG9rZW5TdHJpbmcuZm9yU3RyaW5nKG9iaikudGVzdCgpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gZXh0cmFjdFRva2VuRG91YmxlKG9iaiwgZmFsc2UpICE9PSB1bmRlZmluZWQ7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmopICYmIG9iai5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gKFxuICAgICAgKHR5cGVvZiBvYmpbMF0gPT09IFwic3RyaW5nXCIgJiYgVG9rZW5TdHJpbmcuZm9yTGlzdFRva2VuKG9ialswXSkudGVzdCgpKSB8fFxuICAgICAgKHR5cGVvZiBvYmpbMF0gPT09IFwibnVtYmVyXCIgJiZcbiAgICAgICAgZXh0cmFjdFRva2VuRG91YmxlKG9ialswXSwgdHJ1ZSkgIT09IHVuZGVmaW5lZClcbiAgICApO1xuICB9IGVsc2UgaWYgKG9iaiAhPSBudWxsICYmIGNvbnRhaW5zTWFwVG9rZW4ob2JqKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBUb2tlbml6YXRpb24uaXNSZXNvbHZhYmxlKG9iaik7XG4gIH1cbn1cblxuLyoqXG4gKiBCaXQgcGF0dGVybiBpbiB0aGUgdG9wIDE2IGJpdHMgb2YgYSBkb3VibGUgdG8gaW5kaWNhdGUgYSBUb2tlblxuICpcbiAqIEFuIElFRUUgZG91YmxlIGluIExFIG1lbW9yeSBvcmRlciBsb29rcyBsaWtlIHRoaXMgKGdyb3VwZWRcbiAqIGludG8gb2N0ZXRzLCB0aGVuIGdyb3VwZWQgaW50byAzMi1iaXQgd29yZHMpOlxuICpcbiAqIG1tbW1tbW1tLm1tbW1tbW1tLm1tbW1tbW1tLm1tbW1tbW1tIHwgbW1tbW1tbW0ubW1tbW1tbW0uRUVFRW1tbW0uc0VFRUVFRUVcbiAqXG4gKiAtIG06IG1hbnRpc3NhICg1MiBiaXRzKVxuICogLSBFOiBleHBvbmVudCAoMTEgYml0cylcbiAqIC0gczogc2lnbiAoMSBiaXQpXG4gKlxuICogV2UgcHV0IHRoZSBmb2xsb3dpbmcgbWFya2VyIGludG8gdGhlIHRvcCAxNiBiaXRzIChleHBvbmVudCBhbmQgc2lnbiksIGFuZFxuICogdXNlIHRoZSBtYW50aXNzYSBwYXJ0IHRvIGVuY29kZSB0aGUgdG9rZW4gaW5kZXguIFRvIHNhdmUgc29tZSBiaXQgdHdpZGRsaW5nXG4gKiB3ZSB1c2UgYWxsIHRvcCAxNiBiaXRzIGZvciB0aGUgdGFnLiBUaGF0IGxvc2VzIHVzIDQgbWFudGlzc2EgYml0cyB0byBzdG9yZVxuICogaW5mb3JtYXRpb24gaW4gYnV0IHdlIHN0aWxsIGhhdmUgNDgsIHdoaWNoIGlzIGdvaW5nIHRvIGJlIHBsZW50eSBmb3IgYW55XG4gKiBudW1iZXIgb2YgdG9rZW5zIHRvIGJlIGNyZWF0ZWQgZHVyaW5nIHRoZSBsaWZldGltZSBvZiBhbnkgQ0RLIGFwcGxpY2F0aW9uLlxuICpcbiAqIENhbid0IGhhdmUgYWxsIGJpdHMgc2V0IGJlY2F1c2UgdGhhdCBtYWtlcyBhIE5hTiwgc28gdW5zZXQgdGhlIGxlYXN0XG4gKiBzaWduaWZpY2FudCBleHBvbmVudCBiaXQuXG4gKlxuICogQ3VycmVudGx5IG5vdCBzdXBwb3J0aW5nIEJFIGFyY2hpdGVjdHVyZXMuXG4gKi9cbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1iaXR3aXNlXG5jb25zdCBET1VCTEVfVE9LRU5fTUFSS0VSX0JJVFMgPSAweGZkZmYgPDwgMTY7XG5cbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1iaXR3aXNlXG5jb25zdCBET1VCTEVfTElTVF9UT0tFTl9NQVJLRVJfQklUUyA9IDB4ZmJmZiA8PCAxNjtcblxuLyoqXG4gKiBIaWdoZXN0IGVuY29kYWJsZSBudW1iZXJcbiAqL1xuY29uc3QgTUFYX0VOQ09EQUJMRV9JTlRFR0VSID0gTWF0aC5wb3coMiwgNDgpIC0gMTtcblxuLyoqXG4gKiBHZXQgMl4zMiBhcyBhIG51bWJlciwgc28gd2UgY2FuIGRvIG11bHRpcGxpY2F0aW9uIGFuZCBkaXYgaW5zdGVhZCBvZiBiaXQgc2hpZnRpbmdcbiAqXG4gKiBOZWNlc3NhcnkgYmVjYXVzZSBpbiBKYXZhU2NyaXB0LCBiaXQgb3BlcmF0aW9ucyBpbXBsaWNpdGx5IGNvbnZlcnRcbiAqIHRvIGludDMyIGFuZCB3ZSBuZWVkIHRoZW0gdG8gd29yayBvbiBcImludDY0XCJzLlxuICpcbiAqIFNvIGluc3RlYWQgb2YgeCA+PiAzMiwgd2UgZG8gTWF0aC5mbG9vcih4IC8gMl4zMiksIGFuZCB2aWNlIHZlcnNhLlxuICovXG5jb25zdCBCSVRTMzIgPSBNYXRoLnBvdygyLCAzMik7XG5cbi8qKlxuICogUmV0dXJuIGEgc3BlY2lhbCBEb3VibGUgdmFsdWUgdGhhdCBlbmNvZGVzIHRoZSBnaXZlbiBub25uZWdhdGl2ZSBpbnRlZ2VyXG4gKlxuICogV2UgdXNlIHRoaXMgdG8gZW5jb2RlIFRva2VuIG9yZGluYWxzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVG9rZW5Eb3VibGUoeDogbnVtYmVyLCBsaXN0OiBib29sZWFuKSB7XG4gIGlmIChNYXRoLmZsb29yKHgpICE9PSB4IHx8IHggPCAwKSB7XG4gICAgdGhyb3cgY2FuT25seUVuY29kZVBvc2l0aXZlSW50ZWdlcnMoKTtcbiAgfVxuICBpZiAoeCA+IE1BWF9FTkNPREFCTEVfSU5URUdFUikge1xuICAgIHRocm93IGluZGV4VG9vTGFyZ2VUb0VuY29kZSh4KTtcbiAgfVxuXG4gIGNvbnN0IGJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcig4KTtcbiAgY29uc3QgaW50cyA9IG5ldyBVaW50MzJBcnJheShidWYpO1xuXG4gIC8vIHRzbGludDpkaXNhYmxlOm5vLWJpdHdpc2VcbiAgaW50c1swXSA9IHggJiAweDAwMDBmZmZmZmZmZjsgLy8gQm90dG9tIDMyIGJpdHMgb2YgbnVtYmVyXG5cbiAgLy8gVGhpcyBuZWVkcyBhbiBcInggPj4gMzJcIiBidXQgdGhhdCB3aWxsIG1ha2UgaXQgYSAzMi1iaXQgbnVtYmVyIGluc3RlYWRcbiAgLy8gb2YgYSA2NC1iaXQgbnVtYmVyLlxuICBpbnRzWzFdID1cbiAgICAoc2hyMzIoeCkgJiAweGZmZmYpIHxcbiAgICAobGlzdCA/IERPVUJMRV9MSVNUX1RPS0VOX01BUktFUl9CSVRTIDogRE9VQkxFX1RPS0VOX01BUktFUl9CSVRTKTsgLy8gVG9wIDE2IGJpdHMgb2YgbnVtYmVyIGFuZCB0aGUgbWFza1xuICAvLyB0c2xpbnQ6ZW5hYmxlOm5vLWJpdHdpc2VcblxuICByZXR1cm4gbmV3IEZsb2F0NjRBcnJheShidWYpWzBdO1xufVxuXG4vKipcbiAqIFNoaWZ0IGEgNjQtYml0IGludCByaWdodCAzMiBiaXRzXG4gKi9cbmZ1bmN0aW9uIHNocjMyKHg6IG51bWJlcikge1xuICByZXR1cm4gTWF0aC5mbG9vcih4IC8gQklUUzMyKTtcbn1cblxuLyoqXG4gKiBTaGlmdCBhIDY0LWJpdCBsZWZ0IDMyIGJpdHNcbiAqL1xuZnVuY3Rpb24gc2hsMzIoeDogbnVtYmVyKSB7XG4gIHJldHVybiB4ICogQklUUzMyO1xufVxuXG4vKipcbiAqIEV4dHJhY3QgdGhlIGVuY29kZWQgaW50ZWdlciBvdXQgb2YgdGhlIHNwZWNpYWwgRG91YmxlIHZhbHVlXG4gKlxuICogUmV0dXJucyB1bmRlZmluZWQgaWYgdGhlIGZsb2F0IGlzIGEgbm90IGFuIGVuY29kZWQgdG9rZW4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0VG9rZW5Eb3VibGUoXG4gIGVuY29kZWQ6IG51bWJlcixcbiAgbGlzdDogYm9vbGVhblxuKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgY29uc3QgYnVmID0gbmV3IEFycmF5QnVmZmVyKDgpO1xuICBuZXcgRmxvYXQ2NEFycmF5KGJ1ZilbMF0gPSBlbmNvZGVkO1xuXG4gIGNvbnN0IGludHMgPSBuZXcgVWludDMyQXJyYXkoYnVmKTtcblxuICAvLyB0c2xpbnQ6ZGlzYWJsZTpuby1iaXR3aXNlXG4gIGlmIChcbiAgICAoaW50c1sxXSAmIDB4ZmZmZjAwMDApICE9PVxuICAgIChsaXN0ID8gRE9VQkxFX0xJU1RfVE9LRU5fTUFSS0VSX0JJVFMgOiBET1VCTEVfVE9LRU5fTUFSS0VSX0JJVFMpXG4gICkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyBNdXN0IHVzZSArIGluc3RlYWQgb2YgfCBoZXJlIChiaXR3aXNlIG9wZXJhdGlvbnNcbiAgLy8gd2lsbCBmb3JjZSAzMi1iaXRzIGludGVnZXIgYXJpdGhtZXRpYywgKyB3aWxsIG5vdCkuXG4gIHJldHVybiBpbnRzWzBdICsgc2hsMzIoaW50c1sxXSAmIDB4ZmZmZik7XG4gIC8vIHRzbGludDplbmFibGU6bm8tYml0d2lzZVxufVxuIl19