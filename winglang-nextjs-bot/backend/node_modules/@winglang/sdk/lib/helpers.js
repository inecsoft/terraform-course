"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveDirname = exports.createExternRequire = exports.assign = exports.lookup = exports.unwrap = exports.normalPath = exports.nodeof = exports.range = exports.assert = exports.neq = exports.eq = void 0;
// Code in this file will be automatically included in all inflight code bundles,
// so avoid importing anything heavy here.
const node_assert_1 = require("node:assert");
const path = __importStar(require("node:path"));
// since we moved from node:18 to node:20 the deepStrictEqual doesn't work as expected.
// https://github.com/winglang/wing/issues/4444
// therefore we're using a local version of the comparison from node 18.
const equality_1 = require("./util/equality");
function eq(a, b) {
    try {
        return (0, equality_1.deepStrictEqual)(a, b);
    }
    catch {
        return false;
    }
}
exports.eq = eq;
function neq(a, b) {
    try {
        (0, node_assert_1.notDeepStrictEqual)(a, b);
        return true;
    }
    catch {
        return false;
    }
}
exports.neq = neq;
function assert(condition, message) {
    if (!condition) {
        throw new Error("assertion failed: " + message);
    }
}
exports.assert = assert;
function range(start, end, inclusive) {
    function* iterator() {
        let i = start;
        let limit = inclusive ? (end < start ? end - 1 : end + 1) : end;
        while (i < limit)
            yield i++;
        while (i > limit)
            yield i--;
    }
    return iterator();
}
exports.range = range;
function nodeof(construct) {
    // Should only be used preflight, avoid bundling
    const Node = eval("require('./std/node').Node");
    return Node.of(construct);
}
exports.nodeof = nodeof;
function normalPath(p) {
    return p.replace(/\\+/g, "/");
}
exports.normalPath = normalPath;
function unwrap(value) {
    if (value != null) {
        return value;
    }
    throw new Error("Unexpected nil");
}
exports.unwrap = unwrap;
function lookup(obj, index) {
    checkIndex(index);
    if (typeof index === "number") {
        index = checkArrayAccess(obj, index);
        return obj[index];
    }
    if (typeof obj !== "object") {
        throw new TypeError(`Lookup failed, value is not an object (found "${typeof obj}")`);
    }
    if (!(index in obj)) {
        throw new RangeError(`Key "${index}" not found`);
    }
    return obj[index];
}
exports.lookup = lookup;
function assign(obj, index, kind, value) {
    checkIndex(index);
    if (typeof index === "number") {
        index = checkArrayAccess(obj, index);
    }
    if (typeof index === "string" && typeof obj !== "object") {
        throw new TypeError(`Assignment failed, value is not an object (found \"${typeof obj}\")`);
    }
    switch (kind) {
        case "=":
            obj[index] = value;
            break;
        case "+=":
            obj[index] += value;
            break;
        case "-=":
            obj[index] -= value;
            break;
        default:
            throw new Error(`Invalid assignment kind: ${kind}`);
    }
}
exports.assign = assign;
function checkIndex(index) {
    if (typeof index !== "string" && typeof index !== "number") {
        throw new TypeError(`Index must be a string or number (found "${typeof index}")`);
    }
}
function checkArrayAccess(obj, index) {
    if (!Array.isArray(obj) && !Buffer.isBuffer(obj) && typeof obj !== "string") {
        throw new TypeError("Index is a number but collection is not an array or string");
    }
    if (index < 0 && index >= -obj.length) {
        index = obj.length + index;
    }
    if (index < 0 || index >= obj.length) {
        throw new RangeError(`Index ${index} out of bounds for array of length ${obj.length}`);
    }
    return index;
}
function createExternRequire(dirname) {
    return (externPath) => {
        // using eval to always avoid bundling
        const jiti = eval("require('jiti')");
        const esbuild = eval("require('esbuild')");
        const newRequire = jiti(dirname, {
            sourceMaps: true,
            interopDefault: true,
            transform(opts) {
                return esbuild.transformSync(opts.source, {
                    format: "cjs",
                    target: "node20",
                    sourcemap: "inline",
                    loader: opts.ts ? "ts" : "js",
                });
            },
        });
        return newRequire(externPath);
    };
}
exports.createExternRequire = createExternRequire;
function resolveDirname(outdir, relativeSourceDir) {
    return normalPath(path.resolve(outdir, relativeSourceDir));
}
exports.resolveDirname = resolveDirname;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGVscGVycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9oZWxwZXJzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsaUZBQWlGO0FBQ2pGLDBDQUEwQztBQUMxQyw2Q0FBaUQ7QUFDakQsZ0RBQWtDO0FBR2xDLHVGQUF1RjtBQUN2RiwrQ0FBK0M7QUFDL0Msd0VBQXdFO0FBQ3hFLDhDQUFrRDtBQUVsRCxTQUFnQixFQUFFLENBQUMsQ0FBTSxFQUFFLENBQU07SUFDL0IsSUFBSSxDQUFDO1FBQ0gsT0FBTyxJQUFBLDBCQUFlLEVBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQy9CLENBQUM7SUFBQyxNQUFNLENBQUM7UUFDUCxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7QUFDSCxDQUFDO0FBTkQsZ0JBTUM7QUFFRCxTQUFnQixHQUFHLENBQUMsQ0FBTSxFQUFFLENBQU07SUFDaEMsSUFBSSxDQUFDO1FBQ0gsSUFBQSxnQ0FBa0IsRUFBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDekIsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBQUMsTUFBTSxDQUFDO1FBQ1AsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0FBQ0gsQ0FBQztBQVBELGtCQU9DO0FBRUQsU0FBZ0IsTUFBTSxDQUFDLFNBQWMsRUFBRSxPQUFlO0lBQ3BELElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUNmLE1BQU0sSUFBSSxLQUFLLENBQUMsb0JBQW9CLEdBQUcsT0FBTyxDQUFDLENBQUM7SUFDbEQsQ0FBQztBQUNILENBQUM7QUFKRCx3QkFJQztBQUVELFNBQWdCLEtBQUssQ0FBQyxLQUFhLEVBQUUsR0FBVyxFQUFFLFNBQWtCO0lBQ2xFLFFBQVEsQ0FBQyxDQUFDLFFBQVE7UUFDaEIsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDO1FBQ2QsSUFBSSxLQUFLLEdBQUcsU0FBUyxDQUFDLENBQUMs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LFVBQVUsR0FBRyxJQUFJLENBQUMsT0FBTyxFQUFFO1lBQy9CLFVBQVUsRUFBRSxJQUFJO1lBQ2hCLGNBQWMsRUFBRSxJQUFJO1lBQ3BCLFNBQVMsQ0FBQyxJQUFJO2dCQUNaLE9BQU8sT0FBTyxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFO29CQUN4QyxNQUFNLEVBQUUsS0FBSztvQkFDYixNQUFNLEVBQUUsUUFBUTtvQkFDaEIsU0FBUyxFQUFFLFFBQVE7b0JBQ25CLE1BQU0sRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUk7aUJBQzlCLENBQUMsQ0FBQztZQUNMLENBQUM7U0FDRixDQUFDLENBQUM7UUFDSCxPQUFPLFVBQVUsQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUNoQyxDQUFDLENBQUM7QUFDSixDQUFDO0FBcEJELGtEQW9CQztBQUVELFNBQWdCLGNBQWMsQ0FDNUIsTUFBYyxFQUNkLGlCQUF5QjtJQUV6QixPQUFPLFVBQVUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxpQkFBaUIsQ0FBQyxDQUFDLENBQUM7QUFDN0QsQ0FBQztBQUxELHdDQUtDIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29kZSBpbiB0aGlzIGZpbGUgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGluY2x1ZGVkIGluIGFsbCBpbmZsaWdodCBjb2RlIGJ1bmRsZXMsXG4vLyBzbyBhdm9pZCBpbXBvcnRpbmcgYW55dGhpbmcgaGVhdnkgaGVyZS5cbmltcG9ydCB7IG5vdERlZXBTdHJpY3RFcXVhbCB9IGZyb20gXCJub2RlOmFzc2VydFwiO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tIFwibm9kZTpwYXRoXCI7XG5pbXBvcnQgdHlwZSB7IENvbnN0cnVjdCB9IGZyb20gXCJjb25zdHJ1Y3RzXCI7XG5pbXBvcnQgdHlwZSB7IE5vZGUgfSBmcm9tIFwiLi9zdGQvbm9kZVwiO1xuLy8gc2luY2Ugd2UgbW92ZWQgZnJvbSBub2RlOjE4IHRvIG5vZGU6MjAgdGhlIGRlZXBTdHJpY3RFcXVhbCBkb2Vzbid0IHdvcmsgYXMgZXhwZWN0ZWQuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vd2luZ2xhbmcvd2luZy9pc3N1ZXMvNDQ0NFxuLy8gdGhlcmVmb3JlIHdlJ3JlIHVzaW5nIGEgbG9jYWwgdmVyc2lvbiBvZiB0aGUgY29tcGFyaXNvbiBmcm9tIG5vZGUgMTguXG5pbXBvcnQgeyBkZWVwU3RyaWN0RXF1YWwgfSBmcm9tIFwiLi91dGlsL2VxdWFsaXR5XCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBlcShhOiBhbnksIGI6IGFueSk6IGJvb2xlYW4ge1xuICB0cnkge1xuICAgIHJldHVybiBkZWVwU3RyaWN0RXF1YWwoYSwgYik7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbmVxKGE6IGFueSwgYjogYW55KTogYm9vbGVhbiB7XG4gIHRyeSB7XG4gICAgbm90RGVlcFN0cmljdEVxdWFsKGEsIGIpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydChjb25kaXRpb246IGFueSwgbWVzc2FnZTogc3RyaW5nKTogYXNzZXJ0cyBjb25kaXRpb24ge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImFzc2VydGlvbiBmYWlsZWQ6IFwiICsgbWVzc2FnZSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmdlKHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyLCBpbmNsdXNpdmU6IGJvb2xlYW4pIHtcbiAgZnVuY3Rpb24qIGl0ZXJhdG9yKCkge1xuICAgIGxldCBpID0gc3RhcnQ7XG4gICAgbGV0IGxpbWl0ID0gaW5jbHVzaXZlID8gKGVuZCA8IHN0YXJ0ID8gZW5kIC0gMSA6IGVuZCArIDEpIDogZW5kO1xuICAgIHdoaWxlIChpIDwgbGltaXQpIHlpZWxkIGkrKztcbiAgICB3aGlsZSAoaSA+IGxpbWl0KSB5aWVsZCBpLS07XG4gIH1cbiAgcmV0dXJuIGl0ZXJhdG9yKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub2Rlb2YoY29uc3RydWN0OiBDb25zdHJ1Y3QpOiBOb2RlIHtcbiAgLy8gU2hvdWxkIG9ubHkgYmUgdXNlZCBwcmVmbGlnaHQsIGF2b2lkIGJ1bmRsaW5nXG4gIGNvbnN0IE5vZGUgPSBldmFsKFwicmVxdWlyZSgnLi9zdGQvbm9kZScpLk5vZGVcIik7XG4gIHJldHVybiBOb2RlLm9mKGNvbnN0cnVjdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxQYXRoKHA6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBwLnJlcGxhY2UoL1xcXFwrL2csIFwiL1wiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVud3JhcDxUPih2YWx1ZTogVCk6IFQgfCBuZXZlciB7XG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgbmlsXCIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9va3VwKG9iajogYW55LCBpbmRleDogc3RyaW5nIHwgbnVtYmVyKTogYW55IHtcbiAgY2hlY2tJbmRleChpbmRleCk7XG5cbiAgaWYgKHR5cGVvZiBpbmRleCA9PT0gXCJudW1iZXJcIikge1xuICAgIGluZGV4ID0gY2hlY2tBcnJheUFjY2VzcyhvYmosIGluZGV4KTtcbiAgICByZXR1cm4gb2JqW2luZGV4XTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgIGBMb29rdXAgZmFpbGVkLCB2YWx1ZSBpcyBub3QgYW4gb2JqZWN0IChmb3VuZCBcIiR7dHlwZW9mIG9ian1cIilgXG4gICAgKTtcbiAgfVxuXG4gIGlmICghKGluZGV4IGluIG9iaikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgS2V5IFwiJHtpbmRleH1cIiBub3QgZm91bmRgKTtcbiAgfVxuXG4gIHJldHVybiBvYmpbaW5kZXhdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduKFxuICBvYmo6IGFueSxcbiAgaW5kZXg6IHN0cmluZyB8IG51bWJlcixcbiAga2luZDogXCI9XCIgfCBcIis9XCIgfCBcIi09XCIsXG4gIHZhbHVlOiBhbnlcbikge1xuICBjaGVja0luZGV4KGluZGV4KTtcblxuICBpZiAodHlwZW9mIGluZGV4ID09PSBcIm51bWJlclwiKSB7XG4gICAgaW5kZXggPSBjaGVja0FycmF5QWNjZXNzKG9iaiwgaW5kZXgpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpbmRleCA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgIGBBc3NpZ25tZW50IGZhaWxlZCwgdmFsdWUgaXMgbm90IGFuIG9iamVjdCAoZm91bmQgXFxcIiR7dHlwZW9mIG9ian1cXFwiKWBcbiAgICApO1xuICB9XG5cbiAgc3dpdGNoIChraW5kKSB7XG4gICAgY2FzZSBcIj1cIjpcbiAgICAgIG9ialtpbmRleF0gPSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCIrPVwiOlxuICAgICAgb2JqW2luZGV4XSArPSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCItPVwiOlxuICAgICAgb2JqW2luZGV4XSAtPSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYXNzaWdubWVudCBraW5kOiAke2tpbmR9YCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tJbmRleChpbmRleDogc3RyaW5nIHwgbnVtYmVyKSB7XG4gIGlmICh0eXBlb2YgaW5kZXggIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGluZGV4ICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgIGBJbmRleCBtdXN0IGJlIGEgc3RyaW5nIG9yIG51bWJlciAoZm91bmQgXCIke3R5cGVvZiBpbmRleH1cIilgXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0FycmF5QWNjZXNzKG9iajogYW55LCBpbmRleDogbnVtYmVyKTogbnVtYmVyIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KG9iaikgJiYgIUJ1ZmZlci5pc0J1ZmZlcihvYmopICYmIHR5cGVvZiBvYmogIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgXCJJbmRleCBpcyBhIG51bWJlciBidXQgY29sbGVjdGlvbiBpcyBub3QgYW4gYXJyYXkgb3Igc3RyaW5nXCJcbiAgICApO1xuICB9XG4gIGlmIChpbmRleCA8IDAgJiYgaW5kZXggPj0gLW9iai5sZW5ndGgpIHtcbiAgICBpbmRleCA9IG9iai5sZW5ndGggKyBpbmRleDtcbiAgfVxuICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IG9iai5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcbiAgICAgIGBJbmRleCAke2luZGV4fSBvdXQgb2YgYm91bmRzIGZvciBhcnJheSBvZiBsZW5ndGggJHtvYmoubGVuZ3RofWBcbiAgICApO1xuICB9XG4gIHJldHVybiBpbmRleDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUV4dGVyblJlcXVpcmUoZGlybmFtZTogc3RyaW5nKSB7XG4gIHJldHVybiAoZXh0ZXJuUGF0aDogc3RyaW5nKSA9PiB7XG4gICAgLy8gdXNpbmcgZXZhbCB0byBhbHdheXMgYXZvaWQgYnVuZGxpbmdcbiAgICBjb25zdCBqaXRpOiB0eXBlb2YgaW1wb3J0KFwiaml0aVwiKS5kZWZhdWx0ID0gZXZhbChcInJlcXVpcmUoJ2ppdGknKVwiKTtcbiAgICBjb25zdCBlc2J1aWxkOiB0eXBlb2YgaW1wb3J0KFwiZXNidWlsZFwiKSA9IGV2YWwoXCJyZXF1aXJlKCdlc2J1aWxkJylcIik7XG5cbiAgICBjb25zdCBuZXdSZXF1aXJlID0gaml0aShkaXJuYW1lLCB7XG4gICAgICBzb3VyY2VNYXBzOiB0cnVlLFxuICAgICAgaW50ZXJvcERlZmF1bHQ6IHRydWUsXG4gICAgICB0cmFuc2Zvcm0ob3B0cykge1xuICAgICAgICByZXR1cm4gZXNidWlsZC50cmFuc2Zvcm1TeW5jKG9wdHMuc291cmNlLCB7XG4gICAgICAgICAgZm9ybWF0OiBcImNqc1wiLFxuICAgICAgICAgIHRhcmdldDogXCJub2RlMjBcIixcbiAgICAgICAgICBzb3VyY2VtYXA6IFwiaW5saW5lXCIsXG4gICAgICAgICAgbG9hZGVyOiBvcHRzLnRzID8gXCJ0c1wiIDogXCJqc1wiLFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIG5ld1JlcXVpcmUoZXh0ZXJuUGF0aCk7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlRGlybmFtZShcbiAgb3V0ZGlyOiBzdHJpbmcsXG4gIHJlbGF0aXZlU291cmNlRGlyOiBzdHJpbmdcbik6IHN0cmluZyB7XG4gIHJldHVybiBub3JtYWxQYXRoKHBhdGgucmVzb2x2ZShvdXRkaXIsIHJlbGF0aXZlU291cmNlRGlyKSk7XG59XG4iXX0=