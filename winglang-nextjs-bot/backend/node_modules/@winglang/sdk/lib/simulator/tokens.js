"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveTokens = exports.parseToken = void 0;
const tokens_1 = require("../target-sim/tokens");
function parseToken(s) {
    const ref = s.slice(2, -1);
    const parts = ref.split("#");
    if (parts.length !== 3) {
        throw new Error(`Invalid token reference: ${s}`);
    }
    const [_, path, rest] = parts;
    if (rest.startsWith("attrs.")) {
        const attrName = rest.slice(6);
        return { path, attr: attrName };
    }
    else if (rest.startsWith("props.")) {
        const propPath = rest.slice(6);
        return { path, prop: propPath };
    }
    else {
        throw new Error(`Invalid token reference: ${s}`);
    }
}
exports.parseToken = parseToken;
/**
 * Return an object with all tokens in it resolved to their appropriate values.
 *
 * A token can be a string like "${app/my_bucket#attrs.handle}". This token would be resolved to
 * the "handle" attribute of the resource at path "app/my_bucket". If that attribute does not
 * exist at the time of resolution (for example, if my_bucket is not being simulated yet), an
 * error will be thrown.
 *
 * Tokens can also be nested, like "${app/my_bucket#attrs.handle}/foo/bar".
 *
 * @param obj The object to resolve tokens in.
 * @returns The resolved token or throws an error if the token cannot be resolved.
 */
function resolveTokens(obj, resolver) {
    if (obj === undefined) {
        return obj;
    }
    if (typeof obj === "string") {
        // there are two cases - a token can be the entire string, or it can be part of the string.
        // first, check if the entire string is a token
        if (tokens_1.SIMULATOR_TOKEN_REGEX_FULL.test(obj)) {
            return resolver(parseToken(obj));
        }
        // otherwise, check if the string contains tokens inside it. if so, we need to resolve them
        // and then check if the result is a string
        const globalRegex = new RegExp(tokens_1.SIMULATOR_TOKEN_REGEX.source, "g");
        const matches = obj.matchAll(globalRegex);
        const replacements = [];
        for (const match of matches) {
            const value = resolveTokens(match[0], resolver);
            if (typeof value !== "string") {
                throw new Error(`Expected token "${match[0]}" to resolve to a string, but it resolved to ${typeof value}.`);
            }
            replacements.push({ match, value });
        }
        // replace all the tokens in reverse order, and return the result
        // if a token returns another token (god forbid), do not resolve it again
        let result = obj;
        for (const { match, value } of replacements.reverse()) {
            if (match.index === undefined) {
                throw new Error(`unexpected error: match.index is undefined`);
            }
            result =
                result.slice(0, match.index) +
                    value +
                    result.slice(match.index + match[0].length);
        }
        return result;
    }
    if (Array.isArray(obj)) {
        const result = [];
        for (const x of obj) {
            const value = resolveTokens(x, resolver);
            result.push(value);
        }
        return result;
    }
    if (typeof obj === "object") {
        const ret = {};
        for (const [key, v] of Object.entries(obj)) {
            ret[key] = resolveTokens(v, resolver);
        }
        return ret;
    }
    return obj;
}
exports.resolveTokens = resolveTokens;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9rZW5zLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3NpbXVsYXRvci90b2tlbnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsaURBRzhCO0FBUTlCLFNBQWdCLFVBQVUsQ0FBQyxDQUFTO0lBQ2xDLE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDM0IsTUFBTSxLQUFLLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUM3QixJQUFJLEtBQUssQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFLENBQUM7UUFDdkIsTUFBTSxJQUFJLEtBQUssQ0FBQyw0QkFBNEIsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUNuRCxDQUFDO0lBRUQsTUFBTSxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDO0lBRTlCLElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDO1FBQzlCLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDL0IsT0FBTyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLENBQUM7SUFDbEMsQ0FBQztTQUFNLElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDO1FBQ3JDLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDL0IsT0FBTyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLENBQUM7SUFDbEMsQ0FBQztTQUFNLENBQUM7UUFDTixNQUFNLElBQUksS0FBSyxDQUFDLDRCQUE0QixDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ25ELENBQUM7QUFDSCxDQUFDO0FBbEJELGdDQWtCQztBQUlEOzs7Ozs7Ozs7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QWtFQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIFNJTVVMQVRPUl9UT0tFTl9SRUdFWCxcbiAgU0lNVUxBVE9SX1RPS0VOX1JFR0VYX0ZVTEwsXG59IGZyb20gXCIuLi90YXJnZXQtc2ltL3Rva2Vuc1wiO1xuXG50eXBlIFRva2VuID0ge1xuICBwYXRoOiBzdHJpbmc7XG4gIGF0dHI/OiBzdHJpbmc7XG4gIHByb3A/OiBzdHJpbmc7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VUb2tlbihzOiBzdHJpbmcpOiBUb2tlbiB7XG4gIGNvbnN0IHJlZiA9IHMuc2xpY2UoMiwgLTEpO1xuICBjb25zdCBwYXJ0cyA9IHJlZi5zcGxpdChcIiNcIik7XG4gIGlmIChwYXJ0cy5sZW5ndGggIT09IDMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdG9rZW4gcmVmZXJlbmNlOiAke3N9YCk7XG4gIH1cblxuICBjb25zdCBbXywgcGF0aCwgcmVzdF0gPSBwYXJ0cztcblxuICBpZiAocmVzdC5zdGFydHNXaXRoKFwiYXR0cnMuXCIpKSB7XG4gICAgY29uc3QgYXR0ck5hbWUgPSByZXN0LnNsaWNlKDYpO1xuICAgIHJldHVybiB7IHBhdGgsIGF0dHI6IGF0dHJOYW1lIH07XG4gIH0gZWxzZSBpZiAocmVzdC5zdGFydHNXaXRoKFwicHJvcHMuXCIpKSB7XG4gICAgY29uc3QgcHJvcFBhdGggPSByZXN0LnNsaWNlKDYpO1xuICAgIHJldHVybiB7IHBhdGgsIHByb3A6IHByb3BQYXRoIH07XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRva2VuIHJlZmVyZW5jZTogJHtzfWApO1xuICB9XG59XG5cbnR5cGUgVG9rZW5SZXNvbHZlciA9ICh0b2tlbjogVG9rZW4pID0+IHN0cmluZztcblxuLyoqXG4gKiBSZXR1cm4gYW4gb2JqZWN0IHdpdGggYWxsIHRva2VucyBpbiBpdCByZXNvbHZlZCB0byB0aGVpciBhcHByb3ByaWF0ZSB2YWx1ZXMuXG4gKlxuICogQSB0b2tlbiBjYW4gYmUgYSBzdHJpbmcgbGlrZSBcIiR7YXBwL215X2J1Y2tldCNhdHRycy5oYW5kbGV9XCIuIFRoaXMgdG9rZW4gd291bGQgYmUgcmVzb2x2ZWQgdG9cbiAqIHRoZSBcImhhbmRsZVwiIGF0dHJpYnV0ZSBvZiB0aGUgcmVzb3VyY2UgYXQgcGF0aCBcImFwcC9teV9idWNrZXRcIi4gSWYgdGhhdCBhdHRyaWJ1dGUgZG9lcyBub3RcbiAqIGV4aXN0IGF0IHRoZSB0aW1lIG9mIHJlc29sdXRpb24gKGZvciBleGFtcGxlLCBpZiBteV9idWNrZXQgaXMgbm90IGJlaW5nIHNpbXVsYXRlZCB5ZXQpLCBhblxuICogZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gKlxuICogVG9rZW5zIGNhbiBhbHNvIGJlIG5lc3RlZCwgbGlrZSBcIiR7YXBwL215X2J1Y2tldCNhdHRycy5oYW5kbGV9L2Zvby9iYXJcIi5cbiAqXG4gKiBAcGFyYW0gb2JqIFRoZSBvYmplY3QgdG8gcmVzb2x2ZSB0b2tlbnMgaW4uXG4gKiBAcmV0dXJucyBUaGUgcmVzb2x2ZWQgdG9rZW4gb3IgdGhyb3dzIGFuIGVycm9yIGlmIHRoZSB0b2tlbiBjYW5ub3QgYmUgcmVzb2x2ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlVG9rZW5zKG9iajogYW55LCByZXNvbHZlcjogVG9rZW5SZXNvbHZlcik6IGFueSB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gXCJzdHJpbmdcIikge1xuICAgIC8vIHRoZXJlIGFyZSB0d28gY2FzZXMgLSBhIHRva2VuIGNhbiBiZSB0aGUgZW50aXJlIHN0cmluZywgb3IgaXQgY2FuIGJlIHBhcnQgb2YgdGhlIHN0cmluZy5cbiAgICAvLyBmaXJzdCwgY2hlY2sgaWYgdGhlIGVudGlyZSBzdHJpbmcgaXMgYSB0b2tlblxuICAgIGlmIChTSU1VTEFUT1JfVE9LRU5fUkVHRVhfRlVMTC50ZXN0KG9iaikpIHtcbiAgICAgIHJldHVybiByZXNvbHZlcihwYXJzZVRva2VuKG9iaikpO1xuICAgIH1cblxuICAgIC8vIG90aGVyd2lzZSwgY2hlY2sgaWYgdGhlIHN0cmluZyBjb250YWlucyB0b2tlbnMgaW5zaWRlIGl0LiBpZiBzbywgd2UgbmVlZCB0byByZXNvbHZlIHRoZW1cbiAgICAvLyBhbmQgdGhlbiBjaGVjayBpZiB0aGUgcmVzdWx0IGlzIGEgc3RyaW5nXG4gICAgY29uc3QgZ2xvYmFsUmVnZXggPSBuZXcgUmVnRXhwKFNJTVVMQVRPUl9UT0tFTl9SRUdFWC5zb3VyY2UsIFwiZ1wiKTtcbiAgICBjb25zdCBtYXRjaGVzID0gb2JqLm1hdGNoQWxsKGdsb2JhbFJlZ2V4KTtcbiAgICBjb25zdCByZXBsYWNlbWVudHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG1hdGNoIG9mIG1hdGNoZXMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gcmVzb2x2ZVRva2VucyhtYXRjaFswXSwgcmVzb2x2ZXIpO1xuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgRXhwZWN0ZWQgdG9rZW4gXCIke1xuICAgICAgICAgICAgbWF0Y2hbMF1cbiAgICAgICAgICB9XCIgdG8gcmVzb2x2ZSB0byBhIHN0cmluZywgYnV0IGl0IHJlc29sdmVkIHRvICR7dHlwZW9mIHZhbHVlfS5gXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJlcGxhY2VtZW50cy5wdXNoKHsgbWF0Y2gsIHZhbHVlIH0pO1xuICAgIH1cblxuICAgIC8vIHJlcGxhY2UgYWxsIHRoZSB0b2tlbnMgaW4gcmV2ZXJzZSBvcmRlciwgYW5kIHJldHVybiB0aGUgcmVzdWx0XG4gICAgLy8gaWYgYSB0b2tlbiByZXR1cm5zIGFub3RoZXIgdG9rZW4gKGdvZCBmb3JiaWQpLCBkbyBub3QgcmVzb2x2ZSBpdCBhZ2FpblxuICAgIGxldCByZXN1bHQgPSBvYmo7XG4gICAgZm9yIChjb25zdCB7IG1hdGNoLCB2YWx1ZSB9IG9mIHJlcGxhY2VtZW50cy5yZXZlcnNlKCkpIHtcbiAgICAgIGlmIChtYXRjaC5pbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5leHBlY3RlZCBlcnJvcjogbWF0Y2guaW5kZXggaXMgdW5kZWZpbmVkYCk7XG4gICAgICB9XG4gICAgICByZXN1bHQgPVxuICAgICAgICByZXN1bHQuc2xpY2UoMCwgbWF0Y2guaW5kZXgpICtcbiAgICAgICAgdmFsdWUgK1xuICAgICAgICByZXN1bHQuc2xpY2UobWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChjb25zdCB4IG9mIG9iaikge1xuICAgICAgY29uc3QgdmFsdWUgPSByZXNvbHZlVG9rZW5zKHgsIHJlc29sdmVyKTtcbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIpIHtcbiAgICBjb25zdCByZXQ6IGFueSA9IHt9O1xuICAgIGZvciAoY29uc3QgW2tleSwgdl0gb2YgT2JqZWN0LmVudHJpZXMob2JqKSkge1xuICAgICAgcmV0W2tleV0gPSByZXNvbHZlVG9rZW5zKHYsIHJlc29sdmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG4iXX0=