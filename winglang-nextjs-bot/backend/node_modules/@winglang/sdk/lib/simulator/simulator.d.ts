import { Tree } from "./tree";
import { Trace } from "../std";
declare const HANDLE_ATTRIBUTE = "handle";
/**
 * Props for `Simulator`.
 */
export interface SimulatorProps {
    /**
     * Path to a Wing simulator output directory (.wsim).
     */
    readonly simfile: string;
    /**
     * Path to a state directory where the simulator can store state between
     * simulation runs.
     * @default - a directory named ".state" inside the simulator output directory
     */
    readonly stateDir?: string;
    /**
     * The factory that produces resource simulations.
     *
     * @default - a factory that produces simulations for built-in Wing SDK
     * resources
     */
    readonly factory?: ISimulatorFactory;
}
/**
 * A collection of callbacks that are invoked at key lifecycle events of the
 * simulator.
 */
export interface ISimulatorLifecycleHooks {
    /**
     * A function to run whenever a trace is emitted.
     */
    onTrace?(event: Trace): void;
}
/**
 * Props for `ISimulatorContext.withTrace`.
 */
export interface IWithTraceProps {
    /**
     * The trace message.
     */
    readonly message: any;
    /**
     * A function to run as part of the trace.
     */
    activity(): Promise<any>;
}
/**
 * Context that is passed to individual resource simulations.
 */
export interface ISimulatorContext {
    /**
     * The directory where the compilation output is
     */
    readonly simdir: string;
    /**
     * The directory for the resource's state.
     */
    readonly statedir: string;
    /**
     * The path of the resource that is being simulated.
     */
    readonly resourcePath: string;
    /**
     * The handle of the resource that is being simulated.
     */
    readonly resourceHandle: string;
    /**
     * The url that the simulator server is listening on.
     */
    readonly serverUrl: string;
    /**
     * Obtain a client given a resource's handle.
     */
    getClient(handle: string, asAdmin?: boolean): unknown;
    /**
     * Add a trace. Traces are breadcrumbs of information about resource
     * operations that occurred during simulation, useful for understanding how
     * resources interact or debugging an application.
     */
    addTrace(trace: Trace): void;
    /**
     * Register a trace associated with a resource activity. The activity will be
     * run, and the trace will be populated with the result's success or failure.
     */
    withTrace(trace: IWithTraceProps): Promise<any>;
    /**
     * Get a list of all traces until this point.
     */
    listTraces(): Trace[];
    /**
     * Sets the runtime attributes of a resource.
     * @param path The resource path
     * @param attrs Attributes to set (will be merged with existing attributes)
     */
    setResourceAttributes(path: string, attrs: Record<string, any>): void;
    /**
     * Returns the runtime attributes of a resource.
     * @param path The resource path
     */
    resourceAttributes(path: string): Record<string, any>;
}
/**
 * A subscriber that can listen for traces emitted by the simulator.
 */
export interface ITraceSubscriber {
    /**
     * Called when a trace is emitted.
     */
    callback(event: Trace): void;
}
/**
 * A simulator that can be used to test your application locally.
 */
export declare class Simulator {
    private readonly statedir;
    private _running;
    private readonly _handles;
    private _traces;
    private readonly _traceSubscribers;
    private _serverUrl;
    private _server;
    private _model;
    private _policyRegistry;
    private state;
    constructor(props: SimulatorProps);
    private _loadApp;
    /**
     * Start the simulator.
     */
    start(): Promise<void>;
    private startResources;
    /**
     * Updates the running simulation with a new version of the app. This will create/update/delete
     * resources as necessary to get to the desired state.
     * @param simDir The path to the new version of the app
     */
    update(simDir: string): Promise<void>;
    /**
     * Stop the simulation and clean up all resources.
     */
    stop(): Promise<void>;
    private isStarted;
    private stopResource;
    private addSimulatorTrace;
    /**
     * Stop the simulation, reload the simulation tree from the latest version of
     * the app file, and restart the simulation.
     */
    reload(resetState: boolean): Promise<void>;
    /**
     * Get a list of all resource paths.
     */
    listResources(): string[];
    /**
     * Get a list of all traces from the most recent simulation run.
     */
    listTraces(): Trace[];
    /**
     * Get a resource client.
     * @returns the resource
     */
    getResource(path: string): any;
    /**
     * Get a resource client.
     * @returns The resource or undefined if not found
     */
    tryGetResource(path: string): any | undefined;
    private tryGetResourceHandle;
    /**
     * Obtain a resource's configuration, including its type, props, and attrs.
     * @returns The resource configuration or undefined if not found
     */
    tryGetResourceConfig(path: string): BaseResourceSchema | undefined;
    /**
     * Obtain a resource's configuration, including its type, props, and attrs.
     * @param path The resource path
     * @returns The resource configuration
     */
    getResourceConfig(path: string): BaseResourceSchema;
    /**
     * Obtain a resource's state directory path.
     * @param path The resource path
     * @returns The resource state directory path
     */
    getResourceStateDir(path: string): string;
    private ensureStateDirExists;
    /**
     * Obtain a resource's visual interaction components.
     * @returns An array of UIComponent objects
     */
    getResourceUI(path: string): any;
    private typeInfo;
    /**
     * Register a subscriber that will be notified when a trace is emitted by
     * the simulator.
     */
    onTrace(subscriber: ITraceSubscriber): void;
    /**
     * Obtain information about the application's construct tree.
     */
    tree(): Tree;
    /**
     * Obtain information about the application's connections.
     */
    connections(): ConnectionData[];
    private checkPermission;
    /**
     * Start a server that allows any resource to be accessed via HTTP.
     */
    private startServer;
    /**
     * Stop the simulator server.
     */
    private stopServer;
    /**
     * The URL that the simulator server is listening on.
     */
    get url(): string;
    private startResource;
    private createContext;
    private addTrace;
    /**
     * Return an object with all tokens in it resolved to their appropriate values.
     *
     * A token can be a string like "${app/my_bucket#attrs.handle}". This token would be resolved to
     * the "handle" attribute of the resource at path "app/my_bucket". If that attribute does not
     * exist at the time of resolution (for example, if my_bucket is not being simulated yet), an
     * error will be thrown.
     *
     * Tokens can also be nested, like "${app/my_bucket#attrs.handle}/foo/bar".
     *
     * @param obj The object to resolve tokens in.
     * @returns `undefined` if the token could not be resolved (e.g. needs a dependency), otherwise
     * the resolved value.
     */
    private resolveTokens;
    /**
     * Given the "current" set of resources and a "next" set of resources, calculate the diff and
     * determine which resources need to be added, updated or deleted.
     *
     * Note that dependencies are not considered here but they are implicitly handled by the
     * `startResource` and `stopResource` methods. So, for example, when a resource is updated,
     * all of it's dependents will be stopped and started again.
     */
    private planUpdate;
    private shouldReplace;
}
/**
 * A factory that can turn resource descriptions into (inflight) resource simulations.
 */
export interface ISimulatorFactory {
    /**
     * Resolve the parameters needed for creating a specific resource simulation.
     */
    resolve(type: string, props: any, context: ISimulatorContext): ISimulatorResourceInstance;
}
/**
 * Shared interface for resource simulations.
 */
export interface ISimulatorResourceInstance {
    /**
     * Perform any async initialization required by the resource. Return a map of
     * the resource's runtime attributes.
     */
    init(ctx: ISimulatorContext): Promise<Record<string, any>>;
    /**
     * Stop the resource and clean up any physical resources it may have created
     * (files, ports, etc).
     */
    cleanup(): Promise<void>;
    /**
     * Save the resource's state into the state directory.
     */
    save(statedir: string): Promise<void>;
    /**
     * Determines the update plan for applying a new configuration for this resource.
     *
     * If this is not implemented, the default behavior is to automatically replace the resource if
     * the new configuration is different from the current configuration.
     *
     * @param invalidated Whether the new configuration is different from the current configuration.
     */
    plan(invalidated: boolean): Promise<UpdatePlan>;
}
/**
 * Determines how updates are performed on this resource.
 */
export declare enum UpdatePlan {
    /**
     * Does nothing. This resource is already in the desired state.
     */
    SKIP = "SKIP",
    /**
     * Deletes the resource and creates a new instance with the new configuration.
     */
    REPLACE = "REPLACE",
    /**
     * Auto detect changes in new configuration and replace the resource.
     */
    AUTO = "AUTO"
}
/** Schema for simulator.json */
export interface WingSimulatorSchema {
    /** The resources, indexed by their construct path. */
    readonly resources: Record<string, BaseResourceSchema>;
    /** The map of types. */
    readonly types: {
        [fqn: string]: TypeSchema;
    };
    /** The version of the Wing SDK used to synthesize the .wsim file. */
    readonly sdkVersion: string;
}
/** Schema for individual types. */
export interface TypeSchema {
    /** Location of the source file that exports a simulation API. */
    readonly sourcePath: string;
    /** Name of the class that is exported by the `sourcePath`. */
    readonly className: string;
}
/**
 * Schema for individual resources.
 * Only contains fields that need to be returned by `toSimulator()`.
 */
export interface ToSimulatorOutput {
    /** The type of the resource. */
    readonly type: string;
    /** The resource-specific properties needed to create this resource. */
    readonly props: {
        [key: string]: any;
    };
    /** A list of inline policy statements that define permissions for this resource. */
    readonly policy?: PolicyStatement[];
}
/** Schema for individual resources */
export interface BaseResourceSchema extends ToSimulatorOutput {
    /** The resource path from the app's construct tree. */
    readonly path: string;
    /** An opaque tree-unique address of the resource, calculated as a SHA-1 hash of the resource path. */
    readonly addr: string;
    /** The resource-specific attributes that are set after the resource is created. */
    readonly attrs: Record<string, any>;
    /** Resources that should be deployed before this resource. */
    readonly deps?: string[];
}
/** Schema for resource attributes */
export interface BaseResourceAttributes {
    /** The resource's simulator-unique id. */
    readonly [HANDLE_ATTRIBUTE]: string;
}
/** A policy statement that defines a permission for a resource. */
export interface PolicyStatement {
    /** The operation that can be performed. */
    readonly operation: string;
    /** The resource the operation can be performed on. */
    readonly resourceHandle: string;
}
/** Schema for `.connections` in connections.json */
export interface ConnectionData {
    /** The path of the source construct. */
    readonly source: string;
    /**
     * An operation that the source object supports.
     * @default - no operation
     */
    readonly sourceOp?: string;
    /** The path of the target construct. */
    readonly target: string;
    /**
     * An operation that the target object supports.
     * @default - no operation
     */
    readonly targetOp?: string;
    /** A name for the connection. */
    readonly name: string;
}
/**
 * Internal schema for requests to the simulator server's /v1/call endpoint.
 * Subject to breaking changes.
 */
export interface SimulatorServerRequest {
    /** The handle of the resource making the request. */
    readonly caller: string;
    /** The target resource handle (an ID unique among resources in the simulation). */
    readonly handle: string;
    /** The method to call on the resource. */
    readonly method: string;
    /** The arguments to the method. */
    readonly args: any[];
}
/**
 * Internal schema for responses from the simulator server's /v1/call endpoint.
 * Subject to breaking changes.
 */
export interface SimulatorServerResponse {
    /** The result of the method call. */
    readonly result?: any;
    /** The error that occurred during the method call. */
    readonly error?: any;
}
export {};
