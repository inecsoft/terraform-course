"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeSimulatorClient = void 0;
const http = __importStar(require("http"));
const serialization_1 = require("./serialization");
function makeHttpRequest(options) {
    return new Promise((resolve, reject) => {
        const req = http.request(options, (res) => {
            let data = "";
            res.on("data", (chunk) => {
                data += chunk;
            });
            res.on("end", () => {
                resolve(data);
            });
        });
        req.on("error", (e) => {
            reject(e);
        });
        if (options.body !== undefined) {
            req.write(options.body);
        }
        req.end();
    });
}
/**
 * Creates a proxy object that forwards method calls to the simulator server.
 *
 * @param url The URL of the simulator server
 * @param handle The handle for the resource we're calling methods on or getting properties from
 * @param caller The handle of the resource that is making the calls
 * @returns A proxy object that forwards calls to the simulator server
 */
function makeSimulatorClient(url, handle, caller) {
    let proxy;
    let hasThenMethod = true; // assume that the object has a "then" method until proven otherwise
    const get = (_target, method, _receiver) => {
        if (method === "then" && !hasThenMethod) {
            return undefined;
        }
        return async function (...args) {
            const body = { caller, handle, method, args };
            const parsedUrl = new URL(url);
            const resp = await makeHttpRequest({
                hostname: parsedUrl.hostname,
                port: parsedUrl.port,
                path: "/v1/call",
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                },
                body: JSON.stringify(body),
            });
            let parsed = (0, serialization_1.deserialize)(resp);
            if (parsed.error) {
                // objects with "then" methods are special-cased by the JS runtime
                // because they are assumed to be promises, and can be awaited. [0]
                // however, this client don't know ahead of time what methods are on the
                // object, so we have to assume that it has a "then" method until
                // we get an error back from the server saying that it doesn't.
                //
                // [0]: https://stackoverflow.com/questions/55262996/does-awaiting-a-non-promise-have-any-detectable-effect
                if (method === "then" &&
                    parsed.error?.message?.startsWith('Method "then" not found on resource')) {
                    hasThenMethod = false;
                    // args[0] is the onFulfilled callback passed to the then method.
                    // we call it with the proxy object so that that `await client`
                    // returns the proxy object back, as callers might expect.
                    return args[0](proxy);
                }
                let err = new Error();
                err.message = parsed.error?.message;
                err.name = parsed.error?.name;
                if (parsed.error?.stack) {
                    // combine the stack trace from the server with the stack trace from the client
                    err.stack = `${parsed.error.stack}\n${err.stack}`;
                }
                throw err;
            }
            return parsed.result;
        };
    };
    proxy = new Proxy({}, { get });
    return proxy;
}
exports.makeSimulatorClient = makeSimulatorClient;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xpZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3NpbXVsYXRvci9jbGllbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwyQ0FBNkI7QUFDN0IsbURBQThDO0FBVTlDLFNBQVMsZUFBZSxDQUFDLE9BQTJCO0lBQ2xELE9BQU8sSUFBSSxPQUFPLENBQUMsQ0FBQyxPQUFPLEVBQUUsTUFBTSxFQUFFLEVBQUU7UUFDckMsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQyxHQUFHLEVBQUUsRUFBRTtZQUN4QyxJQUFJLElBQUksR0FBRyxFQUFFLENBQUM7WUFFZCxHQUFHLENBQUMsRUFBRSxDQUFDLE1BQU0sRUFBRSxDQUFDLEtBQUssRUFBRSxFQUFFO2dCQUN2QixJQUFJLElBQUksS0FBSyxDQUFDO1lBQ2hCLENBQUMsQ0FBQyxDQUFDO1lBRUgsR0FBRyxDQUFDLEVBQUUsQ0FBQyxLQUFLLEVBQUUsR0FBRyxFQUFFO2dCQUNqQixPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDaEIsQ0FBQyxDQUFDLENBQUM7UUFDTCxDQUFDLENBQUMsQ0FBQztRQUVILEdBQUcsQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUU7WUFDcEIsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ1osQ0FBQyxDQUFDLENBQUM7UUFFSCxJQUFJLE9BQU8sQ0FBQyxJQUFJLEtBQUssU0FBUyxFQUFFLENBQUM7WUFDL0IsR0FBRyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDMUIsQ0FBQztRQUVELEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQztJQUNaLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQUVEOzs7Ozs7O0dBT0c7QUFDSCxTQUFnQixtQkFBbUIsQ0FDakMsR0FBVyxFQUNYLE1BQWMsRUFDZCxNQUFjO0lBRWQsSUFBSSxLQUFVLENBQUM7SUFDZixJQUFJLGFBQWEsR0FBRyxJQUFJLENBQUMsQ0FBQyxvRUFBb0U7SUFFOUYsTUFBTSxHQUFHLEdBQUcsQ0FBQyxPQUFZLEVBQUUsTUFBYyxFQUFFLFNBQWMsRUFBRSxFQUFFO1FBQzNELElBQUksTUFBTSxLQUFLLE1BQU0sSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO1lBQ3hDLE9BQU8sU0FBUyxDQUFDO1FBQ25CLENBQUM7UUFFRCxPQUFPLEtBQUssV0FBVyxHQUFHLElBQVc7WUFDbkMsTUFBTSxJQUFJLEdBQTJCLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLENBQUM7WUFDdEUsTUFBTSxTQUFTLEdBQUcsSUFBSSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDL0IsTUFBTSxJQUFJLEdBQUcsTUFBTSxlQUFlLENBQUM7Z0JBQ2pDLFFBQVEsRUFBRSxTQUFTLENBQUMsUUFBUTtnQkFDNUIsSUFBSSxFQUFFLFNBQVMsQ0FBQyxJQUFJO2dCQUNwQixJQUFJLEVBQUUsVUFBVTtnQkFDaEIsTUFBTSxFQUFFLE1BQU07Z0JBQ2QsT0FBTyxFQUFFO29CQUNQLGNBQWMsRUFBRSxrQkFBa0I7aUJBQ25DO2dCQUNELElBQUksRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQzthQUMzQixDQUFDLENBQUM7WUFFSCxJQUFJLE1BQU0sR0FBNEIsSUFBQSwyQkFBVyxFQUFDLElBQUksQ0FBQyxDQUFDO1lBRXhELElBQUksTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDO2dCQUNqQixrRUFBa0U7Z0JBQ2xFLG1FQUFtRTtnQkFDbkUsd0VBQXdFO2dCQUN4RSxpRUFBaUU7Z0JBQ2pFLCtEQUErRDtnQkFDL0QsRUFBRTtnQkFDRiwyR0FBMkc7Z0JBQzNHLElBQ0UsTUFBTSxLQUFLLE1BQU07b0JBQ2pCLE1BQU0sQ0FBQyxLQUFLLEVBQUUsT0FBTyxFQUFFLFVBQVUsQ0FDL0IscUNBQXFDLENBQ3RDLEVBQ0QsQ0FBQztvQkFDRCxhQUFhLEdBQUcsS0FBSyxDQUFDO29CQUN0QixpRUFBaUU7b0JBQ2pFLCtEQUErRDtvQkFDL0QsMERBQTBEO29CQUMxRCxPQUFPLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDeEIsQ0FBQztnQkFFRCxJQUFJLEdBQUcsR0FBRyxJQUFJLEtBQUssRUFBRSxDQUFDO2dCQUN0QixHQUFHLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQyxLQUFLLEVBQUUsT0FBTyxDQUFDO2dCQUNwQyxHQUFHLENBQUMsSUFBSSxHQUFHLE1BQU0sQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDO2dCQUU5QixJQUFJLE1BQU0sQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLENBQUM7b0JBQ3hCLCtFQUErRTtvQkFDL0UsR0FBRyxDQUFDLEtBQUssR0FBRyxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsS0FBSyxLQUFLLEdBQUcsQ0FBQyxLQUFLLEVBQUUsQ0FBQztnQkFDcEQsQ0FBQztnQkFFRCxNQUFNLEdBQUcsQ0FBQztZQUNaLENBQUM7WUFFRCxPQUFPLE1BQU0sQ0FBQyxNQUFNLENBQUM7UUFDdkIsQ0FBQyxDQUFDO0lBQ0osQ0FBQyxDQUFDO0lBRUYsS0FBSyxHQUFHLElBQUksS0FBSyxDQUFDLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUM7SUFDL0IsT0FBTyxLQUFLLENBQUM7QUFDZixDQUFDO0FBcEVELGtEQW9FQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGh0dHAgZnJvbSBcImh0dHBcIjtcbmltcG9ydCB7IGRlc2VyaWFsaXplIH0gZnJvbSBcIi4vc2VyaWFsaXphdGlvblwiO1xuaW1wb3J0IHR5cGUge1xuICBTaW11bGF0b3JTZXJ2ZXJSZXF1ZXN0LFxuICBTaW11bGF0b3JTZXJ2ZXJSZXNwb25zZSxcbn0gZnJvbSBcIi4vc2ltdWxhdG9yXCI7XG5cbmludGVyZmFjZSBIdHRwUmVxdWVzdE9wdGlvbnMgZXh0ZW5kcyBodHRwLlJlcXVlc3RPcHRpb25zIHtcbiAgYm9keT86IHN0cmluZztcbn1cblxuZnVuY3Rpb24gbWFrZUh0dHBSZXF1ZXN0KG9wdGlvbnM6IEh0dHBSZXF1ZXN0T3B0aW9ucyk6IFByb21pc2U8c3RyaW5nPiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgcmVxID0gaHR0cC5yZXF1ZXN0KG9wdGlvbnMsIChyZXMpID0+IHtcbiAgICAgIGxldCBkYXRhID0gXCJcIjtcblxuICAgICAgcmVzLm9uKFwiZGF0YVwiLCAoY2h1bmspID0+IHtcbiAgICAgICAgZGF0YSArPSBjaHVuaztcbiAgICAgIH0pO1xuXG4gICAgICByZXMub24oXCJlbmRcIiwgKCkgPT4ge1xuICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXEub24oXCJlcnJvclwiLCAoZSkgPT4ge1xuICAgICAgcmVqZWN0KGUpO1xuICAgIH0pO1xuXG4gICAgaWYgKG9wdGlvbnMuYm9keSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXEud3JpdGUob3B0aW9ucy5ib2R5KTtcbiAgICB9XG5cbiAgICByZXEuZW5kKCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBwcm94eSBvYmplY3QgdGhhdCBmb3J3YXJkcyBtZXRob2QgY2FsbHMgdG8gdGhlIHNpbXVsYXRvciBzZXJ2ZXIuXG4gKlxuICogQHBhcmFtIHVybCBUaGUgVVJMIG9mIHRoZSBzaW11bGF0b3Igc2VydmVyXG4gKiBAcGFyYW0gaGFuZGxlIFRoZSBoYW5kbGUgZm9yIHRoZSByZXNvdXJjZSB3ZSdyZSBjYWxsaW5nIG1ldGhvZHMgb24gb3IgZ2V0dGluZyBwcm9wZXJ0aWVzIGZyb21cbiAqIEBwYXJhbSBjYWxsZXIgVGhlIGhhbmRsZSBvZiB0aGUgcmVzb3VyY2UgdGhhdCBpcyBtYWtpbmcgdGhlIGNhbGxzXG4gKiBAcmV0dXJucyBBIHByb3h5IG9iamVjdCB0aGF0IGZvcndhcmRzIGNhbGxzIHRvIHRoZSBzaW11bGF0b3Igc2VydmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlU2ltdWxhdG9yQ2xpZW50KFxuICB1cmw6IHN0cmluZyxcbiAgaGFuZGxlOiBzdHJpbmcsXG4gIGNhbGxlcjogc3RyaW5nXG4pIHtcbiAgbGV0IHByb3h5OiBhbnk7XG4gIGxldCBoYXNUaGVuTWV0aG9kID0gdHJ1ZTsgLy8gYXNzdW1lIHRoYXQgdGhlIG9iamVjdCBoYXMgYSBcInRoZW5cIiBtZXRob2QgdW50aWwgcHJvdmVuIG90aGVyd2lzZVxuXG4gIGNvbnN0IGdldCA9IChfdGFyZ2V0OiBhbnksIG1ldGhvZDogc3RyaW5nLCBfcmVjZWl2ZXI6IGFueSkgPT4ge1xuICAgIGlmIChtZXRob2QgPT09IFwidGhlblwiICYmICFoYXNUaGVuTWV0aG9kKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiBhc3luYyBmdW5jdGlvbiAoLi4uYXJnczogYW55W10pIHtcbiAgICAgIGNvbnN0IGJvZHk6IFNpbXVsYXRvclNlcnZlclJlcXVlc3QgPSB7IGNhbGxlciwgaGFuZGxlLCBtZXRob2QsIGFyZ3MgfTtcbiAgICAgIGNvbnN0IHBhcnNlZFVybCA9IG5ldyBVUkwodXJsKTtcbiAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCBtYWtlSHR0cFJlcXVlc3Qoe1xuICAgICAgICBob3N0bmFtZTogcGFyc2VkVXJsLmhvc3RuYW1lLFxuICAgICAgICBwb3J0OiBwYXJzZWRVcmwucG9ydCxcbiAgICAgICAgcGF0aDogXCIvdjEvY2FsbFwiLFxuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgfSk7XG5cbiAgICAgIGxldCBwYXJzZWQ6IFNpbXVsYXRvclNlcnZlclJlc3BvbnNlID0gZGVzZXJpYWxpemUocmVzcCk7XG5cbiAgICAgIGlmIChwYXJzZWQuZXJyb3IpIHtcbiAgICAgICAgLy8gb2JqZWN0cyB3aXRoIFwidGhlblwiIG1ldGhvZHMgYXJlIHNwZWNpYWwtY2FzZWQgYnkgdGhlIEpTIHJ1bnRpbWVcbiAgICAgICAgLy8gYmVjYXVzZSB0aGV5IGFyZSBhc3N1bWVkIHRvIGJlIHByb21pc2VzLCBhbmQgY2FuIGJlIGF3YWl0ZWQuIFswXVxuICAgICAgICAvLyBob3dldmVyLCB0aGlzIGNsaWVudCBkb24ndCBrbm93IGFoZWFkIG9mIHRpbWUgd2hhdCBtZXRob2RzIGFyZSBvbiB0aGVcbiAgICAgICAgLy8gb2JqZWN0LCBzbyB3ZSBoYXZlIHRvIGFzc3VtZSB0aGF0IGl0IGhhcyBhIFwidGhlblwiIG1ldGhvZCB1bnRpbFxuICAgICAgICAvLyB3ZSBnZXQgYW4gZXJyb3IgYmFjayBmcm9tIHRoZSBzZXJ2ZXIgc2F5aW5nIHRoYXQgaXQgZG9lc24ndC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gWzBdOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81NTI2Mjk5Ni9kb2VzLWF3YWl0aW5nLWEtbm9uLXByb21pc2UtaGF2ZS1hbnktZGV0ZWN0YWJsZS1lZmZlY3RcbiAgICAgICAgaWYgKFxuICAgICAgICAgIG1ldGhvZCA9PT0gXCJ0aGVuXCIgJiZcbiAgICAgICAgICBwYXJzZWQuZXJyb3I/Lm1lc3NhZ2U/LnN0YXJ0c1dpdGgoXG4gICAgICAgICAgICAnTWV0aG9kIFwidGhlblwiIG5vdCBmb3VuZCBvbiByZXNvdXJjZSdcbiAgICAgICAgICApXG4gICAgICAgICkge1xuICAgICAgICAgIGhhc1RoZW5NZXRob2QgPSBmYWxzZTtcbiAgICAgICAgICAvLyBhcmdzWzBdIGlzIHRoZSBvbkZ1bGZpbGxlZCBjYWxsYmFjayBwYXNzZWQgdG8gdGhlIHRoZW4gbWV0aG9kLlxuICAgICAgICAgIC8vIHdlIGNhbGwgaXQgd2l0aCB0aGUgcHJveHkgb2JqZWN0IHNvIHRoYXQgdGhhdCBgYXdhaXQgY2xpZW50YFxuICAgICAgICAgIC8vIHJldHVybnMgdGhlIHByb3h5IG9iamVjdCBiYWNrLCBhcyBjYWxsZXJzIG1pZ2h0IGV4cGVjdC5cbiAgICAgICAgICByZXR1cm4gYXJnc1swXShwcm94eSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZXJyID0gbmV3IEVycm9yKCk7XG4gICAgICAgIGVyci5tZXNzYWdlID0gcGFyc2VkLmVycm9yPy5tZXNzYWdlO1xuICAgICAgICBlcnIubmFtZSA9IHBhcnNlZC5lcnJvcj8ubmFtZTtcblxuICAgICAgICBpZiAocGFyc2VkLmVycm9yPy5zdGFjaykge1xuICAgICAgICAgIC8vIGNvbWJpbmUgdGhlIHN0YWNrIHRyYWNlIGZyb20gdGhlIHNlcnZlciB3aXRoIHRoZSBzdGFjayB0cmFjZSBmcm9tIHRoZSBjbGllbnRcbiAgICAgICAgICBlcnIuc3RhY2sgPSBgJHtwYXJzZWQuZXJyb3Iuc3RhY2t9XFxuJHtlcnIuc3RhY2t9YDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcnNlZC5yZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICBwcm94eSA9IG5ldyBQcm94eSh7fSwgeyBnZXQgfSk7XG4gIHJldHVybiBwcm94eTtcbn1cbiJdfQ==