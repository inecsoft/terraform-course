"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.sanitizeParamLikeObject = exports.parseHttpMethod = exports.DEFAULT_RESPONSE_STATUS = exports.HttpMethod = exports.ApiInflightMethods = exports.Api = exports.API_FQN = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const constants_1 = require("../constants");
const errors_1 = require("../core/errors");
const types_1 = require("../core/types");
const std_1 = require("../std");
/**
 * Global identifier for `Api`.
 */
exports.API_FQN = (0, constants_1.fqnForType)("cloud.Api");
/**
 * Functionality shared between all `Api` implementations.
 * @inflight `@winglang/sdk.cloud.IApiClient`
 * @abstract
 */
class Api extends std_1.Resource {
    /**
     * Converts input path to a valid OpenAPI path (replaces `:` based path params with `{}`)
     * @param path The path to convert (assumes path is valid)
     * @returns OpenAPI path
     */
    static renderOpenApiPath(path) {
        return path.replace(/\/:([A-Za-z0-9_-]+)/g, "/{$1}");
    }
    /**
     * Generates an object containing default CORS response headers and OPTIONS response headers.
     * @param corsOptions The CORS options to generate the headers from.
     * @returns An object containing default CORS response headers and OPTIONS response headers.
     */
    static renderCorsHeaders(corsOptions) {
        if (corsOptions == undefined) {
            return;
        }
        const { allowOrigin = "*", allowHeaders = [], allowMethods = [], exposeHeaders = [], allowCredentials = false, maxAge = std_1.Duration.fromMinutes(5), } = corsOptions;
        const defaultHeaders = {
            "Access-Control-Allow-Origin": allowOrigin || "*",
            "Access-Control-Expose-Headers": exposeHeaders.join(",") || "",
            "Access-Control-Allow-Credentials": allowCredentials ? "true" : "false",
        };
        const optionsHeaders = {
            "Access-Control-Allow-Origin": allowOrigin || "*",
            "Access-Control-Allow-Headers": allowHeaders.join(",") || "",
            "Access-Control-Allow-Methods": allowMethods.join(",") || "",
            "Access-Control-Max-Age": maxAge.seconds.toString(),
        };
        return {
            defaultResponse: defaultHeaders,
            optionsResponse: optionsHeaders,
        };
    }
    /**
     * The base URL of the API endpoint.
     */
    get url() {
        return this._endpoint.url;
    }
    /**
     * The Endpoint of the API.
     * @abstract
     * @internal
     */
    get _endpoint() {
        throw new errors_1.AbstractMemberError();
    }
    constructor(scope, id, props = {}) {
        if (new.target === Api) {
            return std_1.Resource._newFromFactory(exports.API_FQN, scope, id, props);
        }
        super(scope, id);
        // https://spec.openapis.org/oas/v3.0.3
        this.apiSpec = {
            paths: {},
        };
        this.corsDefaultValues = {
            allowOrigin: "*",
            allowMethods: [
                HttpMethod.GET,
                HttpMethod.POST,
                HttpMethod.PUT,
                HttpMethod.DELETE,
                HttpMethod.HEAD,
                HttpMethod.OPTIONS,
            ],
            allowHeaders: ["Content-Type", "Authorization", "X-Requested-With"],
            exposeHeaders: [],
            allowCredentials: false,
            maxAge: std_1.Duration.fromMinutes(5),
        };
        this.corsOptions = props.cors ? this._cors(props.corsOptions) : undefined;
        std_1.Node.of(this).title = "Api";
        std_1.Node.of(this).description = "A REST API endpoint";
    }
    /**
     * Add a inflight handler to the api for GET requests on the given path.
     * @param path The path to handle GET requests for.
     * @param inflight The function to handle the request.
     * @param props Options for the route.
     * @abstract
     */
    get(path, inflight, props) {
        path;
        inflight;
        props;
        throw new errors_1.AbstractMemberError();
    }
    /**
     * Add a inflight handler to the api for POST requests on the given path.
     * @param path The path to handle POST requests for.
     * @param inflight The function to handle the request.
     * @param props Options for the route.
     * @abstract
     */
    post(path, inflight, props) {
        path;
        inflight;
        props;
        throw new errors_1.AbstractMemberError();
    }
    /**
     * Add a inflight handler to the api for PUT requests on the given path.
     * @param path The path to handle PUT requests for.
     * @param inflight The function to handle the request.
     * @param props Options for the route.
     * @abstract
     */
    put(path, inflight, props) {
        path;
        inflight;
        props;
        throw new errors_1.AbstractMemberError();
    }
    /**
     * Add a inflight handler to the api for DELETE requests on the given path.
     * @param path The path to handle DELETE requests for.
     * @param inflight The function to handle the request.
     * @param props Options for the route.
     * @abstract
     */
    delete(path, inflight, props) {
        path;
        inflight;
        props;
        throw new errors_1.AbstractMemberError();
    }
    /**
     * Add a inflight handler to the api for PATCH requests on the given path.
     * @param path The path to handle PATCH requests for.
     * @param inflight The function to handle the request.
     * @param props Options for the route.
     * @abstract
     */
    patch(path, inflight, props) {
        path;
        inflight;
        props;
        throw new errors_1.AbstractMemberError();
    }
    /**
     * Add a inflight handler to the api for OPTIONS requests on the given path.
     * @param path The path to handle OPTIONS requests for.
     * @param inflight The function to handle the request.
     * @param props Options for the route.
     * @abstract
     */
    options(path, inflight, props) {
        path;
        inflight;
        props;
        throw new errors_1.AbstractMemberError();
    }
    /**
     * Add a inflight handler to the api for HEAD requests on the given path.
     * @param path The path to handle HEAD requests for.
     * @param inflight The function to handle the request.
     * @param props Options for the route.
     * @abstract
     */
    head(path, inflight, props) {
        path;
        inflight;
        props;
        throw new errors_1.AbstractMemberError();
    }
    /**
     * Add a inflight handler to the api for CONNECT requests on the given path.
     * @param path The path to handle CONNECT requests for.
     * @param inflight The function to handle the request.
     * @param props Options for the route.
     * @abstract
     */
    connect(path, inflight, props) {
        path;
        inflight;
        props;
        throw new errors_1.AbstractMemberError();
    }
    /**
     * Validating path:
     * if has `:` prefix - the part following that prefix is only letter, digit or _, not empty and placed before and after "/"
     * @param path
     * @throws if the path is invalid
     * @internal
     */
    _validatePath(path) {
        if (!/^((\/\:[a-zA-Z0-9_\-]+|\/[a-zA-Z0-9_\-\.]*)*(?:\?[^#]*)?)?$/g.test(path)) {
            throw new Error(`Invalid path ${path}. Url parts can only contain alpha-numeric chars, "-", "_" and ".". Params can only contain alpha-numeric chars and "_".`);
        }
    }
    /**
     * Returns CORS configuration. If props are provided, they will have precedence over defaults.
     * @param props
     * @returns ApiCorsOptions
     * @internal
     */
    _cors(props) {
        return {
            ...this.corsDefaultValues,
            ...props,
        };
    }
    /**
     * Checks if two given paths are siblings.
     * @param pathA
     * @param pathB
     * @returns A boolean value indicating if provided paths are siblings.
     * @internal
     */
    _arePathsSiblings(pathA, pathB) {
        const partsA = pathA.split("/");
        const partsB = pathB.split("/");
        let shorter = partsA.length < partsB.length ? partsA : partsB;
        for (let i = 0; i < shorter.length; i++) {
            const partA = partsA[i];
            const partB = partsB[i];
            if ((!partA.match(/^:.+?$/) || !partB.match(/^:.+?$/)) &&
                partA[i] !== partB[i]) {
                return false;
            }
            if (partA.match(/^:.+?$/) &&
                partB.match(/^:.+?$/) &&
                partA[i] !== partB[i]) {
                return true;
            }
        }
        return false;
    }
    /**
     * Checks if two given paths are ambiguous.
     * @param pathA
     * @param pathB
     * @returns A boolean value indicating if provided paths are ambiguous.
     * @internal
     */
    _arePathsAmbiguous(pathA, pathB) {
        const partsA = pathA.split("/");
        const partsB = pathB.split("/");
        if (partsA.length !== partsB.length) {
            return false;
        }
        for (let i = 0; i < partsA.length; i++) {
            const partA = partsA[i];
            const partB = partsB[i];
            if (partA !== partB && !partA.match(/^:.+?$/) && !partB.match(/^:.+?$/)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Checks if provided path and method are ambigous with paths and methods already defined in the api spec.
     * @param path Path to be checked
     * @param method HTTP method
     * @returns A boolean value indicating if provided path and method are ambiguous.
     * @internal
     */
    _findAmbiguousPath(path, method) {
        const existingPaths = Object.keys(this.apiSpec.paths);
        return existingPaths.find((existingPath) => !!this.apiSpec.paths[existingPath][method.toLowerCase()] &&
            this._arePathsAmbiguous(existingPath, path));
    }
    /**
     * Checks if provided path is a sibling of paths already defined in the api spec- i.e "/:username" and "/:id".
     * @param path Path to be checked
     * @returns A boolean value indicating if provided path has a sibling.
     * @internal
     */
    _findSiblingPath(path) {
        const existingPaths = Object.keys(this.apiSpec.paths);
        return existingPaths.find((existingPath) => this._arePathsSiblings(existingPath, path));
    }
    /**
     * Generates the OpenAPI schema for CORS headers based on the provided CORS options.
     * @param corsOptions The CORS options to generate the schema from.
     * @returns An object representing the OpenAPI schema for CORS headers.
     */
    _corsOpenApiSchema(corsOptions) {
        const corsHeaders = {};
        if (corsOptions) {
            const corsHeaderSchema = {
                schema: {
                    type: "string",
                },
            };
            corsHeaders["Access-Control-Allow-Origin"] = corsHeaderSchema;
            corsHeaders["Access-Control-Allow-Methods"] = corsHeaderSchema;
            corsHeaders["Access-Control-Allow-Headers"] = corsHeaderSchema;
            corsHeaders["Access-Control-Max-Age"] = corsHeaderSchema;
        }
        return corsHeaders;
    }
    /**
     * Add a route to the api spec.
     * @param path The path to add.
     * @param method The method to add.
     * @param apiSpecExtension The extension to add to the api spec for this route and method.
     *
     * @internal
     * */
    _addToSpec(path, method, apiSpecExtension, corsOptions) {
        if (this.apiSpec.paths[path]?.[method.toLowerCase()]) {
            throw new Error(`Endpoint for path '${path}' and method '${method}' already exists`);
        }
        const ambiguousPath = this._findAmbiguousPath(path, method);
        if (!!ambiguousPath) {
            throw new Error(`Endpoint for path '${path}' and method '${method}' is ambiguous - it conflicts with existing endpoint for path '${ambiguousPath}'`);
        }
        const siblingPath = this._findSiblingPath(path);
        if (!!siblingPath) {
            throw new Error(`Endpoint for path '${path}' and method '${method}' conflicts with existing sibling endpoint for path '${siblingPath}'- try to match the parameter names to avoid this error.`);
        }
        const operationId = `${method.toLowerCase()}${path === "/" ? "" : path.replace("/", "-")}`;
        const pathParams = path.match(/:([A-Za-z0-9_-]+)/g);
        const pathParameters = [];
        if (pathParams) {
            pathParams.forEach((param) => {
                const paramName = param.replace(":", "");
                pathParameters.push({
                    name: paramName,
                    in: "path",
                    required: true,
                    schema: {
                        type: "string",
                    },
                });
            });
        }
        const corsOpenApiSchema = this._corsOpenApiSchema(corsOptions);
        const methodSpec = {
            [method.toLowerCase()]: {
                operationId: operationId,
                responses: {
                    "200": {
                        description: "200 response",
                        content: {},
                        ...(Object.keys(corsOpenApiSchema).length > 0
                            ? { headers: corsOpenApiSchema }
                            : {}),
                    },
                },
                parameters: pathParameters,
                ...apiSpecExtension,
            },
        };
        this.apiSpec.paths[path] = {
            ...this.apiSpec.paths[path],
            ...methodSpec,
        };
    }
    /**
     * Return the OpenAPI spec for this Api.
     * @internal */
    _getOpenApiSpec() {
        // Convert our paths to valid OpenAPI paths
        let paths = {};
        Object.keys(this.apiSpec.paths).forEach((key) => {
            paths[Api.renderOpenApiPath(key)] = this.apiSpec.paths[key];
        });
        // https://spec.openapis.org/oas/v3.0.3
        return {
            ...this.apiSpec,
            openapi: "3.0.3",
            paths: paths,
        };
    }
}
exports.Api = Api;
_a = JSII_RTTI_SYMBOL_1;
Api[_a] = { fqn: "@winglang/sdk.cloud.Api", version: "0.0.0" };
/**
 * List of inflight operations available for `Api`.
 * @internal
 */
var ApiInflightMethods;
(function (ApiInflightMethods) {
    /** When the API endpoint receives a request. */
    ApiInflightMethods["REQUEST"] = "request";
})(ApiInflightMethods || (exports.ApiInflightMethods = ApiInflightMethods = {}));
/**
 * Allowed HTTP methods for a endpoint.
 */
var HttpMethod;
(function (HttpMethod) {
    /** Get */
    HttpMethod["GET"] = "GET";
    /** Head */
    HttpMethod["HEAD"] = "HEAD";
    /** Post */
    HttpMethod["POST"] = "POST";
    /** Put */
    HttpMethod["PUT"] = "PUT";
    /** Delete */
    HttpMethod["DELETE"] = "DELETE";
    /** Connect */
    HttpMethod["CONNECT"] = "CONNECT";
    /** Options */
    HttpMethod["OPTIONS"] = "OPTIONS";
    /** Patch */
    HttpMethod["PATCH"] = "PATCH";
})(HttpMethod || (exports.HttpMethod = HttpMethod = {}));
exports.DEFAULT_RESPONSE_STATUS = 200;
/**
 * Parse an HTTP method string to an HttpMethod enum
 * @param method HTTP method string
 * @returns HttpMethod enum
 * @throws Error if the method is not supported
 */
function parseHttpMethod(method) {
    switch (method) {
        case "GET":
            return HttpMethod.GET;
        case "POST":
            return HttpMethod.POST;
        case "PUT":
            return HttpMethod.PUT;
        case "HEAD":
            return HttpMethod.HEAD;
        case "DELETE":
            return HttpMethod.DELETE;
        case "CONNECT":
            return HttpMethod.CONNECT;
        case "OPTIONS":
            return HttpMethod.OPTIONS;
        case "PATCH":
            return HttpMethod.PATCH;
        default:
            throw new Error(`Unsupported HTTP method: ${method}`);
    }
}
exports.parseHttpMethod = parseHttpMethod;
/**
 * Convert an object with multi-valued parameters to a an object with
 * single-valued parameters.
 */
function sanitizeParamLikeObject(obj) {
    const newObj = {};
    Object.keys(obj).forEach((key) => {
        const value = obj[key];
        if (Array.isArray(value)) {
            newObj[key] = value.join(",");
        }
        else if (typeof value === "string") {
            newObj[key] = value;
        }
    });
    return newObj;
}
exports.sanitizeParamLikeObject = sanitizeParamLikeObject;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBpLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2Nsb3VkL2FwaS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUdBLDRDQUEwQztBQUMxQywyQ0FBcUQ7QUFDckQseUNBQWdEO0FBQ2hELGdDQUE2RDtBQUU3RDs7R0FFRztBQUVVLFFBQUEsT0FBTyxHQUFHLElBQUEsc0JBQVUsRUFBQyxXQUFXLENBQUMsQ0FBQztBQXFJL0M7Ozs7R0FJRztBQUVILE1BQWEsR0FBSSxTQUFRLGNBQVE7SUFDL0I7Ozs7T0FJRztJQUNJLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxJQUFZO1FBQzFDLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxzQkFBc0IsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUN2RCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLE1BQU0sQ0FBQyxpQkFBaUIsQ0FDN0IsV0FBNEI7UUFFNUIsSUFBSSxXQUFXLElBQUksU0FBUyxFQUFFLENBQUM7WUFDN0IsT0FBTztRQUNULENBQUM7UUFFRCxNQUFNLEVBQ0osV0FBVyxHQUFHLEdBQUcsRUFDakIsWUFBWSxHQUFHLEVBQUUsRUFDakIsWUFBWSxHQUFHLEVBQUUsRUFDakIsYUFBYSxHQUFHLEVBQUUsRUFDbEIsZ0JBQWdCLEdBQUcsS0FBSyxFQUN4QixNQUFNLEdBQUcsY0FBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsR0FDakMsR0FBRyxXQUFXLENBQUM7UUFFaEIsTUFBTSxjQUFjLEdBQStCO1lBQ2pELDZCQUE2QixFQUFFLFdBQVcsSUFBSSxHQUFHO1lBQ2pELCtCQUErQixFQUFFLGFBQWEsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRTtZQUM5RCxrQ0FBa0MsRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxPQUFPO1NBQ3hFLENBQUM7UUFFRixNQUFNLGNBQWMsR0FBK0I7WUFDakQsNkJBQTZCLEVBQUUsV0FBVyxJ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TyxVQUFVLENBQUMsT0FBTyxDQUFDO1FBQzVCLEtBQUssT0FBTztZQUNWLE9BQU8sVUFBVSxDQUFDLEtBQUssQ0FBQztRQUMxQjtZQUNFLE1BQU0sSUFBSSxLQUFLLENBQUMsNEJBQTRCLE1BQU0sRUFBRSxDQUFDLENBQUM7SUFDMUQsQ0FBQztBQUNILENBQUM7QUFyQkQsMENBcUJDO0FBRUQ7OztHQUdHO0FBQ0gsU0FBZ0IsdUJBQXVCLENBQ3JDLEdBQWtEO0lBRWxELE1BQU0sTUFBTSxHQUEyQixFQUFFLENBQUM7SUFDMUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRTtRQUMvQixNQUFNLEtBQUssR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDdkIsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUM7WUFDekIsTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDaEMsQ0FBQzthQUFNLElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxFQUFFLENBQUM7WUFDckMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQztRQUN0QixDQUFDO0lBQ0gsQ0FBQyxDQUFDLENBQUM7SUFDSCxPQUFPLE1BQU0sQ0FBQztBQUNoQixDQUFDO0FBYkQsMERBYUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb25zdHJ1Y3QgfSBmcm9tIFwiY29uc3RydWN0c1wiO1xuaW1wb3J0IHsgRW5kcG9pbnQgfSBmcm9tIFwiLi9lbmRwb2ludFwiO1xuaW1wb3J0IHsgRnVuY3Rpb25Qcm9wcyB9IGZyb20gXCIuL2Z1bmN0aW9uXCI7XG5pbXBvcnQgeyBmcW5Gb3JUeXBlIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgQWJzdHJhY3RNZW1iZXJFcnJvciB9IGZyb20gXCIuLi9jb3JlL2Vycm9yc1wiO1xuaW1wb3J0IHsgSU5GTElHSFRfU1lNQk9MIH0gZnJvbSBcIi4uL2NvcmUvdHlwZXNcIjtcbmltcG9ydCB7IE5vZGUsIFJlc291cmNlLCBEdXJhdGlvbiwgSUluZmxpZ2h0IH0gZnJvbSBcIi4uL3N0ZFwiO1xuXG4vKipcbiAqIEdsb2JhbCBpZGVudGlmaWVyIGZvciBgQXBpYC5cbiAqL1xuXG5leHBvcnQgY29uc3QgQVBJX0ZRTiA9IGZxbkZvclR5cGUoXCJjbG91ZC5BcGlcIik7XG5cbi8qKlxuICogQ29ycyBPcHRpb25zIGZvciBgQXBpYC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBcGlDb3JzT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgYWxsb3dlZCBvcmlnaW4uXG4gICAqIEBleGFtcGxlIFwiaHR0cHM6Ly9leGFtcGxlLmNvbVwiXG4gICAqIEBkZWZhdWx0IC0gXCIqXCJcbiAgICovXG4gIHJlYWRvbmx5IGFsbG93T3JpZ2luPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbGlzdCBvZiBhbGxvd2VkIG1ldGhvZHMuXG4gICAqIEBleGFtcGxlIFtIdHRwTWV0aG9kLkdFVCwgSHR0cE1ldGhvZC5QT1NUXVxuICAgKiBAZGVmYXVsdCAtIFtIdHRwTWV0aG9kLkdFVCwgSHR0cE1ldGhvZC5QT1NULCBIdHRwTWV0aG9kLlBVVCwgSHR0cE1ldGhvZC5QQVRDSCwgSHR0cE1ldGhvZC5ERUxFVEUsIEh0dHBNZXRob2QuSEVBRCwgSHR0cE1ldGhvZC5PUFRJT05TXVxuICAgKi9cbiAgcmVhZG9ubHkgYWxsb3dNZXRob2RzPzogQXJyYXk8SHR0cE1ldGhvZD47XG5cbiAgLyoqXG4gICAqIFRoZSBsaXN0IG9mIGFsbG93ZWQgaGVhZGVycy5cbiAgICogQGV4YW1wbGUgW1wiQ29udGVudC1UeXBlXCJdXG4gICAqIEBkZWZhdWx0IC0gW1wiQ29udGVudC1UeXBlXCIsIFwiQXV0aG9yaXphdGlvblwiXVxuICAgKi9cbiAgcmVhZG9ubHkgYWxsb3dIZWFkZXJzPzogQXJyYXk8c3RyaW5nPjtcblxuICAvKipcbiAgICogVGhlIGxpc3Qgb2YgZXhwb3NlZCBoZWFkZXJzLlxuICAgKiBAZXhhbXBsZSBbXCJDb250ZW50LVR5cGVcIl1cbiAgICogQGRlZmF1bHQgLSBbXVxuICAgKi9cbiAgcmVhZG9ubHkgZXhwb3NlSGVhZGVycz86IEFycmF5PHN0cmluZz47XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gYWxsb3cgY3JlZGVudGlhbHMuXG4gICAqIEBkZWZhdWx0IC0gZmFsc2VcbiAgICovXG4gIHJlYWRvbmx5IGFsbG93Q3JlZGVudGlhbHM/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBIb3cgbG9uZyB0aGUgYnJvd3NlciBzaG91bGQgY2FjaGUgcHJlZmxpZ2h0IHJlcXVlc3QgcmVzdWx0cy5cbiAgICogQGRlZmF1bHQgLSAzMDAgc2Vjb25kc1xuICAgKi9cbiAgcmVhZG9ubHkgbWF4QWdlPzogRHVyYXRpb247XG59XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgYEFwaWAuXG4gKi9cblxuZXhwb3J0IGludGVyZmFjZSBBcGlQcm9wcyB7XG4gIC8qKlxuICAgKiBPcHRpb25zIGZvciBjb25maWd1cmluZyB0aGUgQVBJJ3MgQ09SUyBiZWhhdmlvciBhY3Jvc3MgYWxsIHJvdXRlcy5cbiAgICogT3B0aW9ucyBjYW4gYWxzbyBiZSBvdmVycmlkZGVuIG9uIGEgcGVyLXJvdXRlIGJhc2lzLiAobm90IHlldCBpbXBsZW1lbnRlZClcbiAgICogV2hlbiBlbmFibGVkIHRoaXMgd2lsbCBhZGQgQ09SUyBoZWFkZXJzIHdpdGggZGVmYXVsdCBvcHRpb25zLlxuICAgKiBDYW4gYmUgY3VzdG9taXplZCBieSBwYXNzaW5nIGBjb3JzT3B0aW9uc2BcbiAgICogQGV4YW1wbGUgdHJ1ZVxuICAgKiBAZGVmYXVsdCAtIGZhbHNlLCBDT1JTIGNvbmZpZ3VyYXRpb24gaXMgZGlzYWJsZWRcbiAgICovXG4gIHJlYWRvbmx5IGNvcnM/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBPcHRpb25zIGZvciBjb25maWd1cmluZyB0aGUgQVBJJ3MgQ09SUyBiZWhhdmlvciBhY3Jvc3MgYWxsIHJvdXRlcy5cbiAgICogT3B0aW9ucyBjYW4gYWxzbyBiZSBvdmVycmlkZGVuIG9uIGEgcGVyLXJvdXRlIGJhc2lzLiAobm90IHlldCBpbXBsZW1lbnRlZClcbiAgICpcbiAgICogQGV4YW1wbGUgeyBhbGxvd09yaWdpbjogXCJodHRwczovL2V4YW1wbGUuY29tXCIgfVxuICAgKiBAZGVmYXVsdCAtIERlZmF1bHQgQ09SUyBvcHRpb25zIGFyZSBhcHBsaWVkIHdoZW4gYGNvcnNgIGlzIHNldCB0byBgdHJ1ZWBcbiAgICogIGFsbG93T3JpZ2luOiBcIipcIixcbiAgICogIGFsbG93TWV0aG9kczogW1xuICAgKiAgIEh0dHBNZXRob2QuR0VULFxuICAgKiAgIEh0dHBNZXRob2QuUE9TVCxcbiAgICogICBIdHRwTWV0aG9kLlBVVCxcbiAgICogICBIdHRwTWV0aG9kLkRFTEVURSxcbiAgICogICBIdHRwTWV0aG9kLkhFQUQsXG4gICAqICAgSHR0cE1ldGhvZC5PUFRJT05TLFxuICAgKiAgXSxcbiAgICogIGFsbG93SGVhZGVyczogW1wiQ29udGVudC1UeXBlXCIsIFwiQXV0aG9yaXphdGlvblwiXSxcbiAgICogIGV4cG9zZUhlYWRlcnM6IFtdLFxuICAgKiAgYWxsb3dDcmVkZW50aWFsczogZmFsc2UsXG4gICAqXG4gICAqL1xuICByZWFkb25seSBjb3JzT3B0aW9ucz86IEFwaUNvcnNPcHRpb25zO1xufVxuLyoqXG4gKiBUaGUgT3BlbkFQSSBzcGVjLlxuICovXG4vLyBUT0RPOiBUaGlzIHNob3VsZCBiZSBhIHR5cGUgZnJvbSB0aGUgT3BlbkFQSSBzcGVjLiBXZSBjYW4gZWl0aGVyIHVzZSBhIGV4dGVybmFsIHBhY2thZ2Ugb3IgZGVmaW5lIGl0IG91cnNlbHZlcy5cbmV4cG9ydCB0eXBlIE9wZW5BcGlTcGVjID0gYW55O1xuXG4vKipcbiAqIFRoZSBPcGVuQVBJIHNwZWMgZXh0ZW5zaW9uIGZvciBhIHJvdXRlLlxuICogQHNlZSBodHRwczovL3NwZWMub3BlbmFwaXMub3JnL29hcy92My4wLjNcbiAqICovXG5leHBvcnQgdHlwZSBPcGVuQXBpU3BlY0V4dGVuc2lvbiA9IGFueTtcblxuLyoqXG4gKiBUaGUgT3BlbkFQSSBzcGVjIGZvciBDT1JTIGhlYWRlcnMuXG4gKiAqL1xuZXhwb3J0IHR5cGUgT3BlbkFwaUNvcnNIZWFkZXJzID0gUmVjb3JkPHN0cmluZywgeyBzY2hlbWE6IHsgdHlwZTogc3RyaW5nIH0gfT47XG5cbi8qKlxuICogVHlwZSBkZWZpbml0aW9uIGZvciBkZWZhdWx0IENPUlMgaGVhZGVycy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBcIkFjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpblwiIC0gU3BlY2lmaWVzIHRoZSBvcmlnaW4gdGhhdCBpcyBhbGxvd2VkIHRvIGFjY2VzcyB0aGUgcmVzb3VyY2UuIFNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0FjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpbn1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBcIkFjY2Vzcy1Db250cm9sLUV4cG9zZS1IZWFkZXJzXCIgLSBMaXN0cyB0aGUgaGVhZGVycyB0aGF0IHRoZSBjbGllbnQgY2FuIGFjY2Vzcy4gU2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvQWNjZXNzLUNvbnRyb2wtRXhwb3NlLUhlYWRlcnN9XG4gKiBAcHJvcGVydHkge3N0cmluZ30gXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1DcmVkZW50aWFsc1wiIC0gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHJlc3BvbnNlIHRvIHRoZSByZXF1ZXN0IGNhbiBiZSBleHBvc2VkIHdoZW4gdGhlIGNyZWRlbnRpYWxzIGZsYWcgaXMgdHJ1ZS4gU2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvQWNjZXNzLUNvbnRyb2wtQWxsb3ctQ3JlZGVudGlhbHN9XG4gKi9cbnR5cGUgQ29yc0RlZmF1bHRSZXNwb25zZUhlYWRlcnMgPSB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xuXG4vKipcbiAqIFR5cGUgZGVmaW5pdGlvbiBmb3IgQ09SUyBvcHRpb24gaGVhZGVycy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBcIkFjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpblwiIC0gU3BlY2lmaWVzIHRoZSBvcmlnaW4gdGhhdCBpcyBhbGxvd2VkIHRvIGFjY2VzcyB0aGUgcmVzb3VyY2UuIFNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0FjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpbn1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBcIkFjY2Vzcy1Db250cm9sLUFsbG93LUhlYWRlcnNcIiAtIFNwZWNpZmllcyB0aGUgaGVhZGVycyB0aGF0IGFyZSBhbGxvd2VkIGluIGEgcmVxdWVzdC4gU2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvQWNjZXNzLUNvbnRyb2wtQWxsb3ctSGVhZGVyc31cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBcIkFjY2Vzcy1Db250cm9sLUFsbG93LU1ldGhvZHNcIiAtIFNwZWNpZmllcyB0aGUgbWV0aG9kcyB0aGF0IGFyZSBhbGxvd2VkIGluIGEgcmVxdWVzdC4gU2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvQWNjZXNzLUNvbnRyb2wtQWxsb3ctTWV0aG9kc31cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBcIkFjY2Vzcy1Db250cm9sLU1heC1BZ2VcIiAtIEluZGljYXRlcyBob3cgbG9uZyB0aGUgcmVzdWx0cyBvZiBhIHByZWZsaWdodCByZXF1ZXN0IGNhbiBiZSBjYWNoZWQuIFNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0FjY2Vzcy1Db250cm9sLU1heC1BZ2V9XG4gKi9cbnR5cGUgQ29yc09wdGlvbnNSZXNwb25zZUhlYWRlcnMgPSB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xuXG4vKipcbiAqIFR5cGUgZGVmaW5pdGlvbiBmb3IgQ09SUyBoZWFkZXJzIHdoaWNoIGluY2x1ZGVzIGRlZmF1bHQgYW5kIG9wdGlvbnMgaGVhZGVycy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb3JzSGVhZGVycyB7XG4gIC8qKlxuICAgKiBEZWZhdWx0IENPUlMgcmVzcG9uc2UgaGVhZGVycy5cbiAgICovXG4gIHJlYWRvbmx5IGRlZmF1bHRSZXNwb25zZTogQ29yc0RlZmF1bHRSZXNwb25zZUhlYWRlcnM7XG5cbiAgLyoqXG4gICAqIENPUlMgb3B0aW9ucyByZXNwb25zZSBoZWFkZXJzLlxuICAgKi9cbiAgcmVhZG9ubHkgb3B0aW9uc1Jlc3BvbnNlOiBDb3JzT3B0aW9uc1Jlc3BvbnNlSGVhZGVycztcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsaXR5IHNoYXJlZCBiZXR3ZWVuIGFsbCBgQXBpYCBpbXBsZW1lbnRhdGlvbnMuXG4gKiBAaW5mbGlnaHQgYEB3aW5nbGFuZy9zZGsuY2xvdWQuSUFwaUNsaWVudGBcbiAqIEBhYnN0cmFjdFxuICovXG5cbmV4cG9ydCBjbGFzcyBBcGkgZXh0ZW5kcyBSZXNvdXJjZSB7XG4gIC8qKlxuICAgKiBDb252ZXJ0cyBpbnB1dCBwYXRoIHRvIGEgdmFsaWQgT3BlbkFQSSBwYXRoIChyZXBsYWNlcyBgOmAgYmFzZWQgcGF0aCBwYXJhbXMgd2l0aCBge31gKVxuICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byBjb252ZXJ0IChhc3N1bWVzIHBhdGggaXMgdmFsaWQpXG4gICAqIEByZXR1cm5zIE9wZW5BUEkgcGF0aFxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZW5kZXJPcGVuQXBpUGF0aChwYXRoOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gcGF0aC5yZXBsYWNlKC9cXC86KFtBLVphLXowLTlfLV0rKS9nLCBcIi97JDF9XCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhbiBvYmplY3QgY29udGFpbmluZyBkZWZhdWx0IENPUlMgcmVzcG9uc2UgaGVhZGVycyBhbmQgT1BUSU9OUyByZXNwb25zZSBoZWFkZXJzLlxuICAgKiBAcGFyYW0gY29yc09wdGlvbnMgVGhlIENPUlMgb3B0aW9ucyB0byBnZW5lcmF0ZSB0aGUgaGVhZGVycyBmcm9tLlxuICAgKiBAcmV0dXJucyBBbiBvYmplY3QgY29udGFpbmluZyBkZWZhdWx0IENPUlMgcmVzcG9uc2UgaGVhZGVycyBhbmQgT1BUSU9OUyByZXNwb25zZSBoZWFkZXJzLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZW5kZXJDb3JzSGVhZGVycyhcbiAgICBjb3JzT3B0aW9ucz86IEFwaUNvcnNPcHRpb25zXG4gICk6IENvcnNIZWFkZXJzIHwgdW5kZWZpbmVkIHtcbiAgICBpZiAoY29yc09wdGlvbnMgPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgYWxsb3dPcmlnaW4gPSBcIipcIixcbiAgICAgIGFsbG93SGVhZGVycyA9IFtdLFxuICAgICAgYWxsb3dNZXRob2RzID0gW10sXG4gICAgICBleHBvc2VIZWFkZXJzID0gW10sXG4gICAgICBhbGxvd0NyZWRlbnRpYWxzID0gZmFsc2UsXG4gICAgICBtYXhBZ2UgPSBEdXJhdGlvbi5mcm9tTWludXRlcyg1KSxcbiAgICB9ID0gY29yc09wdGlvbnM7XG5cbiAgICBjb25zdCBkZWZhdWx0SGVhZGVyczogQ29yc0RlZmF1bHRSZXNwb25zZUhlYWRlcnMgPSB7XG4gICAgICBcIkFjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpblwiOiBhbGxvd09yaWdpbiB8fCBcIipcIixcbiAgICAgIFwiQWNjZXNzLUNvbnRyb2wtRXhwb3NlLUhlYWRlcnNcIjogZXhwb3NlSGVhZGVycy5qb2luKFwiLFwiKSB8fCBcIlwiLFxuICAgICAgXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1DcmVkZW50aWFsc1wiOiBhbGxvd0NyZWRlbnRpYWxzID8gXCJ0cnVlXCIgOiBcImZhbHNlXCIsXG4gICAgfTtcblxuICAgIGNvbnN0IG9wdGlvbnNIZWFkZXJzOiBDb3JzT3B0aW9uc1Jlc3BvbnNlSGVhZGVycyA9IHtcbiAgICAgIFwiQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luXCI6IGFsbG93T3JpZ2luIHx8IFwiKlwiLFxuICAgICAgXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1IZWFkZXJzXCI6IGFsbG93SGVhZGVycy5qb2luKFwiLFwiKSB8fCBcIlwiLFxuICAgICAgXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1NZXRob2RzXCI6IGFsbG93TWV0aG9kcy5qb2luKFwiLFwiKSB8fCBcIlwiLFxuICAgICAgXCJBY2Nlc3MtQ29udHJvbC1NYXgtQWdlXCI6IG1heEFnZS5zZWNvbmRzLnRvU3RyaW5nKCksXG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICBkZWZhdWx0UmVzcG9uc2U6IGRlZmF1bHRIZWFkZXJzLFxuICAgICAgb3B0aW9uc1Jlc3BvbnNlOiBvcHRpb25zSGVhZGVycyxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIFVSTCBvZiB0aGUgQVBJIGVuZHBvaW50LlxuICAgKi9cbiAgcHVibGljIGdldCB1cmwoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fZW5kcG9pbnQudXJsO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBFbmRwb2ludCBvZiB0aGUgQVBJLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0IF9lbmRwb2ludCgpOiBFbmRwb2ludCB7XG4gICAgdGhyb3cgbmV3IEFic3RyYWN0TWVtYmVyRXJyb3IoKTtcbiAgfVxuXG4gIC8vIGh0dHBzOi8vc3BlYy5vcGVuYXBpcy5vcmcvb2FzL3YzLjAuM1xuICBwcml2YXRlIGFwaVNwZWM6IGFueSA9IHtcbiAgICBwYXRoczoge30sXG4gIH07XG5cbiAgcHJpdmF0ZSBjb3JzRGVmYXVsdFZhbHVlczogQXBpQ29yc09wdGlvbnMgPSB7XG4gICAgYWxsb3dPcmlnaW46IFwiKlwiLFxuICAgIGFsbG93TWV0aG9kczogW1xuICAgICAgSHR0cE1ldGhvZC5HRVQsXG4gICAgICBIdHRwTWV0aG9kLlBPU1QsXG4gICAgICBIdHRwTWV0aG9kLlBVVCxcbiAgICAgIEh0dHBNZXRob2QuREVMRVRFLFxuICAgICAgSHR0cE1ldGhvZC5IRUFELFxuICAgICAgSHR0cE1ldGhvZC5PUFRJT05TLFxuICAgIF0sXG4gICAgYWxsb3dIZWFkZXJzOiBbXCJDb250ZW50LVR5cGVcIiwgXCJBdXRob3JpemF0aW9uXCIsIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiXSxcbiAgICBleHBvc2VIZWFkZXJzOiBbXSxcbiAgICBhbGxvd0NyZWRlbnRpYWxzOiBmYWxzZSxcbiAgICBtYXhBZ2U6IER1cmF0aW9uLmZyb21NaW51dGVzKDUpLFxuICB9O1xuXG4gIC8qKlxuICAgKiBDT1JTIG9wdGlvbnMgZm9yIGFwaVxuICAgKi9cbiAgcHJvdGVjdGVkIGNvcnNPcHRpb25zPzogQXBpQ29yc09wdGlvbnM7XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwdWJsaWMgW0lORkxJR0hUX1NZTUJPTF0/OiBJQXBpQ2xpZW50O1xuXG4gIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBBcGlQcm9wcyA9IHt9KSB7XG4gICAgaWYgKG5ldy50YXJnZXQgPT09IEFwaSkge1xuICAgICAgcmV0dXJuIFJlc291cmNlLl9uZXdGcm9tRmFjdG9yeShBUElfRlFOLCBzY29wZSwgaWQsIHByb3BzKTtcbiAgICB9XG5cbiAgICBzdXBlcihzY29wZSwgaWQpO1xuXG4gICAgdGhpcy5jb3JzT3B0aW9ucyA9IHByb3BzLmNvcnMgPyB0aGlzLl9jb3JzKHByb3BzLmNvcnNPcHRpb25zKSA6IHVuZGVmaW5lZDtcblxuICAgIE5vZGUub2YodGhpcykudGl0bGUgPSBcIkFwaVwiO1xuICAgIE5vZGUub2YodGhpcykuZGVzY3JpcHRpb24gPSBcIkEgUkVTVCBBUEkgZW5kcG9pbnRcIjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBpbmZsaWdodCBoYW5kbGVyIHRvIHRoZSBhcGkgZm9yIEdFVCByZXF1ZXN0cyBvbiB0aGUgZ2l2ZW4gcGF0aC5cbiAgICogQHBhcmFtIHBhdGggVGhlIHBhdGggdG8gaGFuZGxlIEdFVCByZXF1ZXN0cyBmb3IuXG4gICAqIEBwYXJhbSBpbmZsaWdodCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIHRoZSByZXF1ZXN0LlxuICAgKiBAcGFyYW0gcHJvcHMgT3B0aW9ucyBmb3IgdGhlIHJvdXRlLlxuICAgKiBAYWJzdHJhY3RcbiAgICovXG4gIHB1YmxpYyBnZXQoXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIGluZmxpZ2h0OiBJQXBpRW5kcG9pbnRIYW5kbGVyLFxuICAgIHByb3BzPzogQXBpR2V0T3B0aW9uc1xuICApOiB2b2lkIHtcbiAgICBwYXRoO1xuICAgIGluZmxpZ2h0O1xuICAgIHByb3BzO1xuICAgIHRocm93IG5ldyBBYnN0cmFjdE1lbWJlckVycm9yKCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgaW5mbGlnaHQgaGFuZGxlciB0byB0aGUgYXBpIGZvciBQT1NUIHJlcXVlc3RzIG9uIHRoZSBnaXZlbiBwYXRoLlxuICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byBoYW5kbGUgUE9TVCByZXF1ZXN0cyBmb3IuXG4gICAqIEBwYXJhbSBpbmZsaWdodCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIHRoZSByZXF1ZXN0LlxuICAgKiBAcGFyYW0gcHJvcHMgT3B0aW9ucyBmb3IgdGhlIHJvdXRlLlxuICAgKiBAYWJzdHJhY3RcbiAgICovXG4gIHB1YmxpYyBwb3N0KFxuICAgIHBhdGg6IHN0cmluZyxcbiAgICBpbmZsaWdodDogSUFwaUVuZHBvaW50SGFuZGxlcixcbiAgICBwcm9wcz86IEFwaVBvc3RPcHRpb25zXG4gICk6IHZvaWQge1xuICAgIHBhdGg7XG4gICAgaW5mbGlnaHQ7XG4gICAgcHJvcHM7XG4gICAgdGhyb3cgbmV3IEFic3RyYWN0TWVtYmVyRXJyb3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBpbmZsaWdodCBoYW5kbGVyIHRvIHRoZSBhcGkgZm9yIFBVVCByZXF1ZXN0cyBvbiB0aGUgZ2l2ZW4gcGF0aC5cbiAgICogQHBhcmFtIHBhdGggVGhlIHBhdGggdG8gaGFuZGxlIFBVVCByZXF1ZXN0cyBmb3IuXG4gICAqIEBwYXJhbSBpbmZsaWdodCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIHRoZSByZXF1ZXN0LlxuICAgKiBAcGFyYW0gcHJvcHMgT3B0aW9ucyBmb3IgdGhlIHJvdXRlLlxuICAgKiBAYWJzdHJhY3RcbiAgICovXG4gIHB1YmxpYyBwdXQoXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIGluZmxpZ2h0OiBJQXBpRW5kcG9pbnRIYW5kbGVyLFxuICAgIHByb3BzPzogQXBpUHV0T3B0aW9uc1xuICApOiB2b2lkIHtcbiAgICBwYXRoO1xuICAgIGluZmxpZ2h0O1xuICAgIHByb3BzO1xuICAgIHRocm93IG5ldyBBYnN0cmFjdE1lbWJlckVycm9yKCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgaW5mbGlnaHQgaGFuZGxlciB0byB0aGUgYXBpIGZvciBERUxFVEUgcmVxdWVzdHMgb24gdGhlIGdpdmVuIHBhdGguXG4gICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIHRvIGhhbmRsZSBERUxFVEUgcmVxdWVzdHMgZm9yLlxuICAgKiBAcGFyYW0gaW5mbGlnaHQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSB0aGUgcmVxdWVzdC5cbiAgICogQHBhcmFtIHByb3BzIE9wdGlvbnMgZm9yIHRoZSByb3V0ZS5cbiAgICogQGFic3RyYWN0XG4gICAqL1xuICBwdWJsaWMgZGVsZXRlKFxuICAgIHBhdGg6IHN0cmluZyxcbiAgICBpbmZsaWdodDogSUFwaUVuZHBvaW50SGFuZGxlcixcbiAgICBwcm9wcz86IEFwaURlbGV0ZU9wdGlvbnNcbiAgKTogdm9pZCB7XG4gICAgcGF0aDtcbiAgICBpbmZsaWdodDtcbiAgICBwcm9wcztcbiAgICB0aHJvdyBuZXcgQWJzdHJhY3RNZW1iZXJFcnJvcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIGluZmxpZ2h0IGhhbmRsZXIgdG8gdGhlIGFwaSBmb3IgUEFUQ0ggcmVxdWVzdHMgb24gdGhlIGdpdmVuIHBhdGguXG4gICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIHRvIGhhbmRsZSBQQVRDSCByZXF1ZXN0cyBmb3IuXG4gICAqIEBwYXJhbSBpbmZsaWdodCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIHRoZSByZXF1ZXN0LlxuICAgKiBAcGFyYW0gcHJvcHMgT3B0aW9ucyBmb3IgdGhlIHJvdXRlLlxuICAgKiBAYWJzdHJhY3RcbiAgICovXG4gIHB1YmxpYyBwYXRjaChcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgaW5mbGlnaHQ6IElBcGlFbmRwb2ludEhhbmRsZXIsXG4gICAgcHJvcHM/OiBBcGlQYXRjaE9wdGlvbnNcbiAgKTogdm9pZCB7XG4gICAgcGF0aDtcbiAgICBpbmZsaWdodDtcbiAgICBwcm9wcztcbiAgICB0aHJvdyBuZXcgQWJzdHJhY3RNZW1iZXJFcnJvcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIGluZmxpZ2h0IGhhbmRsZXIgdG8gdGhlIGFwaSBmb3IgT1BUSU9OUyByZXF1ZXN0cyBvbiB0aGUgZ2l2ZW4gcGF0aC5cbiAgICogQHBhcmFtIHBhdGggVGhlIHBhdGggdG8gaGFuZGxlIE9QVElPTlMgcmVxdWVzdHMgZm9yLlxuICAgKiBAcGFyYW0gaW5mbGlnaHQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSB0aGUgcmVxdWVzdC5cbiAgICogQHBhcmFtIHByb3BzIE9wdGlvbnMgZm9yIHRoZSByb3V0ZS5cbiAgICogQGFic3RyYWN0XG4gICAqL1xuICBwdWJsaWMgb3B0aW9ucyhcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgaW5mbGlnaHQ6IElBcGlFbmRwb2ludEhhbmRsZXIsXG4gICAgcHJvcHM/OiBBcGlPcHRpb25zT3B0aW9uc1xuICApOiB2b2lkIHtcbiAgICBwYXRoO1xuICAgIGluZmxpZ2h0O1xuICAgIHByb3BzO1xuICAgIHRocm93IG5ldyBBYnN0cmFjdE1lbWJlckVycm9yKCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgaW5mbGlnaHQgaGFuZGxlciB0byB0aGUgYXBpIGZvciBIRUFEIHJlcXVlc3RzIG9uIHRoZSBnaXZlbiBwYXRoLlxuICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byBoYW5kbGUgSEVBRCByZXF1ZXN0cyBmb3IuXG4gICAqIEBwYXJhbSBpbmZsaWdodCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIHRoZSByZXF1ZXN0LlxuICAgKiBAcGFyYW0gcHJvcHMgT3B0aW9ucyBmb3IgdGhlIHJvdXRlLlxuICAgKiBAYWJzdHJhY3RcbiAgICovXG4gIHB1YmxpYyBoZWFkKFxuICAgIHBhdGg6IHN0cmluZyxcbiAgICBpbmZsaWdodDogSUFwaUVuZHBvaW50SGFuZGxlcixcbiAgICBwcm9wcz86IEFwaUhlYWRPcHRpb25zXG4gICk6IHZvaWQge1xuICAgIHBhdGg7XG4gICAgaW5mbGlnaHQ7XG4gICAgcHJvcHM7XG4gICAgdGhyb3cgbmV3IEFic3RyYWN0TWVtYmVyRXJyb3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBpbmZsaWdodCBoYW5kbGVyIHRvIHRoZSBhcGkgZm9yIENPTk5FQ1QgcmVxdWVzdHMgb24gdGhlIGdpdmVuIHBhdGguXG4gICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIHRvIGhhbmRsZSBDT05ORUNUIHJlcXVlc3RzIGZvci5cbiAgICogQHBhcmFtIGluZmxpZ2h0IFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgdGhlIHJlcXVlc3QuXG4gICAqIEBwYXJhbSBwcm9wcyBPcHRpb25zIGZvciB0aGUgcm91dGUuXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cbiAgcHVibGljIGNvbm5lY3QoXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIGluZmxpZ2h0OiBJQXBpRW5kcG9pbnRIYW5kbGVyLFxuICAgIHByb3BzPzogQXBpQ29ubmVjdE9wdGlvbnNcbiAgKTogdm9pZCB7XG4gICAgcGF0aDtcbiAgICBpbmZsaWdodDtcbiAgICBwcm9wcztcbiAgICB0aHJvdyBuZXcgQWJzdHJhY3RNZW1iZXJFcnJvcigpO1xuICB9XG4gIC8qKlxuICAgKiBWYWxpZGF0aW5nIHBhdGg6XG4gICAqIGlmIGhhcyBgOmAgcHJlZml4IC0gdGhlIHBhcnQgZm9sbG93aW5nIHRoYXQgcHJlZml4IGlzIG9ubHkgbGV0dGVyLCBkaWdpdCBvciBfLCBub3QgZW1wdHkgYW5kIHBsYWNlZCBiZWZvcmUgYW5kIGFmdGVyIFwiL1wiXG4gICAqIEBwYXJhbSBwYXRoXG4gICAqIEB0aHJvd3MgaWYgdGhlIHBhdGggaXMgaW52YWxpZFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByb3RlY3RlZCBfdmFsaWRhdGVQYXRoKHBhdGg6IHN0cmluZykge1xuICAgIGlmIChcbiAgICAgICEvXigoXFwvXFw6W2EtekEtWjAtOV9cXC1dK3xcXC9bYS16QS1aMC05X1xcLVxcLl0qKSooPzpcXD9bXiNdKik/KT8kL2cudGVzdChwYXRoKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW52YWxpZCBwYXRoICR7cGF0aH0uIFVybCBwYXJ0cyBjYW4gb25seSBjb250YWluIGFscGhhLW51bWVyaWMgY2hhcnMsIFwiLVwiLCBcIl9cIiBhbmQgXCIuXCIuIFBhcmFtcyBjYW4gb25seSBjb250YWluIGFscGhhLW51bWVyaWMgY2hhcnMgYW5kIFwiX1wiLmBcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgQ09SUyBjb25maWd1cmF0aW9uLiBJZiBwcm9wcyBhcmUgcHJvdmlkZWQsIHRoZXkgd2lsbCBoYXZlIHByZWNlZGVuY2Ugb3ZlciBkZWZhdWx0cy5cbiAgICogQHBhcmFtIHByb3BzXG4gICAqIEByZXR1cm5zIEFwaUNvcnNPcHRpb25zXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJvdGVjdGVkIF9jb3JzKHByb3BzPzogQXBpQ29yc09wdGlvbnMpOiBBcGlDb3JzT3B0aW9ucyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnRoaXMuY29yc0RlZmF1bHRWYWx1ZXMsXG4gICAgICAuLi5wcm9wcyxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0d28gZ2l2ZW4gcGF0aHMgYXJlIHNpYmxpbmdzLlxuICAgKiBAcGFyYW0gcGF0aEFcbiAgICogQHBhcmFtIHBhdGhCXG4gICAqIEByZXR1cm5zIEEgYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIGlmIHByb3ZpZGVkIHBhdGhzIGFyZSBzaWJsaW5ncy5cbiAgICogQGludGVybmFsXG4gICAqL1xuXG4gIHByb3RlY3RlZCBfYXJlUGF0aHNTaWJsaW5ncyhwYXRoQTogc3RyaW5nLCBwYXRoQjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgY29uc3QgcGFydHNBID0gcGF0aEEuc3BsaXQoXCIvXCIpO1xuICAgIGNvbnN0IHBhcnRzQiA9IHBhdGhCLnNwbGl0KFwiL1wiKTtcblxuICAgIGxldCBzaG9ydGVyID0gcGFydHNBLmxlbmd0aCA8IHBhcnRzQi5sZW5ndGggPyBwYXJ0c0EgOiBwYXJ0c0I7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNob3J0ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBhcnRBID0gcGFydHNBW2ldO1xuICAgICAgY29uc3QgcGFydEIgPSBwYXJ0c0JbaV07XG4gICAgICBpZiAoXG4gICAgICAgICghcGFydEEubWF0Y2goL146Lis/JC8pIHx8ICFwYXJ0Qi5tYXRjaCgvXjouKz8kLykpICYmXG4gICAgICAgIHBhcnRBW2ldICE9PSBwYXJ0QltpXVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICBwYXJ0QS5tYXRjaCgvXjouKz8kLykgJiZcbiAgICAgICAgcGFydEIubWF0Y2goL146Lis/JC8pICYmXG4gICAgICAgIHBhcnRBW2ldICE9PSBwYXJ0QltpXVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdHdvIGdpdmVuIHBhdGhzIGFyZSBhbWJpZ3VvdXMuXG4gICAqIEBwYXJhbSBwYXRoQVxuICAgKiBAcGFyYW0gcGF0aEJcbiAgICogQHJldHVybnMgQSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgaWYgcHJvdmlkZWQgcGF0aHMgYXJlIGFtYmlndW91cy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcm90ZWN0ZWQgX2FyZVBhdGhzQW1iaWd1b3VzKHBhdGhBOiBzdHJpbmcsIHBhdGhCOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCBwYXJ0c0EgPSBwYXRoQS5zcGxpdChcIi9cIik7XG4gICAgY29uc3QgcGFydHNCID0gcGF0aEIuc3BsaXQoXCIvXCIpO1xuXG4gICAgaWYgKHBhcnRzQS5sZW5ndGggIT09IHBhcnRzQi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzQS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcGFydEEgPSBwYXJ0c0FbaV07XG4gICAgICBjb25zdCBwYXJ0QiA9IHBhcnRzQltpXTtcblxuICAgICAgaWYgKHBhcnRBICE9PSBwYXJ0QiAmJiAhcGFydEEubWF0Y2goL146Lis/JC8pICYmICFwYXJ0Qi5tYXRjaCgvXjouKz8kLykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBwcm92aWRlZCBwYXRoIGFuZCBtZXRob2QgYXJlIGFtYmlnb3VzIHdpdGggcGF0aHMgYW5kIG1ldGhvZHMgYWxyZWFkeSBkZWZpbmVkIGluIHRoZSBhcGkgc3BlYy5cbiAgICogQHBhcmFtIHBhdGggUGF0aCB0byBiZSBjaGVja2VkXG4gICAqIEBwYXJhbSBtZXRob2QgSFRUUCBtZXRob2RcbiAgICogQHJldHVybnMgQSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgaWYgcHJvdmlkZWQgcGF0aCBhbmQgbWV0aG9kIGFyZSBhbWJpZ3VvdXMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJvdGVjdGVkIF9maW5kQW1iaWd1b3VzUGF0aChcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgbWV0aG9kOiBzdHJpbmdcbiAgKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBleGlzdGluZ1BhdGhzID0gT2JqZWN0LmtleXModGhpcy5hcGlTcGVjLnBhdGhzKTtcblxuICAgIHJldHVybiBleGlzdGluZ1BhdGhzLmZpbmQoXG4gICAgICAoZXhpc3RpbmdQYXRoKSA9PlxuICAgICAgICAhIXRoaXMuYXBpU3BlYy5wYXRoc1tleGlzdGluZ1BhdGhdW21ldGhvZC50b0xvd2VyQ2FzZSgpXSAmJlxuICAgICAgICB0aGlzLl9hcmVQYXRoc0FtYmlndW91cyhleGlzdGluZ1BhdGgsIHBhdGgpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgcHJvdmlkZWQgcGF0aCBpcyBhIHNpYmxpbmcgb2YgcGF0aHMgYWxyZWFkeSBkZWZpbmVkIGluIHRoZSBhcGkgc3BlYy0gaS5lIFwiLzp1c2VybmFtZVwiIGFuZCBcIi86aWRcIi5cbiAgICogQHBhcmFtIHBhdGggUGF0aCB0byBiZSBjaGVja2VkXG4gICAqIEByZXR1cm5zIEEgYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIGlmIHByb3ZpZGVkIHBhdGggaGFzIGEgc2libGluZy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcml2YXRlIF9maW5kU2libGluZ1BhdGgocGF0aDogc3RyaW5nKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBleGlzdGluZ1BhdGhzID0gT2JqZWN0LmtleXModGhpcy5hcGlTcGVjLnBhdGhzKTtcblxuICAgIHJldHVybiBleGlzdGluZ1BhdGhzLmZpbmQoKGV4aXN0aW5nUGF0aCkgPT5cbiAgICAgIHRoaXMuX2FyZVBhdGhzU2libGluZ3MoZXhpc3RpbmdQYXRoLCBwYXRoKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIHRoZSBPcGVuQVBJIHNjaGVtYSBmb3IgQ09SUyBoZWFkZXJzIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBDT1JTIG9wdGlvbnMuXG4gICAqIEBwYXJhbSBjb3JzT3B0aW9ucyBUaGUgQ09SUyBvcHRpb25zIHRvIGdlbmVyYXRlIHRoZSBzY2hlbWEgZnJvbS5cbiAgICogQHJldHVybnMgQW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgT3BlbkFQSSBzY2hlbWEgZm9yIENPUlMgaGVhZGVycy5cbiAgICovXG4gIHByaXZhdGUgX2NvcnNPcGVuQXBpU2NoZW1hKGNvcnNPcHRpb25zPzogQXBpQ29yc09wdGlvbnMpOiBPcGVuQXBpQ29yc0hlYWRlcnMge1xuICAgIGNvbnN0IGNvcnNIZWFkZXJzOiBPcGVuQXBpQ29yc0hlYWRlcnMgPSB7fTtcbiAgICBpZiAoY29yc09wdGlvbnMpIHtcbiAgICAgIGNvbnN0IGNvcnNIZWFkZXJTY2hlbWEgPSB7XG4gICAgICAgIHNjaGVtYToge1xuICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgICAgY29yc0hlYWRlcnNbXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW5cIl0gPSBjb3JzSGVhZGVyU2NoZW1hO1xuICAgICAgY29yc0hlYWRlcnNbXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1NZXRob2RzXCJdID0gY29yc0hlYWRlclNjaGVtYTtcbiAgICAgIGNvcnNIZWFkZXJzW1wiQWNjZXNzLUNvbnRyb2wtQWxsb3ctSGVhZGVyc1wiXSA9IGNvcnNIZWFkZXJTY2hlbWE7XG4gICAgICBjb3JzSGVhZGVyc1tcIkFjY2Vzcy1Db250cm9sLU1heC1BZ2VcIl0gPSBjb3JzSGVhZGVyU2NoZW1hO1xuICAgIH1cbiAgICByZXR1cm4gY29yc0hlYWRlcnM7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgcm91dGUgdG8gdGhlIGFwaSBzcGVjLlxuICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byBhZGQuXG4gICAqIEBwYXJhbSBtZXRob2QgVGhlIG1ldGhvZCB0byBhZGQuXG4gICAqIEBwYXJhbSBhcGlTcGVjRXh0ZW5zaW9uIFRoZSBleHRlbnNpb24gdG8gYWRkIHRvIHRoZSBhcGkgc3BlYyBmb3IgdGhpcyByb3V0ZSBhbmQgbWV0aG9kLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICogKi9cbiAgcHVibGljIF9hZGRUb1NwZWMoXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIG1ldGhvZDogc3RyaW5nLFxuICAgIGFwaVNwZWNFeHRlbnNpb246IE9wZW5BcGlTcGVjRXh0ZW5zaW9uLFxuICAgIGNvcnNPcHRpb25zPzogQXBpQ29yc09wdGlvbnNcbiAgKSB7XG4gICAgaWYgKHRoaXMuYXBpU3BlYy5wYXRoc1twYXRoXT8uW21ldGhvZC50b0xvd2VyQ2FzZSgpXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRW5kcG9pbnQgZm9yIHBhdGggJyR7cGF0aH0nIGFuZCBtZXRob2QgJyR7bWV0aG9kfScgYWxyZWFkeSBleGlzdHNgXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBhbWJpZ3VvdXNQYXRoID0gdGhpcy5fZmluZEFtYmlndW91c1BhdGgocGF0aCwgbWV0aG9kKTtcbiAgICBpZiAoISFhbWJpZ3VvdXNQYXRoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBFbmRwb2ludCBmb3IgcGF0aCAnJHtwYXRofScgYW5kIG1ldGhvZCAnJHttZXRob2R9JyBpcyBhbWJpZ3VvdXMgLSBpdCBjb25mbGljdHMgd2l0aCBleGlzdGluZyBlbmRwb2ludCBmb3IgcGF0aCAnJHthbWJpZ3VvdXNQYXRofSdgXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBzaWJsaW5nUGF0aCA9IHRoaXMuX2ZpbmRTaWJsaW5nUGF0aChwYXRoKTtcbiAgICBpZiAoISFzaWJsaW5nUGF0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRW5kcG9pbnQgZm9yIHBhdGggJyR7cGF0aH0nIGFuZCBtZXRob2QgJyR7bWV0aG9kfScgY29uZmxpY3RzIHdpdGggZXhpc3Rpbmcgc2libGluZyBlbmRwb2ludCBmb3IgcGF0aCAnJHtzaWJsaW5nUGF0aH0nLSB0cnkgdG8gbWF0Y2ggdGhlIHBhcmFtZXRlciBuYW1lcyB0byBhdm9pZCB0aGlzIGVycm9yLmBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IG9wZXJhdGlvbklkID0gYCR7bWV0aG9kLnRvTG93ZXJDYXNlKCl9JHtcbiAgICAgIHBhdGggPT09IFwiL1wiID8gXCJcIiA6IHBhdGgucmVwbGFjZShcIi9cIiwgXCItXCIpXG4gICAgfWA7XG4gICAgY29uc3QgcGF0aFBhcmFtcyA9IHBhdGgubWF0Y2goLzooW0EtWmEtejAtOV8tXSspL2cpO1xuICAgIGNvbnN0IHBhdGhQYXJhbWV0ZXJzOiBhbnlbXSA9IFtdO1xuICAgIGlmIChwYXRoUGFyYW1zKSB7XG4gICAgICBwYXRoUGFyYW1zLmZvckVhY2goKHBhcmFtKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhcmFtTmFtZSA9IHBhcmFtLnJlcGxhY2UoXCI6XCIsIFwiXCIpO1xuICAgICAgICBwYXRoUGFyYW1ldGVycy5wdXNoKHtcbiAgICAgICAgICBuYW1lOiBwYXJhbU5hbWUsXG4gICAgICAgICAgaW46IFwicGF0aFwiLFxuICAgICAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgICAgIHNjaGVtYToge1xuICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBjb3JzT3BlbkFwaVNjaGVtYSA9IHRoaXMuX2NvcnNPcGVuQXBpU2NoZW1hKGNvcnNPcHRpb25zKTtcbiAgICBjb25zdCBtZXRob2RTcGVjID0ge1xuICAgICAgW21ldGhvZC50b0xvd2VyQ2FzZSgpXToge1xuICAgICAgICBvcGVyYXRpb25JZDogb3BlcmF0aW9uSWQsXG4gICAgICAgIHJlc3BvbnNlczoge1xuICAgICAgICAgIFwiMjAwXCI6IHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIjIwMCByZXNwb25zZVwiLFxuICAgICAgICAgICAgY29udGVudDoge30sXG4gICAgICAgICAgICAuLi4oT2JqZWN0LmtleXMoY29yc09wZW5BcGlTY2hlbWEpLmxlbmd0aCA+IDBcbiAgICAgICAgICAgICAgPyB7IGhlYWRlcnM6IGNvcnNPcGVuQXBpU2NoZW1hIH1cbiAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgcGFyYW1ldGVyczogcGF0aFBhcmFtZXRlcnMsXG4gICAgICAgIC4uLmFwaVNwZWNFeHRlbnNpb24sXG4gICAgICB9LFxuICAgIH07XG4gICAgdGhpcy5hcGlTcGVjLnBhdGhzW3BhdGhdID0ge1xuICAgICAgLi4udGhpcy5hcGlTcGVjLnBhdGhzW3BhdGhdLFxuICAgICAgLi4ubWV0aG9kU3BlYyxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgT3BlbkFQSSBzcGVjIGZvciB0aGlzIEFwaS5cbiAgICogQGludGVybmFsICovXG4gIHB1YmxpYyBfZ2V0T3BlbkFwaVNwZWMoKTogT3BlbkFwaVNwZWMge1xuICAgIC8vIENvbnZlcnQgb3VyIHBhdGhzIHRvIHZhbGlkIE9wZW5BUEkgcGF0aHNcbiAgICBsZXQgcGF0aHM6IHsgW2tleTogc3RyaW5nXTogYW55IH0gPSB7fTtcbiAgICBPYmplY3Qua2V5cyh0aGlzLmFwaVNwZWMucGF0aHMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgcGF0aHNbQXBpLnJlbmRlck9wZW5BcGlQYXRoKGtleSldID0gdGhpcy5hcGlTcGVjLnBhdGhzW2tleV07XG4gICAgfSk7XG5cbiAgICAvLyBodHRwczovL3NwZWMub3BlbmFwaXMub3JnL29hcy92My4wLjNcbiAgICByZXR1cm4ge1xuICAgICAgLi4udGhpcy5hcGlTcGVjLFxuICAgICAgb3BlbmFwaTogXCIzLjAuM1wiLFxuICAgICAgcGF0aHM6IHBhdGhzLFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBCYXNlIG9wdGlvbnMgZm9yIEFwaSBlbmRwb2ludHMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQXBpRW5kcG9pbnRPcHRpb25zIGV4dGVuZHMgRnVuY3Rpb25Qcm9wcyB7fVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIEFwaSBnZXQgZW5kcG9pbnQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQXBpR2V0T3B0aW9ucyBleHRlbmRzIEFwaUVuZHBvaW50T3B0aW9ucyB7fVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIEFwaSBwb3N0IGVuZHBvaW50LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEFwaVBvc3RPcHRpb25zIGV4dGVuZHMgQXBpRW5kcG9pbnRPcHRpb25zIHt9XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgQXBpIHB1dCBlbmRwb2ludC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBcGlQdXRPcHRpb25zIGV4dGVuZHMgQXBpRW5kcG9pbnRPcHRpb25zIHt9XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgQXBpIHB1dCBlbmRwb2ludC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBcGlEZWxldGVPcHRpb25zIGV4dGVuZHMgQXBpRW5kcG9pbnRPcHRpb25zIHt9XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgQXBpIHBhdGNoIGVuZHBvaW50LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEFwaVBhdGNoT3B0aW9ucyBleHRlbmRzIEFwaUVuZHBvaW50T3B0aW9ucyB7fVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIEFwaSBwYXRjaCBlbmRwb2ludC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBcGlPcHRpb25zT3B0aW9ucyBleHRlbmRzIEFwaUVuZHBvaW50T3B0aW9ucyB7fVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIEFwaSBwYXRjaCBlbmRwb2ludC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBcGlIZWFkT3B0aW9ucyBleHRlbmRzIEFwaUVuZHBvaW50T3B0aW9ucyB7fVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIEFwaSBwYXRjaCBlbmRwb2ludC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBcGlDb25uZWN0T3B0aW9ucyBleHRlbmRzIEFwaUVuZHBvaW50T3B0aW9ucyB7fVxuXG4vKipcbiAqIEluZmxpZ2h0IG1ldGhvZHMgYW5kIG1lbWJlcnMgb2YgYGNsb3VkLkFwaWAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSUFwaUNsaWVudCB7fVxuXG4vKipcbiAqIExpc3Qgb2YgaW5mbGlnaHQgb3BlcmF0aW9ucyBhdmFpbGFibGUgZm9yIGBBcGlgLlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBlbnVtIEFwaUluZmxpZ2h0TWV0aG9kcyB7XG4gIC8qKiBXaGVuIHRoZSBBUEkgZW5kcG9pbnQgcmVjZWl2ZXMgYSByZXF1ZXN0LiAqL1xuICBSRVFVRVNUID0gXCJyZXF1ZXN0XCIsXG59XG5cbi8qKlxuICogQWxsb3dlZCBIVFRQIG1ldGhvZHMgZm9yIGEgZW5kcG9pbnQuXG4gKi9cbmV4cG9ydCBlbnVtIEh0dHBNZXRob2Qge1xuICAvKiogR2V0ICovXG4gIEdFVCA9IFwiR0VUXCIsXG4gIC8qKiBIZWFkICovXG4gIEhFQUQgPSBcIkhFQURcIixcbiAgLyoqIFBvc3QgKi9cbiAgUE9TVCA9IFwiUE9TVFwiLFxuICAvKiogUHV0ICovXG4gIFBVVCA9IFwiUFVUXCIsXG4gIC8qKiBEZWxldGUgKi9cbiAgREVMRVRFID0gXCJERUxFVEVcIixcbiAgLyoqIENvbm5lY3QgKi9cbiAgQ09OTkVDVCA9IFwiQ09OTkVDVFwiLFxuICAvKiogT3B0aW9ucyAqL1xuICBPUFRJT05TID0gXCJPUFRJT05TXCIsXG4gIC8qKiBQYXRjaCAqL1xuICBQQVRDSCA9IFwiUEFUQ0hcIixcbn1cblxuLyoqXG4gKiBTaGFwZSBvZiBhIHJlcXVlc3QgdG8gYW4gaW5mbGlnaHQgaGFuZGxlci5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBcGlSZXF1ZXN0IHtcbiAgLyoqIFRoZSByZXF1ZXN0J3MgSFRUUCBtZXRob2QuICovXG4gIHJlYWRvbmx5IG1ldGhvZDogSHR0cE1ldGhvZDtcbiAgLyoqIFRoZSByZXF1ZXN0J3MgcGF0aC4gKi9cbiAgcmVhZG9ubHkgcGF0aDogc3RyaW5nO1xuICAvKiogVGhlIHJlcXVlc3QncyBxdWVyeSBzdHJpbmcgdmFsdWVzLiAqL1xuICByZWFkb25seSBxdWVyeTogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgLyoqIFRoZSBwYXRoIHZhcmlhYmxlcy4gKi9cbiAgcmVhZG9ubHkgdmFyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgLyoqIFRoZSByZXF1ZXN0J3MgYm9keS4gKi9cbiAgcmVhZG9ubHkgYm9keT86IHN0cmluZztcbiAgLyoqIFRoZSByZXF1ZXN0J3MgaGVhZGVycy4gKi9cbiAgcmVhZG9ubHkgaGVhZGVycz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG59XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX1JFU1BPTlNFX1NUQVRVUyA9IDIwMDtcblxuLyoqXG4gKiBTaGFwZSBvZiBhIHJlc3BvbnNlIGZyb20gYSBpbmZsaWdodCBoYW5kbGVyLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEFwaVJlc3BvbnNlIHtcbiAgLyoqXG4gICAqIFRoZSByZXNwb25zZSdzIHN0YXR1cyBjb2RlLlxuICAgKiBAZGVmYXVsdCAyMDBcbiAgICoqL1xuICByZWFkb25seSBzdGF0dXM/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSByZXNwb25zZSdzIGJvZHkuXG4gICAqIEBkZWZhdWx0IC0gbm8gYm9keVxuICAgKiovXG4gIHJlYWRvbmx5IGJvZHk/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgcmVzcG9uc2UncyBoZWFkZXJzLlxuICAgKiBAZGVmYXVsdCB7fVxuICAgKiovXG4gIHJlYWRvbmx5IGhlYWRlcnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xufVxuXG4vKipcbiAqIEEgcmVzb3VyY2Ugd2l0aCBhbiBpbmZsaWdodCBcImhhbmRsZVwiIG1ldGhvZCB0aGF0IGNhbiBiZSBwYXNzZWQgdG9cbiAqIG9uZSBvZiB0aGUgYEFwaWAgcmVxdWVzdCBwcmVmbGlnaHQgbWV0aG9kcy5cbiAqXG4gKiBAaW5mbGlnaHQgYEB3aW5nbGFuZy9zZGsuY2xvdWQuSUFwaUVuZHBvaW50SGFuZGxlckNsaWVudGBcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJQXBpRW5kcG9pbnRIYW5kbGVyIGV4dGVuZHMgSUluZmxpZ2h0IHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBbSU5GTElHSFRfU1lNQk9MXT86IElBcGlFbmRwb2ludEhhbmRsZXJDbGllbnRbXCJoYW5kbGVcIl07XG59XG5cbi8qKlxuICogSW5mbGlnaHQgY2xpZW50IGZvciBgSUFwaUVuZHBvaW50SGFuZGxlcmAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSUFwaUVuZHBvaW50SGFuZGxlckNsaWVudCB7XG4gIC8qKlxuICAgKiBJbmZsaWdodCB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gYSByZXF1ZXN0IGlzIG1hZGUgdG8gdGhlIGVuZHBvaW50LlxuICAgKiBAaW5mbGlnaHRcbiAgICovXG4gIGhhbmRsZShyZXF1ZXN0OiBBcGlSZXF1ZXN0KTogUHJvbWlzZTxBcGlSZXNwb25zZSB8IHVuZGVmaW5lZD47XG59XG5cbi8qKlxuICogUGFyc2UgYW4gSFRUUCBtZXRob2Qgc3RyaW5nIHRvIGFuIEh0dHBNZXRob2QgZW51bVxuICogQHBhcmFtIG1ldGhvZCBIVFRQIG1ldGhvZCBzdHJpbmdcbiAqIEByZXR1cm5zIEh0dHBNZXRob2QgZW51bVxuICogQHRocm93cyBFcnJvciBpZiB0aGUgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSHR0cE1ldGhvZChtZXRob2Q6IHN0cmluZyk6IEh0dHBNZXRob2Qge1xuICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgIGNhc2UgXCJHRVRcIjpcbiAgICAgIHJldHVybiBIdHRwTWV0aG9kLkdFVDtcbiAgICBjYXNlIFwiUE9TVFwiOlxuICAgICAgcmV0dXJuIEh0dHBNZXRob2QuUE9TVDtcbiAgICBjYXNlIFwiUFVUXCI6XG4gICAgICByZXR1cm4gSHR0cE1ldGhvZC5QVVQ7XG4gICAgY2FzZSBcIkhFQURcIjpcbiAgICAgIHJldHVybiBIdHRwTWV0aG9kLkhFQUQ7XG4gICAgY2FzZSBcIkRFTEVURVwiOlxuICAgICAgcmV0dXJuIEh0dHBNZXRob2QuREVMRVRFO1xuICAgIGNhc2UgXCJDT05ORUNUXCI6XG4gICAgICByZXR1cm4gSHR0cE1ldGhvZC5DT05ORUNUO1xuICAgIGNhc2UgXCJPUFRJT05TXCI6XG4gICAgICByZXR1cm4gSHR0cE1ldGhvZC5PUFRJT05TO1xuICAgIGNhc2UgXCJQQVRDSFwiOlxuICAgICAgcmV0dXJuIEh0dHBNZXRob2QuUEFUQ0g7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgSFRUUCBtZXRob2Q6ICR7bWV0aG9kfWApO1xuICB9XG59XG5cbi8qKlxuICogQ29udmVydCBhbiBvYmplY3Qgd2l0aCBtdWx0aS12YWx1ZWQgcGFyYW1ldGVycyB0byBhIGFuIG9iamVjdCB3aXRoXG4gKiBzaW5nbGUtdmFsdWVkIHBhcmFtZXRlcnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYW5pdGl6ZVBhcmFtTGlrZU9iamVjdChcbiAgb2JqOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBzdHJpbmdbXSB8IHVuZGVmaW5lZD5cbikge1xuICBjb25zdCBuZXdPYmo6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcbiAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IG9ialtrZXldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgbmV3T2JqW2tleV0gPSB2YWx1ZS5qb2luKFwiLFwiKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgbmV3T2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbmV3T2JqO1xufVxuIl19