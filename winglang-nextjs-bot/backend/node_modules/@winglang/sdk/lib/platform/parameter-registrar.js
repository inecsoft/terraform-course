"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveValueFromPath = exports.ParameterRegistrar = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const ajv_1 = __importDefault(require("ajv"));
const constructs_1 = require("constructs");
const util_1 = require("./util");
const std_1 = require("../std");
/**
 * Parameter Registrar
 *
 * This class is used to register and lookup parameter values.
 */
class ParameterRegistrar extends constructs_1.Construct {
    constructor(scope, id) {
        super(scope, id);
        /** Cache for parameter lookups */
        this.parameterValueByPath = {};
        /** List of all registered parameter schemas */
        this.parameterSchemas = [];
        /** @internal */
        this._rawParameters = (0, util_1.loadPlatformSpecificValues)();
        std_1.Node.of(this).hidden = true;
    }
    /**
     * Retrieve a parameter value by its path
     *
     * @param path the path of the parameter
     * @returns the value of the parameter
     */
    value(path) {
        if (this.parameterValueByPath[path] === undefined) {
            // attempt to read the value from the raw parameters, then cache it
            this.parameterValueByPath[path] = resolveValueFromPath(this._rawParameters, path);
        }
        return this.parameterValueByPath[path];
    }
    /**
     * Read parameters
     *
     * @param options options for reading parameters
     * @returns the schema as a string
     */
    read(options) {
        if (options?.schema) {
            this.addSchema(options.schema);
            const fields = (0, util_1.extractFieldsFromSchema)(options.schema._rawSchema // If a JsonSchema object is passed in, extract raw schema from it
                ? options.schema._rawSchema
                : options.schema);
            return (0, util_1.filterParametersBySchema)(fields, this._rawParameters);
        }
        return this._rawParameters;
    }
    /**
     * Add parameter schema to registrar
     *
     * @param schema schema to add to the registrar
     */
    addSchema(schema) {
        // If a JsonSchema object is passed in, extract the raw schema from it
        const schemaToAdd = schema._rawSchema ? schema._rawSchema : schema;
        if (!this.parameterSchemas.includes(schemaToAdd)) {
            this.parameterSchemas.push(schemaToAdd);
        }
    }
    /**
     * Helper method to add a parameter schema at a given path.
     * This method will nest the schema under the given path, making it easier to nest schemas.
     *
     * @param schema the schema to add
     * @param path the path to nest the schema under
     * @param recursiveRequire whether or not to require all the nested properties
     */
    addSchemaAtPath(schema, path, recursiveRequire = false) {
        this.addSchema(this._nestSchemaUnderPath(schema, path, recursiveRequire));
    }
    /**
     * This is a helper method to nest a schema under a path.
     *
     * I.E. if you have a json schema that looks like this:
     * { type: "object", properties: { foo: { type: "string" } } }
     *
     * And we want to nest it under the path "bar/baz", then this method will return:
     * { type: "object", properties: { bar: { type: "object", properties: { baz: { type: "object", properties: { foo: { type: "string" } } } } } } }
     *
     * making it easier to nest schemas under paths, without writing out the object boilerplate.
     *
     * @internal
     */
    _nestSchemaUnderPath(schema, path, recursiveRequire = false) {
        const parts = path.split("/");
        if (parts.length === 0 || path === "") {
            // base case just return the schema
            return schema;
        }
        const currentKey = parts[0];
        // Create and return the schema
        return {
            type: "object",
            properties: {
                // recurse for the next part of the path
                [currentKey]: this._nestSchemaUnderPath(schema, parts.slice(1).join("/"), recursiveRequire),
            },
            required: recursiveRequire ? [currentKey] : [],
        };
    }
    /**
     * @internal
     */
    _preSynthesize() {
        if (this.parameterSchemas.length === 0) {
            return;
        }
        const platformParameterSchema = {
            allOf: [...this.parameterSchemas],
        };
        const ajv = new ajv_1.default({ allErrors: true });
        const validator = ajv.compile(platformParameterSchema);
        const valid = validator(this._rawParameters);
        if (!valid) {
            throw new Error(`Parameter validation errors:\n- ${validator.errors
                ?.map((error) => error.message)
                .join("\n- ")}

(hint: make sure to use --values to provide the required parameters file)
        `);
        }
    }
}
exports.ParameterRegistrar = ParameterRegistrar;
_a = JSII_RTTI_SYMBOL_1;
ParameterRegistrar[_a] = { fqn: "@winglang/sdk.platform.ParameterRegistrar", version: "0.0.0" };
/**
 * Retrieves a value from an object using a given path
 *
 * @param rawParameters the object to retrieve the value from
 * @param path the path to the value (I.E. "foo/bar/baz")
 * @internal
 */
function resolveValueFromPath(rawParameters, path) {
    if (!rawParameters) {
        return undefined;
    }
    const pathParts = path.split("/");
    if (pathParts.length === 1) {
        return rawParameters[pathParts[0]];
    }
    // recurse
    const nextPath = pathParts.slice(1).join("/");
    return resolveValueFromPath(rawParameters[pathParts[0]], nextPath);
}
exports.resolveValueFromPath = resolveValueFromPath;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFyYW1ldGVyLXJlZ2lzdHJhci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wbGF0Zm9ybS9wYXJhbWV0ZXItcmVnaXN0cmFyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUEsOENBQXNCO0FBQ3RCLDJDQUF1QztBQUN2QyxpQ0FJZ0I7QUFDaEIsZ0NBQW9DO0FBVXBDOzs7O0dBSUc7QUFDSCxNQUFhLGtCQUFtQixTQUFRLHNCQUFTO0lBVS9DLFlBQVksS0FBZ0IsRUFBRSxFQUFVO1FBQ3RDLEtBQUssQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFWbkIsa0NBQWtDO1FBQzFCLHlCQUFvQixHQUEyQixFQUFFLENBQUM7UUFDMUQsK0NBQStDO1FBQ3ZDLHFCQUFnQixHQUFVLEVBQUUsQ0FBQztRQUVyQyxnQkFBZ0I7UUFDQSxtQkFBYyxHQUM1QixJQUFBLGlDQUEwQixHQUFFLENBQUM7UUFJN0IsVUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDO0lBQzlCLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNJLEtBQUssQ0FBQyxJQUFZO1FBQ3ZCLElBQUksSUFBSSxDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxLQUFLLFNBQVMsRUFBRSxDQUFDO1lBQ2xELG1FQUFtRTtZQUNuRSxJQUFJLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLEdBQUcsb0JBQW9CLENBQ3BELElBQUksQ0FBQyxjQUFjLEVBQ25CLElBQUksQ0FDTCxDQUFDO1FBQ0osQ0FBQztRQUVELE9BQU8sSUFBSSxDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3pDLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNJLElBQUksQ0FBQyxPQUE4QjtRQUN4QyxJQUFJLE9BQU8sRUFBRSxNQUFNLEVBQUUsQ0FBQztZQUNwQixJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENB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QUFFLEVBQUUsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDO2lCQUNuQyxJQUFJLENBQUMsTUFBTSxDQUFDOzs7U0FHZCxDQUNGLENBQUM7UUFDSixDQUFDO0lBQ0gsQ0FBQzs7QUFqSkgsZ0RBa0pDOzs7QUFFRDs7Ozs7O0dBTUc7QUFDSCxTQUFnQixvQkFBb0IsQ0FDbEMsYUFBcUMsRUFDckMsSUFBWTtJQUVaLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztRQUNuQixPQUFPLFNBQVMsQ0FBQztJQUNuQixDQUFDO0lBRUQsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUVsQyxJQUFJLFNBQVMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFLENBQUM7UUFDM0IsT0FBTyxhQUFhLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUVELFVBQVU7SUFDVixNQUFNLFFBQVEsR0FBRyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUM5QyxPQUFPLG9CQUFvQixDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQztBQUNyRSxDQUFDO0FBakJELG9EQWlCQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBBanYgZnJvbSBcImFqdlwiO1xuaW1wb3J0IHsgQ29uc3RydWN0IH0gZnJvbSBcImNvbnN0cnVjdHNcIjtcbmltcG9ydCB7XG4gIGxvYWRQbGF0Zm9ybVNwZWNpZmljVmFsdWVzLFxuICBleHRyYWN0RmllbGRzRnJvbVNjaGVtYSxcbiAgZmlsdGVyUGFyYW1ldGVyc0J5U2NoZW1hLFxufSBmcm9tIFwiLi91dGlsXCI7XG5pbXBvcnQgeyBKc29uLCBOb2RlIH0gZnJvbSBcIi4uL3N0ZFwiO1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIHJlYWRpbmcgcGFyYW1ldGVyc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlYWRQYXJhbWV0ZXJPcHRpb25zIHtcbiAgLyoqIFNjaGVtYSB0byBsaW1pdCB0aGUgcmVhZCB0byAqL1xuICByZWFkb25seSBzY2hlbWE/OiBhbnk7XG59XG5cbi8qKlxuICogUGFyYW1ldGVyIFJlZ2lzdHJhclxuICpcbiAqIFRoaXMgY2xhc3MgaXMgdXNlZCB0byByZWdpc3RlciBhbmQgbG9va3VwIHBhcmFtZXRlciB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBQYXJhbWV0ZXJSZWdpc3RyYXIgZXh0ZW5kcyBDb25zdHJ1Y3Qge1xuICAvKiogQ2FjaGUgZm9yIHBhcmFtZXRlciBsb29rdXBzICovXG4gIHByaXZhdGUgcGFyYW1ldGVyVmFsdWVCeVBhdGg6IHsgW2tleTogc3RyaW5nXTogYW55IH0gPSB7fTtcbiAgLyoqIExpc3Qgb2YgYWxsIHJlZ2lzdGVyZWQgcGFyYW1ldGVyIHNjaGVtYXMgKi9cbiAgcHJpdmF0ZSBwYXJhbWV0ZXJTY2hlbWFzOiBhbnlbXSA9IFtdO1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHVibGljIHJlYWRvbmx5IF9yYXdQYXJhbWV0ZXJzOiB7IFtrZXk6IHN0cmluZ106IGFueSB9ID1cbiAgICBsb2FkUGxhdGZvcm1TcGVjaWZpY1ZhbHVlcygpO1xuXG4gIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcpIHtcbiAgICBzdXBlcihzY29wZSwgaWQpO1xuICAgIE5vZGUub2YodGhpcykuaGlkZGVuID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSBhIHBhcmFtZXRlciB2YWx1ZSBieSBpdHMgcGF0aFxuICAgKlxuICAgKiBAcGFyYW0gcGF0aCB0aGUgcGF0aCBvZiB0aGUgcGFyYW1ldGVyXG4gICAqIEByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgcGFyYW1ldGVyXG4gICAqL1xuICBwdWJsaWMgdmFsdWUocGF0aDogc3RyaW5nKTogYW55IHtcbiAgICBpZiAodGhpcy5wYXJhbWV0ZXJWYWx1ZUJ5UGF0aFtwYXRoXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBhdHRlbXB0IHRvIHJlYWQgdGhlIHZhbHVlIGZyb20gdGhlIHJhdyBwYXJhbWV0ZXJzLCB0aGVuIGNhY2hlIGl0XG4gICAgICB0aGlzLnBhcmFtZXRlclZhbHVlQnlQYXRoW3BhdGhdID0gcmVzb2x2ZVZhbHVlRnJvbVBhdGgoXG4gICAgICAgIHRoaXMuX3Jhd1BhcmFtZXRlcnMsXG4gICAgICAgIHBhdGhcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucGFyYW1ldGVyVmFsdWVCeVBhdGhbcGF0aF07XG4gIH1cblxuICAvKipcbiAgICogUmVhZCBwYXJhbWV0ZXJzXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIG9wdGlvbnMgZm9yIHJlYWRpbmcgcGFyYW1ldGVyc1xuICAgKiBAcmV0dXJucyB0aGUgc2NoZW1hIGFzIGEgc3RyaW5nXG4gICAqL1xuICBwdWJsaWMgcmVhZChvcHRpb25zPzogUmVhZFBhcmFtZXRlck9wdGlvbnMpOiBKc29uIHtcbiAgICBpZiAob3B0aW9ucz8uc2NoZW1hKSB7XG4gICAgICB0aGlzLmFkZFNjaGVtYShvcHRpb25zLnNjaGVtYSk7XG4gICAgICBjb25zdCBmaWVsZHMgPSBleHRyYWN0RmllbGRzRnJvbVNjaGVtYShcbiAgICAgICAgb3B0aW9ucy5zY2hlbWEuX3Jhd1NjaGVtYSAvLyBJZiBhIEpzb25TY2hlbWEgb2JqZWN0IGlzIHBhc3NlZCBpbiwgZXh0cmFjdCByYXcgc2NoZW1hIGZyb20gaXRcbiAgICAgICAgICA/IG9wdGlvbnMuc2NoZW1hLl9yYXdTY2hlbWFcbiAgICAgICAgICA6IG9wdGlvbnMuc2NoZW1hXG4gICAgICApO1xuICAgICAgcmV0dXJuIGZpbHRlclBhcmFtZXRlcnNCeVNjaGVtYShmaWVsZHMsIHRoaXMuX3Jhd1BhcmFtZXRlcnMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmF3UGFyYW1ldGVycyBhcyBKc29uO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBwYXJhbWV0ZXIgc2NoZW1hIHRvIHJlZ2lzdHJhclxuICAgKlxuICAgKiBAcGFyYW0gc2NoZW1hIHNjaGVtYSB0byBhZGQgdG8gdGhlIHJlZ2lzdHJhclxuICAgKi9cbiAgcHVibGljIGFkZFNjaGVtYShzY2hlbWE6IGFueSkge1xuICAgIC8vIElmIGEgSnNvblNjaGVtYSBvYmplY3QgaXMgcGFzc2VkIGluLCBleHRyYWN0IHRoZSByYXcgc2NoZW1hIGZyb20gaXRcbiAgICBjb25zdCBzY2hlbWFUb0FkZCA9IHNjaGVtYS5fcmF3U2NoZW1hID8gc2NoZW1hLl9yYXdTY2hlbWEgOiBzY2hlbWE7XG4gICAgaWYgKCF0aGlzLnBhcmFtZXRlclNjaGVtYXMuaW5jbHVkZXMoc2NoZW1hVG9BZGQpKSB7XG4gICAgICB0aGlzLnBhcmFtZXRlclNjaGVtYXMucHVzaChzY2hlbWFUb0FkZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciBtZXRob2QgdG8gYWRkIGEgcGFyYW1ldGVyIHNjaGVtYSBhdCBhIGdpdmVuIHBhdGguXG4gICAqIFRoaXMgbWV0aG9kIHdpbGwgbmVzdCB0aGUgc2NoZW1hIHVuZGVyIHRoZSBnaXZlbiBwYXRoLCBtYWtpbmcgaXQgZWFzaWVyIHRvIG5lc3Qgc2NoZW1hcy5cbiAgICpcbiAgICogQHBhcmFtIHNjaGVtYSB0aGUgc2NoZW1hIHRvIGFkZFxuICAgKiBAcGFyYW0gcGF0aCB0aGUgcGF0aCB0byBuZXN0IHRoZSBzY2hlbWEgdW5kZXJcbiAgICogQHBhcmFtIHJlY3Vyc2l2ZVJlcXVpcmUgd2hldGhlciBvciBub3QgdG8gcmVxdWlyZSBhbGwgdGhlIG5lc3RlZCBwcm9wZXJ0aWVzXG4gICAqL1xuICBwdWJsaWMgYWRkU2NoZW1hQXRQYXRoKHNjaGVtYTogYW55LCBwYXRoOiBzdHJpbmcsIHJlY3Vyc2l2ZVJlcXVpcmUgPSBmYWxzZSkge1xuICAgIHRoaXMuYWRkU2NoZW1hKHRoaXMuX25lc3RTY2hlbWFVbmRlclBhdGgoc2NoZW1hLCBwYXRoLCByZWN1cnNpdmVSZXF1aXJlKSk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyBhIGhlbHBlciBtZXRob2QgdG8gbmVzdCBhIHNjaGVtYSB1bmRlciBhIHBhdGguXG4gICAqXG4gICAqIEkuRS4gaWYgeW91IGhhdmUgYSBqc29uIHNjaGVtYSB0aGF0IGxvb2tzIGxpa2UgdGhpczpcbiAgICogeyB0eXBlOiBcIm9iamVjdFwiLCBwcm9wZXJ0aWVzOiB7IGZvbzogeyB0eXBlOiBcInN0cmluZ1wiIH0gfSB9XG4gICAqXG4gICAqIEFuZCB3ZSB3YW50IHRvIG5lc3QgaXQgdW5kZXIgdGhlIHBhdGggXCJiYXIvYmF6XCIsIHRoZW4gdGhpcyBtZXRob2Qgd2lsbCByZXR1cm46XG4gICAqIHsgdHlwZTogXCJvYmplY3RcIiwgcHJvcGVydGllczogeyBiYXI6IHsgdHlwZTogXCJvYmplY3RcIiwgcHJvcGVydGllczogeyBiYXo6IHsgdHlwZTogXCJvYmplY3RcIiwgcHJvcGVydGllczogeyBmb286IHsgdHlwZTogXCJzdHJpbmdcIiB9IH0gfSB9IH0gfSB9XG4gICAqXG4gICAqIG1ha2luZyBpdCBlYXNpZXIgdG8gbmVzdCBzY2hlbWFzIHVuZGVyIHBhdGhzLCB3aXRob3V0IHdyaXRpbmcgb3V0IHRoZSBvYmplY3QgYm9pbGVycGxhdGUuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHVibGljIF9uZXN0U2NoZW1hVW5kZXJQYXRoKFxuICAgIHNjaGVtYTogYW55LFxuICAgIHBhdGg6IHN0cmluZyxcbiAgICByZWN1cnNpdmVSZXF1aXJlID0gZmFsc2VcbiAgKTogYW55IHtcbiAgICBjb25zdCBwYXJ0cyA9IHBhdGguc3BsaXQoXCIvXCIpO1xuXG4gICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMCB8fCBwYXRoID09PSBcIlwiKSB7XG4gICAgICAvLyBiYXNlIGNhc2UganVzdCByZXR1cm4gdGhlIHNjaGVtYVxuICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICB9XG5cbiAgICBjb25zdCBjdXJyZW50S2V5ID0gcGFydHNbMF07XG5cbiAgICAvLyBDcmVhdGUgYW5kIHJldHVybiB0aGUgc2NoZW1hXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIC8vIHJlY3Vyc2UgZm9yIHRoZSBuZXh0IHBhcnQgb2YgdGhlIHBhdGhcbiAgICAgICAgW2N1cnJlbnRLZXldOiB0aGlzLl9uZXN0U2NoZW1hVW5kZXJQYXRoKFxuICAgICAgICAgIHNjaGVtYSxcbiAgICAgICAgICBwYXJ0cy5zbGljZSgxKS5qb2luKFwiL1wiKSxcbiAgICAgICAgICByZWN1cnNpdmVSZXF1aXJlXG4gICAgICAgICksXG4gICAgICB9LFxuICAgICAgcmVxdWlyZWQ6IHJlY3Vyc2l2ZVJlcXVpcmUgPyBbY3VycmVudEtleV0gOiBbXSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHVibGljIF9wcmVTeW50aGVzaXplKCkge1xuICAgIGlmICh0aGlzLnBhcmFtZXRlclNjaGVtYXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcGxhdGZvcm1QYXJhbWV0ZXJTY2hlbWEgPSB7XG4gICAgICBhbGxPZjogWy4uLnRoaXMucGFyYW1ldGVyU2NoZW1hc10sXG4gICAgfTtcblxuICAgIGNvbnN0IGFqdiA9IG5ldyBBanYoeyBhbGxFcnJvcnM6IHRydWUgfSk7XG4gICAgY29uc3QgdmFsaWRhdG9yID0gYWp2LmNvbXBpbGUocGxhdGZvcm1QYXJhbWV0ZXJTY2hlbWEpO1xuICAgIGNvbnN0IHZhbGlkID0gdmFsaWRhdG9yKHRoaXMuX3Jhd1BhcmFtZXRlcnMpO1xuXG4gICAgaWYgKCF2YWxpZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgUGFyYW1ldGVyIHZhbGlkYXRpb24gZXJyb3JzOlxcbi0gJHt2YWxpZGF0b3IuZXJyb3JzXG4gICAgICAgICAgPy5tYXAoKGVycm9yOiBhbnkpID0+IGVycm9yLm1lc3NhZ2UpXG4gICAgICAgICAgLmpvaW4oXCJcXG4tIFwiKX1cblxuKGhpbnQ6IG1ha2Ugc3VyZSB0byB1c2UgLS12YWx1ZXMgdG8gcHJvdmlkZSB0aGUgcmVxdWlyZWQgcGFyYW1ldGVycyBmaWxlKVxuICAgICAgICBgXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJldHJpZXZlcyBhIHZhbHVlIGZyb20gYW4gb2JqZWN0IHVzaW5nIGEgZ2l2ZW4gcGF0aFxuICpcbiAqIEBwYXJhbSByYXdQYXJhbWV0ZXJzIHRoZSBvYmplY3QgdG8gcmV0cmlldmUgdGhlIHZhbHVlIGZyb21cbiAqIEBwYXJhbSBwYXRoIHRoZSBwYXRoIHRvIHRoZSB2YWx1ZSAoSS5FLiBcImZvby9iYXIvYmF6XCIpXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVWYWx1ZUZyb21QYXRoKFxuICByYXdQYXJhbWV0ZXJzOiB7IFtrZXk6IHN0cmluZ106IGFueSB9LFxuICBwYXRoOiBzdHJpbmdcbik6IGFueSB7XG4gIGlmICghcmF3UGFyYW1ldGVycykge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBjb25zdCBwYXRoUGFydHMgPSBwYXRoLnNwbGl0KFwiL1wiKTtcblxuICBpZiAocGF0aFBhcnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiByYXdQYXJhbWV0ZXJzW3BhdGhQYXJ0c1swXV07XG4gIH1cblxuICAvLyByZWN1cnNlXG4gIGNvbnN0IG5leHRQYXRoID0gcGF0aFBhcnRzLnNsaWNlKDEpLmpvaW4oXCIvXCIpO1xuICByZXR1cm4gcmVzb2x2ZVZhbHVlRnJvbVBhdGgocmF3UGFyYW1ldGVyc1twYXRoUGFydHNbMF1dLCBuZXh0UGF0aCk7XG59XG4iXX0=