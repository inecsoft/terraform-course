"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestRunner = void 0;
const terraform_output_1 = require("cdktf/lib/terraform-output");
const tokens_1 = require("cdktf/lib/tokens");
const function_1 = require("./function");
const core = __importStar(require("../core"));
const std = __importStar(require("../std"));
const OUTPUT_TEST_RUNNER_FUNCTION_IDENTIFIERS = "WING_TEST_RUNNER_FUNCTION_IDENTIFIERS";
/**
 * AWS implementation of `cloud.TestRunner`.
 *
 * @inflight `@winglang/sdk.cloud.ITestRunnerClient`
 */
class TestRunner extends std.TestRunner {
    constructor(scope, id, props = {}) {
        super(scope, id, props);
        // This output is created so the CLI's `wing test` command can obtain a list
        // of all ARNs of test functions by running `terraform output`.
        const output = new terraform_output_1.TerraformOutput(this, "TestFunctionArns", {
            value: tokens_1.Lazy.stringValue({
                produce: () => {
                    return JSON.stringify([...this.getTestFunctionArns().entries()]);
                },
            }),
        });
        output.overrideLogicalId(OUTPUT_TEST_RUNNER_FUNCTION_IDENTIFIERS);
    }
    onLift(host, ops) {
        // Collect all of the test functions and their ARNs, and pass them to the
        // test engine so they can be invoked inflight.
        // TODO: are we going to run into AWS's 4KB environment variable limit here?
        // some solutions:
        // - base64 encode the string value
        // - move the logic for picking one test from each isolated environment to
        //   here so that if there are N tests in the original app and N
        //   environments, we only need to output N test function ARNs instead of
        //   N * N
        const testFunctions = this.getTestFunctionArns();
        host.addEnvironment(this.envTestFunctionArns(), JSON.stringify([...testFunctions.entries()]));
        super.onLift(host, ops);
    }
    /** @internal */
    _preSynthesize() {
        // add a dependency on each test function
        for (const test of this.findTests()) {
            if (test._fn) {
                this.node.addDependency(test._fn);
            }
        }
        super._preSynthesize();
    }
    getTestFunctionArns() {
        const arns = new Map();
        for (const test of this.findTests()) {
            if (test._fn) {
                if (!(test._fn instanceof function_1.Function)) {
                    throw new Error(`Unsupported test function type, ${test._fn.node.path} was not a tfaws.Function`);
                }
                arns.set(test.node.path, test._fn.functionArn);
            }
        }
        return arns;
    }
    /** @internal */
    _toInflight() {
        return core.InflightClient.for(__dirname.replace("target-tf-aws", "shared-aws"), __filename, "TestRunnerClient", [`process.env["${this.envTestFunctionArns()}"]`]);
    }
    envTestFunctionArns() {
        return `TEST_RUNNER_FUNCTIONS_${this.node.addr.slice(-8)}`;
    }
}
exports.TestRunner = TestRunner;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVzdC1ydW5uZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvdGFyZ2V0LXRmLWF3cy90ZXN0LXJ1bm5lci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGlFQUE2RDtBQUM3RCw2Q0FBd0M7QUFFeEMseUNBQXFEO0FBQ3JELDhDQUFnQztBQUNoQyw0Q0FBOEI7QUFFOUIsTUFBTSx1Q0FBdUMsR0FDM0MsdUNBQXVDLENBQUM7QUFFMUM7Ozs7R0FJRztBQUNILE1BQWEsVUFBVyxTQUFRLEdBQUcsQ0FBQyxVQUFVO0lBQzVDLFlBQVksS0FBZ0IsRUFBRSxFQUFVLEVBQUUsUUFBNkIsRUFBRTtRQUN2RSxLQUFLLENBQUMsS0FBSyxFQUFFLEVBQUUsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUV4Qiw0RUFBNEU7UUFDNUUsK0RBQStEO1FBQy9ELE1BQU0sTUFBTSxHQUFHLElBQUksa0NBQWUsQ0FBQyxJQUFJLEVBQUUsa0JBQWtCLEVBQUU7WUFDM0QsS0FBSyxFQUFFLGFBQUksQ0FBQyxXQUFXLENBQUM7Z0JBQ3RCLE9BQU8sRUFBRSxHQUFHLEVBQUU7b0JBQ1osT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsbUJBQW1CLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUM7Z0JBQ25FLENBQUM7YUFDRixDQUFDO1NBQ0gsQ0FBQyxDQUFDO1FBRUgsTUFBTSxDQUFDLGlCQUFpQixDQUFDLHVDQUF1QyxDQUFDLENBQUM7SUFDcEUsQ0FBQztJQUVNLE1BQU0sQ0FBQyxJQUF1QixFQUFFLEdBQWE7UUFDbEQseUVBQXlFO1FBQ3pFLCtDQUErQztRQUMvQyw0RUFBNEU7UUFDNUUsa0JBQWtCO1FBQ2xCLG1DQUFtQztRQUNuQywwRUFBMEU7UUFDMUUsZ0VBQWdFO1FBQ2hFLHlFQUF5RTtRQUN6RSxVQUFVO1FBQ1YsTUFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDLG1CQUFtQixFQUFFLENBQUM7UUFDakQsSUFBSSxDQUFDLGNBQWMsQ0FDakIsSUFBSSxDQUFDLG1CQUFtQixFQUFFLEVBQzFCLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxHQUFHLGFBQWEsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQzdDLENBQUM7UUFFRixLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQztJQUMxQixDQUFDO0lBRUQsZ0JBQWdCO0lBQ1QsY0FBYztRQUNuQix5Q0FBeUM7UUFDekMsS0FBSyxNQUFNLElBQUksSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFLEVBQUUsQ0FBQztZQUNwQyxJQUFJLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztnQkFDYixJQUFJLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDcEMsQ0FBQztRQUNILENBQUM7UUFFRCxLQUFLLENBQUMsY0FBYyxFQUFFLENBQUM7SUFDekIsQ0FBQztJQUVPLG1CQUFtQjtRQUN6QixNQUFNLElBQUksR0FBRyxJQUFJLEdBQUcsRUFBa0IsQ0FBQztRQUN2QyxLQUFLLE1BQU0sSUFBSSxJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUUsRUFBRSxDQUFDO1lBQ3BDLElBQUksSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO2dCQUNiLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLFlBQVksbUJBQVcsQ0FBQyxFQUFFLENBQUM7b0JBQ3ZDLE1BQU0sSUFBSSxLQUFLLENBQ2IsbUNBQW1DLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksMkJBQTJCLENBQ2pGLENBQUM7Z0JBQ0osQ0FBQztnQkFDRCxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFHLElBQUksQ0FBQyxHQUFtQixDQUFDLFdBQVcsQ0FBQyxDQUFDO1lBQ2xFLENBQUM7UUFDSCxDQUFDO1FBQ0QsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQsZ0JBQWdCO0lBQ1QsV0FBVztRQUNoQixPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUM1QixTQUFTLENBQUMsT0FBTyxDQUFDLGVBQWUsRUFBRSxZQUFZLENBQUMsRUFDaEQsVUFBVSxFQUNWLGtCQUFrQixFQUNsQixDQUFDLGdCQUFnQixJQUFJLENBQUMsbUJBQW1CLEVBQUUsSUFBSSxDQUFDLENBQ2pELENBQUM7SUFDSixDQUFDO0lBRU8sbUJBQW1CO1FBQ3pCLE9BQU8seUJBQXlCLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7SUFDN0QsQ0FBQztDQUNGO0FBNUVELGdDQTRFQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRlcnJhZm9ybU91dHB1dCB9IGZyb20gXCJjZGt0Zi9saWIvdGVycmFmb3JtLW91dHB1dFwiO1xuaW1wb3J0IHsgTGF6eSB9IGZyb20gXCJjZGt0Zi9saWIvdG9rZW5zXCI7XG5pbXBvcnQgeyBDb25zdHJ1Y3QgfSBmcm9tIFwiY29uc3RydWN0c1wiO1xuaW1wb3J0IHsgRnVuY3Rpb24gYXMgQXdzRnVuY3Rpb24gfSBmcm9tIFwiLi9mdW5jdGlvblwiO1xuaW1wb3J0ICogYXMgY29yZSBmcm9tIFwiLi4vY29yZVwiO1xuaW1wb3J0ICogYXMgc3RkIGZyb20gXCIuLi9zdGRcIjtcblxuY29uc3QgT1VUUFVUX1RFU1RfUlVOTkVSX0ZVTkNUSU9OX0lERU5USUZJRVJTID1cbiAgXCJXSU5HX1RFU1RfUlVOTkVSX0ZVTkNUSU9OX0lERU5USUZJRVJTXCI7XG5cbi8qKlxuICogQVdTIGltcGxlbWVudGF0aW9uIG9mIGBjbG91ZC5UZXN0UnVubmVyYC5cbiAqXG4gKiBAaW5mbGlnaHQgYEB3aW5nbGFuZy9zZGsuY2xvdWQuSVRlc3RSdW5uZXJDbGllbnRgXG4gKi9cbmV4cG9ydCBjbGFzcyBUZXN0UnVubmVyIGV4dGVuZHMgc3RkLlRlc3RSdW5uZXIge1xuICBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogc3RkLlRlc3RSdW5uZXJQcm9wcyA9IHt9KSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCBwcm9wcyk7XG5cbiAgICAvLyBUaGlzIG91dHB1dCBpcyBjcmVhdGVkIHNvIHRoZSBDTEkncyBgd2luZyB0ZXN0YCBjb21tYW5kIGNhbiBvYnRhaW4gYSBsaXN0XG4gICAgLy8gb2YgYWxsIEFSTnMgb2YgdGVzdCBmdW5jdGlvbnMgYnkgcnVubmluZyBgdGVycmFmb3JtIG91dHB1dGAuXG4gICAgY29uc3Qgb3V0cHV0ID0gbmV3IFRlcnJhZm9ybU91dHB1dCh0aGlzLCBcIlRlc3RGdW5jdGlvbkFybnNcIiwge1xuICAgICAgdmFsdWU6IExhenkuc3RyaW5nVmFsdWUoe1xuICAgICAgICBwcm9kdWNlOiAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFsuLi50aGlzLmdldFRlc3RGdW5jdGlvbkFybnMoKS5lbnRyaWVzKCldKTtcbiAgICAgICAgfSxcbiAgICAgIH0pLFxuICAgIH0pO1xuXG4gICAgb3V0cHV0Lm92ZXJyaWRlTG9naWNhbElkKE9VVFBVVF9URVNUX1JVTk5FUl9GVU5DVElPTl9JREVOVElGSUVSUyk7XG4gIH1cblxuICBwdWJsaWMgb25MaWZ0KGhvc3Q6IHN0ZC5JSW5mbGlnaHRIb3N0LCBvcHM6IHN0cmluZ1tdKTogdm9pZCB7XG4gICAgLy8gQ29sbGVjdCBhbGwgb2YgdGhlIHRlc3QgZnVuY3Rpb25zIGFuZCB0aGVpciBBUk5zLCBhbmQgcGFzcyB0aGVtIHRvIHRoZVxuICAgIC8vIHRlc3QgZW5naW5lIHNvIHRoZXkgY2FuIGJlIGludm9rZWQgaW5mbGlnaHQuXG4gICAgLy8gVE9ETzogYXJlIHdlIGdvaW5nIHRvIHJ1biBpbnRvIEFXUydzIDRLQiBlbnZpcm9ubWVudCB2YXJpYWJsZSBsaW1pdCBoZXJlP1xuICAgIC8vIHNvbWUgc29sdXRpb25zOlxuICAgIC8vIC0gYmFzZTY0IGVuY29kZSB0aGUgc3RyaW5nIHZhbHVlXG4gICAgLy8gLSBtb3ZlIHRoZSBsb2dpYyBmb3IgcGlja2luZyBvbmUgdGVzdCBmcm9tIGVhY2ggaXNvbGF0ZWQgZW52aXJvbm1lbnQgdG9cbiAgICAvLyAgIGhlcmUgc28gdGhhdCBpZiB0aGVyZSBhcmUgTiB0ZXN0cyBpbiB0aGUgb3JpZ2luYWwgYXBwIGFuZCBOXG4gICAgLy8gICBlbnZpcm9ubWVudHMsIHdlIG9ubHkgbmVlZCB0byBvdXRwdXQgTiB0ZXN0IGZ1bmN0aW9uIEFSTnMgaW5zdGVhZCBvZlxuICAgIC8vICAgTiAqIE5cbiAgICBjb25zdCB0ZXN0RnVuY3Rpb25zID0gdGhpcy5nZXRUZXN0RnVuY3Rpb25Bcm5zKCk7XG4gICAgaG9zdC5hZGRFbnZpcm9ubWVudChcbiAgICAgIHRoaXMuZW52VGVzdEZ1bmN0aW9uQXJucygpLFxuICAgICAgSlNPTi5zdHJpbmdpZnkoWy4uLnRlc3RGdW5jdGlvbnMuZW50cmllcygpXSlcbiAgICApO1xuXG4gICAgc3VwZXIub25MaWZ0KGhvc3QsIG9wcyk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHB1YmxpYyBfcHJlU3ludGhlc2l6ZSgpOiB2b2lkIHtcbiAgICAvLyBhZGQgYSBkZXBlbmRlbmN5IG9uIGVhY2ggdGVzdCBmdW5jdGlvblxuICAgIGZvciAoY29uc3QgdGVzdCBvZiB0aGlzLmZpbmRUZXN0cygpKSB7XG4gICAgICBpZiAodGVzdC5fZm4pIHtcbiAgICAgICAgdGhpcy5ub2RlLmFkZERlcGVuZGVuY3kodGVzdC5fZm4pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN1cGVyLl9wcmVTeW50aGVzaXplKCk7XG4gIH1cblxuICBwcml2YXRlIGdldFRlc3RGdW5jdGlvbkFybnMoKTogTWFwPHN0cmluZywgc3RyaW5nPiB7XG4gICAgY29uc3QgYXJucyA9IG5ldyBNYXA8c3RyaW5nLCBzdHJpbmc+KCk7XG4gICAgZm9yIChjb25zdCB0ZXN0IG9mIHRoaXMuZmluZFRlc3RzKCkpIHtcbiAgICAgIGlmICh0ZXN0Ll9mbikge1xuICAgICAgICBpZiAoISh0ZXN0Ll9mbiBpbnN0YW5jZW9mIEF3c0Z1bmN0aW9uKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBVbnN1cHBvcnRlZCB0ZXN0IGZ1bmN0aW9uIHR5cGUsICR7dGVzdC5fZm4ubm9kZS5wYXRofSB3YXMgbm90IGEgdGZhd3MuRnVuY3Rpb25gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBhcm5zLnNldCh0ZXN0Lm5vZGUucGF0aCwgKHRlc3QuX2ZuIGFzIEF3c0Z1bmN0aW9uKS5mdW5jdGlvbkFybik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcm5zO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwdWJsaWMgX3RvSW5mbGlnaHQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gY29yZS5JbmZsaWdodENsaWVudC5mb3IoXG4gICAgICBfX2Rpcm5hbWUucmVwbGFjZShcInRhcmdldC10Zi1hd3NcIiwgXCJzaGFyZWQtYXdzXCIpLFxuICAgICAgX19maWxlbmFtZSxcbiAgICAgIFwiVGVzdFJ1bm5lckNsaWVudFwiLFxuICAgICAgW2Bwcm9jZXNzLmVudltcIiR7dGhpcy5lbnZUZXN0RnVuY3Rpb25Bcm5zKCl9XCJdYF1cbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBlbnZUZXN0RnVuY3Rpb25Bcm5zKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGBURVNUX1JVTk5FUl9GVU5DVElPTlNfJHt0aGlzLm5vZGUuYWRkci5zbGljZSgtOCl9YDtcbiAgfVxufVxuIl19