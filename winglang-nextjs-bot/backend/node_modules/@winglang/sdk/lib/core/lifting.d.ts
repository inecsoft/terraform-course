import { IInflightHost, IHostedLiftable } from "../std";
/**
 * This is the name of a special operation that is used as a key
 * by the compiler in the `_liftMap` matrix to indicate that
 * some transitive object dependencies are always required no matter
 * what operations are passed to the `host`.
 *
 * As a user, this operation is hidden so it will not be
 * passed as an op to `onLift` or `onLiftType` methods.
 */
export declare const INFLIGHT_INIT_METHOD_NAME = "$inflight_init";
/**
 * Creates a liftable type from a class or enum
 * @param type The type to lift, Should be a class or enum.
 * @param moduleSpec A module specifier that the type can be imported from. e.g. "aws-cdk-lib"
 * @param path The dotted path to the type in the module. e.g. "aws_s3.Bucket" to access `require("aws-cdk-lib").aws_s3.Bucket`
 * @returns A liftable type, either the same type or a wrapper
 */
export declare function toLiftableModuleType(type: any, moduleSpec: string, path: string): any;
export declare function liftObject(obj: any): string;
export type LiftMap = Record<string, Array<[any, Array<string>]>>;
export type LiftMapNormalized = Record<string, Map<any, Set<string>>>;
/**
 * Merge two matrixes of lifting dependencies.
 *
 * See the unit tests in `lifting.test.ts` for examples.
 */
export declare function mergeLiftDeps(matrix1?: LiftMapNormalized, matrix2?: LiftMapNormalized): LiftMapNormalized;
/**
 * Collects all of the objects that need to be lifted for a given object and set of operations, by
 * traversing the object graph.
 *
 * Internally, it keeps track of a queue of objects and corresponding operations that need to be lifted
 * by the inflight host (the explored set), and a queue of objects and operations that need to be
 * explored (the queue). Objects (any JavaScript values) can be re-added to the queue multiple times
 * if new operations are determined as needed by the inflight host.
 *
 * For example, suppose an inflight host needs to call op1 on object A and op2 on object B.
 * In addition, object B needs op3 on object A.
 * The explored set and queue after each step of the main loop is shown below:
 *
 * ```
 * explored: {} | queue: [(A, [op1]), (B, [op2])]
 * explored: {A: [op1]} | queue: [(B, [op2])]
 * explored: {A: [op1], B: [op2]} | queue: [(A, [op3])]
 * explored: {A: [op1, op3], B: [op2]} | queue: []
 */
export declare function collectLifts(initialObj: any, initialOps: Array<string>): Map<any, Set<string>>;
/**
 * Represents a type with static methods that may have other things to lift.
 */
export interface ILiftableType {
    /**
     * Compiler-generated data that describes the dependencies of this object on other
     * objects. This is used to determine which permissions need to be granted to the
     * inflight host.
     * @internal
     */
    _liftTypeMap?: LiftMap;
    /**
     * A hook called by the Wing compiler once for each inflight host that needs to
     * use this type inflight. The list of requested inflight methods
     * needed by the inflight host are given by `ops`.
     *
     * This method is commonly used for adding permissions, environment variables, or
     * other capabilities to the inflight host.
     */
    onLiftType(host: IInflightHost, ops: string[]): void;
}
/**
 * Lifting utilities.
 */
export declare class Lifting {
    /**
     * Perform the full lifting process on an object.
     *
     * Use this instead of calling `onLift` since it will also lift all of the
     * object's dependencies, and it will ensure that the onLift methods of
     * all objects are all called at most once.
     */
    static lift(obj: IHostedLiftable, host: IInflightHost, ops: Array<string>): void;
}
