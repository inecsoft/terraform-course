"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Lifting = exports.collectLifts = exports.mergeLiftDeps = exports.liftObject = exports.toLiftableModuleType = exports.INFLIGHT_INIT_METHOD_NAME = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const constructs_1 = require("constructs");
const errors_1 = require("./errors");
const tokens_1 = require("./tokens");
/**
 * This is the name of a special operation that is used as a key
 * by the compiler in the `_liftMap` matrix to indicate that
 * some transitive object dependencies are always required no matter
 * what operations are passed to the `host`.
 *
 * As a user, this operation is hidden so it will not be
 * passed as an op to `onLift` or `onLiftType` methods.
 */
exports.INFLIGHT_INIT_METHOD_NAME = "$inflight_init";
/**
 * Inflight closures are liftable objects that have a single inflight
 * method called "handle". This method contains the inflight code
 * that will be executed by the inflight host.
 */
const INFLIGHT_CLOSURE_HANDLE_METHOD = "handle";
/**
 * The prefix used to name inflight closure object types.
 */
const INFLIGHT_CLOSURE_TYPE_PREFIX = "$Closure";
/**
 * Creates a liftable type from a class or enum
 * @param type The type to lift, Should be a class or enum.
 * @param moduleSpec A module specifier that the type can be imported from. e.g. "aws-cdk-lib"
 * @param path The dotted path to the type in the module. e.g. "aws_s3.Bucket" to access `require("aws-cdk-lib").aws_s3.Bucket`
 * @returns A liftable type, either the same type or a wrapper
 */
function toLiftableModuleType(type, moduleSpec, path) {
    if (typeof type?._toInflightType === "function" ||
        type?.constructor?.name === "Object") {
        return type;
    }
    else {
        return {
            _toInflightType: () => `require("${moduleSpec}").${path}`,
        };
    }
}
exports.toLiftableModuleType = toLiftableModuleType;
function liftObject(obj) {
    // since typeof(null) is "object", we cover all nullity cases (undefined and null) apriori.
    if (obj == null) {
        return JSON.stringify(obj);
    }
    const tokenResolver = (0, tokens_1.getTokenResolver)(obj);
    if (tokenResolver) {
        return tokenResolver.lift(obj);
    }
    // if the object is a type, and it has a "_toInflightType" method, we use it to serialize
    // fyi, typeof(obj) in this case is a "function".
    if (typeof obj?._toInflightType === "function") {
        return obj._toInflightType();
    }
    switch (typeof obj) {
        case "string":
        case "boolean":
        case "number":
            return JSON.stringify(obj);
        case "object":
            if (Array.isArray(obj)) {
                return `[${obj.map((o) => liftObject(o)).join(",")}]`;
            }
            if (obj instanceof Set) {
                return `new Set(${liftObject(Array.from(obj))})`;
            }
            if (obj instanceof Map) {
                return `new Map(${liftObject(Array.from(obj))})`;
            }
            // if the object is a resource (i.e. has a "_toInflight" method"), we use it to serialize
            // itself.
            if (typeof obj._toInflight === "function") {
                return obj._toInflight();
            }
            // structs are just plain objects
            if (obj.constructor.name === "Object") {
                const lines = [];
                lines.push("{");
                for (const [k, v] of Object.entries(obj)) {
                    lines.push(`\"${k.replace(/"/g, '\\"')}\": ${liftObject(v)},`);
                }
                lines.push("}");
                return lines.join("");
            }
            break;
    }
    throw new Error(`Unable to lift object of type ${obj?.constructor?.name}`);
}
exports.liftObject = liftObject;
/**
 * Merge two matrixes of lifting dependencies.
 *
 * See the unit tests in `lifting.test.ts` for examples.
 */
function mergeLiftDeps(matrix1 = {}, matrix2 = {}) {
    const result = {};
    for (const [op, deps] of Object.entries(matrix1)) {
        result[op] = new Map();
        for (const [obj, objDeps] of deps) {
            result[op].set(obj, new Set(objDeps));
        }
    }
    for (const [op, deps] of Object.entries(matrix2)) {
        const resultDeps = result[op] ?? new Map();
        for (const [obj, objDeps] of deps) {
            const resultObjDeps = resultDeps.get(obj) ?? new Set();
            for (const dep of objDeps) {
                resultObjDeps.add(dep);
            }
            resultDeps.set(obj, resultObjDeps);
        }
        result[op] = resultDeps;
    }
    return result;
}
exports.mergeLiftDeps = mergeLiftDeps;
/**
 * Converts a matrix of lifting dependencies from the format emitted by the Wing compiler
 * (using plain objects and arrays) to a denser format (using Maps and Sets),
 * deduplicating object references if needed.
 *
 * The deduplication is needed because the compiler might generate something like:
 * ```
 * [
 *   [obj1, ["op1"]],
 *   [obj2, ["op2"]],
 * ]
 * ```
 * not knowing that during preflight execution, obj1 and obj2 are the same object.
 * The deduplication will turn this into:
 * ```
 * new Map([obj1, new Set(["op1", "op2"])])
 * ```
 */
function parseMatrix(data) {
    const result = {};
    for (const [op, pairs] of Object.entries(data)) {
        result[op] = new Map();
        for (const [obj, objDeps] of pairs) {
            if (!result[op].has(obj)) {
                result[op].set(obj, new Set());
            }
            const depSet = result[op].get(obj);
            for (const dep of objDeps) {
                depSet.add(dep);
            }
        }
    }
    return result;
}
// for debugging
// function printMatrix(data: LiftMapNormalized): string {
//   const lines = [];
//   for (const [op, pairs] of Object.entries(data)) {
//     lines.push(`${op}: {`);
//     for (const [obj, objDeps] of pairs) {
//       if (Construct.isConstruct(obj)) {
//         lines.push(`  ${obj.node.path}: [${[...objDeps]}]`);
//       } else {
//         lines.push(`  ${obj?.constructor?.name ?? obj}: [${[...objDeps]}]`);
//       }
//     }
//     lines.push("}");
//   }
//   return lines.join("\n");
// }
/**
 * Collects all of the objects that need to be lifted for a given object and set of operations, by
 * traversing the object graph.
 *
 * Internally, it keeps track of a queue of objects and corresponding operations that need to be lifted
 * by the inflight host (the explored set), and a queue of objects and operations that need to be
 * explored (the queue). Objects (any JavaScript values) can be re-added to the queue multiple times
 * if new operations are determined as needed by the inflight host.
 *
 * For example, suppose an inflight host needs to call op1 on object A and op2 on object B.
 * In addition, object B needs op3 on object A.
 * The explored set and queue after each step of the main loop is shown below:
 *
 * ```
 * explored: {} | queue: [(A, [op1]), (B, [op2])]
 * explored: {A: [op1]} | queue: [(B, [op2])]
 * explored: {A: [op1], B: [op2]} | queue: [(A, [op3])]
 * explored: {A: [op1, op3], B: [op2]} | queue: []
 */
function collectLifts(initialObj, initialOps) {
    if (initialOps.includes(exports.INFLIGHT_INIT_METHOD_NAME)) {
        throw new Error(`The operation ${exports.INFLIGHT_INIT_METHOD_NAME} is implicit and should not be requested explicitly.`);
    }
    const explored = new Map();
    const queue = new Array([initialObj, [...initialOps]]);
    const matrixCache = new Map();
    while (queue.length > 0) {
        // `obj` and `ops` are the preflight object and operations requested on it
        let [obj, ops] = queue.shift();
        let newObj = false;
        if (!explored.has(obj)) {
            explored.set(obj, new Set());
            newObj = true;
        }
        let existingOps = explored.get(obj);
        // Filter out any ops that we've already processed for this object.
        ops = ops.filter((op) => !existingOps.has(op));
        // If there are no ops left and we have already seen the object, skip further processing.
        if (ops.length === 0 && !newObj) {
            continue;
        }
        // Add the new ops to the explored set.
        for (const op of ops) {
            existingOps.add(op);
        }
        // Inspect the object to see if there are any transitive dependency information.
        // Currently there are a few ways to do this:
        // - The compiler may generate a _liftMap property on the object
        // - The compiler may generate a static _liftTypeMap method on a class
        let matrix;
        if (matrixCache.has(obj)) {
            matrix = matrixCache.get(obj);
        }
        else if (typeof obj === "object" && obj._liftMap !== undefined) {
            matrix = parseMatrix(obj._liftMap ?? {});
            matrixCache.set(obj, matrix);
        }
        else if (typeof obj === "function" &&
            typeof obj._liftTypeMap !== undefined) {
            matrix = parseMatrix(obj._liftTypeMap ?? {});
            matrixCache.set(obj, matrix);
        }
        else {
            // If the object doesn't have any dependency information, we can skip it.
            // In the future, we might want to do more advanced analysis to
            // lift collections of objects with onLift methods etc.
            // Before we `continue` to the next iteration, check for some basic collection types
            // so if the user puts tokens in a collection, they'll get lifted.
            //
            // We can't calculate what ops to put for the collection items (for
            // example, for cases where the items are resources) since the compiler
            // doesn't produce that information yet.
            let items_to_explore = [];
            if (Array.isArray(obj)) {
                items_to_explore = obj;
            }
            else if (obj instanceof Set) {
                items_to_explore = obj;
            }
            else if (obj instanceof Map) {
                items_to_explore = obj.values();
            }
            else if (typeof obj === "object" && obj.constructor.name === "Object") {
                items_to_explore = Object.values(obj);
            }
            for (const item of items_to_explore) {
                if (!explored.has(item)) {
                    let item_ops = [];
                    // If the item is an inflight closure type then implicitly add the "handle" operation
                    if (isInflightClosureObject(item)) {
                        item_ops.push(INFLIGHT_CLOSURE_HANDLE_METHOD);
                    }
                    queue.push([item, item_ops]);
                }
            }
            continue;
        }
        for (const op of [...ops, exports.INFLIGHT_INIT_METHOD_NAME]) {
            const objDeps = matrix[op];
            // If the op is $inflight_init, then the operation is implicit
            // so it's okay it's not defined in the matrix
            if (op === exports.INFLIGHT_INIT_METHOD_NAME && !objDeps) {
                continue;
            }
            if (!objDeps) {
                if (constructs_1.Construct.isConstruct(obj)) {
                    throw new errors_1.NotImplementedError(`Resource ${obj.node.path} does not support inflight operation ${op}.\nIt might not be implemented yet.`, { resource: obj.constructor.name, operation: op });
                }
                else {
                    throw new Error(`Unknown operation ${op} requested for object ${obj} (${obj.constructor.name})`);
                }
            }
            for (const [depObj, depOps] of objDeps.entries()) {
                if (depOps.has(exports.INFLIGHT_INIT_METHOD_NAME)) {
                    throw new Error(`The operation ${exports.INFLIGHT_INIT_METHOD_NAME} is implicit and should not be requested explicitly.`);
                }
                queue.push([depObj, [...depOps]]);
            }
        }
    }
    return explored;
}
exports.collectLifts = collectLifts;
/**
 * Returns whether the given item is an inflight closure object.
 */
function isInflightClosureObject(item) {
    return (typeof item === "object" &&
        typeof item.constructor === "function" &&
        typeof item.constructor.name === "string" &&
        item.constructor.name.startsWith(INFLIGHT_CLOSURE_TYPE_PREFIX) &&
        item._liftMap !== undefined &&
        item._liftMap[INFLIGHT_CLOSURE_HANDLE_METHOD] !== undefined);
}
/**
 * Lifting utilities.
 */
class Lifting {
    /**
     * Perform the full lifting process on an object.
     *
     * Use this instead of calling `onLift` since it will also lift all of the
     * object's dependencies, and it will ensure that the onLift methods of
     * all objects are all called at most once.
     */
    static lift(obj, host, ops) {
        // obtain all of the objects that need lifting
        const lifts = collectLifts(obj, ops);
        // call all of the onLift methods
        for (const [liftedObj, liftedOps] of lifts) {
            const tokens = (0, tokens_1.getTokenResolver)(liftedObj);
            if (tokens) {
                tokens.onLiftValue(host, liftedObj);
                continue;
            }
            if (typeof liftedObj === "object" &&
                typeof liftedObj.onLift === "function") {
                liftedObj.onLift(host, [...liftedOps]);
                continue;
            }
            if (typeof liftedObj === "function" &&
                typeof liftedObj.onLiftType === "function") {
                liftedObj.onLiftType(host, [...liftedOps]);
                continue;
            }
            // no lift-related methods to call - it's probably a primitive
            // so no capabilities need to be added to the inflight host
        }
    }
}
exports.Lifting = Lifting;
_a = JSII_RTTI_SYMBOL_1;
Lifting[_a] = { fqn: "@winglang/sdk.core.Lifting", version: "0.0.0" };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGlmdGluZy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb3JlL2xpZnRpbmcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSwyQ0FBdUM7QUFDdkMscUNBQStDO0FBQy9DLHFDQUE0QztBQUc1Qzs7Ozs7Ozs7R0FRRztBQUNVLFFBQUEseUJBQXlCLEdBQUcsZ0JBQWdCLENBQUM7QUFFMUQ7Ozs7R0FJRztBQUNILE1BQU0sOEJBQThCLEdBQUcsUUFBUSxDQUFDO0FBRWhEOztHQUVHO0FBQ0gsTUFBTSw0QkFBNEIsR0FBRyxVQUFVLENBQUM7QUFFaEQ7Ozs7OztHQU1HO0FBQ0gsU0FBZ0Isb0JBQW9CLENBQ2xDLElBQVMsRUFDVCxVQUFrQixFQUNsQixJQUFZO0lBRVosSUFDRSxPQUFPLElBQUksRUFBRSxlQUFlLEtBQUssVUFBVTtRQUMzQyxJQUFJLEVBQUUsV0FBVyxFQUFFLElBQUksS0FBSyxRQUFRLEVBQ3BDLENBQUM7UUFDRCxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7U0FBTSxDQUFDO1FBQ04sT0FBTztZQUNMLGVBQWUsRUFBRSxHQUFHLEVBQUUsQ0FBQyxZQUFZLFVBQVUsTUFBTSxJQUFJLEVBQUU7U0FDMUQsQ0FBQztJQUNKLENBQUM7QUFDSCxDQUFDO0FBZkQsb0RBZUM7QUFFRCxTQUFnQixVQUFVLENBQUMsR0FBUTtJQUNqQywyRkFBMkY7SUFDM0YsSUFBSSxHQUFHLElBQUksSUFBSSxFQUFFLENBQUM7UUFDaEIsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQzdCLENBQUM7SUFFRCxNQUFNLGFBQWEsR0FBRyxJQUFBLHlCQUFnQixFQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQzVDLElBQUksYUFBYSxFQUFFLENBQUM7UUFDbEIsT0FBTyxhQUFhLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ2pDLENBQUM7SUFFRCx5RkFBeUY7SUFDekYsaURBQWlEO0lBQ2pE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QWdCLEVBQUMsU0FBUyxDQUFDLENBQUM7WUFDM0MsSUFBSSxNQUFNLEVBQUUsQ0FBQztnQkFDWCxNQUFNLENBQUMsV0FBVyxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQztnQkFDcEMsU0FBUztZQUNYLENBQUM7WUFFRCxJQUNFLE9BQU8sU0FBUyxLQUFLLFFBQVE7Z0JBQzdCLE9BQU8sU0FBUyxDQUFDLE1BQU0sS0FBSyxVQUFVLEVBQ3RDLENBQUM7Z0JBQ0QsU0FBUyxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUUsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxDQUFDLENBQUM7Z0JBQ3ZDLFNBQVM7WUFDWCxDQUFDO1lBRUQsSUFDRSxPQUFPLFNBQVMsS0FBSyxVQUFVO2dCQUMvQixPQUFPLFNBQVMsQ0FBQyxVQUFVLEtBQUssVUFBVSxFQUMxQyxDQUFDO2dCQUNELFNBQVMsQ0FBQyxVQUFVLENBQUMsSUFBSSxFQUFFLENBQUMsR0FBRyxTQUFTLENBQUMsQ0FBQyxDQUFDO2dCQUMzQyxTQUFTO1lBQ1gsQ0FBQztZQUVELDhEQUE4RDtZQUM5RCwyREFBMkQ7UUFDN0QsQ0FBQztJQUNILENBQUM7O0FBM0NILDBCQTRDQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbnN0cnVjdCB9IGZyb20gXCJjb25zdHJ1Y3RzXCI7XG5pbXBvcnQgeyBOb3RJbXBsZW1lbnRlZEVycm9yIH0gZnJvbSBcIi4vZXJyb3JzXCI7XG5pbXBvcnQgeyBnZXRUb2tlblJlc29sdmVyIH0gZnJvbSBcIi4vdG9rZW5zXCI7XG5pbXBvcnQgeyBJSW5mbGlnaHRIb3N0LCBJTGlmdGFibGUsIElIb3N0ZWRMaWZ0YWJsZSB9IGZyb20gXCIuLi9zdGRcIjtcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBuYW1lIG9mIGEgc3BlY2lhbCBvcGVyYXRpb24gdGhhdCBpcyB1c2VkIGFzIGEga2V5XG4gKiBieSB0aGUgY29tcGlsZXIgaW4gdGhlIGBfbGlmdE1hcGAgbWF0cml4IHRvIGluZGljYXRlIHRoYXRcbiAqIHNvbWUgdHJhbnNpdGl2ZSBvYmplY3QgZGVwZW5kZW5jaWVzIGFyZSBhbHdheXMgcmVxdWlyZWQgbm8gbWF0dGVyXG4gKiB3aGF0IG9wZXJhdGlvbnMgYXJlIHBhc3NlZCB0byB0aGUgYGhvc3RgLlxuICpcbiAqIEFzIGEgdXNlciwgdGhpcyBvcGVyYXRpb24gaXMgaGlkZGVuIHNvIGl0IHdpbGwgbm90IGJlXG4gKiBwYXNzZWQgYXMgYW4gb3AgdG8gYG9uTGlmdGAgb3IgYG9uTGlmdFR5cGVgIG1ldGhvZHMuXG4gKi9cbmV4cG9ydCBjb25zdCBJTkZMSUdIVF9JTklUX01FVEhPRF9OQU1FID0gXCIkaW5mbGlnaHRfaW5pdFwiO1xuXG4vKipcbiAqIEluZmxpZ2h0IGNsb3N1cmVzIGFyZSBsaWZ0YWJsZSBvYmplY3RzIHRoYXQgaGF2ZSBhIHNpbmdsZSBpbmZsaWdodFxuICogbWV0aG9kIGNhbGxlZCBcImhhbmRsZVwiLiBUaGlzIG1ldGhvZCBjb250YWlucyB0aGUgaW5mbGlnaHQgY29kZVxuICogdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGJ5IHRoZSBpbmZsaWdodCBob3N0LlxuICovXG5jb25zdCBJTkZMSUdIVF9DTE9TVVJFX0hBTkRMRV9NRVRIT0QgPSBcImhhbmRsZVwiO1xuXG4vKipcbiAqIFRoZSBwcmVmaXggdXNlZCB0byBuYW1lIGluZmxpZ2h0IGNsb3N1cmUgb2JqZWN0IHR5cGVzLlxuICovXG5jb25zdCBJTkZMSUdIVF9DTE9TVVJFX1RZUEVfUFJFRklYID0gXCIkQ2xvc3VyZVwiO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBsaWZ0YWJsZSB0eXBlIGZyb20gYSBjbGFzcyBvciBlbnVtXG4gKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSB0byBsaWZ0LCBTaG91bGQgYmUgYSBjbGFzcyBvciBlbnVtLlxuICogQHBhcmFtIG1vZHVsZVNwZWMgQSBtb2R1bGUgc3BlY2lmaWVyIHRoYXQgdGhlIHR5cGUgY2FuIGJlIGltcG9ydGVkIGZyb20uIGUuZy4gXCJhd3MtY2RrLWxpYlwiXG4gKiBAcGFyYW0gcGF0aCBUaGUgZG90dGVkIHBhdGggdG8gdGhlIHR5cGUgaW4gdGhlIG1vZHVsZS4gZS5nLiBcImF3c19zMy5CdWNrZXRcIiB0byBhY2Nlc3MgYHJlcXVpcmUoXCJhd3MtY2RrLWxpYlwiKS5hd3NfczMuQnVja2V0YFxuICogQHJldHVybnMgQSBsaWZ0YWJsZSB0eXBlLCBlaXRoZXIgdGhlIHNhbWUgdHlwZSBvciBhIHdyYXBwZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvTGlmdGFibGVNb2R1bGVUeXBlKFxuICB0eXBlOiBhbnksXG4gIG1vZHVsZVNwZWM6IHN0cmluZyxcbiAgcGF0aDogc3RyaW5nXG4pIHtcbiAgaWYgKFxuICAgIHR5cGVvZiB0eXBlPy5fdG9JbmZsaWdodFR5cGUgPT09IFwiZnVuY3Rpb25cIiB8fFxuICAgIHR5cGU/LmNvbnN0cnVjdG9yPy5uYW1lID09PSBcIk9iamVjdFwiXG4gICkge1xuICAgIHJldHVybiB0eXBlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICBfdG9JbmZsaWdodFR5cGU6ICgpID0+IGByZXF1aXJlKFwiJHttb2R1bGVTcGVjfVwiKS4ke3BhdGh9YCxcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsaWZ0T2JqZWN0KG9iajogYW55KTogc3RyaW5nIHtcbiAgLy8gc2luY2UgdHlwZW9mKG51bGwpIGlzIFwib2JqZWN0XCIsIHdlIGNvdmVyIGFsbCBudWxsaXR5IGNhc2VzICh1bmRlZmluZWQgYW5kIG51bGwpIGFwcmlvcmkuXG4gIGlmIChvYmogPT0gbnVsbCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmopO1xuICB9XG5cbiAgY29uc3QgdG9rZW5SZXNvbHZlciA9IGdldFRva2VuUmVzb2x2ZXIob2JqKTtcbiAgaWYgKHRva2VuUmVzb2x2ZXIpIHtcbiAgICByZXR1cm4gdG9rZW5SZXNvbHZlci5saWZ0KG9iaik7XG4gIH1cblxuICAvLyBpZiB0aGUgb2JqZWN0IGlzIGEgdHlwZSwgYW5kIGl0IGhhcyBhIFwiX3RvSW5mbGlnaHRUeXBlXCIgbWV0aG9kLCB3ZSB1c2UgaXQgdG8gc2VyaWFsaXplXG4gIC8vIGZ5aSwgdHlwZW9mKG9iaikgaW4gdGhpcyBjYXNlIGlzIGEgXCJmdW5jdGlvblwiLlxuICBpZiAodHlwZW9mIG9iaj8uX3RvSW5mbGlnaHRUeXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gb2JqLl90b0luZmxpZ2h0VHlwZSgpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlb2Ygb2JqKSB7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaik7XG5cbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgIHJldHVybiBgWyR7b2JqLm1hcCgobykgPT4gbGlmdE9iamVjdChvKSkuam9pbihcIixcIil9XWA7XG4gICAgICB9XG5cbiAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgcmV0dXJuIGBuZXcgU2V0KCR7bGlmdE9iamVjdChBcnJheS5mcm9tKG9iaikpfSlgO1xuICAgICAgfVxuXG4gICAgICBpZiAob2JqIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIHJldHVybiBgbmV3IE1hcCgke2xpZnRPYmplY3QoQXJyYXkuZnJvbShvYmopKX0pYDtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgdGhlIG9iamVjdCBpcyBhIHJlc291cmNlIChpLmUuIGhhcyBhIFwiX3RvSW5mbGlnaHRcIiBtZXRob2RcIiksIHdlIHVzZSBpdCB0byBzZXJpYWxpemVcbiAgICAgIC8vIGl0c2VsZi5cbiAgICAgIGlmICh0eXBlb2YgKG9iaiBhcyBJTGlmdGFibGUpLl90b0luZmxpZ2h0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIChvYmogYXMgSUxpZnRhYmxlKS5fdG9JbmZsaWdodCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBzdHJ1Y3RzIGFyZSBqdXN0IHBsYWluIG9iamVjdHNcbiAgICAgIGlmIChvYmouY29uc3RydWN0b3IubmFtZSA9PT0gXCJPYmplY3RcIikge1xuICAgICAgICBjb25zdCBsaW5lcyA9IFtdO1xuICAgICAgICBsaW5lcy5wdXNoKFwie1wiKTtcbiAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXMob2JqKSkge1xuICAgICAgICAgIGxpbmVzLnB1c2goYFxcXCIke2sucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpfVxcXCI6ICR7bGlmdE9iamVjdCh2KX0sYCk7XG4gICAgICAgIH1cbiAgICAgICAgbGluZXMucHVzaChcIn1cIik7XG4gICAgICAgIHJldHVybiBsaW5lcy5qb2luKFwiXCIpO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGxpZnQgb2JqZWN0IG9mIHR5cGUgJHtvYmo/LmNvbnN0cnVjdG9yPy5uYW1lfWApO1xufVxuXG5leHBvcnQgdHlwZSBMaWZ0TWFwID0gUmVjb3JkPHN0cmluZywgQXJyYXk8W2FueSwgQXJyYXk8c3RyaW5nPl0+PjtcbmV4cG9ydCB0eXBlIExpZnRNYXBOb3JtYWxpemVkID0gUmVjb3JkPHN0cmluZywgTWFwPGFueSwgU2V0PHN0cmluZz4+PjtcblxuLyoqXG4gKiBNZXJnZSB0d28gbWF0cml4ZXMgb2YgbGlmdGluZyBkZXBlbmRlbmNpZXMuXG4gKlxuICogU2VlIHRoZSB1bml0IHRlc3RzIGluIGBsaWZ0aW5nLnRlc3QudHNgIGZvciBleGFtcGxlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlTGlmdERlcHMoXG4gIG1hdHJpeDE6IExpZnRNYXBOb3JtYWxpemVkID0ge30sXG4gIG1hdHJpeDI6IExpZnRNYXBOb3JtYWxpemVkID0ge31cbik6IExpZnRNYXBOb3JtYWxpemVkIHtcbiAgY29uc3QgcmVzdWx0OiBMaWZ0TWFwTm9ybWFsaXplZCA9IHt9O1xuICBmb3IgKGNvbnN0IFtvcCwgZGVwc10gb2YgT2JqZWN0LmVudHJpZXMobWF0cml4MSkpIHtcbiAgICByZXN1bHRbb3BdID0gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgW29iaiwgb2JqRGVwc10gb2YgZGVwcykge1xuICAgICAgcmVzdWx0W29wXS5zZXQob2JqLCBuZXcgU2V0KG9iakRlcHMpKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGNvbnN0IFtvcCwgZGVwc10gb2YgT2JqZWN0LmVudHJpZXMobWF0cml4MikpIHtcbiAgICBjb25zdCByZXN1bHREZXBzID0gcmVzdWx0W29wXSA/PyBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBbb2JqLCBvYmpEZXBzXSBvZiBkZXBzKSB7XG4gICAgICBjb25zdCByZXN1bHRPYmpEZXBzID0gcmVzdWx0RGVwcy5nZXQob2JqKSA/PyBuZXcgU2V0KCk7XG4gICAgICBmb3IgKGNvbnN0IGRlcCBvZiBvYmpEZXBzKSB7XG4gICAgICAgIHJlc3VsdE9iakRlcHMuYWRkKGRlcCk7XG4gICAgICB9XG4gICAgICByZXN1bHREZXBzLnNldChvYmosIHJlc3VsdE9iakRlcHMpO1xuICAgIH1cbiAgICByZXN1bHRbb3BdID0gcmVzdWx0RGVwcztcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBtYXRyaXggb2YgbGlmdGluZyBkZXBlbmRlbmNpZXMgZnJvbSB0aGUgZm9ybWF0IGVtaXR0ZWQgYnkgdGhlIFdpbmcgY29tcGlsZXJcbiAqICh1c2luZyBwbGFpbiBvYmplY3RzIGFuZCBhcnJheXMpIHRvIGEgZGVuc2VyIGZvcm1hdCAodXNpbmcgTWFwcyBhbmQgU2V0cyksXG4gKiBkZWR1cGxpY2F0aW5nIG9iamVjdCByZWZlcmVuY2VzIGlmIG5lZWRlZC5cbiAqXG4gKiBUaGUgZGVkdXBsaWNhdGlvbiBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgY29tcGlsZXIgbWlnaHQgZ2VuZXJhdGUgc29tZXRoaW5nIGxpa2U6XG4gKiBgYGBcbiAqIFtcbiAqICAgW29iajEsIFtcIm9wMVwiXV0sXG4gKiAgIFtvYmoyLCBbXCJvcDJcIl1dLFxuICogXVxuICogYGBgXG4gKiBub3Qga25vd2luZyB0aGF0IGR1cmluZyBwcmVmbGlnaHQgZXhlY3V0aW9uLCBvYmoxIGFuZCBvYmoyIGFyZSB0aGUgc2FtZSBvYmplY3QuXG4gKiBUaGUgZGVkdXBsaWNhdGlvbiB3aWxsIHR1cm4gdGhpcyBpbnRvOlxuICogYGBgXG4gKiBuZXcgTWFwKFtvYmoxLCBuZXcgU2V0KFtcIm9wMVwiLCBcIm9wMlwiXSldKVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIHBhcnNlTWF0cml4KGRhdGE6IExpZnRNYXApOiBMaWZ0TWFwTm9ybWFsaXplZCB7XG4gIGNvbnN0IHJlc3VsdDogTGlmdE1hcE5vcm1hbGl6ZWQgPSB7fTtcbiAgZm9yIChjb25zdCBbb3AsIHBhaXJzXSBvZiBPYmplY3QuZW50cmllcyhkYXRhKSkge1xuICAgIHJlc3VsdFtvcF0gPSBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBbb2JqLCBvYmpEZXBzXSBvZiBwYWlycykge1xuICAgICAgaWYgKCFyZXN1bHRbb3BdLmhhcyhvYmopKSB7XG4gICAgICAgIHJlc3VsdFtvcF0uc2V0KG9iaiwgbmV3IFNldCgpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRlcFNldCA9IHJlc3VsdFtvcF0uZ2V0KG9iaikhO1xuICAgICAgZm9yIChjb25zdCBkZXAgb2Ygb2JqRGVwcykge1xuICAgICAgICBkZXBTZXQuYWRkKGRlcCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIGZvciBkZWJ1Z2dpbmdcbi8vIGZ1bmN0aW9uIHByaW50TWF0cml4KGRhdGE6IExpZnRNYXBOb3JtYWxpemVkKTogc3RyaW5nIHtcbi8vICAgY29uc3QgbGluZXMgPSBbXTtcbi8vICAgZm9yIChjb25zdCBbb3AsIHBhaXJzXSBvZiBPYmplY3QuZW50cmllcyhkYXRhKSkge1xuLy8gICAgIGxpbmVzLnB1c2goYCR7b3B9OiB7YCk7XG4vLyAgICAgZm9yIChjb25zdCBbb2JqLCBvYmpEZXBzXSBvZiBwYWlycykge1xuLy8gICAgICAgaWYgKENvbnN0cnVjdC5pc0NvbnN0cnVjdChvYmopKSB7XG4vLyAgICAgICAgIGxpbmVzLnB1c2goYCAgJHtvYmoubm9kZS5wYXRofTogWyR7Wy4uLm9iakRlcHNdfV1gKTtcbi8vICAgICAgIH0gZWxzZSB7XG4vLyAgICAgICAgIGxpbmVzLnB1c2goYCAgJHtvYmo/LmNvbnN0cnVjdG9yPy5uYW1lID8/IG9ian06IFske1suLi5vYmpEZXBzXX1dYCk7XG4vLyAgICAgICB9XG4vLyAgICAgfVxuLy8gICAgIGxpbmVzLnB1c2goXCJ9XCIpO1xuLy8gICB9XG4vLyAgIHJldHVybiBsaW5lcy5qb2luKFwiXFxuXCIpO1xuLy8gfVxuXG4vKipcbiAqIENvbGxlY3RzIGFsbCBvZiB0aGUgb2JqZWN0cyB0aGF0IG5lZWQgdG8gYmUgbGlmdGVkIGZvciBhIGdpdmVuIG9iamVjdCBhbmQgc2V0IG9mIG9wZXJhdGlvbnMsIGJ5XG4gKiB0cmF2ZXJzaW5nIHRoZSBvYmplY3QgZ3JhcGguXG4gKlxuICogSW50ZXJuYWxseSwgaXQga2VlcHMgdHJhY2sgb2YgYSBxdWV1ZSBvZiBvYmplY3RzIGFuZCBjb3JyZXNwb25kaW5nIG9wZXJhdGlvbnMgdGhhdCBuZWVkIHRvIGJlIGxpZnRlZFxuICogYnkgdGhlIGluZmxpZ2h0IGhvc3QgKHRoZSBleHBsb3JlZCBzZXQpLCBhbmQgYSBxdWV1ZSBvZiBvYmplY3RzIGFuZCBvcGVyYXRpb25zIHRoYXQgbmVlZCB0byBiZVxuICogZXhwbG9yZWQgKHRoZSBxdWV1ZSkuIE9iamVjdHMgKGFueSBKYXZhU2NyaXB0IHZhbHVlcykgY2FuIGJlIHJlLWFkZGVkIHRvIHRoZSBxdWV1ZSBtdWx0aXBsZSB0aW1lc1xuICogaWYgbmV3IG9wZXJhdGlvbnMgYXJlIGRldGVybWluZWQgYXMgbmVlZGVkIGJ5IHRoZSBpbmZsaWdodCBob3N0LlxuICpcbiAqIEZvciBleGFtcGxlLCBzdXBwb3NlIGFuIGluZmxpZ2h0IGhvc3QgbmVlZHMgdG8gY2FsbCBvcDEgb24gb2JqZWN0IEEgYW5kIG9wMiBvbiBvYmplY3QgQi5cbiAqIEluIGFkZGl0aW9uLCBvYmplY3QgQiBuZWVkcyBvcDMgb24gb2JqZWN0IEEuXG4gKiBUaGUgZXhwbG9yZWQgc2V0IGFuZCBxdWV1ZSBhZnRlciBlYWNoIHN0ZXAgb2YgdGhlIG1haW4gbG9vcCBpcyBzaG93biBiZWxvdzpcbiAqXG4gKiBgYGBcbiAqIGV4cGxvcmVkOiB7fSB8IHF1ZXVlOiBbKEEsIFtvcDFdKSwgKEIsIFtvcDJdKV1cbiAqIGV4cGxvcmVkOiB7QTogW29wMV19IHwgcXVldWU6IFsoQiwgW29wMl0pXVxuICogZXhwbG9yZWQ6IHtBOiBbb3AxXSwgQjogW29wMl19IHwgcXVldWU6IFsoQSwgW29wM10pXVxuICogZXhwbG9yZWQ6IHtBOiBbb3AxLCBvcDNdLCBCOiBbb3AyXX0gfCBxdWV1ZTogW11cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbGxlY3RMaWZ0cyhcbiAgaW5pdGlhbE9iajogYW55LFxuICBpbml0aWFsT3BzOiBBcnJheTxzdHJpbmc+XG4pOiBNYXA8YW55LCBTZXQ8c3RyaW5nPj4ge1xuICBpZiAoaW5pdGlhbE9wcy5pbmNsdWRlcyhJTkZMSUdIVF9JTklUX01FVEhPRF9OQU1FKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBUaGUgb3BlcmF0aW9uICR7SU5GTElHSFRfSU5JVF9NRVRIT0RfTkFNRX0gaXMgaW1wbGljaXQgYW5kIHNob3VsZCBub3QgYmUgcmVxdWVzdGVkIGV4cGxpY2l0bHkuYFxuICAgICk7XG4gIH1cblxuICBjb25zdCBleHBsb3JlZCA9IG5ldyBNYXA8YW55LCBTZXQ8c3RyaW5nPj4oKTtcbiAgY29uc3QgcXVldWUgPSBuZXcgQXJyYXk8W2FueSwgQXJyYXk8c3RyaW5nPl0+KFtpbml0aWFsT2JqLCBbLi4uaW5pdGlhbE9wc11dKTtcbiAgY29uc3QgbWF0cml4Q2FjaGUgPSBuZXcgTWFwPGFueSwgTGlmdE1hcE5vcm1hbGl6ZWQ+KCk7XG5cbiAgd2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAvLyBgb2JqYCBhbmQgYG9wc2AgYXJlIHRoZSBwcmVmbGlnaHQgb2JqZWN0IGFuZCBvcGVyYXRpb25zIHJlcXVlc3RlZCBvbiBpdFxuICAgIGxldCBbb2JqLCBvcHNdOiBbYW55LCBBcnJheTxzdHJpbmc+XSA9IHF1ZXVlLnNoaWZ0KCkhO1xuXG4gICAgbGV0IG5ld09iaiA9IGZhbHNlO1xuICAgIGlmICghZXhwbG9yZWQuaGFzKG9iaikpIHtcbiAgICAgIGV4cGxvcmVkLnNldChvYmosIG5ldyBTZXQoKSk7XG4gICAgICBuZXdPYmogPSB0cnVlO1xuICAgIH1cblxuICAgIGxldCBleGlzdGluZ09wcyA9IGV4cGxvcmVkLmdldChvYmopITtcblxuICAgIC8vIEZpbHRlciBvdXQgYW55IG9wcyB0aGF0IHdlJ3ZlIGFscmVhZHkgcHJvY2Vzc2VkIGZvciB0aGlzIG9iamVjdC5cbiAgICBvcHMgPSBvcHMuZmlsdGVyKChvcCkgPT4gIWV4aXN0aW5nT3BzLmhhcyhvcCkpO1xuXG4gICAgLy8gSWYgdGhlcmUgYXJlIG5vIG9wcyBsZWZ0IGFuZCB3ZSBoYXZlIGFscmVhZHkgc2VlbiB0aGUgb2JqZWN0LCBza2lwIGZ1cnRoZXIgcHJvY2Vzc2luZy5cbiAgICBpZiAob3BzLmxlbmd0aCA9PT0gMCAmJiAhbmV3T2JqKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBBZGQgdGhlIG5ldyBvcHMgdG8gdGhlIGV4cGxvcmVkIHNldC5cbiAgICBmb3IgKGNvbnN0IG9wIG9mIG9wcykge1xuICAgICAgZXhpc3RpbmdPcHMuYWRkKG9wKTtcbiAgICB9XG5cbiAgICAvLyBJbnNwZWN0IHRoZSBvYmplY3QgdG8gc2VlIGlmIHRoZXJlIGFyZSBhbnkgdHJhbnNpdGl2ZSBkZXBlbmRlbmN5IGluZm9ybWF0aW9uLlxuICAgIC8vIEN1cnJlbnRseSB0aGVyZSBhcmUgYSBmZXcgd2F5cyB0byBkbyB0aGlzOlxuICAgIC8vIC0gVGhlIGNvbXBpbGVyIG1heSBnZW5lcmF0ZSBhIF9saWZ0TWFwIHByb3BlcnR5IG9uIHRoZSBvYmplY3RcbiAgICAvLyAtIFRoZSBjb21waWxlciBtYXkgZ2VuZXJhdGUgYSBzdGF0aWMgX2xpZnRUeXBlTWFwIG1ldGhvZCBvbiBhIGNsYXNzXG5cbiAgICBsZXQgbWF0cml4OiBMaWZ0TWFwTm9ybWFsaXplZDtcbiAgICBpZiAobWF0cml4Q2FjaGUuaGFzKG9iaikpIHtcbiAgICAgIG1hdHJpeCA9IG1hdHJpeENhY2hlLmdldChvYmopITtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiYgb2JqLl9saWZ0TWFwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG1hdHJpeCA9IHBhcnNlTWF0cml4KG9iai5fbGlmdE1hcCA/PyB7fSk7XG4gICAgICBtYXRyaXhDYWNoZS5zZXQob2JqLCBtYXRyaXgpO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgIHR5cGVvZiBvYmouX2xpZnRUeXBlTWFwICE9PSB1bmRlZmluZWRcbiAgICApIHtcbiAgICAgIG1hdHJpeCA9IHBhcnNlTWF0cml4KG9iai5fbGlmdFR5cGVNYXAgPz8ge30pO1xuICAgICAgbWF0cml4Q2FjaGUuc2V0KG9iaiwgbWF0cml4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdGhlIG9iamVjdCBkb2Vzbid0IGhhdmUgYW55IGRlcGVuZGVuY3kgaW5mb3JtYXRpb24sIHdlIGNhbiBza2lwIGl0LlxuICAgICAgLy8gSW4gdGhlIGZ1dHVyZSwgd2UgbWlnaHQgd2FudCB0byBkbyBtb3JlIGFkdmFuY2VkIGFuYWx5c2lzIHRvXG4gICAgICAvLyBsaWZ0IGNvbGxlY3Rpb25zIG9mIG9iamVjdHMgd2l0aCBvbkxpZnQgbWV0aG9kcyBldGMuXG5cbiAgICAgIC8vIEJlZm9yZSB3ZSBgY29udGludWVgIHRvIHRoZSBuZXh0IGl0ZXJhdGlvbiwgY2hlY2sgZm9yIHNvbWUgYmFzaWMgY29sbGVjdGlvbiB0eXBlc1xuICAgICAgLy8gc28gaWYgdGhlIHVzZXIgcHV0cyB0b2tlbnMgaW4gYSBjb2xsZWN0aW9uLCB0aGV5J2xsIGdldCBsaWZ0ZWQuXG4gICAgICAvL1xuICAgICAgLy8gV2UgY2FuJ3QgY2FsY3VsYXRlIHdoYXQgb3BzIHRvIHB1dCBmb3IgdGhlIGNvbGxlY3Rpb24gaXRlbXMgKGZvclxuICAgICAgLy8gZXhhbXBsZSwgZm9yIGNhc2VzIHdoZXJlIHRoZSBpdGVtcyBhcmUgcmVzb3VyY2VzKSBzaW5jZSB0aGUgY29tcGlsZXJcbiAgICAgIC8vIGRvZXNuJ3QgcHJvZHVjZSB0aGF0IGluZm9ybWF0aW9uIHlldC5cblxuICAgICAgbGV0IGl0ZW1zX3RvX2V4cGxvcmU6IEl0ZXJhYmxlPGFueT4gPSBbXTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgaXRlbXNfdG9fZXhwbG9yZSA9IG9iajtcbiAgICAgIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgIGl0ZW1zX3RvX2V4cGxvcmUgPSBvYmo7XG4gICAgICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICBpdGVtc190b19leHBsb3JlID0gb2JqLnZhbHVlcygpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIk9iamVjdFwiKSB7XG4gICAgICAgIGl0ZW1zX3RvX2V4cGxvcmUgPSBPYmplY3QudmFsdWVzKG9iaik7XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtc190b19leHBsb3JlKSB7XG4gICAgICAgIGlmICghZXhwbG9yZWQuaGFzKGl0ZW0pKSB7XG4gICAgICAgICAgbGV0IGl0ZW1fb3BzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICAgIC8vIElmIHRoZSBpdGVtIGlzIGFuIGluZmxpZ2h0IGNsb3N1cmUgdHlwZSB0aGVuIGltcGxpY2l0bHkgYWRkIHRoZSBcImhhbmRsZVwiIG9wZXJhdGlvblxuICAgICAgICAgIGlmIChpc0luZmxpZ2h0Q2xvc3VyZU9iamVjdChpdGVtKSkge1xuICAgICAgICAgICAgaXRlbV9vcHMucHVzaChJTkZMSUdIVF9DTE9TVVJFX0hBTkRMRV9NRVRIT0QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBxdWV1ZS5wdXNoKFtpdGVtLCBpdGVtX29wc10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IG9wIG9mIFsuLi5vcHMsIElORkxJR0hUX0lOSVRfTUVUSE9EX05BTUVdKSB7XG4gICAgICBjb25zdCBvYmpEZXBzID0gbWF0cml4W29wXTtcblxuICAgICAgLy8gSWYgdGhlIG9wIGlzICRpbmZsaWdodF9pbml0LCB0aGVuIHRoZSBvcGVyYXRpb24gaXMgaW1wbGljaXRcbiAgICAgIC8vIHNvIGl0J3Mgb2theSBpdCdzIG5vdCBkZWZpbmVkIGluIHRoZSBtYXRyaXhcbiAgICAgIGlmIChvcCA9PT0gSU5GTElHSFRfSU5JVF9NRVRIT0RfTkFNRSAmJiAhb2JqRGVwcykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFvYmpEZXBzKSB7XG4gICAgICAgIGlmIChDb25zdHJ1Y3QuaXNDb25zdHJ1Y3Qob2JqKSkge1xuICAgICAgICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFxuICAgICAgICAgICAgYFJlc291cmNlICR7b2JqLm5vZGUucGF0aH0gZG9lcyBub3Qgc3VwcG9ydCBpbmZsaWdodCBvcGVyYXRpb24gJHtvcH0uXFxuSXQgbWlnaHQgbm90IGJlIGltcGxlbWVudGVkIHlldC5gLFxuICAgICAgICAgICAgeyByZXNvdXJjZTogb2JqLmNvbnN0cnVjdG9yLm5hbWUsIG9wZXJhdGlvbjogb3AgfVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFVua25vd24gb3BlcmF0aW9uICR7b3B9IHJlcXVlc3RlZCBmb3Igb2JqZWN0ICR7b2JqfSAoJHtvYmouY29uc3RydWN0b3IubmFtZX0pYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBbZGVwT2JqLCBkZXBPcHNdIG9mIG9iakRlcHMuZW50cmllcygpKSB7XG4gICAgICAgIGlmIChkZXBPcHMuaGFzKElORkxJR0hUX0lOSVRfTUVUSE9EX05BTUUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFRoZSBvcGVyYXRpb24gJHtJTkZMSUdIVF9JTklUX01FVEhPRF9OQU1FfSBpcyBpbXBsaWNpdCBhbmQgc2hvdWxkIG5vdCBiZSByZXF1ZXN0ZWQgZXhwbGljaXRseS5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBxdWV1ZS5wdXNoKFtkZXBPYmosIFsuLi5kZXBPcHNdXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV4cGxvcmVkO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gaXRlbSBpcyBhbiBpbmZsaWdodCBjbG9zdXJlIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gaXNJbmZsaWdodENsb3N1cmVPYmplY3QoaXRlbTogYW55KTogYm9vbGVhbiB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIGl0ZW0gPT09IFwib2JqZWN0XCIgJiZcbiAgICB0eXBlb2YgaXRlbS5jb25zdHJ1Y3RvciA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgdHlwZW9mIGl0ZW0uY29uc3RydWN0b3IubmFtZSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgIGl0ZW0uY29uc3RydWN0b3IubmFtZS5zdGFydHNXaXRoKElORkxJR0hUX0NMT1NVUkVfVFlQRV9QUkVGSVgpICYmXG4gICAgaXRlbS5fbGlmdE1hcCAhPT0gdW5kZWZpbmVkICYmXG4gICAgaXRlbS5fbGlmdE1hcFtJTkZMSUdIVF9DTE9TVVJFX0hBTkRMRV9NRVRIT0RdICE9PSB1bmRlZmluZWRcbiAgKTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgdHlwZSB3aXRoIHN0YXRpYyBtZXRob2RzIHRoYXQgbWF5IGhhdmUgb3RoZXIgdGhpbmdzIHRvIGxpZnQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSUxpZnRhYmxlVHlwZSB7XG4gIC8qKlxuICAgKiBDb21waWxlci1nZW5lcmF0ZWQgZGF0YSB0aGF0IGRlc2NyaWJlcyB0aGUgZGVwZW5kZW5jaWVzIG9mIHRoaXMgb2JqZWN0IG9uIG90aGVyXG4gICAqIG9iamVjdHMuIFRoaXMgaXMgdXNlZCB0byBkZXRlcm1pbmUgd2hpY2ggcGVybWlzc2lvbnMgbmVlZCB0byBiZSBncmFudGVkIHRvIHRoZVxuICAgKiBpbmZsaWdodCBob3N0LlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9saWZ0VHlwZU1hcD86IExpZnRNYXA7XG5cbiAgLyoqXG4gICAqIEEgaG9vayBjYWxsZWQgYnkgdGhlIFdpbmcgY29tcGlsZXIgb25jZSBmb3IgZWFjaCBpbmZsaWdodCBob3N0IHRoYXQgbmVlZHMgdG9cbiAgICogdXNlIHRoaXMgdHlwZSBpbmZsaWdodC4gVGhlIGxpc3Qgb2YgcmVxdWVzdGVkIGluZmxpZ2h0IG1ldGhvZHNcbiAgICogbmVlZGVkIGJ5IHRoZSBpbmZsaWdodCBob3N0IGFyZSBnaXZlbiBieSBgb3BzYC5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgY29tbW9ubHkgdXNlZCBmb3IgYWRkaW5nIHBlcm1pc3Npb25zLCBlbnZpcm9ubWVudCB2YXJpYWJsZXMsIG9yXG4gICAqIG90aGVyIGNhcGFiaWxpdGllcyB0byB0aGUgaW5mbGlnaHQgaG9zdC5cbiAgICovXG4gIG9uTGlmdFR5cGUoaG9zdDogSUluZmxpZ2h0SG9zdCwgb3BzOiBzdHJpbmdbXSk6IHZvaWQ7XG59XG5cbi8qKlxuICogTGlmdGluZyB1dGlsaXRpZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBMaWZ0aW5nIHtcbiAgLyoqXG4gICAqIFBlcmZvcm0gdGhlIGZ1bGwgbGlmdGluZyBwcm9jZXNzIG9uIGFuIG9iamVjdC5cbiAgICpcbiAgICogVXNlIHRoaXMgaW5zdGVhZCBvZiBjYWxsaW5nIGBvbkxpZnRgIHNpbmNlIGl0IHdpbGwgYWxzbyBsaWZ0IGFsbCBvZiB0aGVcbiAgICogb2JqZWN0J3MgZGVwZW5kZW5jaWVzLCBhbmQgaXQgd2lsbCBlbnN1cmUgdGhhdCB0aGUgb25MaWZ0IG1ldGhvZHMgb2ZcbiAgICogYWxsIG9iamVjdHMgYXJlIGFsbCBjYWxsZWQgYXQgbW9zdCBvbmNlLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBsaWZ0KFxuICAgIG9iajogSUhvc3RlZExpZnRhYmxlLFxuICAgIGhvc3Q6IElJbmZsaWdodEhvc3QsXG4gICAgb3BzOiBBcnJheTxzdHJpbmc+XG4gICkge1xuICAgIC8vIG9idGFpbiBhbGwgb2YgdGhlIG9iamVjdHMgdGhhdCBuZWVkIGxpZnRpbmdcbiAgICBjb25zdCBsaWZ0cyA9IGNvbGxlY3RMaWZ0cyhvYmosIG9wcyk7XG5cbiAgICAvLyBjYWxsIGFsbCBvZiB0aGUgb25MaWZ0IG1ldGhvZHNcbiAgICBmb3IgKGNvbnN0IFtsaWZ0ZWRPYmosIGxpZnRlZE9wc10gb2YgbGlmdHMpIHtcbiAgICAgIGNvbnN0IHRva2VucyA9IGdldFRva2VuUmVzb2x2ZXIobGlmdGVkT2JqKTtcbiAgICAgIGlmICh0b2tlbnMpIHtcbiAgICAgICAgdG9rZW5zLm9uTGlmdFZhbHVlKGhvc3QsIGxpZnRlZE9iaik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIHR5cGVvZiBsaWZ0ZWRPYmogPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgdHlwZW9mIGxpZnRlZE9iai5vbkxpZnQgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgKSB7XG4gICAgICAgIGxpZnRlZE9iai5vbkxpZnQoaG9zdCwgWy4uLmxpZnRlZE9wc10pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICB0eXBlb2YgbGlmdGVkT2JqID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgdHlwZW9mIGxpZnRlZE9iai5vbkxpZnRUeXBlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICkge1xuICAgICAgICBsaWZ0ZWRPYmoub25MaWZ0VHlwZShob3N0LCBbLi4ubGlmdGVkT3BzXSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBubyBsaWZ0LXJlbGF0ZWQgbWV0aG9kcyB0byBjYWxsIC0gaXQncyBwcm9iYWJseSBhIHByaW1pdGl2ZVxuICAgICAgLy8gc28gbm8gY2FwYWJpbGl0aWVzIG5lZWQgdG8gYmUgYWRkZWQgdG8gdGhlIGluZmxpZ2h0IGhvc3RcbiAgICB9XG4gIH1cbn1cbiJdfQ==