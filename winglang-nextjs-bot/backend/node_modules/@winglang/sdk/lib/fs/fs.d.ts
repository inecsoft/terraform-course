/// <reference types="node" />
import { Datetime, Json } from "../std";
/**
 * Custom settings for reading from a file
 */
export interface ReadFileOptions {
    /**
     * The character encoding utilized for file reading.
     * @default "utf-8"
     */
    readonly encoding?: BufferEncoding;
    /**
     * The `flag` can be set to specify the attributes.
     * @default "r".
     */
    readonly flag?: string;
}
/**
 * Custom settings for writing to a file
 */
export interface WriteFileOptions {
    /**
     * The character encoding utilized for file writing.
     * @default "utf-8"
     */
    readonly encoding?: BufferEncoding;
    /**
     * The `flag` can be set to specify the attributes.
     * @default "w".
     */
    readonly flag?: string;
}
/**
 * Custom settings for creating directory
 */
export interface MkdirOptions {
    /**
     * Indicates whether parent folders should be created.
     * If a folder was created, the path to the first created folder will be returned.
     * @default true
     */
    readonly recursive?: boolean;
    /**
     * A file mode. The string will be parsed as an octal integer.
     * @default "0777"
     */
    readonly mode?: string;
}
/**
 * Custom settings for removing files and directories
 */
export interface RemoveOptions {
    /**
     * When `true`, exceptions will be ignored if `path` does not exist.
     * @default true
     */
    readonly force?: boolean;
    /**
     * If `true`, perform a recursive directory removal. In
     * recursive mode, operations are retried on failure.
     * @default true
     */
    readonly recursive?: boolean;
}
/**
 * Represents the type of a file system object.
 */
export declare enum FileType {
    /** Represents a regular file. */
    FILE = "File",
    /** Represents a directory. */
    DIRECTORY = "Directory",
    /** Represents a symbolic link. */
    SYMLINK = "Symlink",
    /**
     * Represents any type of file system object that is not `FILE`, `DIRECTORY` or `SYMLINK`.
     * This includes sockets, FIFOs (named pipes), block devices, and character devices.
     */
    OTHER = "Other"
}
/**
 * Represents the type of the target for creating symbolic links.
 */
export declare enum SymlinkType {
    /** Symbolic link that points to a file. */
    FILE = "file",
    /** Symbolic link that points to a directory. */
    DIRECTORY = "dir",
    /** Windows-specific: Symbolic link that points to a directory junction. */
    JUNCTION = "junction"
}
/**
 * Metadata of a file system object.
 */
export interface Metadata {
    /** The type of file. */
    readonly fileType: FileType;
    /** The size of the file in bytes. */
    readonly size: number;
    /** The permissions of the file. */
    readonly permissions: string;
    /** The date and time the file was last accessed. */
    readonly accessed: Datetime;
    /** The date and time the file was last modified. */
    readonly modified: Datetime;
    /** The date and time the file was created. */
    readonly created: Datetime;
}
/**
 * Options for `glob`, based on https://www.npmjs.com/package/glob
 */
export interface GlobOptions {
    /**
     * The current working directory in which to search.
     *
     * @default process.cwd()
     */
    readonly cwd?: string;
    /**
     * Include `.dot` files in normal matches and globstar matches. Note that an explicit dot in a
     * portion of the pattern will always match dot files.
     *
     * @default false
     */
    readonly dot?: boolean;
    /**
     * Do not match directories, only files. (Note: to match only directories, put a `/` at the end of
     * the pattern.)
     *
     * @default false
     */
    readonly nodir?: boolean;
    /**
     * An array of glob patterns to exclude from matches. To ignore all children within a directory,
     * as well as the entry itself, append '/**' to the ignore pattern.
     * @default []
     */
    readonly ignore?: string[];
    /**
     * Follow symlinked directories when expanding `**` patterns. This can result in a lot of
     * duplicate references in the presence of cyclic links, and make performance quite bad.
     * @default false
     */
    readonly follow?: boolean;
    /**
     * Set to `true` to always receive absolute paths for matched files. Set to `false` to always
     * receive relative paths for matched files.
     * @default false
     */
    readonly absolute?: boolean;
    /**
     * Specify a number to limit the depth of the directory traversal to this many levels below the
     * cwd.
     *
     * @default - no limit
     */
    readonly maxDepth?: number;
}
/**
 * The fs class is used for interacting with the file system.
 * All file paths must be POSIX file paths (/ instead of \),
 * and will be normalized to the target platform if running on Windows.
 */
export declare class Util {
    /**
     * Join all arguments together and normalize the resulting path.
     * @param paths The array of path need to join.
     * @returns The resulting path after joining all the paths.
     */
    static join(...paths: string[]): string;
    /**
     * Retrieve the name of the directory from a given file path.
     * @param path The path to evaluate.
     * @returns The directory name of the path.
     */
    static dirname(path: string): string;
    /**
     * Retrieve the final segment of a given file path.
     * @param path The path to evaluate.
     * @returns The last portion of a path.
     */
    static basename(path: string): string;
    /**
     * Solve the relative path from {from} to {to} based on the current working directory.
     * At times we have two absolute paths, and we need to derive the relative path from one to the other.
     * @returns The relative path from {from} to {to}.
     */
    static relative(from: string, to: string): string;
    /**
     * The right-most parameter is considered {to}. Other parameters are considered an array of {from}.
     *
     * Starting from leftmost {from} parameter, resolves {to} to an absolute path.
     *
     * If {to} isn't already absolute, {from} arguments are prepended in right to left order,
     * until an absolute path is found. If after using all {from} paths still no absolute path is found,
     * the current working directory is used as well. The resulting path is normalized,
     * and trailing slashes are removed unless the path gets resolved to the root directory.
     *
     * @param paths A sequence of paths or path segments.
     * @returns The resulting path after performing the resolve operation.
     */
    static absolute(...paths: string[]): string;
    /**
     * Check if the path exists.
     * @param path The path to evaluate.
     * @returns `true` if the path exists, `false` otherwise.
     */
    static exists(path: string): boolean;
    /**
     * Read the contents of the directory.
     * @param dirpath The path to evaluate.
     * @returns The contents of the directory.
     */
    static readdir(dirpath: string): Array<string>;
    /**
     * If the path exists, read the contents of the directory; otherwise, return `undefined`.
     * @param dirpath The path to evaluate.
     * @returns The contents of the directory if the path exists, `undefined` otherwise.
     */
    static tryReaddir(dirpath: string): Array<string> | undefined;
    /**
     * Create a directory.
     * @param dirpath The path to the directory you want to create.
     */
    static mkdir(dirpath: string, opts?: MkdirOptions): void;
    /**
     * Create a temporary directory.
     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
     * @param prefix The prefix for the directory to be created, default `wingtemp`.
     * @returns The created directory path.
     */
    static mkdtemp(prefix?: string): string;
    /**
     * Read the entire contents of a file.
     * @param filepath The path of the file to be read.
     * @param options The `encoding` can be set to specify the character encoding. And the `flag` can be set to specify the attributes.
     * If a flag is not provided, it defaults to `"r"`.
     * @returns The contents of the `filepath`.
     */
    static readFile(filepath: string, options?: ReadFileOptions): string;
    /**
     * If the file exists and can be read successfully, read the entire contents;
     * otherwise, return `undefined`.
     * @param filepath The path of the file to be read.
     * @param options The `encoding` can be set to specify the character encoding, or the `flag` can be set to specify the attributes.
     * @returns The contents of the `filepath`, `undefined` otherwise.
     */
    static tryReadFile(filepath: string, options?: ReadFileOptions): string | undefined;
    /**
     * Read the contents of the file and convert it to JSON.
     * @param filepath The file path of the JSON file.
     * @returns The JSON object contained in the file.
     * @throws Will throw if the content is not in valid JSON format.
     */
    static readJson(filepath: string): Json;
    /**
     * Retrieve the contents of the file and convert it to JSON
     * if the file exists and can be parsed successfully, otherwise, return `undefined`.
     * @param filepath The file path of the JSON file.
     * @returns The JSON object contained in the file, `undefined` otherwise.
     * @throws Will throw if the content is not in valid JSON format.
     */
    static tryReadJson(filepath: string): Json | undefined;
    /**
     * Convert all YAML objects from a single file into JSON objects.
     * @param filepath The file path of the YAML file.
     * @returns The JSON objects converted from YAML objects in the file.
     * @throws Will throw if the content is not in valid YAML format.
     */
    static readYaml(filepath: string): Json[];
    /**
     * Convert all YAML objects from a single file into JSON objects
     * if the file exists and can be parsed successfully, `undefined` otherwise.
     * @param filepath The file path of the YAML file.
     * @returns The JSON objects converted from YAML objects in the file, `undefined` otherwise.
     * @throws Will throw if the content is not in valid YAML format.
     */
    static tryReadYaml(filepath: string): Json[] | undefined;
    /**
     * Writes data to a file, replacing the file if it already exists.
     * @param filepath The file path that needs to be written.
     * @param data The data to write.
     * @param options The `encoding` can be set to specify the character encoding. And the `flag` can be set to specify the attributes.
     * If a flag is not provided, it defaults to `"w"`.
     */
    static writeFile(filepath: string, data: string, options?: WriteFileOptions): void;
    /**
     * Writes JSON to a file, replacing the file if it already exists.
     * @param filepath The file path that needs to be written.
     * @param obj The JSON object to be dumped.
     */
    static writeJson(filepath: string, obj: Json): void;
    /**
     * Writes multiple YAML objects to a file, replacing the file if it already exists.
     * @param filepath The file path that needs to be written.
     * @param objs The YANL objects to be dumped.
     */
    static writeYaml(filepath: string, ...objs: Json[]): void;
    /**
     * Appends new data to the end of an existing file
     * @param filepath The file path that needs to be appended.
     * @param data The text to be appended to the file.
     * @param options The `encoding` can be set to specify the character encoding. And the `flag` can be set to specify the attributes.
     * If a flag is not provided, it defaults to `"w"`.
     */
    static appendFile(filepath: string, data: string, options?: WriteFileOptions): void;
    /**
     * Remove files and directories (modeled on the standard POSIX `rm`utility). Returns `undefined`.
     * @param path The path to the file or directory you want to remove.
     */
    static remove(path: string, opts?: RemoveOptions): void;
    /**
     * Checks if the given path is a directory and exists.
     * @param path The path to check.
     * @returns `true` if the path is an existing directory, `false` otherwise.
     */
    static isDir(path: string): boolean;
    /**
     * Gets the stats of the given path.
     * @param path The path to get stats for.
     * @returns The stats of the path, formatted as a `Metadata` object.
     */
    static metadata(path: string): Metadata;
    /**
     * Gets the stats of the given path without following symbolic links.
     * @param path The path to get stats for.
     * @returns The stats of the path, formatted as a `Metadata` object.
     */
    static symlinkMetadata(path: string): Metadata;
    /**
     * Set the permissions of the file, directory, etc.
     * Expects a permission string like `"755"` or `"644"`.
     * @param path The path of the file or directory.
     * @param permissions The mode to set as a string.
     */
    static setPermissions(path: string, permissions: string): void;
    /**
     * Extracts the extension (without the leading dot) from the path, if possible.
     * @param path The path to get extension for.
     * @returns The file extension without the leading dot, or `nil` if:
     *          - The file name starts with a dot (hidden files).
     *          - There is no dot in the file name.
     *          - The dot is the last character in the file name.
     */
    static extension(path: string): string | undefined;
    /**
     * Creates a symbolic link.
     * @param target The path to the target file or directory.
     * @param path The path to the symbolic link to be created.
     * @param type The type of the target. It can be `FILE`, `DIRECTORY`, or `JUNCTION` (Windows only).
     *             Defaults to `FILE` if not specified.
     */
    static symlink(target: string, path: string, type?: SymlinkType): void;
    /**
     * Match files using the patterns the shell uses.
     *
     * Built with the great `glob` package, based on https://www.npmjs.com/package/glob
  
     * @param pattern The pattern to match.
     * @param options Glob options.
     * @returns List of matching files.
     */
    static glob(pattern: string, options?: GlobOptions): string[];
    /**
     * Calculate an MD5 content hash of all the files that match a glob pattern.
     *
     * @param dir The root directory.
     * @param globPattern The glob pattern to match (defaults to all files and subdirectories).
     * @returns An md5 hash of the file contents.
     */
    static md5(dir: string, globPattern?: string): string;
    /**
     * @internal
     */
    static _toInflightType(): string;
    /**
     * Returns the `Metadata` object based on the given `fs.Stats` object.
     * @param stats The `fs.Stats` object.
     * @returns The `Metadata` object.
     */
    private static _metadata;
    /**
     * Returns the type of the file based on the given `fs.Stats` object.
     * @param stats The `fs.Stats` object.
     * @returns The type of the file.
     */
    private static _fileType;
    /**
     * Converts a numeric mode into a string representation of its permissions.
     * For example, this will convert the numeric mode `33279` into a `"755"` string.
     * @param mode The numeric mode to convert.
     * @returns A string representation of the permissions.
     */
    private static _formatPermissions;
}
