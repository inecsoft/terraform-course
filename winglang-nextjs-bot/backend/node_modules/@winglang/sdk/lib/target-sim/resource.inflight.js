"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Resource = void 0;
const path = __importStar(require("path"));
const resource_1 = require("./resource");
const bundling_1 = require("../shared/bundling");
const sandbox_1 = require("../shared/sandbox");
const simulator_1 = require("../simulator");
const std_1 = require("../std");
class Resource {
    constructor(props) {
        this.timeout = 30000;
        this.sourceCodeFile = props.sourceCodeFile;
    }
    get context() {
        if (!this._context) {
            throw new Error("Cannot access context during class construction");
        }
        return this._context;
    }
    async createBundle() {
        this.bundle = await sandbox_1.Sandbox.createBundle(this.resolvedSourceCodeFile, (msg, level) => {
            this.addTrace(msg, std_1.TraceType.RESOURCE, level);
        });
    }
    async init(context) {
        this._context = context;
        this.resolvedSourceCodeFile = path.resolve(context.simdir, this.sourceCodeFile);
        await this.createBundle();
        this.sandbox = new sandbox_1.Sandbox(this.bundle.outfilePath, {
            env: {
                WING_SIMULATOR_URL: this.context.serverUrl,
                WING_SIMULATOR_CALLER: this.context.resourceHandle,
            },
            log: (internal, level, message) => {
                this.addTrace(message, internal ? std_1.TraceType.SIMULATOR : std_1.TraceType.LOG, level);
            },
            // A resource needs to respond to method calls in a timely manner since
            // the simulator server will wait for a response before responding to
            // the caller. The default timeout is 30 seconds.
            timeout: this.timeout,
        });
        // We're communicating with the sandbox via IPC. It's not possible to pass
        // an IResourceContext object directly because methods like `resolveToken`
        // are not serializable. So instead, a fake ctx object is created within the
        // inflight wrapper code - see `resource.ts`.
        try {
            const attrs = await this.sandbox.call("start", this.context.statedir);
            return attrs;
        }
        catch (err) {
            this.context.addTrace({
                data: {
                    message: "Error initializing resource",
                    status: "failure",
                    error: err,
                },
                type: std_1.TraceType.LOG,
                level: std_1.LogLevel.ERROR,
                sourcePath: this.context.resourcePath,
                sourceType: resource_1.SIM_RESOURCE_FQN,
                timestamp: new Date().toISOString(),
            });
            return {};
        }
    }
    async cleanup() {
        try {
            // TODO: set a timeout for the stop call
            while (true) {
                try {
                    return await this.sandbox.call("stop");
                }
                catch (err) {
                    if (err instanceof sandbox_1.SandboxMultipleConcurrentCallsError) {
                        // If the sandbox is busy, wait and try again
                        this.addTrace("Sandbox is busy, waiting and retrying...", std_1.TraceType.SIMULATOR, std_1.LogLevel.VERBOSE);
                        await new Promise((resolve) => setTimeout(resolve, 100));
                    }
                    else {
                        throw err;
                    }
                }
            }
        }
        catch (err) {
            this.context.addTrace({
                data: {
                    message: "Error calling onStop",
                    status: "failure",
                    error: err,
                },
                type: std_1.TraceType.LOG,
                level: std_1.LogLevel.ERROR,
                sourcePath: this.context.resourcePath,
                sourceType: resource_1.SIM_RESOURCE_FQN,
                timestamp: new Date().toISOString(),
            });
        }
        finally {
            await this.sandbox.cleanup();
        }
    }
    async save() { }
    async plan(invalidated) {
        // TODO: support customizing update plans
        if (invalidated) {
            return simulator_1.UpdatePlan.REPLACE;
        }
        // Check if any of the bundled files have changed since the last bundling
        const bundleInvalidated = await (0, bundling_1.isBundleInvalidated)(this.resolvedSourceCodeFile, this.bundle, (msg) => this.addTrace(msg, std_1.TraceType.SIMULATOR, std_1.LogLevel.VERBOSE));
        if (bundleInvalidated) {
            return simulator_1.UpdatePlan.REPLACE;
        }
        return simulator_1.UpdatePlan.SKIP;
    }
    async call(method, args = []) {
        return this.context.withTrace({
            activity: async () => {
                // TODO: If requests take a long time for a resource to process,
                // we may end up passing requests to the sandbox after they have
                // timed out. We should consider adding a timeout to the call method
                // here or track the request's response deadline in some way.
                while (true) {
                    try {
                        return await this.sandbox.call("call", method, ...args);
                    }
                    catch (err) {
                        if (err instanceof sandbox_1.SandboxMultipleConcurrentCallsError) {
                            // If the sandbox is busy, wait and try again
                            this.addTrace("Sandbox is busy, waiting and retrying...", std_1.TraceType.SIMULATOR, std_1.LogLevel.VERBOSE);
                            await new Promise((resolve) => setTimeout(resolve, 100));
                        }
                        else if (err instanceof sandbox_1.SandboxTimeoutError) {
                            throw new Error(`Call to resource "${this.context.resourcePath}" timed out after ${this.timeout}ms`);
                        }
                        else {
                            throw err;
                        }
                    }
                }
            },
            message: this.formatCallMessage(method, args),
        });
    }
    formatCallMessage(method, args) {
        let message = method.toString();
        message += "(";
        for (let i = 0; i < args.length; i++) {
            let arg = args[i];
            if (arg === null || arg === undefined) {
                message += "nil";
            }
            else {
                message += JSON.stringify(args[i]);
            }
            if (i < args.length - 1) {
                message += ", ";
            }
        }
        message += ")";
        return message;
    }
    addTrace(message, type, level) {
        this.context.addTrace({
            data: { message, level },
            type,
            level: level ?? std_1.LogLevel.INFO,
            sourcePath: this.context.resourcePath,
            sourceType: resource_1.SIM_RESOURCE_FQN,
            timestamp: new Date().toISOString(),
        });
    }
}
exports.Resource = Resource;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVzb3VyY2UuaW5mbGlnaHQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvdGFyZ2V0LXNpbS9yZXNvdXJjZS5pbmZsaWdodC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDJDQUE2QjtBQUM3Qix5Q0FBK0Q7QUFFL0QsaURBQWlFO0FBQ2pFLCtDQUkyQjtBQUMzQiw0Q0FJc0I7QUFDdEIsZ0NBQW1EO0FBRW5ELE1BQWEsUUFBUTtJQVFuQixZQUFZLEtBQXdCO1FBRm5CLFlBQU8sR0FBRyxLQUFNLENBQUM7UUFHaEMsSUFBSSxDQUFDLGNBQWMsR0FBRyxLQUFLLENBQUMsY0FBYyxDQUFDO0lBQzdDLENBQUM7SUFFRCxJQUFZLE9BQU87UUFDakIsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUNuQixNQUFNLElBQUksS0FBSyxDQUFDLGlEQUFpRCxDQUFDLENBQUM7UUFDckUsQ0FBQztRQUNELE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQztJQUN2QixDQUFDO0lBRU8sS0FBSyxDQUFDLFlBQVk7UUFDeEIsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLGlCQUFPLENBQUMsWUFBWSxDQUN0QyxJQUFJLENBQUMsc0JBQXNCLEVBQzNCLENBQUMsR0FBRyxFQUFFLEtBQUssRUFBRSxFQUFFO1lBQ2IsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLEVBQUUsZUFBUyxDQUFDLFFBQVEsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUNoRCxDQUFDLENBQ0YsQ0FBQztJQUNKLENBQUM7SUFFTSxLQUFLLENBQUMsSUFBSSxDQUNmLE9BQTBCO1FBRTFCLElBQUksQ0FBQyxRQUFRLEdBQUcsT0FBTyxDQUFDO1FBQ3hCLElBQUksQ0FBQyxzQkFBc0IsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUN4QyxPQUFPLENBQUMsTUFBTSxFQUNkLElBQUksQ0FBQyxjQUFjLENBQ3BCLENBQUM7UUFD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R0FBRyxLQUFLLElBQUksSUFBSSxHQUFHLEtBQUssU0FBUyxFQUFFLENBQUM7Z0JBQ3RDLE9BQU8sSUFBSSxLQUFLLENBQUM7WUFDbkIsQ0FBQztpQkFBTSxDQUFDO2dCQUNOLE9BQU8sSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3RDLENBQUM7WUFDRCxJQUFJLENBQUMsR0FBRyxJQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDO2dCQUN6QixPQUFPLElBQUksSUFBSSxDQUFDO1lBQ2xCLENBQUM7UUFDSCxDQUFDO1FBQ0QsT0FBTyxJQUFJLEdBQUcsQ0FBQztRQUNmLE9BQU8sT0FBTyxDQUFDO0lBQ2pCLENBQUM7SUFFTyxRQUFRLENBQUMsT0FBZSxFQUFFLElBQWUsRUFBRSxLQUFnQjtRQUNqRSxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQztZQUNwQixJQUFJLEVBQUUsRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFO1lBQ3hCLElBQUk7WUFDSixLQUFLLEVBQUUsS0FBSyxJQUFJLGNBQVEsQ0FBQyxJQUFJO1lBQzdCLFVBQVUsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLFlBQVk7WUFDckMsVUFBVSxFQUFFLDJCQUFnQjtZQUM1QixTQUFTLEVBQUUsSUFBSSxJQUFJLEVBQUUsQ0FBQyxXQUFXLEVBQUU7U0FDcEMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztDQUNGO0FBMU1ELDRCQTBNQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHBhdGggZnJvbSBcInBhdGhcIjtcbmltcG9ydCB7IElSZXNvdXJjZUNsaWVudCwgU0lNX1JFU09VUkNFX0ZRTiB9IGZyb20gXCIuL3Jlc291cmNlXCI7XG5pbXBvcnQgeyBTaW1SZXNvdXJjZUF0dHJpYnV0ZXMsIFNpbVJlc291cmNlU2NoZW1hIH0gZnJvbSBcIi4vc2NoZW1hLXJlc291cmNlc1wiO1xuaW1wb3J0IHsgQnVuZGxlLCBpc0J1bmRsZUludmFsaWRhdGVkIH0gZnJvbSBcIi4uL3NoYXJlZC9idW5kbGluZ1wiO1xuaW1wb3J0IHtcbiAgU2FuZGJveE11bHRpcGxlQ29uY3VycmVudENhbGxzRXJyb3IsXG4gIFNhbmRib3gsXG4gIFNhbmRib3hUaW1lb3V0RXJyb3IsXG59IGZyb20gXCIuLi9zaGFyZWQvc2FuZGJveFwiO1xuaW1wb3J0IHtcbiAgSVNpbXVsYXRvckNvbnRleHQsXG4gIElTaW11bGF0b3JSZXNvdXJjZUluc3RhbmNlLFxuICBVcGRhdGVQbGFuLFxufSBmcm9tIFwiLi4vc2ltdWxhdG9yXCI7XG5pbXBvcnQgeyBKc29uLCBMb2dMZXZlbCwgVHJhY2VUeXBlIH0gZnJvbSBcIi4uL3N0ZFwiO1xuXG5leHBvcnQgY2xhc3MgUmVzb3VyY2UgaW1wbGVtZW50cyBJUmVzb3VyY2VDbGllbnQsIElTaW11bGF0b3JSZXNvdXJjZUluc3RhbmNlIHtcbiAgcHJpdmF0ZSBfY29udGV4dDogSVNpbXVsYXRvckNvbnRleHQgfCB1bmRlZmluZWQ7XG4gIHByaXZhdGUgcmVhZG9ubHkgc291cmNlQ29kZUZpbGU6IHN0cmluZztcbiAgcHJpdmF0ZSByZXNvbHZlZFNvdXJjZUNvZGVGaWxlITogc3RyaW5nO1xuICBwcml2YXRlIHNhbmRib3g6IFNhbmRib3ggfCB1bmRlZmluZWQ7XG4gIHByaXZhdGUgYnVuZGxlOiBCdW5kbGUgfCB1bmRlZmluZWQ7XG4gIHByaXZhdGUgcmVhZG9ubHkgdGltZW91dCA9IDMwXzAwMDtcblxuICBjb25zdHJ1Y3Rvcihwcm9wczogU2ltUmVzb3VyY2VTY2hlbWEpIHtcbiAgICB0aGlzLnNvdXJjZUNvZGVGaWxlID0gcHJvcHMuc291cmNlQ29kZUZpbGU7XG4gIH1cblxuICBwcml2YXRlIGdldCBjb250ZXh0KCk6IElTaW11bGF0b3JDb250ZXh0IHtcbiAgICBpZiAoIXRoaXMuX2NvbnRleHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhY2Nlc3MgY29udGV4dCBkdXJpbmcgY2xhc3MgY29uc3RydWN0aW9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY29udGV4dDtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgY3JlYXRlQnVuZGxlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMuYnVuZGxlID0gYXdhaXQgU2FuZGJveC5jcmVhdGVCdW5kbGUoXG4gICAgICB0aGlzLnJlc29sdmVkU291cmNlQ29kZUZpbGUsXG4gICAgICAobXNnLCBsZXZlbCkgPT4ge1xuICAgICAgICB0aGlzLmFkZFRyYWNlKG1zZywgVHJhY2VUeXBlLlJFU09VUkNFLCBsZXZlbCk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBpbml0KFxuICAgIGNvbnRleHQ6IElTaW11bGF0b3JDb250ZXh0XG4gICk6IFByb21pc2U8U2ltUmVzb3VyY2VBdHRyaWJ1dGVzPiB7XG4gICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5yZXNvbHZlZFNvdXJjZUNvZGVGaWxlID0gcGF0aC5yZXNvbHZlKFxuICAgICAgY29udGV4dC5zaW1kaXIsXG4gICAgICB0aGlzLnNvdXJjZUNvZGVGaWxlXG4gICAgKTtcbiAgICBhd2FpdCB0aGlzLmNyZWF0ZUJ1bmRsZSgpO1xuICAgIHRoaXMuc2FuZGJveCA9IG5ldyBTYW5kYm94KHRoaXMuYnVuZGxlIS5vdXRmaWxlUGF0aCwge1xuICAgICAgZW52OiB7XG4gICAgICAgIFdJTkdfU0lNVUxBVE9SX1VSTDogdGhpcy5jb250ZXh0LnNlcnZlclVybCxcbiAgICAgICAgV0lOR19TSU1VTEFUT1JfQ0FMTEVSOiB0aGlzLmNvbnRleHQucmVzb3VyY2VIYW5kbGUsXG4gICAgICB9LFxuICAgICAgbG9nOiAoaW50ZXJuYWwsIGxldmVsLCBtZXNzYWdlKSA9PiB7XG4gICAgICAgIHRoaXMuYWRkVHJhY2UoXG4gICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICBpbnRlcm5hbCA/IFRyYWNlVHlwZS5TSU1VTEFUT1IgOiBUcmFjZVR5cGUuTE9HLFxuICAgICAgICAgIGxldmVsXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgLy8gQSByZXNvdXJjZSBuZWVkcyB0byByZXNwb25kIHRvIG1ldGhvZCBjYWxscyBpbiBhIHRpbWVseSBtYW5uZXIgc2luY2VcbiAgICAgIC8vIHRoZSBzaW11bGF0b3Igc2VydmVyIHdpbGwgd2FpdCBmb3IgYSByZXNwb25zZSBiZWZvcmUgcmVzcG9uZGluZyB0b1xuICAgICAgLy8gdGhlIGNhbGxlci4gVGhlIGRlZmF1bHQgdGltZW91dCBpcyAzMCBzZWNvbmRzLlxuICAgICAgdGltZW91dDogdGhpcy50aW1lb3V0LFxuICAgIH0pO1xuXG4gICAgLy8gV2UncmUgY29tbXVuaWNhdGluZyB3aXRoIHRoZSBzYW5kYm94IHZpYSBJUEMuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHBhc3NcbiAgICAvLyBhbiBJUmVzb3VyY2VDb250ZXh0IG9iamVjdCBkaXJlY3RseSBiZWNhdXNlIG1ldGhvZHMgbGlrZSBgcmVzb2x2ZVRva2VuYFxuICAgIC8vIGFyZSBub3Qgc2VyaWFsaXphYmxlLiBTbyBpbnN0ZWFkLCBhIGZha2UgY3R4IG9iamVjdCBpcyBjcmVhdGVkIHdpdGhpbiB0aGVcbiAgICAvLyBpbmZsaWdodCB3cmFwcGVyIGNvZGUgLSBzZWUgYHJlc291cmNlLnRzYC5cbiAgICB0cnkge1xuICAgICAgY29uc3QgYXR0cnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSBhd2FpdCB0aGlzLnNhbmRib3guY2FsbChcbiAgICAgICAgXCJzdGFydFwiLFxuICAgICAgICB0aGlzLmNvbnRleHQuc3RhdGVkaXJcbiAgICAgICk7XG4gICAgICByZXR1cm4gYXR0cnM7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLmNvbnRleHQuYWRkVHJhY2Uoe1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgbWVzc2FnZTogXCJFcnJvciBpbml0aWFsaXppbmcgcmVzb3VyY2VcIixcbiAgICAgICAgICBzdGF0dXM6IFwiZmFpbHVyZVwiLFxuICAgICAgICAgIGVycm9yOiBlcnIsXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGU6IFRyYWNlVHlwZS5MT0csXG4gICAgICAgIGxldmVsOiBMb2dMZXZlbC5FUlJPUixcbiAgICAgICAgc291cmNlUGF0aDogdGhpcy5jb250ZXh0LnJlc291cmNlUGF0aCxcbiAgICAgICAgc291cmNlVHlwZTogU0lNX1JFU09VUkNFX0ZRTixcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgY2xlYW51cCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgLy8gVE9ETzogc2V0IGEgdGltZW91dCBmb3IgdGhlIHN0b3AgY2FsbFxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5zYW5kYm94IS5jYWxsKFwic3RvcFwiKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFNhbmRib3hNdWx0aXBsZUNvbmN1cnJlbnRDYWxsc0Vycm9yKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgc2FuZGJveCBpcyBidXN5LCB3YWl0IGFuZCB0cnkgYWdhaW5cbiAgICAgICAgICAgIHRoaXMuYWRkVHJhY2UoXG4gICAgICAgICAgICAgIFwiU2FuZGJveCBpcyBidXN5LCB3YWl0aW5nIGFuZCByZXRyeWluZy4uLlwiLFxuICAgICAgICAgICAgICBUcmFjZVR5cGUuU0lNVUxBVE9SLFxuICAgICAgICAgICAgICBMb2dMZXZlbC5WRVJCT1NFXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuY29udGV4dC5hZGRUcmFjZSh7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBtZXNzYWdlOiBcIkVycm9yIGNhbGxpbmcgb25TdG9wXCIsXG4gICAgICAgICAgc3RhdHVzOiBcImZhaWx1cmVcIixcbiAgICAgICAgICBlcnJvcjogZXJyLFxuICAgICAgICB9LFxuICAgICAgICB0eXBlOiBUcmFjZVR5cGUuTE9HLFxuICAgICAgICBsZXZlbDogTG9nTGV2ZWwuRVJST1IsXG4gICAgICAgIHNvdXJjZVBhdGg6IHRoaXMuY29udGV4dC5yZXNvdXJjZVBhdGgsXG4gICAgICAgIHNvdXJjZVR5cGU6IFNJTV9SRVNPVVJDRV9GUU4sXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgfSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGF3YWl0IHRoaXMuc2FuZGJveCEuY2xlYW51cCgpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBzYXZlKCk6IFByb21pc2U8dm9pZD4ge31cblxuICBwdWJsaWMgYXN5bmMgcGxhbihpbnZhbGlkYXRlZDogYm9vbGVhbik6IFByb21pc2U8VXBkYXRlUGxhbj4ge1xuICAgIC8vIFRPRE86IHN1cHBvcnQgY3VzdG9taXppbmcgdXBkYXRlIHBsYW5zXG4gICAgaWYgKGludmFsaWRhdGVkKSB7XG4gICAgICByZXR1cm4gVXBkYXRlUGxhbi5SRVBMQUNFO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGFueSBvZiB0aGUgYnVuZGxlZCBmaWxlcyBoYXZlIGNoYW5nZWQgc2luY2UgdGhlIGxhc3QgYnVuZGxpbmdcbiAgICBjb25zdCBidW5kbGVJbnZhbGlkYXRlZCA9IGF3YWl0IGlzQnVuZGxlSW52YWxpZGF0ZWQoXG4gICAgICB0aGlzLnJlc29sdmVkU291cmNlQ29kZUZpbGUsXG4gICAgICB0aGlzLmJ1bmRsZSEsXG4gICAgICAobXNnKSA9PiB0aGlzLmFkZFRyYWNlKG1zZywgVHJhY2VUeXBlLlNJTVVMQVRPUiwgTG9nTGV2ZWwuVkVSQk9TRSlcbiAgICApO1xuICAgIGlmIChidW5kbGVJbnZhbGlkYXRlZCkge1xuICAgICAgcmV0dXJuIFVwZGF0ZVBsYW4uUkVQTEFDRTtcbiAgICB9XG5cbiAgICByZXR1cm4gVXBkYXRlUGxhbi5TS0lQO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGNhbGwobWV0aG9kOiBzdHJpbmcsIGFyZ3M6IEFycmF5PEpzb24+ID0gW10pOiBQcm9taXNlPEpzb24+IHtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0LndpdGhUcmFjZSh7XG4gICAgICBhY3Rpdml0eTogYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBUT0RPOiBJZiByZXF1ZXN0cyB0YWtlIGEgbG9uZyB0aW1lIGZvciBhIHJlc291cmNlIHRvIHByb2Nlc3MsXG4gICAgICAgIC8vIHdlIG1heSBlbmQgdXAgcGFzc2luZyByZXF1ZXN0cyB0byB0aGUgc2FuZGJveCBhZnRlciB0aGV5IGhhdmVcbiAgICAgICAgLy8gdGltZWQgb3V0LiBXZSBzaG91bGQgY29uc2lkZXIgYWRkaW5nIGEgdGltZW91dCB0byB0aGUgY2FsbCBtZXRob2RcbiAgICAgICAgLy8gaGVyZSBvciB0cmFjayB0aGUgcmVxdWVzdCdzIHJlc3BvbnNlIGRlYWRsaW5lIGluIHNvbWUgd2F5LlxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5zYW5kYm94IS5jYWxsKFwiY2FsbFwiLCBtZXRob2QsIC4uLmFyZ3MpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFNhbmRib3hNdWx0aXBsZUNvbmN1cnJlbnRDYWxsc0Vycm9yKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZSBzYW5kYm94IGlzIGJ1c3ksIHdhaXQgYW5kIHRyeSBhZ2FpblxuICAgICAgICAgICAgICB0aGlzLmFkZFRyYWNlKFxuICAgICAgICAgICAgICAgIFwiU2FuZGJveCBpcyBidXN5LCB3YWl0aW5nIGFuZCByZXRyeWluZy4uLlwiLFxuICAgICAgICAgICAgICAgIFRyYWNlVHlwZS5TSU1VTEFUT1IsXG4gICAgICAgICAgICAgICAgTG9nTGV2ZWwuVkVSQk9TRVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDApKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyIGluc3RhbmNlb2YgU2FuZGJveFRpbWVvdXRFcnJvcikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgYENhbGwgdG8gcmVzb3VyY2UgXCIke3RoaXMuY29udGV4dC5yZXNvdXJjZVBhdGh9XCIgdGltZWQgb3V0IGFmdGVyICR7dGhpcy50aW1lb3V0fW1zYFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMuZm9ybWF0Q2FsbE1lc3NhZ2UobWV0aG9kLCBhcmdzKSxcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgZm9ybWF0Q2FsbE1lc3NhZ2UobWV0aG9kOiBzdHJpbmcsIGFyZ3M6IEFycmF5PEpzb24+KTogc3RyaW5nIHtcbiAgICBsZXQgbWVzc2FnZSA9IG1ldGhvZC50b1N0cmluZygpO1xuICAgIG1lc3NhZ2UgKz0gXCIoXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgYXJnID0gYXJncyFbaV07XG4gICAgICBpZiAoYXJnID09PSBudWxsIHx8IGFyZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gXCJuaWxcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gSlNPTi5zdHJpbmdpZnkoYXJncyFbaV0pO1xuICAgICAgfVxuICAgICAgaWYgKGkgPCBhcmdzIS5sZW5ndGggLSAxKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gXCIsIFwiO1xuICAgICAgfVxuICAgIH1cbiAgICBtZXNzYWdlICs9IFwiKVwiO1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG5cbiAgcHJpdmF0ZSBhZGRUcmFjZShtZXNzYWdlOiBzdHJpbmcsIHR5cGU6IFRyYWNlVHlwZSwgbGV2ZWw/OiBMb2dMZXZlbCkge1xuICAgIHRoaXMuY29udGV4dC5hZGRUcmFjZSh7XG4gICAgICBkYXRhOiB7IG1lc3NhZ2UsIGxldmVsIH0sXG4gICAgICB0eXBlLFxuICAgICAgbGV2ZWw6IGxldmVsID8/IExvZ0xldmVsLklORk8sXG4gICAgICBzb3VyY2VQYXRoOiB0aGlzLmNvbnRleHQucmVzb3VyY2VQYXRoLFxuICAgICAgc291cmNlVHlwZTogU0lNX1JFU09VUkNFX0ZRTixcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIH0pO1xuICB9XG59XG4iXX0=