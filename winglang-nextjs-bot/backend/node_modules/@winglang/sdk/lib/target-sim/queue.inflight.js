"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Queue = void 0;
const cloud_1 = require("../cloud");
const simulator_1 = require("../simulator/simulator");
const std_1 = require("../std");
class Queue {
    constructor(props) {
        this.messages = new Array();
        this.subscribers = new Array();
        this.timeoutSeconds = props.timeout;
        this.retentionPeriod = props.retentionPeriod;
        this.dlq = props.dlq;
        this.processLoop = runEvery(100, async () => this.processMessages()); // every 0.1 seconds
    }
    get context() {
        if (!this._context) {
            throw new Error("Cannot access context during class construction");
        }
        return this._context;
    }
    async init(context) {
        this._context = context;
        await this.processLoop.start();
        return {};
    }
    async cleanup() {
        await this.processLoop.stop();
    }
    async save() { }
    async plan() {
        return simulator_1.UpdatePlan.AUTO;
    }
    async addEventSubscription(subscriber, subscriptionProps) {
        const s = {
            functionHandle: subscriber,
            ...subscriptionProps,
        };
        this.subscribers.push(s);
    }
    async removeEventSubscription(subscriber) {
        const index = this.subscribers.findIndex((s) => s.functionHandle === subscriber);
        if (index >= 0) {
            this.subscribers.splice(index, 1);
        }
    }
    // TODO: enforce maximum queue message size?
    async push(...messages) {
        return this.context.withTrace({
            message: `Push (messages=${messages}).`,
            activity: async () => {
                if (messages.includes("")) {
                    throw new Error("Empty messages are not allowed");
                }
                for (const message of messages) {
                    this.messages.push(new QueueMessage(this.retentionPeriod, cloud_1.DEFAULT_DELIVERY_ATTEMPTS, message));
                }
            },
        });
    }
    async purge() {
        return this.context.withTrace({
            message: `Purge ().`,
            activity: async () => {
                this.messages.length = 0;
            },
        });
    }
    async approxSize() {
        return this.context.withTrace({
            message: `ApproxSize ().`,
            activity: async () => {
                return this.messages.length;
            },
        });
    }
    async pop() {
        return this.context.withTrace({
            message: `Pop ().`,
            activity: async () => {
                // extract a random message from the queue
                const message = this.messages.splice(Math.floor(Math.random() * this.messages.length), 1)[0];
                return message?.payload;
            },
        });
    }
    async processMessages() {
        let processedMessages = false;
        do {
            processedMessages = false;
            // Remove messages that have expired
            const currentTime = new Date();
            for (let index = this.messages.length - 1; index >= 0; index--) {
                const message = this.messages[index];
                if (message.retentionTimeout < currentTime) {
                    await this.context.withTrace({
                        activity: async () => this.messages.splice(index, 1),
                        message: `Removing expired message (message=${message.payload}).`,
                    });
                }
            }
            // Randomize the order of subscribers to avoid user code making
            // assumptions on the order that subscribers process messages.
            for (const subscriber of new RandomArrayIterator(this.subscribers)) {
                // Extract random messages from the queue
                const messages = new Array();
                for (let i = 0; i < subscriber.batchSize; i++) {
                    const message = this.messages.splice(Math.floor(Math.random() * this.messages.length), 1)[0];
                    if (message) {
                        messages.push(message);
                    }
                }
                const messagesPayload = messages.map((m) => m.payload);
                if (messagesPayload.length === 0) {
                    continue;
                }
                const fnClient = this.context.getClient(subscriber.functionHandle);
                if (!fnClient) {
                    throw new Error("No function client found");
                }
                // If the function we picked is at capacity, keep the messages in the queue
                const hasWorkers = await fnClient.hasAvailableWorkers();
                if (!hasWorkers) {
                    this.messages.push(...messages);
                    continue;
                }
                this.context.addTrace({
                    type: std_1.TraceType.RESOURCE,
                    level: std_1.LogLevel.VERBOSE,
                    data: {
                        message: `Sending messages (messages=${JSON.stringify(messagesPayload)}, subscriber=${subscriber.functionHandle}).`,
                    },
                    sourcePath: this.context.resourcePath,
                    sourceType: cloud_1.QUEUE_FQN,
                    timestamp: new Date().toISOString(),
                });
                // we don't use invokeAsync here because we want to wait for the function to finish
                // and requeue the messages if it fails
                void fnClient
                    .invoke(JSON.stringify({ messages: messages }))
                    .then((result) => {
                    if (this.dlq && result) {
                        const errorList = JSON.parse(result);
                        let retriesMessages = [];
                        for (const msg of errorList) {
                            if (msg.remainingDeliveryAttempts < this.dlq.maxDeliveryAttempts) {
                                msg.remainingDeliveryAttempts++;
                                retriesMessages.push(msg);
                            }
                            else {
                                let dlq = this.context.getClient(this.dlq.dlqHandler);
                                void dlq.push(msg.payload).catch((err) => {
                                    this.context.addTrace({
                                        type: std_1.TraceType.RESOURCE,
                                        level: std_1.LogLevel.ERROR,
                                        data: {
                                            message: `Pushing messages to the dead-letter queue generates an error -> ${err}`,
                                        },
                                        sourcePath: this.context.resourcePath,
                                        sourceType: cloud_1.QUEUE_FQN,
                                        timestamp: new Date().toISOString(),
                                    });
                                });
                            }
                        }
                        this.messages.push(...retriesMessages);
                    }
                })
                    .catch((err) => {
                    // If the function is at a concurrency limit, pretend we just didn't call it
                    if (err.message ===
                        "Too many requests, the function has reached its concurrency limit.") {
                        this.messages.push(...messages);
                        return;
                    }
                    // If the function returns an error, put the message back on the queue after timeout period
                    this.context.addTrace({
                        data: {
                            message: `Subscriber error - returning ${messagesPayload.length} messages to queue: ${err.message}`,
                        },
                        sourcePath: this.context.resourcePath,
                        sourceType: cloud_1.QUEUE_FQN,
                        type: std_1.TraceType.RESOURCE,
                        level: std_1.LogLevel.ERROR,
                        timestamp: new Date().toISOString(),
                    });
                    this.pushMessagesBackToQueue(messages);
                });
                processedMessages = true;
            }
        } while (processedMessages);
    }
    pushMessagesBackToQueue(messages) {
        setTimeout(() => {
            // Don't push back messages with retention timeouts that have expired
            const retainedMessages = messages.filter((message) => message.retentionTimeout > new Date());
            this.messages.push(...retainedMessages);
            this.context.addTrace({
                data: {
                    message: `${retainedMessages.length} messages pushed back to queue after visibility timeout.`,
                },
                sourcePath: this.context.resourcePath,
                sourceType: cloud_1.QUEUE_FQN,
                type: std_1.TraceType.RESOURCE,
                level: std_1.LogLevel.WARNING,
                timestamp: new Date().toISOString(),
            });
        }, this.timeoutSeconds * 1000);
    }
}
exports.Queue = Queue;
class QueueMessage {
    constructor(retentionPeriod, remainingDeliveryAttempts, message) {
        const currentTime = new Date();
        currentTime.setSeconds(retentionPeriod + currentTime.getSeconds());
        this.retentionTimeout = currentTime;
        this.payload = message;
        this.remainingDeliveryAttempts = remainingDeliveryAttempts;
    }
}
class RandomArrayIterator {
    constructor(values) {
        this.values = values;
        this.length = this.values.length;
    }
    next() {
        if (this.length === 0) {
            return { done: true, value: undefined };
        }
        const i = Math.floor(Math.random() * this.length);
        const j = --this.length;
        const value = this.values[i];
        this.values[i] = this.values[j];
        this.values[j] = value;
        return { value };
    }
    [Symbol.iterator]() {
        return this;
    }
}
/**
 * Runs an asynchronous function every `interval` milliseconds.
 * If the function takes longer than `interval` to run, it will be run again immediately.
 * Otherwise, it will wait until `interval` milliseconds have passed before running again.
 * @param interval The interval in milliseconds
 * @param fn The function to run
 * @returns A controller that can be used to stop the loop
 */
function runEvery(interval, fn) {
    let keepRunning = true;
    let resolveStopPromise;
    let stopCalled = false; // in case it is called multiple times
    let stopPromise = new Promise((resolve) => {
        resolveStopPromise = resolve;
    });
    async function loop() {
        while (keepRunning) {
            const startTime = Date.now();
            try {
                await fn();
            }
            catch (err) {
                console.error(err);
                keepRunning = false;
            }
            const endTime = Date.now();
            const elapsedTime = endTime - startTime;
            await new Promise((resolve) => setTimeout(resolve, Math.max(interval - elapsedTime, 0)));
        }
        resolveStopPromise(); // resolve the promise when the loop exits
    }
    const controller = {
        async stop() {
            if (!stopCalled) {
                stopCalled = true;
                keepRunning = false;
                await stopPromise; // wait for the loop to finish
            }
        },
        async start() {
            void loop();
        },
    };
    return controller;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicXVldWUuaW5mbGlnaHQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvdGFyZ2V0LXNpbS9xdWV1ZS5pbmZsaWdodC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFVQSxvQ0FLa0I7QUFDbEIsc0RBSWdDO0FBQ2hDLGdDQUE2QztBQUU3QyxNQUFhLEtBQUs7SUFXaEIsWUFBWSxLQUFrQjtRQVJiLGFBQVEsR0FBRyxJQUFJLEtBQUssRUFBZ0IsQ0FBQztRQUNyQyxnQkFBVyxHQUFHLElBQUksS0FBSyxFQUFtQixDQUFDO1FBUTFELElBQUksQ0FBQyxjQUFjLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQztRQUNwQyxJQUFJLENBQUMsZUFBZSxHQUFHLEtBQUssQ0FBQyxlQUFlLENBQUM7UUFDN0MsSUFBSSxDQUFDLEdBQUcsR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDO1FBQ3JCLElBQUksQ0FBQyxXQUFXLEdBQUcsUUFBUSxDQUFDLEdBQUcsRUFBRSxLQUFLLElBQUksRUFBRSxDQUFDLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQyxDQUFDLENBQUMsb0JBQW9CO0lBQzVGLENBQUM7SUFFRCxJQUFZLE9BQU87UUFDakIsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUNuQixNQUFNLElBQUksS0FBSyxDQUFDLGlEQUFpRCxDQUFDLENBQUM7UUFDckUsQ0FBQztRQUNELE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQztJQUN2QixDQUFDO0lBRU0sS0FBSyxDQUFDLElBQUksQ0FBQyxPQUEwQjtRQUMxQyxJQUFJLENBQUMsUUFBUSxHQUFHLE9BQU8sQ0FBQztRQUN4QixNQUFNLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDL0IsT0FBTyxFQUFFLENBQUM7SUFDWixDQUFDO0lBRU0sS0FBSyxDQUFDLE9BQU87UUFDbEIsTUFBTSxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksRUFBRSxDQUFDO0lB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QU8sQ0FBQztJQUMvQixDQUFDLENBQUMsQ0FBQztJQUVILEtBQUssVUFBVSxJQUFJO1FBQ2pCLE9BQU8sV0FBVyxFQUFFLENBQUM7WUFDbkIsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBQzdCLElBQUksQ0FBQztnQkFDSCxNQUFNLEVBQUUsRUFBRSxDQUFDO1lBQ2IsQ0FBQztZQUFDLE9BQU8sR0FBRyxFQUFFLENBQUM7Z0JBQ2IsT0FBTyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztnQkFDbkIsV0FBVyxHQUFHLEtBQUssQ0FBQztZQUN0QixDQUFDO1lBQ0QsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBQzNCLE1BQU0sV0FBVyxHQUFHLE9BQU8sR0FBRyxTQUFTLENBQUM7WUFDeEMsTUFBTSxJQUFJLE9BQU8sQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQzVCLFVBQVUsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLEdBQUcsV0FBVyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQ3pELENBQUM7UUFDSixDQUFDO1FBQ0Qsa0JBQWtCLEVBQUUsQ0FBQyxDQUFDLDBDQUEwQztJQUNsRSxDQUFDO0lBRUQsTUFBTSxVQUFVLEdBQUc7UUFDakIsS0FBSyxDQUFDLElBQUk7WUFDUixJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7Z0JBQ2hCLFVBQVUsR0FBRyxJQUFJLENBQUM7Z0JBQ2xCLFdBQVcsR0FBRyxLQUFLLENBQUM7Z0JBQ3BCLE1BQU0sV0FBVyxDQUFDLENBQUMsOEJBQThCO1lBQ25ELENBQUM7UUFDSCxDQUFDO1FBQ0QsS0FBSyxDQUFDLEtBQUs7WUFDVCxLQUFLLElBQUksRUFBRSxDQUFDO1FBQ2QsQ0FBQztLQUNGLENBQUM7SUFFRixPQUFPLFVBQVUsQ0FBQztBQUNwQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSUV2ZW50UHVibGlzaGVyIH0gZnJvbSBcIi4vZXZlbnQtbWFwcGluZ1wiO1xuaW1wb3J0IHR5cGUgeyBGdW5jdGlvbiBhcyBGdW5jdGlvbkNsaWVudCB9IGZyb20gXCIuL2Z1bmN0aW9uLmluZmxpZ2h0XCI7XG5pbXBvcnQge1xuICBRdWV1ZUF0dHJpYnV0ZXMsXG4gIFF1ZXVlU2NoZW1hLFxuICBRdWV1ZVN1YnNjcmliZXIsXG4gIEV2ZW50U3Vic2NyaXB0aW9uLFxuICBEZWFkTGV0dGVyUXVldWVTY2hlbWEsXG4gIFJlc291cmNlSGFuZGxlLFxufSBmcm9tIFwiLi9zY2hlbWEtcmVzb3VyY2VzXCI7XG5pbXBvcnQge1xuICBERUZBVUxUX0RFTElWRVJZX0FUVEVNUFRTLFxuICBJRnVuY3Rpb25DbGllbnQsXG4gIElRdWV1ZUNsaWVudCxcbiAgUVVFVUVfRlFOLFxufSBmcm9tIFwiLi4vY2xvdWRcIjtcbmltcG9ydCB7XG4gIElTaW11bGF0b3JDb250ZXh0LFxuICBJU2ltdWxhdG9yUmVzb3VyY2VJbnN0YW5jZSxcbiAgVXBkYXRlUGxhbixcbn0gZnJvbSBcIi4uL3NpbXVsYXRvci9zaW11bGF0b3JcIjtcbmltcG9ydCB7IExvZ0xldmVsLCBUcmFjZVR5cGUgfSBmcm9tIFwiLi4vc3RkXCI7XG5cbmV4cG9ydCBjbGFzcyBRdWV1ZVxuICBpbXBsZW1lbnRzIElRdWV1ZUNsaWVudCwgSVNpbXVsYXRvclJlc291cmNlSW5zdGFuY2UsIElFdmVudFB1Ymxpc2hlclxue1xuICBwcml2YXRlIHJlYWRvbmx5IG1lc3NhZ2VzID0gbmV3IEFycmF5PFF1ZXVlTWVzc2FnZT4oKTtcbiAgcHJpdmF0ZSByZWFkb25seSBzdWJzY3JpYmVycyA9IG5ldyBBcnJheTxRdWV1ZVN1YnNjcmliZXI+KCk7XG4gIHByaXZhdGUgcmVhZG9ubHkgcHJvY2Vzc0xvb3A6IExvb3BDb250cm9sbGVyO1xuICBwcml2YXRlIF9jb250ZXh0OiBJU2ltdWxhdG9yQ29udGV4dCB8IHVuZGVmaW5lZDtcbiAgcHJpdmF0ZSByZWFkb25seSB0aW1lb3V0U2Vjb25kczogbnVtYmVyO1xuICBwcml2YXRlIHJlYWRvbmx5IHJldGVudGlvblBlcmlvZDogbnVtYmVyO1xuICBwcml2YXRlIHJlYWRvbmx5IGRscT86IERlYWRMZXR0ZXJRdWV1ZVNjaGVtYTtcblxuICBjb25zdHJ1Y3Rvcihwcm9wczogUXVldWVTY2hlbWEpIHtcbiAgICB0aGlzLnRpbWVvdXRTZWNvbmRzID0gcHJvcHMudGltZW91dDtcbiAgICB0aGlzLnJldGVudGlvblBlcmlvZCA9IHByb3BzLnJldGVudGlvblBlcmlvZDtcbiAgICB0aGlzLmRscSA9IHByb3BzLmRscTtcbiAgICB0aGlzLnByb2Nlc3NMb29wID0gcnVuRXZlcnkoMTAwLCBhc3luYyAoKSA9PiB0aGlzLnByb2Nlc3NNZXNzYWdlcygpKTsgLy8gZXZlcnkgMC4xIHNlY29uZHNcbiAgfVxuXG4gIHByaXZhdGUgZ2V0IGNvbnRleHQoKTogSVNpbXVsYXRvckNvbnRleHQge1xuICAgIGlmICghdGhpcy5fY29udGV4dCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFjY2VzcyBjb250ZXh0IGR1cmluZyBjbGFzcyBjb25zdHJ1Y3Rpb25cIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jb250ZXh0O1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGluaXQoY29udGV4dDogSVNpbXVsYXRvckNvbnRleHQpOiBQcm9taXNlPFF1ZXVlQXR0cmlidXRlcz4ge1xuICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgIGF3YWl0IHRoaXMucHJvY2Vzc0xvb3Auc3RhcnQoKTtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgY2xlYW51cCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCB0aGlzLnByb2Nlc3NMb29wLnN0b3AoKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBzYXZlKCk6IFByb21pc2U8dm9pZD4ge31cblxuICBwdWJsaWMgYXN5bmMgcGxhbigpIHtcbiAgICByZXR1cm4gVXBkYXRlUGxhbi5BVVRPO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGFkZEV2ZW50U3Vic2NyaXB0aW9uKFxuICAgIHN1YnNjcmliZXI6IFJlc291cmNlSGFuZGxlLFxuICAgIHN1YnNjcmlwdGlvblByb3BzOiBFdmVudFN1YnNjcmlwdGlvblxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBzID0ge1xuICAgICAgZnVuY3Rpb25IYW5kbGU6IHN1YnNjcmliZXIsXG4gICAgICAuLi5zdWJzY3JpcHRpb25Qcm9wcyxcbiAgICB9IGFzIFF1ZXVlU3Vic2NyaWJlcjtcbiAgICB0aGlzLnN1YnNjcmliZXJzLnB1c2gocyk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgcmVtb3ZlRXZlbnRTdWJzY3JpcHRpb24oXG4gICAgc3Vic2NyaWJlcjogUmVzb3VyY2VIYW5kbGVcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnN1YnNjcmliZXJzLmZpbmRJbmRleChcbiAgICAgIChzKSA9PiBzLmZ1bmN0aW9uSGFuZGxlID09PSBzdWJzY3JpYmVyXG4gICAgKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdGhpcy5zdWJzY3JpYmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IGVuZm9yY2UgbWF4aW11bSBxdWV1ZSBtZXNzYWdlIHNpemU/XG4gIHB1YmxpYyBhc3luYyBwdXNoKC4uLm1lc3NhZ2VzOiBzdHJpbmdbXSk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQud2l0aFRyYWNlKHtcbiAgICAgIG1lc3NhZ2U6IGBQdXNoIChtZXNzYWdlcz0ke21lc3NhZ2VzfSkuYCxcbiAgICAgIGFjdGl2aXR5OiBhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmIChtZXNzYWdlcy5pbmNsdWRlcyhcIlwiKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVtcHR5IG1lc3NhZ2VzIGFyZSBub3QgYWxsb3dlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgbWVzc2FnZXMpIHtcbiAgICAgICAgICB0aGlzLm1lc3NhZ2VzLnB1c2goXG4gICAgICAgICAgICBuZXcgUXVldWVNZXNzYWdlKFxuICAgICAgICAgICAgICB0aGlzLnJldGVudGlvblBlcmlvZCxcbiAgICAgICAgICAgICAgREVGQVVMVF9ERUxJVkVSWV9BVFRFTVBUUyxcbiAgICAgICAgICAgICAgbWVzc2FnZVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgcHVyZ2UoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dC53aXRoVHJhY2Uoe1xuICAgICAgbWVzc2FnZTogYFB1cmdlICgpLmAsXG4gICAgICBhY3Rpdml0eTogYXN5bmMgKCkgPT4ge1xuICAgICAgICB0aGlzLm1lc3NhZ2VzLmxlbmd0aCA9IDA7XG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGFwcHJveFNpemUoKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0LndpdGhUcmFjZSh7XG4gICAgICBtZXNzYWdlOiBgQXBwcm94U2l6ZSAoKS5gLFxuICAgICAgYWN0aXZpdHk6IGFzeW5jICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZXMubGVuZ3RoO1xuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBwb3AoKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+IHtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0LndpdGhUcmFjZSh7XG4gICAgICBtZXNzYWdlOiBgUG9wICgpLmAsXG4gICAgICBhY3Rpdml0eTogYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBleHRyYWN0IGEgcmFuZG9tIG1lc3NhZ2UgZnJvbSB0aGUgcXVldWVcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHRoaXMubWVzc2FnZXMuc3BsaWNlKFxuICAgICAgICAgIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHRoaXMubWVzc2FnZXMubGVuZ3RoKSxcbiAgICAgICAgICAxXG4gICAgICAgIClbMF07XG4gICAgICAgIHJldHVybiBtZXNzYWdlPy5wYXlsb2FkO1xuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgcHJvY2Vzc01lc3NhZ2VzKCkge1xuICAgIGxldCBwcm9jZXNzZWRNZXNzYWdlcyA9IGZhbHNlO1xuICAgIGRvIHtcbiAgICAgIHByb2Nlc3NlZE1lc3NhZ2VzID0gZmFsc2U7XG4gICAgICAvLyBSZW1vdmUgbWVzc2FnZXMgdGhhdCBoYXZlIGV4cGlyZWRcbiAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgIGZvciAobGV0IGluZGV4ID0gdGhpcy5tZXNzYWdlcy5sZW5ndGggLSAxOyBpbmRleCA+PSAwOyBpbmRleC0tKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2VzW2luZGV4XTtcbiAgICAgICAgaWYgKG1lc3NhZ2UucmV0ZW50aW9uVGltZW91dCA8IGN1cnJlbnRUaW1lKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5jb250ZXh0LndpdGhUcmFjZSh7XG4gICAgICAgICAgICBhY3Rpdml0eTogYXN5bmMgKCkgPT4gdGhpcy5tZXNzYWdlcy5zcGxpY2UoaW5kZXgsIDEpLFxuICAgICAgICAgICAgbWVzc2FnZTogYFJlbW92aW5nIGV4cGlyZWQgbWVzc2FnZSAobWVzc2FnZT0ke21lc3NhZ2UucGF5bG9hZH0pLmAsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFJhbmRvbWl6ZSB0aGUgb3JkZXIgb2Ygc3Vic2NyaWJlcnMgdG8gYXZvaWQgdXNlciBjb2RlIG1ha2luZ1xuICAgICAgLy8gYXNzdW1wdGlvbnMgb24gdGhlIG9yZGVyIHRoYXQgc3Vic2NyaWJlcnMgcHJvY2VzcyBtZXNzYWdlcy5cbiAgICAgIGZvciAoY29uc3Qgc3Vic2NyaWJlciBvZiBuZXcgUmFuZG9tQXJyYXlJdGVyYXRvcih0aGlzLnN1YnNjcmliZXJzKSkge1xuICAgICAgICAvLyBFeHRyYWN0IHJhbmRvbSBtZXNzYWdlcyBmcm9tIHRoZSBxdWV1ZVxuICAgICAgICBjb25zdCBtZXNzYWdlcyA9IG5ldyBBcnJheTxRdWV1ZU1lc3NhZ2U+KCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3Vic2NyaWJlci5iYXRjaFNpemU7IGkrKykge1xuICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2VzLnNwbGljZShcbiAgICAgICAgICAgIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHRoaXMubWVzc2FnZXMubGVuZ3RoKSxcbiAgICAgICAgICAgIDFcbiAgICAgICAgICApWzBdO1xuICAgICAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgICAgICBtZXNzYWdlcy5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXNzYWdlc1BheWxvYWQgPSBtZXNzYWdlcy5tYXAoKG0pID0+IG0ucGF5bG9hZCk7XG4gICAgICAgIGlmIChtZXNzYWdlc1BheWxvYWQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBmbkNsaWVudCA9IHRoaXMuY29udGV4dC5nZXRDbGllbnQoXG4gICAgICAgICAgc3Vic2NyaWJlci5mdW5jdGlvbkhhbmRsZVxuICAgICAgICApIGFzIElGdW5jdGlvbkNsaWVudDtcbiAgICAgICAgaWYgKCFmbkNsaWVudCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGZ1bmN0aW9uIGNsaWVudCBmb3VuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSBmdW5jdGlvbiB3ZSBwaWNrZWQgaXMgYXQgY2FwYWNpdHksIGtlZXAgdGhlIG1lc3NhZ2VzIGluIHRoZSBxdWV1ZVxuICAgICAgICBjb25zdCBoYXNXb3JrZXJzID0gYXdhaXQgKFxuICAgICAgICAgIGZuQ2xpZW50IGFzIEZ1bmN0aW9uQ2xpZW50XG4gICAgICAgICkuaGFzQXZhaWxhYmxlV29ya2VycygpO1xuICAgICAgICBpZiAoIWhhc1dvcmtlcnMpIHtcbiAgICAgICAgICB0aGlzLm1lc3NhZ2VzLnB1c2goLi4ubWVzc2FnZXMpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb250ZXh0LmFkZFRyYWNlKHtcbiAgICAgICAgICB0eXBlOiBUcmFjZVR5cGUuUkVTT1VSQ0UsXG4gICAgICAgICAgbGV2ZWw6IExvZ0xldmVsLlZFUkJPU0UsXG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgbWVzc2FnZTogYFNlbmRpbmcgbWVzc2FnZXMgKG1lc3NhZ2VzPSR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgIG1lc3NhZ2VzUGF5bG9hZFxuICAgICAgICAgICAgKX0sIHN1YnNjcmliZXI9JHtzdWJzY3JpYmVyLmZ1bmN0aW9uSGFuZGxlfSkuYCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNvdXJjZVBhdGg6IHRoaXMuY29udGV4dC5yZXNvdXJjZVBhdGgsXG4gICAgICAgICAgc291cmNlVHlwZTogUVVFVUVfRlFOLFxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyB3ZSBkb24ndCB1c2UgaW52b2tlQXN5bmMgaGVyZSBiZWNhdXNlIHdlIHdhbnQgdG8gd2FpdCBmb3IgdGhlIGZ1bmN0aW9uIHRvIGZpbmlzaFxuICAgICAgICAvLyBhbmQgcmVxdWV1ZSB0aGUgbWVzc2FnZXMgaWYgaXQgZmFpbHNcbiAgICAgICAgdm9pZCBmbkNsaWVudFxuICAgICAgICAgIC5pbnZva2UoSlNPTi5zdHJpbmdpZnkoeyBtZXNzYWdlczogbWVzc2FnZXMgfSkpXG4gICAgICAgICAgLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGxxICYmIHJlc3VsdCkge1xuICAgICAgICAgICAgICBjb25zdCBlcnJvckxpc3QgPSBKU09OLnBhcnNlKHJlc3VsdCk7XG4gICAgICAgICAgICAgIGxldCByZXRyaWVzTWVzc2FnZXMgPSBbXTtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBtc2cgb2YgZXJyb3JMaXN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgbXNnLnJlbWFpbmluZ0RlbGl2ZXJ5QXR0ZW1wdHMgPCB0aGlzLmRscS5tYXhEZWxpdmVyeUF0dGVtcHRzXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICBtc2cucmVtYWluaW5nRGVsaXZlcnlBdHRlbXB0cysrO1xuICAgICAgICAgICAgICAgICAgcmV0cmllc01lc3NhZ2VzLnB1c2gobXNnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbGV0IGRscSA9IHRoaXMuY29udGV4dC5nZXRDbGllbnQoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGxxLmRscUhhbmRsZXJcbiAgICAgICAgICAgICAgICAgICkgYXMgSVF1ZXVlQ2xpZW50O1xuXG4gICAgICAgICAgICAgICAgICB2b2lkIGRscS5wdXNoKG1zZy5wYXlsb2FkKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hZGRUcmFjZSh7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogVHJhY2VUeXBlLlJFU09VUkNFLFxuICAgICAgICAgICAgICAgICAgICAgIGxldmVsOiBMb2dMZXZlbC5FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgUHVzaGluZyBtZXNzYWdlcyB0byB0aGUgZGVhZC1sZXR0ZXIgcXVldWUgZ2VuZXJhdGVzIGFuIGVycm9yIC0+ICR7ZXJyfWAsXG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VQYXRoOiB0aGlzLmNvbnRleHQucmVzb3VyY2VQYXRoLFxuICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVR5cGU6IFFVRVVFX0ZRTixcbiAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlcy5wdXNoKC4uLnJldHJpZXNNZXNzYWdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGZ1bmN0aW9uIGlzIGF0IGEgY29uY3VycmVuY3kgbGltaXQsIHByZXRlbmQgd2UganVzdCBkaWRuJ3QgY2FsbCBpdFxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBlcnIubWVzc2FnZSA9PT1cbiAgICAgICAgICAgICAgXCJUb28gbWFueSByZXF1ZXN0cywgdGhlIGZ1bmN0aW9uIGhhcyByZWFjaGVkIGl0cyBjb25jdXJyZW5jeSBsaW1pdC5cIlxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHRoaXMubWVzc2FnZXMucHVzaCguLi5tZXNzYWdlcyk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zIGFuIGVycm9yLCBwdXQgdGhlIG1lc3NhZ2UgYmFjayBvbiB0aGUgcXVldWUgYWZ0ZXIgdGltZW91dCBwZXJpb2RcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5hZGRUcmFjZSh7XG4gICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBgU3Vic2NyaWJlciBlcnJvciAtIHJldHVybmluZyAke21lc3NhZ2VzUGF5bG9hZC5sZW5ndGh9IG1lc3NhZ2VzIHRvIHF1ZXVlOiAke2Vyci5tZXNzYWdlfWAsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNvdXJjZVBhdGg6IHRoaXMuY29udGV4dC5yZXNvdXJjZVBhdGgsXG4gICAgICAgICAgICAgIHNvdXJjZVR5cGU6IFFVRVVFX0ZRTixcbiAgICAgICAgICAgICAgdHlwZTogVHJhY2VUeXBlLlJFU09VUkNFLFxuICAgICAgICAgICAgICBsZXZlbDogTG9nTGV2ZWwuRVJST1IsXG4gICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnB1c2hNZXNzYWdlc0JhY2tUb1F1ZXVlKG1lc3NhZ2VzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgcHJvY2Vzc2VkTWVzc2FnZXMgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKHByb2Nlc3NlZE1lc3NhZ2VzKTtcbiAgfVxuXG4gIHB1YmxpYyBwdXNoTWVzc2FnZXNCYWNrVG9RdWV1ZShtZXNzYWdlczogQXJyYXk8UXVldWVNZXNzYWdlPik6IHZvaWQge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgLy8gRG9uJ3QgcHVzaCBiYWNrIG1lc3NhZ2VzIHdpdGggcmV0ZW50aW9uIHRpbWVvdXRzIHRoYXQgaGF2ZSBleHBpcmVkXG4gICAgICBjb25zdCByZXRhaW5lZE1lc3NhZ2VzID0gbWVzc2FnZXMuZmlsdGVyKFxuICAgICAgICAobWVzc2FnZSkgPT4gbWVzc2FnZS5yZXRlbnRpb25UaW1lb3V0ID4gbmV3IERhdGUoKVxuICAgICAgKTtcbiAgICAgIHRoaXMubWVzc2FnZXMucHVzaCguLi5yZXRhaW5lZE1lc3NhZ2VzKTtcbiAgICAgIHRoaXMuY29udGV4dC5hZGRUcmFjZSh7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBtZXNzYWdlOiBgJHtyZXRhaW5lZE1lc3NhZ2VzLmxlbmd0aH0gbWVzc2FnZXMgcHVzaGVkIGJhY2sgdG8gcXVldWUgYWZ0ZXIgdmlzaWJpbGl0eSB0aW1lb3V0LmAsXG4gICAgICAgIH0sXG4gICAgICAgIHNvdXJjZVBhdGg6IHRoaXMuY29udGV4dC5yZXNvdXJjZVBhdGgsXG4gICAgICAgIHNvdXJjZVR5cGU6IFFVRVVFX0ZRTixcbiAgICAgICAgdHlwZTogVHJhY2VUeXBlLlJFU09VUkNFLFxuICAgICAgICBsZXZlbDogTG9nTGV2ZWwuV0FSTklORyxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB9KTtcbiAgICB9LCB0aGlzLnRpbWVvdXRTZWNvbmRzICogMTAwMCk7XG4gIH1cbn1cblxuY2xhc3MgUXVldWVNZXNzYWdlIHtcbiAgcHVibGljIHJlYWRvbmx5IHJldGVudGlvblRpbWVvdXQ6IERhdGU7XG4gIHB1YmxpYyByZWFkb25seSBwYXlsb2FkOiBzdHJpbmc7XG4gIHB1YmxpYyByZW1haW5pbmdEZWxpdmVyeUF0dGVtcHRzOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcmV0ZW50aW9uUGVyaW9kOiBudW1iZXIsXG4gICAgcmVtYWluaW5nRGVsaXZlcnlBdHRlbXB0czogbnVtYmVyLFxuICAgIG1lc3NhZ2U6IHN0cmluZ1xuICApIHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IG5ldyBEYXRlKCk7XG4gICAgY3VycmVudFRpbWUuc2V0U2Vjb25kcyhyZXRlbnRpb25QZXJpb2QgKyBjdXJyZW50VGltZS5nZXRTZWNvbmRzKCkpO1xuICAgIHRoaXMucmV0ZW50aW9uVGltZW91dCA9IGN1cnJlbnRUaW1lO1xuICAgIHRoaXMucGF5bG9hZCA9IG1lc3NhZ2U7XG4gICAgdGhpcy5yZW1haW5pbmdEZWxpdmVyeUF0dGVtcHRzID0gcmVtYWluaW5nRGVsaXZlcnlBdHRlbXB0cztcbiAgfVxufVxuXG5jbGFzcyBSYW5kb21BcnJheUl0ZXJhdG9yPFQgPSBhbnk+IGltcGxlbWVudHMgSXRlcmFibGU8VD4ge1xuICBwcml2YXRlIGxlbmd0aDogbnVtYmVyO1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IHZhbHVlczogVFtdKSB7XG4gICAgdGhpcy5sZW5ndGggPSB0aGlzLnZhbHVlcy5sZW5ndGg7XG4gIH1cblxuICBwdWJsaWMgbmV4dCgpOiBJdGVyYXRvclJlc3VsdDxUPiB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH07XG4gICAgfVxuXG4gICAgY29uc3QgaSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHRoaXMubGVuZ3RoKTtcbiAgICBjb25zdCBqID0gLS10aGlzLmxlbmd0aDtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMudmFsdWVzW2ldO1xuXG4gICAgdGhpcy52YWx1ZXNbaV0gPSB0aGlzLnZhbHVlc1tqXTtcbiAgICB0aGlzLnZhbHVlc1tqXSA9IHZhbHVlO1xuXG4gICAgcmV0dXJuIHsgdmFsdWUgfTtcbiAgfVxuXG4gIHB1YmxpYyBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG5pbnRlcmZhY2UgTG9vcENvbnRyb2xsZXIge1xuICBzdG9wKCk6IFByb21pc2U8dm9pZD47XG4gIHN0YXJ0KCk6IFByb21pc2U8dm9pZD47XG59XG5cbi8qKlxuICogUnVucyBhbiBhc3luY2hyb25vdXMgZnVuY3Rpb24gZXZlcnkgYGludGVydmFsYCBtaWxsaXNlY29uZHMuXG4gKiBJZiB0aGUgZnVuY3Rpb24gdGFrZXMgbG9uZ2VyIHRoYW4gYGludGVydmFsYCB0byBydW4sIGl0IHdpbGwgYmUgcnVuIGFnYWluIGltbWVkaWF0ZWx5LlxuICogT3RoZXJ3aXNlLCBpdCB3aWxsIHdhaXQgdW50aWwgYGludGVydmFsYCBtaWxsaXNlY29uZHMgaGF2ZSBwYXNzZWQgYmVmb3JlIHJ1bm5pbmcgYWdhaW4uXG4gKiBAcGFyYW0gaW50ZXJ2YWwgVGhlIGludGVydmFsIGluIG1pbGxpc2Vjb25kc1xuICogQHBhcmFtIGZuIFRoZSBmdW5jdGlvbiB0byBydW5cbiAqIEByZXR1cm5zIEEgY29udHJvbGxlciB0aGF0IGNhbiBiZSB1c2VkIHRvIHN0b3AgdGhlIGxvb3BcbiAqL1xuZnVuY3Rpb24gcnVuRXZlcnkoaW50ZXJ2YWw6IG51bWJlciwgZm46ICgpID0+IFByb21pc2U8dm9pZD4pOiBMb29wQ29udHJvbGxlciB7XG4gIGxldCBrZWVwUnVubmluZyA9IHRydWU7XG4gIGxldCByZXNvbHZlU3RvcFByb21pc2U6ICh2YWx1ZT86IHVua25vd24pID0+IHZvaWQ7XG4gIGxldCBzdG9wQ2FsbGVkID0gZmFsc2U7IC8vIGluIGNhc2UgaXQgaXMgY2FsbGVkIG11bHRpcGxlIHRpbWVzXG4gIGxldCBzdG9wUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcmVzb2x2ZVN0b3BQcm9taXNlID0gcmVzb2x2ZTtcbiAgfSk7XG5cbiAgYXN5bmMgZnVuY3Rpb24gbG9vcCgpIHtcbiAgICB3aGlsZSAoa2VlcFJ1bm5pbmcpIHtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBmbigpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAga2VlcFJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgY29uc3QgZWxhcHNlZFRpbWUgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+XG4gICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgTWF0aC5tYXgoaW50ZXJ2YWwgLSBlbGFwc2VkVGltZSwgMCkpXG4gICAgICApO1xuICAgIH1cbiAgICByZXNvbHZlU3RvcFByb21pc2UoKTsgLy8gcmVzb2x2ZSB0aGUgcHJvbWlzZSB3aGVuIHRoZSBsb29wIGV4aXRzXG4gIH1cblxuICBjb25zdCBjb250cm9sbGVyID0ge1xuICAgIGFzeW5jIHN0b3AoKSB7XG4gICAgICBpZiAoIXN0b3BDYWxsZWQpIHtcbiAgICAgICAgc3RvcENhbGxlZCA9IHRydWU7XG4gICAgICAgIGtlZXBSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIGF3YWl0IHN0b3BQcm9taXNlOyAvLyB3YWl0IGZvciB0aGUgbG9vcCB0byBmaW5pc2hcbiAgICAgIH1cbiAgICB9LFxuICAgIGFzeW5jIHN0YXJ0KCkge1xuICAgICAgdm9pZCBsb29wKCk7XG4gICAgfSxcbiAgfTtcblxuICByZXR1cm4gY29udHJvbGxlcjtcbn1cbiJdfQ==