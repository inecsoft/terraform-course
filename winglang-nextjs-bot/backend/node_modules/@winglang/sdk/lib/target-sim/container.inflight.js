"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Container = void 0;
const child_process_1 = require("child_process");
const fs = __importStar(require("fs/promises"));
const path_1 = require("path");
const container_1 = require("./container");
const util_1 = require("./util");
const fs_1 = require("../fs");
const misc_1 = require("../shared/misc");
const simulator_1 = require("../simulator/simulator");
const std_1 = require("../std");
const util_2 = require("../util");
const STATE_FILENAME = "state.json";
class Container {
    constructor(props) {
        this.props = props;
        this.imageTag = props.imageTag;
        this.containerName = `wing-${util_2.Util.ulid()}`.toLocaleLowerCase();
        this.managedVolumes = {};
    }
    get context() {
        if (!this._context) {
            throw new Error("Cannot access context during class construction");
        }
        return this._context;
    }
    async init(context) {
        try {
            return await this.start(context);
        }
        catch (e) {
            this.addTrace(`Failed to start container: ${e.message}`, std_1.TraceType.RESOURCE, std_1.LogLevel.ERROR);
            return {};
        }
    }
    async start(context) {
        this._context = context;
        // Check for a previous state file to see if there was a port that was previously being used
        // if so, try to use it out of convenience
        const state = await this.loadState();
        if (state.managedVolumes) {
            this.managedVolumes = state.managedVolumes;
        }
        await this.prepareImage();
        // start the new container
        const dockerRun = [];
        dockerRun.push("-i");
        dockerRun.push("--rm");
        dockerRun.push("--name", this.containerName);
        if (this.props.network) {
            dockerRun.push(`--network=${this.props.network}`);
        }
        if (this.props.containerPort) {
            dockerRun.push("-p", this.props.containerPort.toString());
        }
        const envFile = await this.createEnvFile();
        if (envFile) {
            dockerRun.push("--env-file", envFile);
        }
        for (const volume of this.props.volumes ?? []) {
            dockerRun.push("-v");
            // if the user specified an anonymous volume
            if (volume.startsWith("/") && !volume.includes(":")) {
                // check if we have a managed volume for this path from a previous run
                if (this.managedVolumes[volume]) {
                    const volumeName = this.managedVolumes[volume];
                    dockerRun.push(`${volumeName}:${volume}`);
                }
                else {
                    const volumeName = `wing-volume-${util_2.Util.ulid()}`;
                    dockerRun.push(`${volumeName}:${volume}`);
                    this.managedVolumes[volume] = volumeName;
                }
            }
            else {
                dockerRun.push(volume);
            }
        }
        if (this.props.entrypoint) {
            dockerRun.push("--entrypoint");
            dockerRun.push(this.props.entrypoint);
        }
        dockerRun.push(this.imageTag);
        for (const a of this.props.args ?? []) {
            dockerRun.push(a);
        }
        this.addTrace(`Starting container from ${this.imageTag}`, std_1.TraceType.RESOURCE, std_1.LogLevel.VERBOSE);
        this.child = this.dockerSpawn("run", dockerRun, {
            logLevel: std_1.LogLevel.INFO,
        });
        this.addTrace(`Waiting for container to ${this.props.containerPort
            ? `listen to ${this.props.containerPort}`
            : "start"}`, std_1.TraceType.RESOURCE, std_1.LogLevel.VERBOSE);
        let hostPort;
        await waitUntil(async () => {
            if (!this.child?.running) {
                throw new Error(`Container ${this.imageTag} stopped unexpectedly`);
            }
            const container = await this.tryInspect(this.containerName);
            // if we are waiting for a port, check if the container is listening to it
            if (this.props.containerPort) {
                // when using the host network, the host port is the same as the container port
                if (this.props.network === "host") {
                    hostPort = this.props.containerPort.toString();
                    return (container?.[0]?.Config?.ExposedPorts?.[`${hostPort}/tcp`] !==
                        undefined);
                }
                hostPort =
                    container?.[0]?.NetworkSettings?.Ports?.[`${this.props.containerPort}/tcp`]?.[0]?.HostPort;
                return hostPort !== undefined;
            }
            // if we are not waiting for a port, just check if the container is running
            return container?.[0]?.State?.Running;
        });
        this.addTrace(`Container ${this.imageTag} started`, std_1.TraceType.RESOURCE, std_1.LogLevel.VERBOSE);
        return {
            [container_1.HOST_PORT_ATTR]: hostPort,
        };
    }
    /**
     * Builds or pulls the docker image used by this container.
     */
    async prepareImage() {
        // if this image is already here, we don't need to do anything
        if (await this.tryInspect(this.imageTag)) {
            this.addTrace(`Image ${this.imageTag} found, No need to build or pull.`, std_1.TraceType.RESOURCE, std_1.LogLevel.VERBOSE);
            return;
        }
        // if this a reference to a local directory, build the image from a docker file
        if ((0, misc_1.isPath)(this.props.image)) {
            this.addTrace(`Building ${this.imageTag} from ${this.props.image}...`, std_1.TraceType.RESOURCE, std_1.LogLevel.VERBOSE);
            await this.docker("build", ["-t", this.imageTag, this.props.image], {
                logLevel: std_1.LogLevel.VERBOSE,
            });
        }
        else {
            this.addTrace(`Pulling ${this.imageTag}...`, std_1.TraceType.RESOURCE, std_1.LogLevel.VERBOSE);
            await this.docker("pull", [this.imageTag], {
                logLevel: std_1.LogLevel.VERBOSE,
            });
        }
    }
    async createEnvFile() {
        const env = this.props.env ?? {};
        if (Object.keys(env).length === 0) {
            return undefined;
        }
        const envFile = (0, path_1.join)(fs_1.Util.mkdtemp(), "env.json");
        const envLines = [];
        for (const k of Object.keys(env)) {
            envLines.push(`${k}=${env[k]}`);
        }
        await fs.writeFile(envFile, envLines.join("\n"));
        return envFile;
    }
    async tryInspect(name) {
        try {
            return JSON.parse(await this.docker("inspect", [name], {
                quiet: true,
            }));
        }
        catch {
            return undefined;
        }
    }
    async cleanup() {
        this.addTrace(`Stopping container ${this.containerName}`, std_1.TraceType.RESOURCE, std_1.LogLevel.VERBOSE);
        await this.child?.kill();
    }
    async save() {
        await this.saveState({ managedVolumes: this.managedVolumes });
    }
    async loadState() {
        const stateFileExists = await (0, util_1.exists)((0, path_1.join)(this.context.statedir, STATE_FILENAME));
        if (stateFileExists) {
            const stateFileContents = await fs.readFile((0, path_1.join)(this.context.statedir, STATE_FILENAME), "utf-8");
            return JSON.parse(stateFileContents);
        }
        else {
            return {};
        }
    }
    async docker(command, args, options = {}) {
        const child = this.dockerSpawn(command, args, options);
        return child.join();
    }
    dockerSpawn(command, args, options = {}) {
        let quiet = options.quiet ?? false;
        const level = options.logLevel ?? std_1.LogLevel.INFO;
        const logErrors = !quiet;
        // can be used to hide container logs (used in our end to end tests). yes, ugly bit pragmatic.
        // otherwise, test output will include lots of non deterministic stuff and that's really hard to
        // snapshot.
        if (process.env.WING_HIDE_CONTAINER_LOGS) {
            quiet = true;
        }
        const commandDesc = `docker ${command}`;
        this.addTrace(`$ ${commandDesc} ${args.join(" ")}`, std_1.TraceType.RESOURCE, std_1.LogLevel.VERBOSE);
        const child = (0, child_process_1.spawn)("docker", [command, ...args], {
            cwd: this.props.cwd,
            stdio: "pipe",
        });
        let started = true;
        child.once("exit", () => {
            started = false;
        });
        const stdout = [];
        const allOutput = [];
        child.stdout.on("data", (data) => {
            stdout.push(data);
            allOutput.push(data);
        });
        child.stderr.on("data", (data) => {
            allOutput.push(data);
        });
        if (!quiet) {
            child.stdout.on("data", (data) => this.addTrace(data.toString(), std_1.TraceType.LOG, level));
            child.stderr.on("data", (data) => this.addTrace(data.toString(), std_1.TraceType.LOG, level));
        }
        child.once("error", (err) => {
            started = false;
            if (logErrors) {
                this.addTrace(err.stack ?? err.message, std_1.TraceType.LOG, std_1.LogLevel.ERROR);
            }
        });
        const self = this;
        return {
            get running() {
                return started;
            },
            async kill() {
                return new Promise((resolve, reject) => {
                    if (!started) {
                        return resolve();
                    }
                    self.addTrace("Sending SIGTERM to container", std_1.TraceType.RESOURCE, std_1.LogLevel.VERBOSE);
                    child.kill("SIGTERM");
                    // if the process doesn't exit in 2 seconds, kill it
                    const timeout = setTimeout(() => {
                        self.addTrace(`Timeout waiting for container ${self._context?.resourcePath} to shutdown, removing forcefully`, std_1.TraceType.RESOURCE, std_1.LogLevel.WARNING);
                        self
                            .docker("rm", ["-f", self.containerName], { quiet: true })
                            .catch(() => { });
                    }, 2000);
                    child.once("error", (err) => {
                        self.addTrace(`Error when shutting down container: ${err.stack ?? err.message}`, std_1.TraceType.RESOURCE, std_1.LogLevel.ERROR);
                        clearTimeout(timeout);
                        reject(err);
                    });
                    child.once("exit", () => {
                        self.addTrace("Container shutdown successfully", std_1.TraceType.RESOURCE, std_1.LogLevel.VERBOSE);
                        clearTimeout(timeout);
                        resolve();
                    });
                });
            },
            async join() {
                return new Promise((ok, ko) => {
                    if (!started) {
                        return ok(stdout.join(""));
                    }
                    child.once("error", ko);
                    child.once("exit", (code) => {
                        if (code === 0) {
                            return ok(stdout.join(""));
                        }
                        else {
                            const message = `Command "${commandDesc}" exited with non-zero code ${code}`;
                            if (logErrors) {
                                self.addTrace(`${message}}\n${allOutput.join("")}`, std_1.TraceType.RESOURCE, std_1.LogLevel.VERBOSE);
                            }
                            return ko(new Error(`${message} (see verbose logs)`));
                        }
                    });
                });
            },
        };
    }
    async saveState(state) {
        await fs.writeFile((0, path_1.join)(this.context.statedir, STATE_FILENAME), JSON.stringify(state));
    }
    async plan() {
        return simulator_1.UpdatePlan.AUTO;
    }
    addTrace(message, type, level) {
        this.context.addTrace({
            data: { message: message.trim() },
            sourcePath: this.context.resourcePath,
            sourceType: "container",
            timestamp: new Date().toISOString(),
            type,
            level,
        });
    }
}
exports.Container = Container;
async function waitUntil(predicate) {
    const timeout = std_1.Duration.fromSeconds(30);
    const interval = std_1.Duration.fromSeconds(0.1);
    let elapsed = 0;
    while (elapsed < timeout.seconds) {
        if (await predicate()) {
            return true;
        }
        elapsed += interval.seconds;
        await util_2.Util.sleep(interval);
    }
    throw new Error("Timeout elapsed");
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udGFpbmVyLmluZmxpZ2h0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3RhcmdldC1zaW0vY29udGFpbmVyLmluZmxpZ2h0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsaURBQXNDO0FBQ3RDLGdEQUFrQztBQUNsQywrQkFBNEI7QUFDNUIsMkNBQStEO0FBRS9ELGlDQUFnQztBQUNoQyw4QkFBbUM7QUFDbkMseUNBQXdDO0FBQ3hDLHNEQUlnQztBQUNoQyxnQ0FBdUQ7QUFDdkQsa0NBQStCO0FBRS9CLE1BQU0sY0FBYyxHQUFHLFlBQVksQ0FBQztBQWFwQyxNQUFhLFNBQVM7SUFPcEIsWUFBb0MsS0FBc0I7UUFBdEIsVUFBSyxHQUFMLEtBQUssQ0FBaUI7UUFDeEQsSUFBSSxDQUFDLFFBQVEsR0FBRyxLQUFLLENBQUMsUUFBUSxDQUFDO1FBQy9CLElBQUksQ0FBQyxhQUFhLEdBQUcsUUFBUSxXQUFJLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBQy9ELElBQUksQ0FBQyxjQUFjLEdBQUcsRUFBRSxDQUFDO0lBQzNCLENBQUM7SUFFRCxJQUFZLE9BQU87UUFDakIsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUNuQixNQUFNLElBQUksS0FBSyxDQUFDLGlEQUFpRCxDQUFDLENBQUM7UUFDckUsQ0FBQztRQUNELE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQztJQUN2QixDQUFDO0lBRU0sS0FBSyxDQUFDLElBQUksQ0FBQyxPQUEwQjtRQUMxQyxJQUFJLENBQUM7WUFDSCxPQUFPLE1BQU0sSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUNuQyxDQUFDO1FBQUMsT0FBTyxDQUFNLEVBQUUsQ0FBQztZQUNoQixJQUFJLENBQUMsUUFBUSxDQUNYLDhCQUE4QixDQUFDLENBQUMsT0FBTyxFQUFFLEVBQ3pD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LEVBQUUsSUFBZSxFQUFFLEtBQWU7UUFDaEUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUM7WUFDcEIsSUFBSSxFQUFFLEVBQUUsT0FBTyxFQUFFLE9BQU8sQ0FBQyxJQUFJLEVBQUUsRUFBRTtZQUNqQyxVQUFVLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxZQUFZO1lBQ3JDLFVBQVUsRUFBRSxXQUFXO1lBQ3ZCLFNBQVMsRUFBRSxJQUFJLElBQUksRUFBRSxDQUFDLFdBQVcsRUFBRTtZQUNuQyxJQUFJO1lBQ0osS0FBSztTQUNOLENBQUMsQ0FBQztJQUNMLENBQUM7Q0FDRjtBQTVhRCw4QkE0YUM7QUFFRCxLQUFLLFVBQVUsU0FBUyxDQUFDLFNBQWlDO0lBQ3hELE1BQU0sT0FBTyxHQUFHLGNBQVEsQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDekMsTUFBTSxRQUFRLEdBQUcsY0FBUSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUMzQyxJQUFJLE9BQU8sR0FBRyxDQUFDLENBQUM7SUFDaEIsT0FBTyxPQUFPLEdBQUcsT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ2pDLElBQUksTUFBTSxTQUFTLEVBQUUsRUFBRSxDQUFDO1lBQ3RCLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUNELE9BQU8sSUFBSSxRQUFRLENBQUMsT0FBTyxDQUFDO1FBQzVCLE1BQU0sV0FBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUM3QixDQUFDO0lBRUQsTUFBTSxJQUFJLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0FBQ3JDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzcGF3biB9IGZyb20gXCJjaGlsZF9wcm9jZXNzXCI7XG5pbXBvcnQgKiBhcyBmcyBmcm9tIFwiZnMvcHJvbWlzZXNcIjtcbmltcG9ydCB7IGpvaW4gfSBmcm9tIFwicGF0aFwiO1xuaW1wb3J0IHsgSUNvbnRhaW5lckNsaWVudCwgSE9TVF9QT1JUX0FUVFIgfSBmcm9tIFwiLi9jb250YWluZXJcIjtcbmltcG9ydCB7IENvbnRhaW5lckF0dHJpYnV0ZXMsIENvbnRhaW5lclNjaGVtYSB9IGZyb20gXCIuL3NjaGVtYS1yZXNvdXJjZXNcIjtcbmltcG9ydCB7IGV4aXN0cyB9IGZyb20gXCIuL3V0aWxcIjtcbmltcG9ydCB7IFV0aWwgYXMgRnMgfSBmcm9tIFwiLi4vZnNcIjtcbmltcG9ydCB7IGlzUGF0aCB9IGZyb20gXCIuLi9zaGFyZWQvbWlzY1wiO1xuaW1wb3J0IHtcbiAgSVNpbXVsYXRvckNvbnRleHQsXG4gIElTaW11bGF0b3JSZXNvdXJjZUluc3RhbmNlLFxuICBVcGRhdGVQbGFuLFxufSBmcm9tIFwiLi4vc2ltdWxhdG9yL3NpbXVsYXRvclwiO1xuaW1wb3J0IHsgRHVyYXRpb24sIExvZ0xldmVsLCBUcmFjZVR5cGUgfSBmcm9tIFwiLi4vc3RkXCI7XG5pbXBvcnQgeyBVdGlsIH0gZnJvbSBcIi4uL3V0aWxcIjtcblxuY29uc3QgU1RBVEVfRklMRU5BTUUgPSBcInN0YXRlLmpzb25cIjtcblxuLyoqXG4gKiBDb250ZW50cyBvZiB0aGUgc3RhdGUgZmlsZSBmb3IgdGhpcyByZXNvdXJjZS5cbiAqL1xuaW50ZXJmYWNlIFN0YXRlRmlsZUNvbnRlbnRzIHtcbiAgLyoqXG4gICAqIEEgbWFwcGluZyBvZiB2b2x1bWUgcGF0aHMgdG8gdGhlIFdpbmctbWFuYWdlZCB2b2x1bWUgbmFtZXMsIHdoaWNoIHdpbGwgYmUgcmV1c2VkXG4gICAqIGFjcm9zcyBzaW11bGF0b3IgcnVucy5cbiAgICovXG4gIHJlYWRvbmx5IG1hbmFnZWRWb2x1bWVzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbn1cblxuZXhwb3J0IGNsYXNzIENvbnRhaW5lciBpbXBsZW1lbnRzIElDb250YWluZXJDbGllbnQsIElTaW11bGF0b3JSZXNvdXJjZUluc3RhbmNlIHtcbiAgcHJpdmF0ZSByZWFkb25seSBpbWFnZVRhZzogc3RyaW5nO1xuICBwcml2YXRlIHJlYWRvbmx5IGNvbnRhaW5lck5hbWU6IHN0cmluZztcbiAgcHJpdmF0ZSBfY29udGV4dDogSVNpbXVsYXRvckNvbnRleHQgfCB1bmRlZmluZWQ7XG4gIHByaXZhdGUgbWFuYWdlZFZvbHVtZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gIHByaXZhdGUgY2hpbGQ6IERvY2tlclByb2Nlc3MgfCB1bmRlZmluZWQ7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgcHJvcHM6IENvbnRhaW5lclNjaGVtYSkge1xuICAgIHRoaXMuaW1hZ2VUYWcgPSBwcm9wcy5pbWFnZVRhZztcbiAgICB0aGlzLmNvbnRhaW5lck5hbWUgPSBgd2luZy0ke1V0aWwudWxpZCgpfWAudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICB0aGlzLm1hbmFnZWRWb2x1bWVzID0ge307XG4gIH1cblxuICBwcml2YXRlIGdldCBjb250ZXh0KCk6IElTaW11bGF0b3JDb250ZXh0IHtcbiAgICBpZiAoIXRoaXMuX2NvbnRleHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhY2Nlc3MgY29udGV4dCBkdXJpbmcgY2xhc3MgY29uc3RydWN0aW9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY29udGV4dDtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBpbml0KGNvbnRleHQ6IElTaW11bGF0b3JDb250ZXh0KTogUHJvbWlzZTxDb250YWluZXJBdHRyaWJ1dGVzPiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnN0YXJ0KGNvbnRleHQpO1xuICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgdGhpcy5hZGRUcmFjZShcbiAgICAgICAgYEZhaWxlZCB0byBzdGFydCBjb250YWluZXI6ICR7ZS5tZXNzYWdlfWAsXG4gICAgICAgIFRyYWNlVHlwZS5SRVNPVVJDRSxcbiAgICAgICAgTG9nTGV2ZWwuRVJST1JcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgc3RhcnQoY29udGV4dDogSVNpbXVsYXRvckNvbnRleHQpOiBQcm9taXNlPENvbnRhaW5lckF0dHJpYnV0ZXM+IHtcbiAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcblxuICAgIC8vIENoZWNrIGZvciBhIHByZXZpb3VzIHN0YXRlIGZpbGUgdG8gc2VlIGlmIHRoZXJlIHdhcyBhIHBvcnQgdGhhdCB3YXMgcHJldmlvdXNseSBiZWluZyB1c2VkXG4gICAgLy8gaWYgc28sIHRyeSB0byB1c2UgaXQgb3V0IG9mIGNvbnZlbmllbmNlXG4gICAgY29uc3Qgc3RhdGU6IFN0YXRlRmlsZUNvbnRlbnRzID0gYXdhaXQgdGhpcy5sb2FkU3RhdGUoKTtcbiAgICBpZiAoc3RhdGUubWFuYWdlZFZvbHVtZXMpIHtcbiAgICAgIHRoaXMubWFuYWdlZFZvbHVtZXMgPSBzdGF0ZS5tYW5hZ2VkVm9sdW1lcztcbiAgICB9XG5cbiAgICBhd2FpdCB0aGlzLnByZXBhcmVJbWFnZSgpO1xuXG4gICAgLy8gc3RhcnQgdGhlIG5ldyBjb250YWluZXJcbiAgICBjb25zdCBkb2NrZXJSdW46IHN0cmluZ1tdID0gW107XG4gICAgZG9ja2VyUnVuLnB1c2goXCItaVwiKTtcbiAgICBkb2NrZXJSdW4ucHVzaChcIi0tcm1cIik7XG4gICAgZG9ja2VyUnVuLnB1c2goXCItLW5hbWVcIiwgdGhpcy5jb250YWluZXJOYW1lKTtcblxuICAgIGlmICh0aGlzLnByb3BzLm5ldHdvcmspIHtcbiAgICAgIGRvY2tlclJ1bi5wdXNoKGAtLW5ldHdvcms9JHt0aGlzLnByb3BzLm5ldHdvcmt9YCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucHJvcHMuY29udGFpbmVyUG9ydCkge1xuICAgICAgZG9ja2VyUnVuLnB1c2goXCItcFwiLCB0aGlzLnByb3BzLmNvbnRhaW5lclBvcnQudG9TdHJpbmcoKSk7XG4gICAgfVxuXG4gICAgY29uc3QgZW52RmlsZSA9IGF3YWl0IHRoaXMuY3JlYXRlRW52RmlsZSgpO1xuICAgIGlmIChlbnZGaWxlKSB7XG4gICAgICBkb2NrZXJSdW4ucHVzaChcIi0tZW52LWZpbGVcIiwgZW52RmlsZSk7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCB2b2x1bWUgb2YgdGhpcy5wcm9wcy52b2x1bWVzID8/IFtdKSB7XG4gICAgICBkb2NrZXJSdW4ucHVzaChcIi12XCIpO1xuXG4gICAgICAvLyBpZiB0aGUgdXNlciBzcGVjaWZpZWQgYW4gYW5vbnltb3VzIHZvbHVtZVxuICAgICAgaWYgKHZvbHVtZS5zdGFydHNXaXRoKFwiL1wiKSAmJiAhdm9sdW1lLmluY2x1ZGVzKFwiOlwiKSkge1xuICAgICAgICAvLyBjaGVjayBpZiB3ZSBoYXZlIGEgbWFuYWdlZCB2b2x1bWUgZm9yIHRoaXMgcGF0aCBmcm9tIGEgcHJldmlvdXMgcnVuXG4gICAgICAgIGlmICh0aGlzLm1hbmFnZWRWb2x1bWVzW3ZvbHVtZV0pIHtcbiAgICAgICAgICBjb25zdCB2b2x1bWVOYW1lID0gdGhpcy5tYW5hZ2VkVm9sdW1lc1t2b2x1bWVdO1xuICAgICAgICAgIGRvY2tlclJ1bi5wdXNoKGAke3ZvbHVtZU5hbWV9OiR7dm9sdW1lfWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHZvbHVtZU5hbWUgPSBgd2luZy12b2x1bWUtJHtVdGlsLnVsaWQoKX1gO1xuICAgICAgICAgIGRvY2tlclJ1bi5wdXNoKGAke3ZvbHVtZU5hbWV9OiR7dm9sdW1lfWApO1xuICAgICAgICAgIHRoaXMubWFuYWdlZFZvbHVtZXNbdm9sdW1lXSA9IHZvbHVtZU5hbWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvY2tlclJ1bi5wdXNoKHZvbHVtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucHJvcHMuZW50cnlwb2ludCkge1xuICAgICAgZG9ja2VyUnVuLnB1c2goXCItLWVudHJ5cG9pbnRcIik7XG4gICAgICBkb2NrZXJSdW4ucHVzaCh0aGlzLnByb3BzLmVudHJ5cG9pbnQpO1xuICAgIH1cblxuICAgIGRvY2tlclJ1bi5wdXNoKHRoaXMuaW1hZ2VUYWcpO1xuXG4gICAgZm9yIChjb25zdCBhIG9mIHRoaXMucHJvcHMuYXJncyA/PyBbXSkge1xuICAgICAgZG9ja2VyUnVuLnB1c2goYSk7XG4gICAgfVxuXG4gICAgdGhpcy5hZGRUcmFjZShcbiAgICAgIGBTdGFydGluZyBjb250YWluZXIgZnJvbSAke3RoaXMuaW1hZ2VUYWd9YCxcbiAgICAgIFRyYWNlVHlwZS5SRVNPVVJDRSxcbiAgICAgIExvZ0xldmVsLlZFUkJPU0VcbiAgICApO1xuXG4gICAgdGhpcy5jaGlsZCA9IHRoaXMuZG9ja2VyU3Bhd24oXCJydW5cIiwgZG9ja2VyUnVuLCB7XG4gICAgICBsb2dMZXZlbDogTG9nTGV2ZWwuSU5GTyxcbiAgICB9KTtcblxuICAgIHRoaXMuYWRkVHJhY2UoXG4gICAgICBgV2FpdGluZyBmb3IgY29udGFpbmVyIHRvICR7XG4gICAgICAgIHRoaXMucHJvcHMuY29udGFpbmVyUG9ydFxuICAgICAgICAgID8gYGxpc3RlbiB0byAke3RoaXMucHJvcHMuY29udGFpbmVyUG9ydH1gXG4gICAgICAgICAgOiBcInN0YXJ0XCJcbiAgICAgIH1gLFxuICAgICAgVHJhY2VUeXBlLlJFU09VUkNFLFxuICAgICAgTG9nTGV2ZWwuVkVSQk9TRVxuICAgICk7XG5cbiAgICBsZXQgaG9zdFBvcnQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICBhd2FpdCB3YWl0VW50aWwoYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmNoaWxkPy5ydW5uaW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29udGFpbmVyICR7dGhpcy5pbWFnZVRhZ30gc3RvcHBlZCB1bmV4cGVjdGVkbHlgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY29udGFpbmVyID0gYXdhaXQgdGhpcy50cnlJbnNwZWN0KHRoaXMuY29udGFpbmVyTmFtZSk7XG5cbiAgICAgIC8vIGlmIHdlIGFyZSB3YWl0aW5nIGZvciBhIHBvcnQsIGNoZWNrIGlmIHRoZSBjb250YWluZXIgaXMgbGlzdGVuaW5nIHRvIGl0XG4gICAgICBpZiAodGhpcy5wcm9wcy5jb250YWluZXJQb3J0KSB7XG4gICAgICAgIC8vIHdoZW4gdXNpbmcgdGhlIGhvc3QgbmV0d29yaywgdGhlIGhvc3QgcG9ydCBpcyB0aGUgc2FtZSBhcyB0aGUgY29udGFpbmVyIHBvcnRcbiAgICAgICAgaWYgKHRoaXMucHJvcHMubmV0d29yayA9PT0gXCJob3N0XCIpIHtcbiAgICAgICAgICBob3N0UG9ydCA9IHRoaXMucHJvcHMuY29udGFpbmVyUG9ydC50b1N0cmluZygpO1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBjb250YWluZXI/LlswXT8uQ29uZmlnPy5FeHBvc2VkUG9ydHM/LltgJHtob3N0UG9ydH0vdGNwYF0gIT09XG4gICAgICAgICAgICB1bmRlZmluZWRcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaG9zdFBvcnQgPVxuICAgICAgICAgIGNvbnRhaW5lcj8uWzBdPy5OZXR3b3JrU2V0dGluZ3M/LlBvcnRzPy5bXG4gICAgICAgICAgICBgJHt0aGlzLnByb3BzLmNvbnRhaW5lclBvcnR9L3RjcGBcbiAgICAgICAgICBdPy5bMF0/Lkhvc3RQb3J0O1xuXG4gICAgICAgIHJldHVybiBob3N0UG9ydCAhPT0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiB3ZSBhcmUgbm90IHdhaXRpbmcgZm9yIGEgcG9ydCwganVzdCBjaGVjayBpZiB0aGUgY29udGFpbmVyIGlzIHJ1bm5pbmdcbiAgICAgIHJldHVybiBjb250YWluZXI/LlswXT8uU3RhdGU/LlJ1bm5pbmc7XG4gICAgfSk7XG5cbiAgICB0aGlzLmFkZFRyYWNlKFxuICAgICAgYENvbnRhaW5lciAke3RoaXMuaW1hZ2VUYWd9IHN0YXJ0ZWRgLFxuICAgICAgVHJhY2VUeXBlLlJFU09VUkNFLFxuICAgICAgTG9nTGV2ZWwuVkVSQk9TRVxuICAgICk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgW0hPU1RfUE9SVF9BVFRSXTogaG9zdFBvcnQsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgb3IgcHVsbHMgdGhlIGRvY2tlciBpbWFnZSB1c2VkIGJ5IHRoaXMgY29udGFpbmVyLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBwcmVwYXJlSW1hZ2UoKSB7XG4gICAgLy8gaWYgdGhpcyBpbWFnZSBpcyBhbHJlYWR5IGhlcmUsIHdlIGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmdcbiAgICBpZiAoYXdhaXQgdGhpcy50cnlJbnNwZWN0KHRoaXMuaW1hZ2VUYWcpKSB7XG4gICAgICB0aGlzLmFkZFRyYWNlKFxuICAgICAgICBgSW1hZ2UgJHt0aGlzLmltYWdlVGFnfSBmb3VuZCwgTm8gbmVlZCB0byBidWlsZCBvciBwdWxsLmAsXG4gICAgICAgIFRyYWNlVHlwZS5SRVNPVVJDRSxcbiAgICAgICAgTG9nTGV2ZWwuVkVSQk9TRVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGlmIHRoaXMgYSByZWZlcmVuY2UgdG8gYSBsb2NhbCBkaXJlY3RvcnksIGJ1aWxkIHRoZSBpbWFnZSBmcm9tIGEgZG9ja2VyIGZpbGVcbiAgICBpZiAoaXNQYXRoKHRoaXMucHJvcHMuaW1hZ2UpKSB7XG4gICAgICB0aGlzLmFkZFRyYWNlKFxuICAgICAgICBgQnVpbGRpbmcgJHt0aGlzLmltYWdlVGFnfSBmcm9tICR7dGhpcy5wcm9wcy5pbWFnZX0uLi5gLFxuICAgICAgICBUcmFjZVR5cGUuUkVTT1VSQ0UsXG4gICAgICAgIExvZ0xldmVsLlZFUkJPU0VcbiAgICAgICk7XG4gICAgICBhd2FpdCB0aGlzLmRvY2tlcihcImJ1aWxkXCIsIFtcIi10XCIsIHRoaXMuaW1hZ2VUYWcsIHRoaXMucHJvcHMuaW1hZ2VdLCB7XG4gICAgICAgIGxvZ0xldmVsOiBMb2dMZXZlbC5WRVJCT1NFLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkVHJhY2UoXG4gICAgICAgIGBQdWxsaW5nICR7dGhpcy5pbWFnZVRhZ30uLi5gLFxuICAgICAgICBUcmFjZVR5cGUuUkVTT1VSQ0UsXG4gICAgICAgIExvZ0xldmVsLlZFUkJPU0VcbiAgICAgICk7XG4gICAgICBhd2FpdCB0aGlzLmRvY2tlcihcInB1bGxcIiwgW3RoaXMuaW1hZ2VUYWddLCB7XG4gICAgICAgIGxvZ0xldmVsOiBMb2dMZXZlbC5WRVJCT1NFLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBjcmVhdGVFbnZGaWxlKCkge1xuICAgIGNvbnN0IGVudiA9IHRoaXMucHJvcHMuZW52ID8/IHt9O1xuICAgIGlmIChPYmplY3Qua2V5cyhlbnYpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBjb25zdCBlbnZGaWxlID0gam9pbihGcy5ta2R0ZW1wKCksIFwiZW52Lmpzb25cIik7XG4gICAgY29uc3QgZW52TGluZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGsgb2YgT2JqZWN0LmtleXMoZW52KSkge1xuICAgICAgZW52TGluZXMucHVzaChgJHtrfT0ke2VudltrXX1gKTtcbiAgICB9XG5cbiAgICBhd2FpdCBmcy53cml0ZUZpbGUoZW52RmlsZSwgZW52TGluZXMuam9pbihcIlxcblwiKSk7XG4gICAgcmV0dXJuIGVudkZpbGU7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHRyeUluc3BlY3QobmFtZTogc3RyaW5nKTogUHJvbWlzZTxhbnkgfCB1bmRlZmluZWQ+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoXG4gICAgICAgIGF3YWl0IHRoaXMuZG9ja2VyKFwiaW5zcGVjdFwiLCBbbmFtZV0sIHtcbiAgICAgICAgICBxdWlldDogdHJ1ZSxcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBjbGVhbnVwKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMuYWRkVHJhY2UoXG4gICAgICBgU3RvcHBpbmcgY29udGFpbmVyICR7dGhpcy5jb250YWluZXJOYW1lfWAsXG4gICAgICBUcmFjZVR5cGUuUkVTT1VSQ0UsXG4gICAgICBMb2dMZXZlbC5WRVJCT1NFXG4gICAgKTtcblxuICAgIGF3YWl0IHRoaXMuY2hpbGQ/LmtpbGwoKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBzYXZlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMuc2F2ZVN0YXRlKHsgbWFuYWdlZFZvbHVtZXM6IHRoaXMubWFuYWdlZFZvbHVtZXMgfSk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGxvYWRTdGF0ZSgpOiBQcm9taXNlPFN0YXRlRmlsZUNvbnRlbnRzPiB7XG4gICAgY29uc3Qgc3RhdGVGaWxlRXhpc3RzID0gYXdhaXQgZXhpc3RzKFxuICAgICAgam9pbih0aGlzLmNvbnRleHQuc3RhdGVkaXIsIFNUQVRFX0ZJTEVOQU1FKVxuICAgICk7XG4gICAgaWYgKHN0YXRlRmlsZUV4aXN0cykge1xuICAgICAgY29uc3Qgc3RhdGVGaWxlQ29udGVudHMgPSBhd2FpdCBmcy5yZWFkRmlsZShcbiAgICAgICAgam9pbih0aGlzLmNvbnRleHQuc3RhdGVkaXIsIFNUQVRFX0ZJTEVOQU1FKSxcbiAgICAgICAgXCJ1dGYtOFwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RhdGVGaWxlQ29udGVudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBkb2NrZXIoXG4gICAgY29tbWFuZDogc3RyaW5nLFxuICAgIGFyZ3M6IHN0cmluZ1tdLFxuICAgIG9wdGlvbnM6IERvY2tlck9wdGlvbnMgPSB7fVxuICApOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IGNoaWxkID0gdGhpcy5kb2NrZXJTcGF3bihjb21tYW5kLCBhcmdzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gY2hpbGQuam9pbigpO1xuICB9XG5cbiAgcHJpdmF0ZSBkb2NrZXJTcGF3bihcbiAgICBjb21tYW5kOiBzdHJpbmcsXG4gICAgYXJnczogc3RyaW5nW10sXG4gICAgb3B0aW9uczogRG9ja2VyT3B0aW9ucyA9IHt9XG4gICk6IERvY2tlclByb2Nlc3Mge1xuICAgIGxldCBxdWlldCA9IG9wdGlvbnMucXVpZXQgPz8gZmFsc2U7XG4gICAgY29uc3QgbGV2ZWwgPSBvcHRpb25zLmxvZ0xldmVsID8/IExvZ0xldmVsLklORk87XG4gICAgY29uc3QgbG9nRXJyb3JzID0gIXF1aWV0O1xuXG4gICAgLy8gY2FuIGJlIHVzZWQgdG8gaGlkZSBjb250YWluZXIgbG9ncyAodXNlZCBpbiBvdXIgZW5kIHRvIGVuZCB0ZXN0cykuIHllcywgdWdseSBiaXQgcHJhZ21hdGljLlxuICAgIC8vIG90aGVyd2lzZSwgdGVzdCBvdXRwdXQgd2lsbCBpbmNsdWRlIGxvdHMgb2Ygbm9uIGRldGVybWluaXN0aWMgc3R1ZmYgYW5kIHRoYXQncyByZWFsbHkgaGFyZCB0b1xuICAgIC8vIHNuYXBzaG90LlxuICAgIGlmIChwcm9jZXNzLmVudi5XSU5HX0hJREVfQ09OVEFJTkVSX0xPR1MpIHtcbiAgICAgIHF1aWV0ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBjb21tYW5kRGVzYyA9IGBkb2NrZXIgJHtjb21tYW5kfWA7XG5cbiAgICB0aGlzLmFkZFRyYWNlKFxuICAgICAgYCQgJHtjb21tYW5kRGVzY30gJHthcmdzLmpvaW4oXCIgXCIpfWAsXG4gICAgICBUcmFjZVR5cGUuUkVTT1VSQ0UsXG4gICAgICBMb2dMZXZlbC5WRVJCT1NFXG4gICAgKTtcblxuICAgIGNvbnN0IGNoaWxkID0gc3Bhd24oXCJkb2NrZXJcIiwgW2NvbW1hbmQsIC4uLmFyZ3NdLCB7XG4gICAgICBjd2Q6IHRoaXMucHJvcHMuY3dkLFxuICAgICAgc3RkaW86IFwicGlwZVwiLFxuICAgIH0pO1xuXG4gICAgbGV0IHN0YXJ0ZWQgPSB0cnVlO1xuXG4gICAgY2hpbGQub25jZShcImV4aXRcIiwgKCkgPT4ge1xuICAgICAgc3RhcnRlZCA9IGZhbHNlO1xuICAgIH0pO1xuXG4gICAgY29uc3Qgc3Rkb3V0OiBCdWZmZXJbXSA9IFtdO1xuICAgIGNvbnN0IGFsbE91dHB1dDogQnVmZmVyW10gPSBbXTtcbiAgICBjaGlsZC5zdGRvdXQub24oXCJkYXRhXCIsIChkYXRhKSA9PiB7XG4gICAgICBzdGRvdXQucHVzaChkYXRhKTtcbiAgICAgIGFsbE91dHB1dC5wdXNoKGRhdGEpO1xuICAgIH0pO1xuXG4gICAgY2hpbGQuc3RkZXJyLm9uKFwiZGF0YVwiLCAoZGF0YSkgPT4ge1xuICAgICAgYWxsT3V0cHV0LnB1c2goZGF0YSk7XG4gICAgfSk7XG5cbiAgICBpZiAoIXF1aWV0KSB7XG4gICAgICBjaGlsZC5zdGRvdXQub24oXCJkYXRhXCIsIChkYXRhKSA9PlxuICAgICAgICB0aGlzLmFkZFRyYWNlKGRhdGEudG9TdHJpbmcoKSwgVHJhY2VUeXBlLkxPRywgbGV2ZWwpXG4gICAgICApO1xuXG4gICAgICBjaGlsZC5zdGRlcnIub24oXCJkYXRhXCIsIChkYXRhKSA9PlxuICAgICAgICB0aGlzLmFkZFRyYWNlKGRhdGEudG9TdHJpbmcoKSwgVHJhY2VUeXBlLkxPRywgbGV2ZWwpXG4gICAgICApO1xuICAgIH1cblxuICAgIGNoaWxkLm9uY2UoXCJlcnJvclwiLCAoZXJyKSA9PiB7XG4gICAgICBzdGFydGVkID0gZmFsc2U7XG5cbiAgICAgIGlmIChsb2dFcnJvcnMpIHtcbiAgICAgICAgdGhpcy5hZGRUcmFjZShlcnIuc3RhY2sgPz8gZXJyLm1lc3NhZ2UsIFRyYWNlVHlwZS5MT0csIExvZ0xldmVsLkVSUk9SKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGdldCBydW5uaW5nKCkge1xuICAgICAgICByZXR1cm4gc3RhcnRlZDtcbiAgICAgIH0sXG4gICAgICBhc3luYyBraWxsKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIGlmICghc3RhcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZWxmLmFkZFRyYWNlKFxuICAgICAgICAgICAgXCJTZW5kaW5nIFNJR1RFUk0gdG8gY29udGFpbmVyXCIsXG4gICAgICAgICAgICBUcmFjZVR5cGUuUkVTT1VSQ0UsXG4gICAgICAgICAgICBMb2dMZXZlbC5WRVJCT1NFXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGNoaWxkLmtpbGwoXCJTSUdURVJNXCIpO1xuXG4gICAgICAgICAgLy8gaWYgdGhlIHByb2Nlc3MgZG9lc24ndCBleGl0IGluIDIgc2Vjb25kcywga2lsbCBpdFxuICAgICAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHNlbGYuYWRkVHJhY2UoXG4gICAgICAgICAgICAgIGBUaW1lb3V0IHdhaXRpbmcgZm9yIGNvbnRhaW5lciAke3NlbGYuX2NvbnRleHQ/LnJlc291cmNlUGF0aH0gdG8gc2h1dGRvd24sIHJlbW92aW5nIGZvcmNlZnVsbHlgLFxuICAgICAgICAgICAgICBUcmFjZVR5cGUuUkVTT1VSQ0UsXG4gICAgICAgICAgICAgIExvZ0xldmVsLldBUk5JTkdcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHNlbGZcbiAgICAgICAgICAgICAgLmRvY2tlcihcInJtXCIsIFtcIi1mXCIsIHNlbGYuY29udGFpbmVyTmFtZV0sIHsgcXVpZXQ6IHRydWUgfSlcbiAgICAgICAgICAgICAgLmNhdGNoKCgpID0+IHt9KTtcbiAgICAgICAgICB9LCAyMDAwKTtcblxuICAgICAgICAgIGNoaWxkLm9uY2UoXCJlcnJvclwiLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICBzZWxmLmFkZFRyYWNlKFxuICAgICAgICAgICAgICBgRXJyb3Igd2hlbiBzaHV0dGluZyBkb3duIGNvbnRhaW5lcjogJHtlcnIuc3RhY2sgPz8gZXJyLm1lc3NhZ2V9YCxcbiAgICAgICAgICAgICAgVHJhY2VUeXBlLlJFU09VUkNFLFxuICAgICAgICAgICAgICBMb2dMZXZlbC5FUlJPUlxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjaGlsZC5vbmNlKFwiZXhpdFwiLCAoKSA9PiB7XG4gICAgICAgICAgICBzZWxmLmFkZFRyYWNlKFxuICAgICAgICAgICAgICBcIkNvbnRhaW5lciBzaHV0ZG93biBzdWNjZXNzZnVsbHlcIixcbiAgICAgICAgICAgICAgVHJhY2VUeXBlLlJFU09VUkNFLFxuICAgICAgICAgICAgICBMb2dMZXZlbC5WRVJCT1NFXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBhc3luYyBqb2luKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKG9rLCBrbykgPT4ge1xuICAgICAgICAgIGlmICghc3RhcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIG9rKHN0ZG91dC5qb2luKFwiXCIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjaGlsZC5vbmNlKFwiZXJyb3JcIiwga28pO1xuICAgICAgICAgIGNoaWxkLm9uY2UoXCJleGl0XCIsIChjb2RlKSA9PiB7XG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gb2soc3Rkb3V0LmpvaW4oXCJcIikpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBDb21tYW5kIFwiJHtjb21tYW5kRGVzY31cIiBleGl0ZWQgd2l0aCBub24temVybyBjb2RlICR7Y29kZX1gO1xuICAgICAgICAgICAgICBpZiAobG9nRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5hZGRUcmFjZShcbiAgICAgICAgICAgICAgICAgIGAke21lc3NhZ2V9fVxcbiR7YWxsT3V0cHV0LmpvaW4oXCJcIil9YCxcbiAgICAgICAgICAgICAgICAgIFRyYWNlVHlwZS5SRVNPVVJDRSxcbiAgICAgICAgICAgICAgICAgIExvZ0xldmVsLlZFUkJPU0VcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGtvKG5ldyBFcnJvcihgJHttZXNzYWdlfSAoc2VlIHZlcmJvc2UgbG9ncylgKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBzYXZlU3RhdGUoc3RhdGU6IFN0YXRlRmlsZUNvbnRlbnRzKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgYXdhaXQgZnMud3JpdGVGaWxlKFxuICAgICAgam9pbih0aGlzLmNvbnRleHQuc3RhdGVkaXIsIFNUQVRFX0ZJTEVOQU1FKSxcbiAgICAgIEpTT04uc3RyaW5naWZ5KHN0YXRlKVxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgcGxhbigpIHtcbiAgICByZXR1cm4gVXBkYXRlUGxhbi5BVVRPO1xuICB9XG5cbiAgcHJpdmF0ZSBhZGRUcmFjZShtZXNzYWdlOiBzdHJpbmcsIHR5cGU6IFRyYWNlVHlwZSwgbGV2ZWw6IExvZ0xldmVsKSB7XG4gICAgdGhpcy5jb250ZXh0LmFkZFRyYWNlKHtcbiAgICAgIGRhdGE6IHsgbWVzc2FnZTogbWVzc2FnZS50cmltKCkgfSxcbiAgICAgIHNvdXJjZVBhdGg6IHRoaXMuY29udGV4dC5yZXNvdXJjZVBhdGgsXG4gICAgICBzb3VyY2VUeXBlOiBcImNvbnRhaW5lclwiLFxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB0eXBlLFxuICAgICAgbGV2ZWwsXG4gICAgfSk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gd2FpdFVudGlsKHByZWRpY2F0ZTogKCkgPT4gUHJvbWlzZTxib29sZWFuPikge1xuICBjb25zdCB0aW1lb3V0ID0gRHVyYXRpb24uZnJvbVNlY29uZHMoMzApO1xuICBjb25zdCBpbnRlcnZhbCA9IER1cmF0aW9uLmZyb21TZWNvbmRzKDAuMSk7XG4gIGxldCBlbGFwc2VkID0gMDtcbiAgd2hpbGUgKGVsYXBzZWQgPCB0aW1lb3V0LnNlY29uZHMpIHtcbiAgICBpZiAoYXdhaXQgcHJlZGljYXRlKCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbGFwc2VkICs9IGludGVydmFsLnNlY29uZHM7XG4gICAgYXdhaXQgVXRpbC5zbGVlcChpbnRlcnZhbCk7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoXCJUaW1lb3V0IGVsYXBzZWRcIik7XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgZG9ja2VyIGNoaWxkIHByb2Nlc3MuXG4gKi9cbmludGVyZmFjZSBEb2NrZXJQcm9jZXNzIHtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIHByb2Nlc3MgaXMgcnVubmluZyBvciBub3QuXG4gICAqL1xuICByZWFkb25seSBydW5uaW5nOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBXYWl0cyBmb3IgdGhlIHByb2Nlc3MgdG8gZXhpdCBhbmQgcmV0dXJucyB0aGUgb3V0cHV0LlxuICAgKiBAcmV0dXJucyBUaGUgb3V0cHV0IG9mIHRoZSBwcm9jZXNzLlxuICAgKi9cbiAgam9pbjogKCkgPT4gUHJvbWlzZTxzdHJpbmc+O1xuXG4gIC8qKlxuICAgKiBLaWxscyB0aGUgcHJvY2Vzcy5cbiAgICovXG4gIGtpbGw6ICgpID0+IFByb21pc2U8dm9pZD47XG59XG5cbmludGVyZmFjZSBEb2NrZXJPcHRpb25zIHtcbiAgLyoqXG4gICAqIENhbiBiZSB1c2VkIHRvIHN1cnByZXNzIGFsbCBsb2dnaW5nIGZyb20gdGhlIGNvbW1hbmQuXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICByZWFkb25seSBxdWlldD86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFRoZSBsb2cgbGV2ZWwgdG8gdXNlIGZvciBjb250YWluZXIgb3V0cHV0IChib3RoIFNURE9VVCBhbmQgU1RERVJSIHdpbGwgdXNlIHRoZSBzYW1lIGxvZyBsZXZlbCkuXG4gICAqIEBkZWZhdWx0IExvZ0xldmVsLklORk9cbiAgICovXG4gIHJlYWRvbmx5IGxvZ0xldmVsPzogTG9nTGV2ZWw7XG59XG4iXX0=