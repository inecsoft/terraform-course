import { T1 } from "./generics";
/**
 * Immutable Array
 *
 * @typeparam T1
 */
export declare class Array {
    /**
     * @internal
     */
    static _toInflightType(): string;
    private constructor();
    /**
     * The length of the array
     * @returns the length of the array
     */
    get length(): number;
    /**
     * Get the value at the given index
     * @macro ((arr, index) => { if (index < 0 || index >= arr.length) throw new Error("Index out of bounds"); return arr[index]; })($self$, $args$)
     * @param index index of the value to get
     * @returns the value at the given index
     */
    at(index: number): T1;
    /**
     * Get the value at the given index, returning nil if the index is out of bounds.
     *
     * @macro $self$.at($args$)
     *
     * @param index index of the value to get
     * @returns the value at the given index, or undefined if the index is out of bounds
     */
    tryAt(index: number): T1 | undefined;
    /**
     * Merge arr to the end of this array
     * @param arr array to merge
     *
     * @returns a new ImmutableArray with the values of this array followed by the values of arr
     */
    concat(arr: Array): Array;
    /**
     * Checks if this array includes searchElement.
     *
     * @macro $self$.includes($args$)
     *
     * @param searchElement to search for.
     * @returns true if this array includes searchElement.
     */
    contains(searchElement: T1): boolean;
    /**
     * Create a mutable shallow copy of this array
     *
     * @macro [...($self$)]
     *
     * @returns a MutableArray with the same values as this array
     */
    copyMut(): MutArray;
    /**
     * Returns the index of the first occurrence of searchElement found.
     *
     * @macro $self$.indexOf($args$)
     *
     * @param searchElement to search for.
     * @returns the index of the first occurrence of searchElement found, or -1 if not found.
     */
    indexOf(searchElement: T1): number;
    /**
     * Returns a new string containing the concatenated values in this array,
     * separated by commas or a specified separator string. If the array has only
     * one item, then that item will be returned without using the separator.
     *
     * @returns a string containing the concatenated values in this array,
     * separated by commas or a specified separator string.
     */
    join(separator?: string): string;
    /**
     * Returns the index of the last occurrence of searchElement found.
     *
     * @macro $self$.lastIndexOf($args$)
     *
     * @param searchElement to search for.
     * @returns the index of the last occurrence of searchElement found, or -1 if not found.
     */
    lastIndexOf(searchElement: T1): number;
    /**
     * Returns a shallow copy of a portion of the array.
     *
     * @macro $self$.slice($args$)
     *
     * @param start the beginning index of the slice, inclusive.
     * @param end the ending index of the slice, exclusive.
     * @returns a new array containing the sliced elements.
     */
    slice(start?: number, end?: number): Array;
}
/**
 * Mutable Array
 *
 * @typeparam T1
 */
export declare class MutArray {
    /**
     * @internal
     */
    static _toInflightType(): string;
    private constructor();
    /**
     * The length of the array
     * @returns the length of the array
     */
    get length(): number;
    /**
     * Get the value at the given index
     * @macro ((arr, index) => { if (index < 0 || index >= arr.length) throw new Error("Index out of bounds"); return arr[index]; })($self$, $args$)
     * @param index index of the value to get
     * @returns the value at the given index
     */
    at(index: number): T1;
    /**
     * Merge arr to the end of this array
     * @param arr array to merge
     *
     * @returns a new MutableArray with the values of this array followed by the values of arr
     */
    concat(arr: MutArray): MutArray;
    /**
     * Checks if this array includes searchElement.
     *
     * @macro $self$.includes($args$)
     *
     * @param searchElement to search for.
     * @returns true if this array includes searchElement.
     */
    contains(searchElement: T1): boolean;
    /**
     * Create an immutable shallow copy of this array
     *
     * @macro [...($self$)]
     *
     * @returns an ImmutableArray with the same values as this array
     */
    copy(): Array;
    /**
     * Returns the index of the first occurrence of searchElement found.
     *
     * @macro $self$.indexOf($args$)
     *
     * @param searchElement to search for.
     * @returns the index of the first occurrence of searchElement found, or -1 if not found.
     */
    indexOf(searchElement: T1): number;
    /**
     * Returns a new string containing the concatenated values in this array,
     * separated by commas or a specified separator string. If the array has only
     * one item, then that item will be returned without using the separator.
     *
     * @returns a string containing the concatenated values in this array,
     * separated by commas or a specified separator string.
     */
    join(separator?: string): string;
    /**
     * Returns the index of the last occurrence of searchElement found.
     *
     * @macro $self$.lastIndexOf($args$)
     *
     * @param searchElement to search for.
     * @returns the index of the last occurrence of searchElement found, or -1 if not found.
     */
    lastIndexOf(searchElement: T1): number;
    /**
     * Add values to end of array
     *
     * @macro $self$.push($args$)
     *
     * @param values values to add
     */
    push(...values: T1[]): void;
    /**
     * Remove value from end of array
     * @returns the value removed
     */
    pop(): T1;
    /**
     * Removes value from the given index of an array
     *
     * @macro ((obj, args) => { if (args[0] < 0 || args[0] >= $self$.length) throw new Error("Index out of bounds"); return obj.splice(args[0], 1)[0]; })($self$, [$args$])
     *
     * @param index the index to remove the value at
     * @returns the value removed
     * @throws index out of bounds error if the given index does not exist for the array
     */
    popAt(index: number): T1;
    /**
     * Sets a new value at the given index of an array
     *
     * @macro ((obj, args) => { if (args[0] < 0 || args[0] >= $self$.length) throw new Error("Index out of bounds"); obj[args[0]] = args[1]; })($self$, [$args$])
     *
     * @param index the index to set the value at
     * @param value the value to set at the given index
     * @throws index out of bounds error if the given index does not exist for the array
     */
    set(index: number, value: T1): void;
    /**
     * Inserts a new value at the given index of an array
     *
     * @macro ((obj, args) => { if (args[0] < 0 || args[0] > $self$.length) throw new Error("Index out of bounds"); obj.splice(args[0], 0, args[1]); })($self$, [$args$])
     *
     * @param index the index to insert the value at
     * @param value the value to insert at the given index
     * @throws index out of bounds error if the given index isn't valid
     */
    insert(index: number, value: T1): void;
    /**
     * Removes first occurrence of a given value in an array
     *
     * @macro ((obj, args) => { if (obj.indexOf(args[0]) !== -1) { obj.splice(obj.indexOf(args[0]), 1); return true; } return false; })($self$, [$args$])
     *
     * @param value the value to remove
     * @returns true if value was removed
     */
    removeFirst(value: T1): boolean;
    /**
     * Returns a shallow copy of a portion of the array.
     *
     * @macro $self$.slice($args$)
     *
     * @param start the beginning index of the slice, inclusive.
     * @param end the ending index of the slice, exclusive.
     * @returns a new array containing the sliced elements.
     */
    slice(start?: number, end?: number): MutArray;
}
