"use strict";
var _a, _b;
Object.defineProperty(exports, "__esModule", { value: true });
exports.MutMap = exports.Map = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const core_1 = require("../core");
/**
 * Immutable Map
 *
 * @typeparam T1
 */
class Map {
    /**
     * @internal
     */
    static _toInflightType() {
        return core_1.InflightClient.forType(__filename, this.name);
    }
    constructor() { }
    /**
     * Returns the number of elements in the map.
     *
     * TODO: For now this has to be a method rather than a getter as macros only work on methods https://github.com/winglang/wing/issues/1658
     * @macro Object.keys($self$).length
     *
     * @returns The number of elements in map
     */
    size() {
        throw new Error("Macro");
    }
    /**
     * Returns a specified element from the map.
     *
     * If the value that is associated to the provided key is an object, then you will get a reference
     * to that object and any change made to that object will effectively modify it inside the map.
     *
     * @macro ((obj, key) => { if (!(key in obj)) throw new Error(`Map does not contain key: "${key}"`); return obj[key]; })($self$, $args$)
     *
     * @param key The key of the element to return.
     * @returns The element associated with the specified key, or throw an error if the key can't be found
     */
    get(key) {
        key;
        throw new Error("Macro");
    }
    /**
     * Optionally returns a specified element from the map.
     *
     * @macro ($self$)[$args$]
     *
     * @param key The key of the element to return.
     * @returns The element associated with the specified key, or undefined if the key can't be found
     */
    tryGet(key) {
        key;
        throw new Error("Macro");
    }
    /**
     * Returns a boolean indicating whether an element with the specified key exists or not.
     *
     * @macro ($args$ in ($self$))
     *
     * @param key The key of the element to test for presence
     * @returns true if an element with the specified key exists in the map; otherwise false.
     */
    has(key) {
        key;
        throw new Error("Macro");
    }
    /**
     * Create a mutable shallow copy of this map
     *
     * @macro {...($self$)}
     *
     * @returns a MutableMap with the same values as this map
     */
    copyMut() {
        throw new Error("Macro");
    }
    /**
     * Returns the keys of this map
     *
     * @macro Object.keys($self$)
     *
     * @returns an array containing the keys of this map
     */
    keys() {
        throw new Error("Macro");
    }
    /**
     * Returns the values of this map
     *
     * @macro Object.values($self$)
     *
     * @returns an array of type T containing the values of this map
     */
    values() {
        throw new Error("Macro");
    }
    /**
     * Returns the entries from the map.
     *
     * @macro Object.entries($self$).map(([key, value]) => ({ key, value }))
     *
     * @returns the entries as Array<ArrayEntry>
     */
    entries() {
        throw new Error("Macro");
    }
}
exports.Map = Map;
_a = JSII_RTTI_SYMBOL_1;
Map[_a] = { fqn: "@winglang/sdk.std.Map", version: "0.0.0" };
/**
 * Mutable Map
 *
 * @typeparam T1
 */
class MutMap {
    /**
     * @internal
     */
    static _toInflightType() {
        return core_1.InflightClient.forType(__filename, this.name);
    }
    constructor() { }
    /**
     * Returns the number of elements in the map.
     *
     * TODO: For now this has to be a method rather than a getter as macros only work on methods https://github.com/winglang/wing/issues/1658
     * @macro Object.keys($self$).length
     *
     * @returns The number of elements in map
     */
    size() {
        throw new Error("Macro");
    }
    /**
     * Removes all elements
     *
     * @macro ((map) => { for(const k in map){delete map[k]}; })($self$)
     */
    clear() {
        throw new Error("Macro");
    }
    /**
     * Create an immutable shallow copy of this map
     *
     * @macro ({...($self$)})
     *
     * @returns an ImmutableMap with the same values as this map
     */
    copy() {
        throw new Error("Macro");
    }
    /**
     * Removes the specified element from a map.
     *
     * @macro (delete ($self$)[$args$])
     *
     * @param key The key
     * @returns true if the given key is no longer present
     */
    delete(key) {
        key;
        throw new Error("Macro");
    }
    /**
     * Returns a specified element from the map.
     *
     * If the value that is associated to the provided key is an object, then you will get a reference
     * to that object and any change made to that object will effectively modify it inside the map.
     *
     * @macro ((obj, key) => { if (!(key in obj)) throw new Error(`MutMap does not contain key: "${key}"`); return obj[key]; })($self$, $args$)
     *
     * @param key The key of the element to return.
     * @returns The element associated with the specified key, or throw an error if the key can't be found
     */
    get(key) {
        key;
        throw new Error("Macro");
    }
    /**
     * Optionally returns a specified element from the map.
     *
     * @macro ($self$)[$args$]
     *
     * @param key The key of the element to return.
     * @returns The element associated with the specified key, or undefined if the key can't be found
     */
    tryGet(key) {
        key;
        throw new Error("Macro");
    }
    /**
     * Returns a boolean indicating whether an element with the specified key exists or not.
     *
     * @macro ($args$ in ($self$))
     *
     * @param key The key of the element to test for presence
     * @returns true if an element with the specified key exists in the map; otherwise false.
     */
    has(key) {
        key;
        throw new Error("Macro");
    }
    /**
     * Adds or updates an entry in a Map object with a specified key and a value.
     *
     * TODO: revisit this macro after we support indexed args https://github.com/winglang/wing/issues/1659
     * @macro ((obj, args) => { obj[args[0]] = args[1]; })($self$, [$args$])
     *
     * @param key The key of the element to add
     * @param value The value of the element to add
     */
    set(key, value) {
        key;
        value;
        throw new Error("Macro");
    }
    /**
     * Returns the keys of this map
     *
     * @macro Object.keys($self$)
     *
     * @returns an array containing the keys of this map
     */
    keys() {
        throw new Error("Macro");
    }
    /**
     * Returns the values of this map
     *
     * @macro Object.values($self$)
     *
     * @returns an array containing of type T the values of this map
     */
    values() {
        throw new Error("Macro");
    }
    /**
     * Returns the entries from the map.
     *
     * @macro Object.entries($self$).map(([key, value]) => ({ key, value }))
     *
     * @returns the entries as Array<ArrayEntry>
     */
    entries() {
        throw new Error("Macro");
    }
}
exports.MutMap = MutMap;
_b = JSII_RTTI_SYMBOL_1;
MutMap[_b] = { fqn: "@winglang/sdk.std.MutMap", version: "0.0.0" };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFwLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3N0ZC9tYXAudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFNQSxrQ0FBeUM7QUFjekM7Ozs7R0FJRztBQUNILE1BQWEsR0FBRztJQUNkOztPQUVHO0lBQ0ksTUFBTSxDQUFDLGVBQWU7UUFDM0IsT0FBTyxxQkFBYyxDQUFDLE9BQU8sQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3ZELENBQUM7SUFFRCxnQkFBdUIsQ0FBQztJQUV4Qjs7Ozs7OztPQU9HO0lBQ0ksSUFBSTtRQUNULE1BQU0sSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDM0IsQ0FBQztJQUVEOzs7Ozs7Ozs7O09BVUc7SUFDSSxHQUFHLENBQUMsR0FBVztRQUNwQixHQUFHLENBQUM7UUFDSixNQUFNLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQzNCLENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0ksTUFBTSxDQUFDLEdBQVc7UUFDdkIsR0FBRyxDQUFDO1FBQ0osTUFBTSxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUMzQixDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNJLEdBQUcsQ0FBQyxHQUFXO1FBQ3BCLEdBQUcsQ0FBQztRQUNKLE1BQU0sSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDM0IsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNJLE9BQU87UUFDWixNQUFNLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQzNCLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSSxJQUFJO1FBQ1QsTUFBTSxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUMzQixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ksTUFBTTtRQUNYLE1BQU0sSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDM0IsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNJLE9BQU87UUFDWixNQUFNLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQzNCLENBQUM7O0FBMUdILGtCQTJHQzs7O0FBRUQ7Ozs7R0FJRztBQUNILE1BQWEsTUFBTTtJQUNqQjs7T0FFRztJQUNJLE1BQU0sQ0FBQyxlQUFlO1FBQzNCLE9BQU8scUJBQWMsQ0FBQyxPQUFPLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN2RCxDQUFDO0lBRUQsZ0JBQXVCLENBQUM7SUFFeEI7Ozs7Ozs7T0FPRztJQUNJLElBQUk7UUFDVCxNQUFNLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQzNCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksS0FBSztRQUNWLE1BQU0sSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDM0IsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNJLElBQUk7UUFDVCxNQUFNLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQzNCLENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0ksTUFBTSxDQUFDLEdBQVc7UUFDdkIsR0FBRyxDQUFDO1FBQ0osTUFBTSxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUMzQixDQUFDO0lBRUQ7Ozs7Ozs7Ozs7T0FVRztJQUNJLEdBQUcsQ0FBQyxHQUFXO1FBQ3BCLEdBQUcsQ0FBQztRQUNKLE1BQU0sSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDM0IsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSSxNQUFNLENBQUMsR0FBVztRQUN2QixHQUFHLENBQUM7UUFDSixNQUFNLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQzNCLENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0ksR0FBRyxDQUFDLEdBQVc7UUFDcEIsR0FBRyxDQUFDO1FBQ0osTUFBTSxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUMzQixDQUFDO0lBRUQ7Ozs7Ozs7O09BUUc7SUFDSSxHQUFHLENBQUMsR0FBVyxFQUFFLEtBQVM7UUFDL0IsR0FBRyxDQUFDO1FBQ0osS0FBSyxDQUFDO1FBQ04sTUFBTSxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUMzQixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ksSUFBSTtRQUNULE1BQU0sSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDM0IsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNJLE1BQU07UUFDWCxNQUFNLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQzNCLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSSxPQUFPO1FBQ1osTUFBTSxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUMzQixDQUFDOztBQS9JSCx3QkFnSkMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGVzZSBjbGFzc2VzIGFyZSB1c2VkIGJ5IFdpbmcgdG8gcHJvdmlkZSBKU0lJIHN1YnNldHMgb2YgdGhlIEpTIE1hcCBjbGFzcy5cbi8vIFRoZXkgc2hvdWxkIG5vdCBiZSBjb25zdW1lZCBkaXJlY3RseSBieSB1c2Vycy5cbi8vIFRPRE86IFRoZXNlIHNob3VsZCBiZSBpbnRlcmZhY2VzLCBjdXJyZW50bHkgV2luZyBkb2VzIG5vdCBzdXBwb3J0IGludGVyZmFjZSBKU0lJIGltcG9ydHNcblxuaW1wb3J0IHsgQXJyYXkgfSBmcm9tIFwiLi9hcnJheVwiO1xuaW1wb3J0IHsgVDEgfSBmcm9tIFwiLi9nZW5lcmljc1wiO1xuaW1wb3J0IHsgSW5mbGlnaHRDbGllbnQgfSBmcm9tIFwiLi4vY29yZVwiO1xuXG4vKipcbiAqIEFycmF5IGVudHJ5IHJlcHJlc2VudGF0aW9uXG4gKlxuICogQHR5cGVwYXJhbSBUMVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEFycmF5RW50cnkge1xuICAvKiogVGhlIGVudHJ5IGtleSAqL1xuICByZWFkb25seSBrZXk6IHN0cmluZztcbiAgLyoqIFRoZSBlbnRyeSB2YWx1ZSAqL1xuICByZWFkb25seSB2YWx1ZTogVDE7XG59XG5cbi8qKlxuICogSW1tdXRhYmxlIE1hcFxuICpcbiAqIEB0eXBlcGFyYW0gVDFcbiAqL1xuZXhwb3J0IGNsYXNzIE1hcCB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgX3RvSW5mbGlnaHRUeXBlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIEluZmxpZ2h0Q2xpZW50LmZvclR5cGUoX19maWxlbmFtZSwgdGhpcy5uYW1lKTtcbiAgfVxuXG4gIHByaXZhdGUgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIG1hcC5cbiAgICpcbiAgICogVE9ETzogRm9yIG5vdyB0aGlzIGhhcyB0byBiZSBhIG1ldGhvZCByYXRoZXIgdGhhbiBhIGdldHRlciBhcyBtYWNyb3Mgb25seSB3b3JrIG9uIG1ldGhvZHMgaHR0cHM6Ly9naXRodWIuY29tL3dpbmdsYW5nL3dpbmcvaXNzdWVzLzE2NThcbiAgICogQG1hY3JvIE9iamVjdC5rZXlzKCRzZWxmJCkubGVuZ3RoXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gbWFwXG4gICAqL1xuICBwdWJsaWMgc2l6ZSgpOiBudW1iZXIge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1hY3JvXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzcGVjaWZpZWQgZWxlbWVudCBmcm9tIHRoZSBtYXAuXG4gICAqXG4gICAqIElmIHRoZSB2YWx1ZSB0aGF0IGlzIGFzc29jaWF0ZWQgdG8gdGhlIHByb3ZpZGVkIGtleSBpcyBhbiBvYmplY3QsIHRoZW4geW91IHdpbGwgZ2V0IGEgcmVmZXJlbmNlXG4gICAqIHRvIHRoYXQgb2JqZWN0IGFuZCBhbnkgY2hhbmdlIG1hZGUgdG8gdGhhdCBvYmplY3Qgd2lsbCBlZmZlY3RpdmVseSBtb2RpZnkgaXQgaW5zaWRlIHRoZSBtYXAuXG4gICAqXG4gICAqIEBtYWNybyAoKG9iaiwga2V5KSA9PiB7IGlmICghKGtleSBpbiBvYmopKSB0aHJvdyBuZXcgRXJyb3IoYE1hcCBkb2VzIG5vdCBjb250YWluIGtleTogXCIke2tleX1cImApOyByZXR1cm4gb2JqW2tleV07IH0pKCRzZWxmJCwgJGFyZ3MkKVxuICAgKlxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGVsZW1lbnQgdG8gcmV0dXJuLlxuICAgKiBAcmV0dXJucyBUaGUgZWxlbWVudCBhc3NvY2lhdGVkIHdpdGggdGhlIHNwZWNpZmllZCBrZXksIG9yIHRocm93IGFuIGVycm9yIGlmIHRoZSBrZXkgY2FuJ3QgYmUgZm91bmRcbiAgICovXG4gIHB1YmxpYyBnZXQoa2V5OiBzdHJpbmcpOiBUMSB7XG4gICAga2V5O1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1hY3JvXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsbHkgcmV0dXJucyBhIHNwZWNpZmllZCBlbGVtZW50IGZyb20gdGhlIG1hcC5cbiAgICpcbiAgICogQG1hY3JvICgkc2VsZiQpWyRhcmdzJF1cbiAgICpcbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBlbGVtZW50IHRvIHJldHVybi5cbiAgICogQHJldHVybnMgVGhlIGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5LCBvciB1bmRlZmluZWQgaWYgdGhlIGtleSBjYW4ndCBiZSBmb3VuZFxuICAgKi9cbiAgcHVibGljIHRyeUdldChrZXk6IHN0cmluZyk6IFQxIHwgdW5kZWZpbmVkIHtcbiAgICBrZXk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWFjcm9cIik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSBleGlzdHMgb3Igbm90LlxuICAgKlxuICAgKiBAbWFjcm8gKCRhcmdzJCBpbiAoJHNlbGYkKSlcbiAgICpcbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBlbGVtZW50IHRvIHRlc3QgZm9yIHByZXNlbmNlXG4gICAqIEByZXR1cm5zIHRydWUgaWYgYW4gZWxlbWVudCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5IGV4aXN0cyBpbiB0aGUgbWFwOyBvdGhlcndpc2UgZmFsc2UuXG4gICAqL1xuICBwdWJsaWMgaGFzKGtleTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAga2V5O1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1hY3JvXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG11dGFibGUgc2hhbGxvdyBjb3B5IG9mIHRoaXMgbWFwXG4gICAqXG4gICAqIEBtYWNybyB7Li4uKCRzZWxmJCl9XG4gICAqXG4gICAqIEByZXR1cm5zIGEgTXV0YWJsZU1hcCB3aXRoIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGlzIG1hcFxuICAgKi9cbiAgcHVibGljIGNvcHlNdXQoKTogTXV0TWFwIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWNyb1wiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBrZXlzIG9mIHRoaXMgbWFwXG4gICAqXG4gICAqIEBtYWNybyBPYmplY3Qua2V5cygkc2VsZiQpXG4gICAqXG4gICAqIEByZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGtleXMgb2YgdGhpcyBtYXBcbiAgICovXG4gIHB1YmxpYyBrZXlzKCk6IHN0cmluZ1tdIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWNyb1wiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB2YWx1ZXMgb2YgdGhpcyBtYXBcbiAgICpcbiAgICogQG1hY3JvIE9iamVjdC52YWx1ZXMoJHNlbGYkKVxuICAgKlxuICAgKiBAcmV0dXJucyBhbiBhcnJheSBvZiB0eXBlIFQgY29udGFpbmluZyB0aGUgdmFsdWVzIG9mIHRoaXMgbWFwXG4gICAqL1xuICBwdWJsaWMgdmFsdWVzKCk6IEFycmF5IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWNyb1wiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAgICpcbiAgICogQG1hY3JvIE9iamVjdC5lbnRyaWVzKCRzZWxmJCkubWFwKChba2V5LCB2YWx1ZV0pID0+ICh7IGtleSwgdmFsdWUgfSkpXG4gICAqXG4gICAqIEByZXR1cm5zIHRoZSBlbnRyaWVzIGFzIEFycmF5PEFycmF5RW50cnk+XG4gICAqL1xuICBwdWJsaWMgZW50cmllcygpOiBBcnJheUVudHJ5W10ge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1hY3JvXCIpO1xuICB9XG59XG5cbi8qKlxuICogTXV0YWJsZSBNYXBcbiAqXG4gKiBAdHlwZXBhcmFtIFQxXG4gKi9cbmV4cG9ydCBjbGFzcyBNdXRNYXAge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIF90b0luZmxpZ2h0VHlwZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiBJbmZsaWdodENsaWVudC5mb3JUeXBlKF9fZmlsZW5hbWUsIHRoaXMubmFtZSk7XG4gIH1cblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBtYXAuXG4gICAqXG4gICAqIFRPRE86IEZvciBub3cgdGhpcyBoYXMgdG8gYmUgYSBtZXRob2QgcmF0aGVyIHRoYW4gYSBnZXR0ZXIgYXMgbWFjcm9zIG9ubHkgd29yayBvbiBtZXRob2RzIGh0dHBzOi8vZ2l0aHViLmNvbS93aW5nbGFuZy93aW5nL2lzc3Vlcy8xNjU4XG4gICAqIEBtYWNybyBPYmplY3Qua2V5cygkc2VsZiQpLmxlbmd0aFxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIG1hcFxuICAgKi9cbiAgcHVibGljIHNpemUoKTogbnVtYmVyIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWNyb1wiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBlbGVtZW50c1xuICAgKlxuICAgKiBAbWFjcm8gKChtYXApID0+IHsgZm9yKGNvbnN0IGsgaW4gbWFwKXtkZWxldGUgbWFwW2tdfTsgfSkoJHNlbGYkKVxuICAgKi9cbiAgcHVibGljIGNsZWFyKCk6IHZvaWQge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1hY3JvXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbW11dGFibGUgc2hhbGxvdyBjb3B5IG9mIHRoaXMgbWFwXG4gICAqXG4gICAqIEBtYWNybyAoey4uLigkc2VsZiQpfSlcbiAgICpcbiAgICogQHJldHVybnMgYW4gSW1tdXRhYmxlTWFwIHdpdGggdGhlIHNhbWUgdmFsdWVzIGFzIHRoaXMgbWFwXG4gICAqL1xuICBwdWJsaWMgY29weSgpOiBNYXAge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1hY3JvXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBlbGVtZW50IGZyb20gYSBtYXAuXG4gICAqXG4gICAqIEBtYWNybyAoZGVsZXRlICgkc2VsZiQpWyRhcmdzJF0pXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleVxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBrZXkgaXMgbm8gbG9uZ2VyIHByZXNlbnRcbiAgICovXG4gIHB1YmxpYyBkZWxldGUoa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBrZXk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWFjcm9cIik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHNwZWNpZmllZCBlbGVtZW50IGZyb20gdGhlIG1hcC5cbiAgICpcbiAgICogSWYgdGhlIHZhbHVlIHRoYXQgaXMgYXNzb2NpYXRlZCB0byB0aGUgcHJvdmlkZWQga2V5IGlzIGFuIG9iamVjdCwgdGhlbiB5b3Ugd2lsbCBnZXQgYSByZWZlcmVuY2VcbiAgICogdG8gdGhhdCBvYmplY3QgYW5kIGFueSBjaGFuZ2UgbWFkZSB0byB0aGF0IG9iamVjdCB3aWxsIGVmZmVjdGl2ZWx5IG1vZGlmeSBpdCBpbnNpZGUgdGhlIG1hcC5cbiAgICpcbiAgICogQG1hY3JvICgob2JqLCBrZXkpID0+IHsgaWYgKCEoa2V5IGluIG9iaikpIHRocm93IG5ldyBFcnJvcihgTXV0TWFwIGRvZXMgbm90IGNvbnRhaW4ga2V5OiBcIiR7a2V5fVwiYCk7IHJldHVybiBvYmpba2V5XTsgfSkoJHNlbGYkLCAkYXJncyQpXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgZWxlbWVudCB0byByZXR1cm4uXG4gICAqIEByZXR1cm5zIFRoZSBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSwgb3IgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGtleSBjYW4ndCBiZSBmb3VuZFxuICAgKi9cbiAgcHVibGljIGdldChrZXk6IHN0cmluZyk6IFQxIHtcbiAgICBrZXk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWFjcm9cIik7XG4gIH1cblxuICAvKipcbiAgICogT3B0aW9uYWxseSByZXR1cm5zIGEgc3BlY2lmaWVkIGVsZW1lbnQgZnJvbSB0aGUgbWFwLlxuICAgKlxuICAgKiBAbWFjcm8gKCRzZWxmJClbJGFyZ3MkXVxuICAgKlxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGVsZW1lbnQgdG8gcmV0dXJuLlxuICAgKiBAcmV0dXJucyBUaGUgZWxlbWVudCBhc3NvY2lhdGVkIHdpdGggdGhlIHNwZWNpZmllZCBrZXksIG9yIHVuZGVmaW5lZCBpZiB0aGUga2V5IGNhbid0IGJlIGZvdW5kXG4gICAqL1xuICBwdWJsaWMgdHJ5R2V0KGtleTogc3RyaW5nKTogVDEgfCB1bmRlZmluZWQge1xuICAgIGtleTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWNyb1wiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgYW4gZWxlbWVudCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5IGV4aXN0cyBvciBub3QuXG4gICAqXG4gICAqIEBtYWNybyAoJGFyZ3MkIGluICgkc2VsZiQpKVxuICAgKlxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGVsZW1lbnQgdG8gdGVzdCBmb3IgcHJlc2VuY2VcbiAgICogQHJldHVybnMgdHJ1ZSBpZiBhbiBlbGVtZW50IHdpdGggdGhlIHNwZWNpZmllZCBrZXkgZXhpc3RzIGluIHRoZSBtYXA7IG90aGVyd2lzZSBmYWxzZS5cbiAgICovXG4gIHB1YmxpYyBoYXMoa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBrZXk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWFjcm9cIik7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBvciB1cGRhdGVzIGFuIGVudHJ5IGluIGEgTWFwIG9iamVjdCB3aXRoIGEgc3BlY2lmaWVkIGtleSBhbmQgYSB2YWx1ZS5cbiAgICpcbiAgICogVE9ETzogcmV2aXNpdCB0aGlzIG1hY3JvIGFmdGVyIHdlIHN1cHBvcnQgaW5kZXhlZCBhcmdzIGh0dHBzOi8vZ2l0aHViLmNvbS93aW5nbGFuZy93aW5nL2lzc3Vlcy8xNjU5XG4gICAqIEBtYWNybyAoKG9iaiwgYXJncykgPT4geyBvYmpbYXJnc1swXV0gPSBhcmdzWzFdOyB9KSgkc2VsZiQsIFskYXJncyRdKVxuICAgKlxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGVsZW1lbnQgdG8gYWRkXG4gICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQgdG8gYWRkXG4gICAqL1xuICBwdWJsaWMgc2V0KGtleTogc3RyaW5nLCB2YWx1ZTogVDEpOiB2b2lkIHtcbiAgICBrZXk7XG4gICAgdmFsdWU7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWFjcm9cIik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUga2V5cyBvZiB0aGlzIG1hcFxuICAgKlxuICAgKiBAbWFjcm8gT2JqZWN0LmtleXMoJHNlbGYkKVxuICAgKlxuICAgKiBAcmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBrZXlzIG9mIHRoaXMgbWFwXG4gICAqL1xuICBwdWJsaWMga2V5cygpOiBzdHJpbmdbXSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWFjcm9cIik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdmFsdWVzIG9mIHRoaXMgbWFwXG4gICAqXG4gICAqIEBtYWNybyBPYmplY3QudmFsdWVzKCRzZWxmJClcbiAgICpcbiAgICogQHJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyBvZiB0eXBlIFQgdGhlIHZhbHVlcyBvZiB0aGlzIG1hcFxuICAgKi9cbiAgcHVibGljIHZhbHVlcygpOiBBcnJheSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWFjcm9cIik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gICAqXG4gICAqIEBtYWNybyBPYmplY3QuZW50cmllcygkc2VsZiQpLm1hcCgoW2tleSwgdmFsdWVdKSA9PiAoeyBrZXksIHZhbHVlIH0pKVxuICAgKlxuICAgKiBAcmV0dXJucyB0aGUgZW50cmllcyBhcyBBcnJheTxBcnJheUVudHJ5PlxuICAgKi9cbiAgcHVibGljIGVudHJpZXMoKTogQXJyYXlFbnRyeVtdIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWNyb1wiKTtcbiAgfVxufVxuIl19