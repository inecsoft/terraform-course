"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Struct = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const json_schema_1 = require("./json_schema");
const core_1 = require("../core");
/**
 * Shared behavior for all structs
 *
 * @typeparam T1
 */
class Struct {
    /**
     * @internal
     */
    static _toInflightType() {
        return core_1.InflightClient.forType(__filename, this.name);
    }
    /**
     * Converts a Json to a Struct
     *
     * @macro $self$._fromJson($args$)
     */
    static fromJson(json, options) {
        json;
        options;
        throw new Error("Macro");
    }
    /**
     * Converts a Json to a Struct, returning nil if the Json is not valid
     *
     * @macro $self$._tryFromJson($args$)
     */
    static tryFromJson(json) {
        json;
        throw new Error("Macro");
    }
    /**
     * Parse a Json string into a Struct
     *
     * @macro $self$._fromJson(JSON.parse($args$))
     */
    static parseJson(json) {
        json;
        throw new Error("Macro");
    }
    /**
     * Parse a Json string into a Struct, returning nil if the Json is not valid
     *
     * @macro $self$._tryParseJson($args$)
     */
    static tryParseJson(json) {
        json;
        throw new Error("Macro");
    }
    /**
     * Retrieve the schema for this struct
     * @macro $self$
     */
    static schema() {
        throw new Error("Macro");
    }
    /**
     * Create an instance of a StructSchema from a JsonSchema
     *
     * @internal
     */
    static _createJsonSchema(schema) {
        return new json_schema_1.JsonSchema(schema);
    }
    constructor() { }
}
exports.Struct = Struct;
_a = JSII_RTTI_SYMBOL_1;
Struct[_a] = { fqn: "@winglang/sdk.std.Struct", version: "0.0.0" };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RydWN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3N0ZC9zdHJ1Y3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFFQSwrQ0FBMkM7QUFDM0Msa0NBQXlDO0FBRXpDOzs7O0dBSUc7QUFDSCxNQUFhLE1BQU07SUFDakI7O09BRUc7SUFDSSxNQUFNLENBQUMsZUFBZTtRQUMzQixPQUFPLHFCQUFjLENBQUMsT0FBTyxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDdkQsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSxNQUFNLENBQUMsUUFBUSxDQUFDLElBQVUsRUFBRSxPQUErQjtRQUNoRSxJQUFJLENBQUM7UUFDTCxPQUFPLENBQUM7UUFDUixNQUFNLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQzNCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksTUFBTSxDQUFDLFdBQVcsQ0FBQyxJQUFVO1FBQ2xDLElBQUksQ0FBQztRQUNMLE1BQU0sSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDM0IsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSxNQUFNLENBQUMsU0FBUyxDQUFDLElBQVk7UUFDbEMsSUFBSSxDQUFDO1FBQ0wsTUFBTSxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUMzQixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLE1BQU0sQ0FBQyxZQUFZLENBQUMsSUFBd0I7UUFDakQsSUFBSSxDQUFDO1FBQ0wsTUFBTSxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUMzQixDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksTUFBTSxDQUFDLE1BQU07UUFDbEIsTUFBTSxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUMzQixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxNQUFZO1FBQzFDLE9BQU8sSUFBSSx3QkFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ2hDLENBQUM7SUFFRCxnQkFBdUIsQ0FBQzs7QUFsRTFCLHdCQW1FQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFQxIH0gZnJvbSBcIi4vZ2VuZXJpY3NcIjtcbmltcG9ydCB7IEpzb24sIEpzb25WYWxpZGF0aW9uT3B0aW9ucyB9IGZyb20gXCIuL2pzb25cIjtcbmltcG9ydCB7IEpzb25TY2hlbWEgfSBmcm9tIFwiLi9qc29uX3NjaGVtYVwiO1xuaW1wb3J0IHsgSW5mbGlnaHRDbGllbnQgfSBmcm9tIFwiLi4vY29yZVwiO1xuXG4vKipcbiAqIFNoYXJlZCBiZWhhdmlvciBmb3IgYWxsIHN0cnVjdHNcbiAqXG4gKiBAdHlwZXBhcmFtIFQxXG4gKi9cbmV4cG9ydCBjbGFzcyBTdHJ1Y3Qge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIF90b0luZmxpZ2h0VHlwZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiBJbmZsaWdodENsaWVudC5mb3JUeXBlKF9fZmlsZW5hbWUsIHRoaXMubmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYSBKc29uIHRvIGEgU3RydWN0XG4gICAqXG4gICAqIEBtYWNybyAkc2VsZiQuX2Zyb21Kc29uKCRhcmdzJClcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZnJvbUpzb24oanNvbjogSnNvbiwgb3B0aW9ucz86IEpzb25WYWxpZGF0aW9uT3B0aW9ucyk6IFQxIHtcbiAgICBqc29uO1xuICAgIG9wdGlvbnM7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWFjcm9cIik7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYSBKc29uIHRvIGEgU3RydWN0LCByZXR1cm5pbmcgbmlsIGlmIHRoZSBKc29uIGlzIG5vdCB2YWxpZFxuICAgKlxuICAgKiBAbWFjcm8gJHNlbGYkLl90cnlGcm9tSnNvbigkYXJncyQpXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHRyeUZyb21Kc29uKGpzb246IEpzb24pOiBUMSB8IHVuZGVmaW5lZCB7XG4gICAganNvbjtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWNyb1wiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBhIEpzb24gc3RyaW5nIGludG8gYSBTdHJ1Y3RcbiAgICpcbiAgICogQG1hY3JvICRzZWxmJC5fZnJvbUpzb24oSlNPTi5wYXJzZSgkYXJncyQpKVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBwYXJzZUpzb24oanNvbjogc3RyaW5nKTogVDEge1xuICAgIGpzb247XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWFjcm9cIik7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgYSBKc29uIHN0cmluZyBpbnRvIGEgU3RydWN0LCByZXR1cm5pbmcgbmlsIGlmIHRoZSBKc29uIGlzIG5vdCB2YWxpZFxuICAgKlxuICAgKiBAbWFjcm8gJHNlbGYkLl90cnlQYXJzZUpzb24oJGFyZ3MkKVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyB0cnlQYXJzZUpzb24oanNvbjogc3RyaW5nIHwgdW5kZWZpbmVkKTogVDEgfCB1bmRlZmluZWQge1xuICAgIGpzb247XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWFjcm9cIik7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmUgdGhlIHNjaGVtYSBmb3IgdGhpcyBzdHJ1Y3RcbiAgICogQG1hY3JvICRzZWxmJFxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBzY2hlbWEoKTogSnNvblNjaGVtYSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWFjcm9cIik7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIGEgU3RydWN0U2NoZW1hIGZyb20gYSBKc29uU2NoZW1hXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBfY3JlYXRlSnNvblNjaGVtYShzY2hlbWE6IEpzb24pOiBKc29uU2NoZW1hIHtcbiAgICByZXR1cm4gbmV3IEpzb25TY2hlbWEoc2NoZW1hKTtcbiAgfVxuXG4gIHByaXZhdGUgY29uc3RydWN0b3IoKSB7fVxufVxuIl19