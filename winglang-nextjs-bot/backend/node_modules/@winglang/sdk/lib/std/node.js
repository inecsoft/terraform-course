"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Node = exports.SDK_SOURCE_MODULE = exports.CONNECTIONS_FILE_PATH = exports.APP_SYMBOL = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const constructs_1 = require("constructs");
const connections_1 = require("../core/connections");
const NODE_SYMBOL = Symbol.for("@winglang/sdk.std.Node");
exports.APP_SYMBOL = Symbol.for("@winglang/sdk.std.Node/app");
const ROOT_SYMBOL = Symbol.for("@winglang/sdk.std.Node/root");
exports.CONNECTIONS_FILE_PATH = "connections.json";
exports.SDK_SOURCE_MODULE = "@winglang/sdk";
/**
 * The internal node of a construct.
 */
class Node {
    /**
     * Marks a type as the root of the tree.
     * @param rootConstructor
     * @internal
     */
    static _markRoot(rootConstructor) {
        rootConstructor[ROOT_SYMBOL] = true;
    }
    /**
     * Return the internal construct node.
     */
    static of(construct) {
        let node = construct[NODE_SYMBOL];
        if (!node) {
            node = new Node(construct);
            construct[NODE_SYMBOL] = node;
        }
        return node;
    }
    constructor(construct) {
        this.construct = construct;
        this._constructsNode = construct.node;
        this._connections = connections_1.Connections.of(construct); // tree-unique instance
    }
    /**
     * Adds a connection between two constructs. A connection is a piece of
     * metadata describing how one construct is related to another construct.
     */
    addConnection(props) {
        this._connections.add({
            source: props.source ?? this.construct,
            ...props,
        });
    }
    // ---- constructs 10.x APIs ----
    // https://github.com/aws/constructs/blob/10.x/src/construct.ts
    /**
     * Returns the scope in which this construct is defined.
     *
     * The value is `undefined` at the root of the construct scope tree.
     */
    get scope() {
        return this._constructsNode.scope;
    }
    /**
     * The id of this construct within the current scope.
     *
     * This is a a scope-unique id. To obtain an app-unique id for this construct, use `addr`.
     */
    get id() {
        return this._constructsNode.id;
    }
    /**
     * The full, absolute path of this construct in the tree.
     *
     * Components are separated by '/'.
     */
    get path() {
        return this._constructsNode.path;
    }
    /**
     * Returns an opaque tree-unique address for this construct.
     *
     * Addresses are 42 characters hexadecimal strings. They begin with "c8"
     * followed by 40 lowercase hexadecimal characters (0-9a-f).
     *
     * Addresses are calculated using a SHA-1 of the components of the construct
     * path.
     *
     * To enable refactorings of construct trees, constructs with the ID `Default`
     * will be excluded from the calculation. In those cases constructs in the
     * same tree may have the same addreess.
     *
     * @example c83a2846e506bcc5f10682b564084bca2d275709ee
     */
    get addr() {
        return this._constructsNode.addr;
    }
    /**
     * Return a direct child by id, or undefined
     *
     * @param id Identifier of direct child
     * @returns the child if found, or undefined
     */
    tryFindChild(id) {
        return this._constructsNode.tryFindChild(id);
    }
    /**
     * Return a direct child by id
     *
     * Throws an error if the child is not found.
     *
     * @param id Identifier of direct child
     * @returns Child with the given id.
     */
    findChild(id) {
        return this._constructsNode.findChild(id);
    }
    /**
     * Returns the child construct that has the id `Default` or `Resource"`.
     * This is usually the construct that provides the bulk of the underlying functionality.
     * Useful for modifications of the underlying construct that are not available at the higher levels.
     *
     * @throws if there is more than one child
     * @returns a construct or undefined if there is no default child
     */
    get defaultChild() {
        return this._constructsNode.defaultChild;
    }
    /**
     * Override the defaultChild property.
     *
     * This should only be used in the cases where the correct
     * default child is not named 'Resource' or 'Default' as it
     * should be.
     *
     * If you set this to undefined, the default behavior of finding
     * the child named 'Resource' or 'Default' will be used.
     */
    set defaultChild(value) {
        this._constructsNode.defaultChild = value;
    }
    /**
     * All direct children of this construct.
     */
    get children() {
        return this._constructsNode.children;
    }
    /**
     * Return this construct and all of its children in the given order
     */
    findAll(order = constructs_1.ConstructOrder.PREORDER) {
        return this._constructsNode.findAll(order);
    }
    /**
     * This can be used to set contextual values.
     * Context must be set before any children are added, since children may consult context info during construction.
     * If the key already exists, it will be overridden.
     * @param key The context key
     * @param value The context value
     */
    setContext(key, value) {
        this._constructsNode.setContext(key, value);
    }
    /**
     * Retrieves a value from tree context if present. Otherwise, would throw an error.
     *
     * Context is usually initialized at the root, but can be overridden at any point in the tree.
     *
     * @param key The context key
     * @returns The context value or throws error if there is no context value for this key
     */
    getContext(key) {
        return this._constructsNode.getContext(key);
    }
    /**
     * Retrieves a value from tree context.
     *
     * Context is usually initialized at the root, but can be overridden at any point in the tree.
     *
     * @param key The context key
     * @returns The context value or `undefined` if there is no context value for this key.
     */
    tryGetContext(key) {
        return this._constructsNode.tryGetContext(key);
    }
    /**
     * An immutable array of metadata objects associated with this construct.
     * This can be used, for example, to implement support for deprecation notices, source mapping, etc.
     */
    get metadata() {
        return this._constructsNode.metadata;
    }
    /**
     * Adds a metadata entry to this construct.
     * Entries are arbitrary values and will also include a stack trace to allow tracing back to
     * the code location for when the entry was added. It can be used, for example, to include source
     * mapping in CloudFormation templates to improve diagnostics.
     *
     * @param type a string denoting the type of metadata
     * @param data the value of the metadata (can be a Token). If null/undefined, metadata will not be added.
     * @param options options
     */
    addMetadata(type, data, options = {}) {
        this._constructsNode.addMetadata(type, data, options);
    }
    /**
     * All parent scopes of this construct.
     *
     * @returns a list of parent scopes. The last element in the list will always
     * be the current construct and the first element will be the root of the
     * tree.
     */
    get scopes() {
        return this._constructsNode.scopes;
    }
    /**
     * Returns the root of the construct tree (the `cloud.App` object).
     *
     * Similar to `app`.
     *
     * @returns The root of the construct tree.
     */
    get root() {
        if (!this._root) {
            this._root = this.findRoot(this.construct);
        }
        return this._root;
    }
    /**
     * Returns the root of the construct tree (the `cloud.App` object).
     *
     * Similar to `root`.
     *
     * @returns The root of the construct tree.
     */
    get app() {
        if (!this._app) {
            this._app = this.findApp(this.construct);
        }
        return this._app;
    }
    /**
     * Returns true if this construct or the scopes in which it is defined are
     * locked.
     */
    get locked() {
        return this._constructsNode.locked;
    }
    /**
     * Add an ordering dependency on another construct.
     *
     * An `IDependable`
     */
    addDependency(...deps) {
        this._constructsNode.addDependency(...deps);
    }
    /**
     * Return all dependencies registered on this node (non-recursive).
     */
    get dependencies() {
        return this._constructsNode.dependencies;
    }
    /**
     * Remove the child with the given name, if present.
     *
     * @returns Whether a child with the given name was deleted.
     * @experimental
     */
    tryRemoveChild(childName) {
        return this._constructsNode.tryRemoveChild(childName);
    }
    /**
     * Adds a validation to this construct.
     *
     * When `node.validate()` is called, the `validate()` method will be called on
     * all validations and all errors will be returned.
     *
     * @param validation The validation object
     */
    addValidation(validation) {
        this._constructsNode.addValidation(validation);
    }
    /**
     * Validates this construct.
     *
     * Invokes the `validate()` method on all validations added through
     * `addValidation()`.
     *
     * @returns an array of validation error messages associated with this
     * construct.
     */
    validate() {
        return this._constructsNode.validate();
    }
    /**
     * Locks this construct from allowing more children to be added. After this
     * call, no more children can be added to this construct or to any children.
     */
    lock() {
        this._constructsNode.lock();
    }
    /**
     * Returns the root app.
     */
    findApp(scope) {
        if (isApp(scope)) {
            return scope;
        }
        if (!scope.node.scope) {
            throw new Error("Cannot find root app");
        }
        return this.findApp(scope.node.scope);
    }
    findRoot(scope) {
        if (isRoot(scope)) {
            return scope;
        }
        if (!scope.node.scope) {
            throw new Error("Cannot find root construct");
        }
        return this.findRoot(scope.node.scope);
    }
}
exports.Node = Node;
_a = JSII_RTTI_SYMBOL_1;
Node[_a] = { fqn: "@winglang/sdk.std.Node", version: "0.0.0" };
function isApp(x) {
    return x && x[exports.APP_SYMBOL];
}
function isRoot(x) {
    return x && x.constructor && x.constructor[ROOT_SYMBOL];
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zdGQvbm9kZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLDJDQU9vQjtBQUNwQixxREFBa0Q7QUFHbEQsTUFBTSxXQUFXLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDO0FBQzVDLFFBQUEsVUFBVSxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsNEJBQTRCLENBQUMsQ0FBQztBQUNuRSxNQUFNLFdBQVcsR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLDZCQUE2QixDQUFDLENBQUM7QUFFakQsUUFBQSxxQkFBcUIsR0FBRyxrQkFBa0IsQ0FBQztBQUMzQyxRQUFBLGlCQUFpQixHQUFHLGVBQWUsQ0FBQztBQUVqRDs7R0FFRztBQUNILE1BQWEsSUFBSTtJQUNmOzs7O09BSUc7SUFDSSxNQUFNLENBQUMsU0FBUyxDQUFDLGVBQW9CO1FBQzFDLGVBQWUsQ0FBQyxXQUFXLENBQUMsR0FBRyxJQUFJLENBQUM7SUFDdEMsQ0FBQztJQUVEOztPQUVHO0lBQ0ksTUFBTSxDQUFDLEVBQUUsQ0FBQyxTQUFxQjtRQUNwQyxJQUFJLElBQUksR0FBSSxTQUFpQixDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBRTNDLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUNWLElBQUksR0FBRyxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUMxQixTQUFpQixDQUFDLFdBQVcsQ0FBQyxHQUFHLElBQUksQ0FBQztRQUN6QyxDQUFDO1FBRUQsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBNkRELFlBQXFDLFNBQXFCO1FBQXJCLGNBQVMsR0FBVCxTQUFTLENBQVk7UUFDeEQsSUFBSSxDQUFDLGVBQWUsR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDO1FBQ3RDLElBQUksQ0FBQyxZQUFZLEdBQUcseUJBQVcsQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUMs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UUFDVCxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksRUFBRSxDQUFDO0lBQzlCLENBQUM7SUFFRDs7T0FFRztJQUNLLE9BQU8sQ0FBQyxLQUFpQjtRQUMvQixJQUFJLEtBQUssQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDO1lBQ2pCLE9BQU8sS0FBYSxDQUFDO1FBQ3ZCLENBQUM7UUFFRCxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztZQUN0QixNQUFNLElBQUksS0FBSyxDQUFDLHNCQUFzQixDQUFDLENBQUM7UUFDMUMsQ0FBQztRQUVELE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3hDLENBQUM7SUFFTyxRQUFRLENBQUMsS0FBaUI7UUFDaEMsSUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQztZQUNsQixPQUFPLEtBQUssQ0FBQztRQUNmLENBQUM7UUFFRCxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztZQUN0QixNQUFNLElBQUksS0FBSyxDQUFDLDRCQUE0QixDQUFDLENBQUM7UUFDaEQsQ0FBQztRQUVELE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3pDLENBQUM7O0FBdFpILG9CQXVaQzs7O0FBNkVELFNBQVMsS0FBSyxDQUFDLENBQU07SUFDbkIsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLGtCQUFVLENBQUMsQ0FBQztBQUM1QixDQUFDO0FBRUQsU0FBUyxNQUFNLENBQUMsQ0FBTTtJQUNwQixPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsV0FBVyxJQUFJLENBQUMsQ0FBQyxXQUFXLENBQUMsV0FBVyxDQUFDLENBQUM7QUFDMUQsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIElDb25zdHJ1Y3QsXG4gIE5vZGUgYXMgQ29uc3RydWN0c05vZGUsXG4gIENvbnN0cnVjdE9yZGVyLFxuICBJRGVwZW5kYWJsZSxcbiAgTWV0YWRhdGFPcHRpb25zLFxuICBJVmFsaWRhdGlvbixcbn0gZnJvbSBcImNvbnN0cnVjdHNcIjtcbmltcG9ydCB7IENvbm5lY3Rpb25zIH0gZnJvbSBcIi4uL2NvcmUvY29ubmVjdGlvbnNcIjtcbmltcG9ydCB7IFBhcmFtZXRlclJlZ2lzdHJhciB9IGZyb20gXCIuLi9wbGF0Zm9ybVwiO1xuXG5jb25zdCBOT0RFX1NZTUJPTCA9IFN5bWJvbC5mb3IoXCJAd2luZ2xhbmcvc2RrLnN0ZC5Ob2RlXCIpO1xuZXhwb3J0IGNvbnN0IEFQUF9TWU1CT0wgPSBTeW1ib2wuZm9yKFwiQHdpbmdsYW5nL3Nkay5zdGQuTm9kZS9hcHBcIik7XG5jb25zdCBST09UX1NZTUJPTCA9IFN5bWJvbC5mb3IoXCJAd2luZ2xhbmcvc2RrLnN0ZC5Ob2RlL3Jvb3RcIik7XG5cbmV4cG9ydCBjb25zdCBDT05ORUNUSU9OU19GSUxFX1BBVEggPSBcImNvbm5lY3Rpb25zLmpzb25cIjtcbmV4cG9ydCBjb25zdCBTREtfU09VUkNFX01PRFVMRSA9IFwiQHdpbmdsYW5nL3Nka1wiO1xuXG4vKipcbiAqIFRoZSBpbnRlcm5hbCBub2RlIG9mIGEgY29uc3RydWN0LlxuICovXG5leHBvcnQgY2xhc3MgTm9kZSB7XG4gIC8qKlxuICAgKiBNYXJrcyBhIHR5cGUgYXMgdGhlIHJvb3Qgb2YgdGhlIHRyZWUuXG4gICAqIEBwYXJhbSByb290Q29uc3RydWN0b3JcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIF9tYXJrUm9vdChyb290Q29uc3RydWN0b3I6IGFueSkge1xuICAgIHJvb3RDb25zdHJ1Y3RvcltST09UX1NZTUJPTF0gPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgaW50ZXJuYWwgY29uc3RydWN0IG5vZGUuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG9mKGNvbnN0cnVjdDogSUNvbnN0cnVjdCk6IE5vZGUge1xuICAgIGxldCBub2RlID0gKGNvbnN0cnVjdCBhcyBhbnkpW05PREVfU1lNQk9MXTtcblxuICAgIGlmICghbm9kZSkge1xuICAgICAgbm9kZSA9IG5ldyBOb2RlKGNvbnN0cnVjdCk7XG4gICAgICAoY29uc3RydWN0IGFzIGFueSlbTk9ERV9TWU1CT0xdID0gbm9kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaXRsZSBvZiB0aGUgY29uc3RydWN0IGZvciBkaXNwbGF5IHB1cnBvc2VzLlxuICAgKi9cbiAgcHVibGljIHRpdGxlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBEZXNjcmlwdGlvbiBvZiB0aGUgY29uc3RydWN0IGZvciBkaXNwbGF5IHB1cnBvc2VzLlxuICAgKi9cbiAgcHVibGljIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgc291cmNlIGZpbGUgb3IgbGlicmFyeSB3aGVyZSB0aGUgY29uc3RydWN0IHdhcyBkZWZpbmVkLlxuICAgKi9cbiAgcHVibGljIHNvdXJjZU1vZHVsZT86IHN0cmluZztcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgY29uc3RydWN0IHNob3VsZCBiZSBoaWRkZW4gYnkgZGVmYXVsdCBpbiB0cmVlIHZpc3VhbGl6YXRpb25zLlxuICAgKi9cbiAgcHVibGljIGhpZGRlbj86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFRoZSBjb2xvciBvZiB0aGUgY29uc3RydWN0IGZvciBkaXNwbGF5IHB1cnBvc2VzLlxuICAgKiBTdXBwb3J0ZWQgY29sb3JzIGFyZTpcbiAgICogLSBvcmFuZ2VcbiAgICogLSBza3lcbiAgICogLSBlbWVyYWxkXG4gICAqIC0gbGltZVxuICAgKiAtIHBpbmtcbiAgICogLSBhbWJlclxuICAgKiAtIGN5YW5cbiAgICogLSBwdXJwbGVcbiAgICogLSByZWRcbiAgICogLSB2aW9sZXRcbiAgICogLSBzbGF0ZVxuICAgKi9cbiAgcHVibGljIGNvbG9yPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgaWNvbiBvZiB0aGUgY29uc3RydWN0IGZvciBkaXNwbGF5IHB1cnBvc2VzLlxuICAgKiBTdXBwb3J0ZWQgaWNvbnMgYXJlIGZyb20gSGVyb2ljb25zOlxuICAgKiAtIGh0dHBzOi8vaGVyb2ljb25zLmNvbS9cbiAgICogZS5nLlxuICAgKiAtIFwiYWNhZGVtaWMtY2FwXCJcbiAgICovXG4gIHB1YmxpYyBpY29uPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBub2RlIGlzIGV4cGFuZGVkIG9yIGNvbGxhcHNlZCBieSBkZWZhdWx0IGluIHRoZSBVSS5cbiAgICogQnkgZGVmYXVsdCwgbm9kZXMgYXJlIGNvbGxhcHNlZC4gU2V0IHRoaXMgdG8gYHRydWVgIGlmIHlvdSB3YW50IHRoZSBub2RlIHRvIGJlIGV4cGFuZGVkIGJ5IGRlZmF1bHQuXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBwdWJsaWMgZXhwYW5kZWQ/OiBib29sZWFuO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgX2NvbnN0cnVjdHNOb2RlOiBDb25zdHJ1Y3RzTm9kZTtcbiAgcHJpdmF0ZSByZWFkb25seSBfY29ubmVjdGlvbnM6IENvbm5lY3Rpb25zO1xuICBwcml2YXRlIF9hcHA6IElBcHAgfCB1bmRlZmluZWQ7XG4gIHByaXZhdGUgX3Jvb3Q6IElDb25zdHJ1Y3QgfCB1bmRlZmluZWQ7XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IGNvbnN0cnVjdDogSUNvbnN0cnVjdCkge1xuICAgIHRoaXMuX2NvbnN0cnVjdHNOb2RlID0gY29uc3RydWN0Lm5vZGU7XG4gICAgdGhpcy5fY29ubmVjdGlvbnMgPSBDb25uZWN0aW9ucy5vZihjb25zdHJ1Y3QpOyAvLyB0cmVlLXVuaXF1ZSBpbnN0YW5jZVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBjb25uZWN0aW9uIGJldHdlZW4gdHdvIGNvbnN0cnVjdHMuIEEgY29ubmVjdGlvbiBpcyBhIHBpZWNlIG9mXG4gICAqIG1ldGFkYXRhIGRlc2NyaWJpbmcgaG93IG9uZSBjb25zdHJ1Y3QgaXMgcmVsYXRlZCB0byBhbm90aGVyIGNvbnN0cnVjdC5cbiAgICovXG4gIHB1YmxpYyBhZGRDb25uZWN0aW9uKHByb3BzOiBBZGRDb25uZWN0aW9uUHJvcHMpIHtcbiAgICB0aGlzLl9jb25uZWN0aW9ucy5hZGQoe1xuICAgICAgc291cmNlOiBwcm9wcy5zb3VyY2UgPz8gdGhpcy5jb25zdHJ1Y3QsXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIC0tLS0gY29uc3RydWN0cyAxMC54IEFQSXMgLS0tLVxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vYXdzL2NvbnN0cnVjdHMvYmxvYi8xMC54L3NyYy9jb25zdHJ1Y3QudHNcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc2NvcGUgaW4gd2hpY2ggdGhpcyBjb25zdHJ1Y3QgaXMgZGVmaW5lZC5cbiAgICpcbiAgICogVGhlIHZhbHVlIGlzIGB1bmRlZmluZWRgIGF0IHRoZSByb290IG9mIHRoZSBjb25zdHJ1Y3Qgc2NvcGUgdHJlZS5cbiAgICovXG4gIHB1YmxpYyBnZXQgc2NvcGUoKTogSUNvbnN0cnVjdCB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnN0cnVjdHNOb2RlLnNjb3BlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBpZCBvZiB0aGlzIGNvbnN0cnVjdCB3aXRoaW4gdGhlIGN1cnJlbnQgc2NvcGUuXG4gICAqXG4gICAqIFRoaXMgaXMgYSBhIHNjb3BlLXVuaXF1ZSBpZC4gVG8gb2J0YWluIGFuIGFwcC11bmlxdWUgaWQgZm9yIHRoaXMgY29uc3RydWN0LCB1c2UgYGFkZHJgLlxuICAgKi9cbiAgcHVibGljIGdldCBpZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9jb25zdHJ1Y3RzTm9kZS5pZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgZnVsbCwgYWJzb2x1dGUgcGF0aCBvZiB0aGlzIGNvbnN0cnVjdCBpbiB0aGUgdHJlZS5cbiAgICpcbiAgICogQ29tcG9uZW50cyBhcmUgc2VwYXJhdGVkIGJ5ICcvJy5cbiAgICovXG4gIHB1YmxpYyBnZXQgcGF0aCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9jb25zdHJ1Y3RzTm9kZS5wYXRoO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb3BhcXVlIHRyZWUtdW5pcXVlIGFkZHJlc3MgZm9yIHRoaXMgY29uc3RydWN0LlxuICAgKlxuICAgKiBBZGRyZXNzZXMgYXJlIDQyIGNoYXJhY3RlcnMgaGV4YWRlY2ltYWwgc3RyaW5ncy4gVGhleSBiZWdpbiB3aXRoIFwiYzhcIlxuICAgKiBmb2xsb3dlZCBieSA0MCBsb3dlcmNhc2UgaGV4YWRlY2ltYWwgY2hhcmFjdGVycyAoMC05YS1mKS5cbiAgICpcbiAgICogQWRkcmVzc2VzIGFyZSBjYWxjdWxhdGVkIHVzaW5nIGEgU0hBLTEgb2YgdGhlIGNvbXBvbmVudHMgb2YgdGhlIGNvbnN0cnVjdFxuICAgKiBwYXRoLlxuICAgKlxuICAgKiBUbyBlbmFibGUgcmVmYWN0b3JpbmdzIG9mIGNvbnN0cnVjdCB0cmVlcywgY29uc3RydWN0cyB3aXRoIHRoZSBJRCBgRGVmYXVsdGBcbiAgICogd2lsbCBiZSBleGNsdWRlZCBmcm9tIHRoZSBjYWxjdWxhdGlvbi4gSW4gdGhvc2UgY2FzZXMgY29uc3RydWN0cyBpbiB0aGVcbiAgICogc2FtZSB0cmVlIG1heSBoYXZlIHRoZSBzYW1lIGFkZHJlZXNzLlxuICAgKlxuICAgKiBAZXhhbXBsZSBjODNhMjg0NmU1MDZiY2M1ZjEwNjgyYjU2NDA4NGJjYTJkMjc1NzA5ZWVcbiAgICovXG4gIHB1YmxpYyBnZXQgYWRkcigpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9jb25zdHJ1Y3RzTm9kZS5hZGRyO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIGRpcmVjdCBjaGlsZCBieSBpZCwgb3IgdW5kZWZpbmVkXG4gICAqXG4gICAqIEBwYXJhbSBpZCBJZGVudGlmaWVyIG9mIGRpcmVjdCBjaGlsZFxuICAgKiBAcmV0dXJucyB0aGUgY2hpbGQgaWYgZm91bmQsIG9yIHVuZGVmaW5lZFxuICAgKi9cbiAgcHVibGljIHRyeUZpbmRDaGlsZChpZDogc3RyaW5nKTogSUNvbnN0cnVjdCB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnN0cnVjdHNOb2RlLnRyeUZpbmRDaGlsZChpZCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgZGlyZWN0IGNoaWxkIGJ5IGlkXG4gICAqXG4gICAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgY2hpbGQgaXMgbm90IGZvdW5kLlxuICAgKlxuICAgKiBAcGFyYW0gaWQgSWRlbnRpZmllciBvZiBkaXJlY3QgY2hpbGRcbiAgICogQHJldHVybnMgQ2hpbGQgd2l0aCB0aGUgZ2l2ZW4gaWQuXG4gICAqL1xuICBwdWJsaWMgZmluZENoaWxkKGlkOiBzdHJpbmcpOiBJQ29uc3RydWN0IHtcbiAgICByZXR1cm4gdGhpcy5fY29uc3RydWN0c05vZGUuZmluZENoaWxkKGlkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjaGlsZCBjb25zdHJ1Y3QgdGhhdCBoYXMgdGhlIGlkIGBEZWZhdWx0YCBvciBgUmVzb3VyY2VcImAuXG4gICAqIFRoaXMgaXMgdXN1YWxseSB0aGUgY29uc3RydWN0IHRoYXQgcHJvdmlkZXMgdGhlIGJ1bGsgb2YgdGhlIHVuZGVybHlpbmcgZnVuY3Rpb25hbGl0eS5cbiAgICogVXNlZnVsIGZvciBtb2RpZmljYXRpb25zIG9mIHRoZSB1bmRlcmx5aW5nIGNvbnN0cnVjdCB0aGF0IGFyZSBub3QgYXZhaWxhYmxlIGF0IHRoZSBoaWdoZXIgbGV2ZWxzLlxuICAgKlxuICAgKiBAdGhyb3dzIGlmIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgY2hpbGRcbiAgICogQHJldHVybnMgYSBjb25zdHJ1Y3Qgb3IgdW5kZWZpbmVkIGlmIHRoZXJlIGlzIG5vIGRlZmF1bHQgY2hpbGRcbiAgICovXG4gIHB1YmxpYyBnZXQgZGVmYXVsdENoaWxkKCk6IElDb25zdHJ1Y3QgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLl9jb25zdHJ1Y3RzTm9kZS5kZWZhdWx0Q2hpbGQ7XG4gIH1cblxuICAvKipcbiAgICogT3ZlcnJpZGUgdGhlIGRlZmF1bHRDaGlsZCBwcm9wZXJ0eS5cbiAgICpcbiAgICogVGhpcyBzaG91bGQgb25seSBiZSB1c2VkIGluIHRoZSBjYXNlcyB3aGVyZSB0aGUgY29ycmVjdFxuICAgKiBkZWZhdWx0IGNoaWxkIGlzIG5vdCBuYW1lZCAnUmVzb3VyY2UnIG9yICdEZWZhdWx0JyBhcyBpdFxuICAgKiBzaG91bGQgYmUuXG4gICAqXG4gICAqIElmIHlvdSBzZXQgdGhpcyB0byB1bmRlZmluZWQsIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIGZpbmRpbmdcbiAgICogdGhlIGNoaWxkIG5hbWVkICdSZXNvdXJjZScgb3IgJ0RlZmF1bHQnIHdpbGwgYmUgdXNlZC5cbiAgICovXG4gIHB1YmxpYyBzZXQgZGVmYXVsdENoaWxkKHZhbHVlOiBJQ29uc3RydWN0IHwgdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5fY29uc3RydWN0c05vZGUuZGVmYXVsdENoaWxkID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQWxsIGRpcmVjdCBjaGlsZHJlbiBvZiB0aGlzIGNvbnN0cnVjdC5cbiAgICovXG4gIHB1YmxpYyBnZXQgY2hpbGRyZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnN0cnVjdHNOb2RlLmNoaWxkcmVuO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGlzIGNvbnN0cnVjdCBhbmQgYWxsIG9mIGl0cyBjaGlsZHJlbiBpbiB0aGUgZ2l2ZW4gb3JkZXJcbiAgICovXG4gIHB1YmxpYyBmaW5kQWxsKFxuICAgIG9yZGVyOiBDb25zdHJ1Y3RPcmRlciA9IENvbnN0cnVjdE9yZGVyLlBSRU9SREVSXG4gICk6IElDb25zdHJ1Y3RbXSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnN0cnVjdHNOb2RlLmZpbmRBbGwob3JkZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gc2V0IGNvbnRleHR1YWwgdmFsdWVzLlxuICAgKiBDb250ZXh0IG11c3QgYmUgc2V0IGJlZm9yZSBhbnkgY2hpbGRyZW4gYXJlIGFkZGVkLCBzaW5jZSBjaGlsZHJlbiBtYXkgY29uc3VsdCBjb250ZXh0IGluZm8gZHVyaW5nIGNvbnN0cnVjdGlvbi5cbiAgICogSWYgdGhlIGtleSBhbHJlYWR5IGV4aXN0cywgaXQgd2lsbCBiZSBvdmVycmlkZGVuLlxuICAgKiBAcGFyYW0ga2V5IFRoZSBjb250ZXh0IGtleVxuICAgKiBAcGFyYW0gdmFsdWUgVGhlIGNvbnRleHQgdmFsdWVcbiAgICovXG4gIHB1YmxpYyBzZXRDb250ZXh0KGtleTogc3RyaW5nLCB2YWx1ZTogYW55KSB7XG4gICAgdGhpcy5fY29uc3RydWN0c05vZGUuc2V0Q29udGV4dChrZXksIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYSB2YWx1ZSBmcm9tIHRyZWUgY29udGV4dCBpZiBwcmVzZW50LiBPdGhlcndpc2UsIHdvdWxkIHRocm93IGFuIGVycm9yLlxuICAgKlxuICAgKiBDb250ZXh0IGlzIHVzdWFsbHkgaW5pdGlhbGl6ZWQgYXQgdGhlIHJvb3QsIGJ1dCBjYW4gYmUgb3ZlcnJpZGRlbiBhdCBhbnkgcG9pbnQgaW4gdGhlIHRyZWUuXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgVGhlIGNvbnRleHQga2V5XG4gICAqIEByZXR1cm5zIFRoZSBjb250ZXh0IHZhbHVlIG9yIHRocm93cyBlcnJvciBpZiB0aGVyZSBpcyBubyBjb250ZXh0IHZhbHVlIGZvciB0aGlzIGtleVxuICAgKi9cbiAgcHVibGljIGdldENvbnRleHQoa2V5OiBzdHJpbmcpOiBhbnkge1xuICAgIHJldHVybiB0aGlzLl9jb25zdHJ1Y3RzTm9kZS5nZXRDb250ZXh0KGtleSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGEgdmFsdWUgZnJvbSB0cmVlIGNvbnRleHQuXG4gICAqXG4gICAqIENvbnRleHQgaXMgdXN1YWxseSBpbml0aWFsaXplZCBhdCB0aGUgcm9vdCwgYnV0IGNhbiBiZSBvdmVycmlkZGVuIGF0IGFueSBwb2ludCBpbiB0aGUgdHJlZS5cbiAgICpcbiAgICogQHBhcmFtIGtleSBUaGUgY29udGV4dCBrZXlcbiAgICogQHJldHVybnMgVGhlIGNvbnRleHQgdmFsdWUgb3IgYHVuZGVmaW5lZGAgaWYgdGhlcmUgaXMgbm8gY29udGV4dCB2YWx1ZSBmb3IgdGhpcyBrZXkuXG4gICAqL1xuICBwdWJsaWMgdHJ5R2V0Q29udGV4dChrZXk6IHN0cmluZyk6IGFueSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnN0cnVjdHNOb2RlLnRyeUdldENvbnRleHQoa2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBpbW11dGFibGUgYXJyYXkgb2YgbWV0YWRhdGEgb2JqZWN0cyBhc3NvY2lhdGVkIHdpdGggdGhpcyBjb25zdHJ1Y3QuXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQsIGZvciBleGFtcGxlLCB0byBpbXBsZW1lbnQgc3VwcG9ydCBmb3IgZGVwcmVjYXRpb24gbm90aWNlcywgc291cmNlIG1hcHBpbmcsIGV0Yy5cbiAgICovXG4gIHB1YmxpYyBnZXQgbWV0YWRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnN0cnVjdHNOb2RlLm1ldGFkYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBtZXRhZGF0YSBlbnRyeSB0byB0aGlzIGNvbnN0cnVjdC5cbiAgICogRW50cmllcyBhcmUgYXJiaXRyYXJ5IHZhbHVlcyBhbmQgd2lsbCBhbHNvIGluY2x1ZGUgYSBzdGFjayB0cmFjZSB0byBhbGxvdyB0cmFjaW5nIGJhY2sgdG9cbiAgICogdGhlIGNvZGUgbG9jYXRpb24gZm9yIHdoZW4gdGhlIGVudHJ5IHdhcyBhZGRlZC4gSXQgY2FuIGJlIHVzZWQsIGZvciBleGFtcGxlLCB0byBpbmNsdWRlIHNvdXJjZVxuICAgKiBtYXBwaW5nIGluIENsb3VkRm9ybWF0aW9uIHRlbXBsYXRlcyB0byBpbXByb3ZlIGRpYWdub3N0aWNzLlxuICAgKlxuICAgKiBAcGFyYW0gdHlwZSBhIHN0cmluZyBkZW5vdGluZyB0aGUgdHlwZSBvZiBtZXRhZGF0YVxuICAgKiBAcGFyYW0gZGF0YSB0aGUgdmFsdWUgb2YgdGhlIG1ldGFkYXRhIChjYW4gYmUgYSBUb2tlbikuIElmIG51bGwvdW5kZWZpbmVkLCBtZXRhZGF0YSB3aWxsIG5vdCBiZSBhZGRlZC5cbiAgICogQHBhcmFtIG9wdGlvbnMgb3B0aW9uc1xuICAgKi9cbiAgcHVibGljIGFkZE1ldGFkYXRhKFxuICAgIHR5cGU6IHN0cmluZyxcbiAgICBkYXRhOiBhbnksXG4gICAgb3B0aW9uczogTWV0YWRhdGFPcHRpb25zID0ge31cbiAgKTogdm9pZCB7XG4gICAgdGhpcy5fY29uc3RydWN0c05vZGUuYWRkTWV0YWRhdGEodHlwZSwgZGF0YSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQWxsIHBhcmVudCBzY29wZXMgb2YgdGhpcyBjb25zdHJ1Y3QuXG4gICAqXG4gICAqIEByZXR1cm5zIGEgbGlzdCBvZiBwYXJlbnQgc2NvcGVzLiBUaGUgbGFzdCBlbGVtZW50IGluIHRoZSBsaXN0IHdpbGwgYWx3YXlzXG4gICAqIGJlIHRoZSBjdXJyZW50IGNvbnN0cnVjdCBhbmQgdGhlIGZpcnN0IGVsZW1lbnQgd2lsbCBiZSB0aGUgcm9vdCBvZiB0aGVcbiAgICogdHJlZS5cbiAgICovXG4gIHB1YmxpYyBnZXQgc2NvcGVzKCk6IElDb25zdHJ1Y3RbXSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnN0cnVjdHNOb2RlLnNjb3BlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByb290IG9mIHRoZSBjb25zdHJ1Y3QgdHJlZSAodGhlIGBjbG91ZC5BcHBgIG9iamVjdCkuXG4gICAqXG4gICAqIFNpbWlsYXIgdG8gYGFwcGAuXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSByb290IG9mIHRoZSBjb25zdHJ1Y3QgdHJlZS5cbiAgICovXG4gIHB1YmxpYyBnZXQgcm9vdCgpOiBJQ29uc3RydWN0IHtcbiAgICBpZiAoIXRoaXMuX3Jvb3QpIHtcbiAgICAgIHRoaXMuX3Jvb3QgPSB0aGlzLmZpbmRSb290KHRoaXMuY29uc3RydWN0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcm9vdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByb290IG9mIHRoZSBjb25zdHJ1Y3QgdHJlZSAodGhlIGBjbG91ZC5BcHBgIG9iamVjdCkuXG4gICAqXG4gICAqIFNpbWlsYXIgdG8gYHJvb3RgLlxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgcm9vdCBvZiB0aGUgY29uc3RydWN0IHRyZWUuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGFwcCgpOiBJQXBwIHtcbiAgICBpZiAoIXRoaXMuX2FwcCkge1xuICAgICAgdGhpcy5fYXBwID0gdGhpcy5maW5kQXBwKHRoaXMuY29uc3RydWN0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fYXBwO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGNvbnN0cnVjdCBvciB0aGUgc2NvcGVzIGluIHdoaWNoIGl0IGlzIGRlZmluZWQgYXJlXG4gICAqIGxvY2tlZC5cbiAgICovXG4gIHB1YmxpYyBnZXQgbG9ja2VkKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25zdHJ1Y3RzTm9kZS5sb2NrZWQ7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGFuIG9yZGVyaW5nIGRlcGVuZGVuY3kgb24gYW5vdGhlciBjb25zdHJ1Y3QuXG4gICAqXG4gICAqIEFuIGBJRGVwZW5kYWJsZWBcbiAgICovXG4gIHB1YmxpYyBhZGREZXBlbmRlbmN5KC4uLmRlcHM6IElEZXBlbmRhYmxlW10pIHtcbiAgICB0aGlzLl9jb25zdHJ1Y3RzTm9kZS5hZGREZXBlbmRlbmN5KC4uLmRlcHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbGwgZGVwZW5kZW5jaWVzIHJlZ2lzdGVyZWQgb24gdGhpcyBub2RlIChub24tcmVjdXJzaXZlKS5cbiAgICovXG4gIHB1YmxpYyBnZXQgZGVwZW5kZW5jaWVzKCk6IElDb25zdHJ1Y3RbXSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnN0cnVjdHNOb2RlLmRlcGVuZGVuY2llcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGNoaWxkIHdpdGggdGhlIGdpdmVuIG5hbWUsIGlmIHByZXNlbnQuXG4gICAqXG4gICAqIEByZXR1cm5zIFdoZXRoZXIgYSBjaGlsZCB3aXRoIHRoZSBnaXZlbiBuYW1lIHdhcyBkZWxldGVkLlxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqL1xuICBwdWJsaWMgdHJ5UmVtb3ZlQ2hpbGQoY2hpbGROYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fY29uc3RydWN0c05vZGUudHJ5UmVtb3ZlQ2hpbGQoY2hpbGROYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgdmFsaWRhdGlvbiB0byB0aGlzIGNvbnN0cnVjdC5cbiAgICpcbiAgICogV2hlbiBgbm9kZS52YWxpZGF0ZSgpYCBpcyBjYWxsZWQsIHRoZSBgdmFsaWRhdGUoKWAgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIG9uXG4gICAqIGFsbCB2YWxpZGF0aW9ucyBhbmQgYWxsIGVycm9ycyB3aWxsIGJlIHJldHVybmVkLlxuICAgKlxuICAgKiBAcGFyYW0gdmFsaWRhdGlvbiBUaGUgdmFsaWRhdGlvbiBvYmplY3RcbiAgICovXG4gIHB1YmxpYyBhZGRWYWxpZGF0aW9uKHZhbGlkYXRpb246IElWYWxpZGF0aW9uKSB7XG4gICAgdGhpcy5fY29uc3RydWN0c05vZGUuYWRkVmFsaWRhdGlvbih2YWxpZGF0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhpcyBjb25zdHJ1Y3QuXG4gICAqXG4gICAqIEludm9rZXMgdGhlIGB2YWxpZGF0ZSgpYCBtZXRob2Qgb24gYWxsIHZhbGlkYXRpb25zIGFkZGVkIHRocm91Z2hcbiAgICogYGFkZFZhbGlkYXRpb24oKWAuXG4gICAqXG4gICAqIEByZXR1cm5zIGFuIGFycmF5IG9mIHZhbGlkYXRpb24gZXJyb3IgbWVzc2FnZXMgYXNzb2NpYXRlZCB3aXRoIHRoaXNcbiAgICogY29uc3RydWN0LlxuICAgKi9cbiAgcHVibGljIHZhbGlkYXRlKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5fY29uc3RydWN0c05vZGUudmFsaWRhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2NrcyB0aGlzIGNvbnN0cnVjdCBmcm9tIGFsbG93aW5nIG1vcmUgY2hpbGRyZW4gdG8gYmUgYWRkZWQuIEFmdGVyIHRoaXNcbiAgICogY2FsbCwgbm8gbW9yZSBjaGlsZHJlbiBjYW4gYmUgYWRkZWQgdG8gdGhpcyBjb25zdHJ1Y3Qgb3IgdG8gYW55IGNoaWxkcmVuLlxuICAgKi9cbiAgcHVibGljIGxvY2soKSB7XG4gICAgdGhpcy5fY29uc3RydWN0c05vZGUubG9jaygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJvb3QgYXBwLlxuICAgKi9cbiAgcHJpdmF0ZSBmaW5kQXBwKHNjb3BlOiBJQ29uc3RydWN0KTogSUFwcCB7XG4gICAgaWYgKGlzQXBwKHNjb3BlKSkge1xuICAgICAgcmV0dXJuIHNjb3BlIGFzIElBcHA7XG4gICAgfVxuXG4gICAgaWYgKCFzY29wZS5ub2RlLnNjb3BlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCByb290IGFwcFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5maW5kQXBwKHNjb3BlLm5vZGUuc2NvcGUpO1xuICB9XG5cbiAgcHJpdmF0ZSBmaW5kUm9vdChzY29wZTogSUNvbnN0cnVjdCk6IElDb25zdHJ1Y3Qge1xuICAgIGlmIChpc1Jvb3Qoc2NvcGUpKSB7XG4gICAgICByZXR1cm4gc2NvcGU7XG4gICAgfVxuXG4gICAgaWYgKCFzY29wZS5ub2RlLnNjb3BlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCByb290IGNvbnN0cnVjdFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5maW5kUm9vdChzY29wZS5ub2RlLnNjb3BlKTtcbiAgfVxufVxuXG4vKipcbiAqIFByb3BzIGZvciBgTm9kZS5hZGRDb25uZWN0aW9uYC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBZGRDb25uZWN0aW9uUHJvcHMge1xuICAvKipcbiAgICogVGhlIHNvdXJjZSBvZiB0aGUgY29ubmVjdGlvbi5cbiAgICogQGRlZmF1bHQgdGhpc1xuICAgKi9cbiAgcmVhZG9ubHkgc291cmNlPzogSUNvbnN0cnVjdDtcblxuICAvKipcbiAgICogQW4gb3BlcmF0aW9uIHRoYXQgdGhlIHNvdXJjZSBjb25zdHJ1Y3Qgc3VwcG9ydHMuXG4gICAqIEBkZWZhdWx0IC0gbm8gb3BlcmF0aW9uXG4gICAqL1xuICByZWFkb25seSBzb3VyY2VPcD86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHRhcmdldCBvZiB0aGUgY29ubmVjdGlvbi5cbiAgICovXG4gIHJlYWRvbmx5IHRhcmdldDogSUNvbnN0cnVjdDtcblxuICAvKipcbiAgICogQW4gb3BlcmF0aW9uIHRoYXQgdGhlIHRhcmdldCBjb25zdHJ1Y3Qgc3VwcG9ydHMuXG4gICAqIEBkZWZhdWx0IC0gbm8gb3BlcmF0aW9uXG4gICAqL1xuICByZWFkb25seSB0YXJnZXRPcD86IHN0cmluZztcblxuICAvKipcbiAgICogQSBuYW1lIGZvciB0aGUgY29ubmVjdGlvbi5cbiAgICovXG4gIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgV2luZyBhcHBsaWNhdGlvbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJQXBwIGV4dGVuZHMgSUNvbnN0cnVjdCB7XG4gIC8qKlxuICAgKiBUeXBlIG1hcmtlci5cbiAgICogQGludGVybmFsXG4gICAqKi9cbiAgcmVhZG9ubHkgW0FQUF9TWU1CT0xdOiB0cnVlO1xuXG4gIC8qKlxuICAgKiBUaGUgYC53aW5nYCBkaXJlY3RvcnkgaW50byB3aGljaCB5b3UgY2FuIGVtaXQgYXJ0aWZhY3RzIGR1cmluZyBwcmVmbGlnaHQuXG4gICAqL1xuICByZWFkb25seSB3b3JrZGlyOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIGB0cnVlYCBpZiB0aGlzIGlzIGEgdGVzdGluZyBlbnZpcm9ubWVudFxuICAgKi9cbiAgcmVhZG9ubHkgaXNUZXN0RW52aXJvbm1lbnQ6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFRoZSBkaXJlY3Rvcnkgb2YgdGhlIGVudHJ5cG9pbnQgb2YgdGhlIGN1cnJlbnQgcHJvZ3JhbS5cbiAgICovXG4gIHJlYWRvbmx5IGVudHJ5cG9pbnREaXI6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGFwcGxpY2F0aW9uJ3MgcGFyYW1ldGVyIHJlZ2lzdHJhclxuICAgKi9cbiAgcmVhZG9ubHkgcGFyYW1ldGVyczogUGFyYW1ldGVyUmVnaXN0cmFyO1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHVuaXF1ZSBJRCBmb3IgdGhlIGdpdmVuIHNjb3BlIGFuZCBwcmVmaXguIFRoZSBuZXdseSBnZW5lcmF0ZWQgSUQgaXNcbiAgICogZ3VhcmFudGVlZCB0byBiZSB1bmlxdWUgd2l0aGluIHRoZSBnaXZlbiBzY29wZS5cbiAgICogSXQgd2lsbCBoYXZlIHRoZSBmb3JtICd7cHJlZml4fXtufScsIHdoZXJlICd7cHJlZml4fScgaXMgdGhlIGdpdmVuIHByZWZpeCBhbmQgJ3tufScgaXMgYW5cbiAgICogYXNjZW5kaW5nIHNlcXVlbmNlIG9mIGludGVnZXJzIHN0YXJ0aW5nIGZyb20gJzAnLlxuICAgKlxuICAgKiBAcGFyYW0gc2NvcGUgdG8gZ3VhcmFudGVlIHVuaXF1ZW5lc3MgaW5cbiAgICogQHBhcmFtIHByZWZpeCBwcmVwZW5kZWQgdG8gdGhlIHVuaXF1ZSBpZGVudGlmaWVyXG4gICAqL1xuICBtYWtlSWQoc2NvcGU6IElDb25zdHJ1Y3QsIHByZWZpeD86IHN0cmluZyk6IHN0cmluZztcbn1cblxuZnVuY3Rpb24gaXNBcHAoeDogYW55KTogeCBpcyBJQXBwIHtcbiAgcmV0dXJuIHggJiYgeFtBUFBfU1lNQk9MXTtcbn1cblxuZnVuY3Rpb24gaXNSb290KHg6IGFueSk6IGJvb2xlYW4ge1xuICByZXR1cm4geCAmJiB4LmNvbnN0cnVjdG9yICYmIHguY29uc3RydWN0b3JbUk9PVF9TWU1CT0xdO1xufVxuIl19