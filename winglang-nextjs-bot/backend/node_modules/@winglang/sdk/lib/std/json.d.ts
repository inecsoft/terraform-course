/**
 * Options for stringify() method.
 */
export interface JsonStringifyOptions {
    /** Indentation spaces number */
    readonly indent: number;
}
/**
 * Options for validating Json
 */
export interface JsonValidationOptions {
    /** Unsafe mode to skip validation (may lead to runtime errors) */
    readonly unsafe?: boolean;
}
/**
 * Json entry representation
 */
export interface JsonEntry {
    /** The entry key */
    readonly key: string;
    /** The entry value */
    readonly value: Json;
}
/**
 * Immutable Json
 */
export declare class Json {
    /**
     * @internal
     */
    static _toInflightType(): string;
    /**
     * Returns the keys from the Json.
     *
     * @macro Object.keys($args$)
     *
     * @param json map to get the keys from
     * @returns the keys as Array<String>
     */
    static keys(json: Json | MutJson): string[];
    /**
     * Returns the values from the Json.
     *
     * @macro Object.values($args$)
     *
     * @param json map to get the values from
     * @returns the values as Array<Json>
     */
    static values(json: Json): Json[];
    /**
     * Returns the entries from the Json.
     *
     * @param json map to get the entries from
     * @returns the entries as Array<JsonEntry>
     */
    static entries(json: Json): JsonEntry[];
    /**
     * Deletes a key in a given Json
     *
     * @macro ((json, key) => { delete json[key]; })($args$)
     *
     * @param json to delete key from
     * @param key the key to delete
     */
    static delete(json: MutJson, key: string): void;
    /**
     * Formats Json as string
     *
     * @macro ((json, opts) => { return JSON.stringify(json, null, opts?.indent) })($args$)
     *
     * @param json to format as string
     * @returns string representation of the Json
     */
    static stringify(json: Json | MutJson, options?: JsonStringifyOptions): string;
    /**
     * Creates an immutable deep copy of the Json.
     *
     * @macro JSON.parse(JSON.stringify($args$))
     *
     * @param json to copy
     * @returns the immutable copy of the Json
     */
    static deepCopy(json: MutJson): Json;
    /**
     * Creates a mutable deep copy of the Json.
     *
     * @macro JSON.parse(JSON.stringify($args$))
     *
     * @param json to copy
     * @returns the mutable copy of the Json
     */
    static deepCopyMut(json: Json): MutJson;
    /**
     * Parse a string into a Json
     *
     * @macro JSON.parse($args$)
     *
     * @param str to parse as Json
     * @returns Json representation of the string
     */
    static parse(str: string): Json;
    /**
     * Try to parse a string into a Json
     *
     * @macro ((args) => { try { return (args === undefined) ? undefined : JSON.parse(args); } catch (err) { return undefined; } })($args$)
     *
     * @param str to parse as Json
     * @returns Json representation of the string or undefined if string is not parsable
     */
    static tryParse(str?: string): Json | undefined;
    private constructor();
    /**
     * Checks if a Json object has a given key
     *
     * @macro ((obj, key) => { return obj.hasOwnProperty(key); })($self$,$args$)
     *
     * @param key The key to check
     * @returns Boolean value corresponding to whether the key exists
     */
    has(key: string): boolean;
    /**
     * Returns the value associated with the specified Json key
     *
     * @macro ((obj, args) => { if (obj[args] === undefined) throw new Error(`Json property "${args}" does not exist`); return obj[args] })($self$, $args$)
     *
     * @param key The key of the Json property
     * @returns The value associated with the specified Json key
     * @throws Json property does not exist if the given key is not part of an existing property
     */
    get(key: string): Json;
    /**
     * Returns a specified element at a given index from Json Array
     *
     * @macro ((obj, args) => { if (obj[args] === undefined) throw new Error("Index out of bounds"); return obj[args] })($self$, $args$)
     *
     * @param index The index of the element in the Json Array to return
     * @returns The element at given index in Json Array
     * @throws index out of bounds error if the given index does not exist for the Json Array
     */
    getAt(index: number): Json;
    /**
     * Optionally returns an specified element from the Json.
     *
     * @macro ($self$)?.[$args$]
     *
     * @param key The key of the element to return
     * @returns The element associated with the specified key, or undefined if the key can't be found
     */
    tryGet(key: string): Json | undefined;
    /**
     * Optionally returns a specified element at a given index from Json Array
     *
     * @macro ($self$)?.[$args$]
     *
     * @param index The index of the element in the Json Array to return
     * @returns The element at given index in Json Array, or undefined if index is not valid
     */
    tryGetAt(index: number): Json | undefined;
    /**
     * Convert Json element to string if possible.
     *
     * @macro ((arg) => { if (typeof arg !== "string") {throw new Error("unable to parse " + typeof arg + " " + arg + " as a string")}; return JSON.parse(JSON.stringify(arg)) })($self$)
     *
     * @returns a string.
     */
    asStr(): string;
    /**
     * Convert Json element to string if possible.
     *
     * @macro ((arg) => { return (typeof arg === "string") ? JSON.parse(JSON.stringify(arg)) : undefined })($self$)
     *
     * @returns a string.
     */
    tryAsStr(): string | undefined;
    /**
     * Convert Json element to number if possible.
     *
     * @macro ((arg) => { if (typeof arg !== "number") {throw new Error("unable to parse " + typeof arg + " " + arg + " as a number")}; return JSON.parse(JSON.stringify(arg)) })($self$)
     *
     * @returns a number.
     */
    asNum(): number;
    /**
     * Convert Json element to number if possible.
     *
     * @macro ((arg) => { return (typeof arg === "number") ? JSON.parse(JSON.stringify(arg)) : undefined })($self$)
     *
     * @returns a number.
     */
    tryAsNum(): number | undefined;
    /**
     * Convert Json element to boolean if possible.
     *
     * @macro ((arg) => { if (typeof arg !== "boolean") {throw new Error("unable to parse " + typeof arg + " " + arg + " as a boolean")}; return JSON.parse(JSON.stringify(arg)) })($self$)
     *
     * @returns a boolean.
     */
    asBool(): boolean;
    /**
     * Convert Json element to boolean if possible.
     *
     * @macro ((arg) => { return (typeof arg === "boolean") ? JSON.parse(JSON.stringify(arg)) : undefined })($self$)
     *
     * @returns a boolean.
     */
    tryAsBool(): boolean | undefined;
}
/**
 * Mutable Json
 */
export declare class MutJson {
    /**
     * @internal
     */
    static _toInflightType(): string;
    private constructor();
    /**
     * Returns the value associated with the specified Json key
     *
     * @macro ((obj, args) => { if (obj[args] === undefined) throw new Error(`Json property "${args}" does not exist`); return obj[args] })($self$, $args$)
     *
     * @param key The key of the Json property
     * @returns The value associated with the specified Json key
     * @throws Json property does not exist if the given key is not part of an existing property
     */
    get(key: string): MutJson;
    /**
     * Returns a specified element at a given index from MutJson Array
     *
     * @macro ((obj, args) => { if (obj[args] === undefined) throw new Error("Index out of bounds"); return obj[args] })($self$, $args$)
     *
     * @param index The index of the element in the MutJson Array to return
     * @returns The element at given index in MutJson Array
     * @throws index out of bounds error if the given index does not exist for the MutJson Array
     */
    getAt(index: number): MutJson;
    /**
     * Adds or updates an element in MutJson with a specific key and value
     *
     * @macro ((obj, key, value) => { obj[key] = value; })($self$, $args$)
     *
     * @param key The key of the element to add
     * @param value The value of the element to add
     */
    set(key: string, value: MutJson): void;
    /**
     * Set element in MutJson Array with a specific key and value
     *
     * @macro ((obj, idx, value) => { obj[idx] = value; })($self$, $args$)
     *
     * @param value The value of the element to set
     */
    setAt(index: number, value: MutJson): void;
    /**
     * Optionally returns an specified element from the Json.
     *
     * @macro ($self$)?.[$args$]
     *
     * @param key The key of the element to return
     * @returns The element associated with the specified key, or undefined if the key can't be found
     */
    tryGet(key: string): MutJson | undefined;
    /**
     * Optionally returns a specified element at a given index from Json Array
     *
     * @macro ($self$)?.[$args$]
     *
     * @param index The index of the element in the Json Array to return
     * @returns The element at given index in Json Array, or undefined if index is not valid
     */
    tryGetAt(index: number): MutJson | undefined;
    /**
     * Convert Json element to string if possible.
     *
     * @macro ((arg) => { if (typeof arg !== "string") {throw new Error("unable to parse " + typeof arg + " " + arg + " as a string")}; return JSON.parse(JSON.stringify(arg)) })($self$)
     *
     * @returns a string.
     */
    asStr(): string;
    /**
     * Convert Json element to string if possible.
     *
     * @macro ((arg) => { return (typeof arg === "string") ? JSON.parse(JSON.stringify(arg)) : undefined })($self$)
     *
     * @returns a string.
     */
    tryAsStr(): string | undefined;
    /**
     * Convert Json element to number if possible.
     *
     * @macro ((arg) => { if (typeof arg !== "number") {throw new Error("unable to parse " + typeof arg + " " + arg + " as a number")}; return JSON.parse(JSON.stringify(arg)) })($self$)
     *
     * @returns a number.
     */
    asNum(): number;
    /**
     * Convert Json element to number if possible.
     *
     * @macro ((arg) => { return (typeof arg === "number") ? JSON.parse(JSON.stringify(arg)) : undefined })($self$)
     *
     * @returns a number.
     */
    tryAsNum(): number | undefined;
    /**
     * Convert Json element to boolean if possible.
     *
     * @macro ((arg) => { if (typeof arg !== "boolean") {throw new Error("unable to parse " + typeof arg + " " + arg + " as a boolean")}; return JSON.parse(JSON.stringify(arg)) })($self$)
     *
     * @returns a boolean.
     */
    asBool(): boolean;
    /**
     * Convert Json element to boolean if possible.
     *
     * @macro ((arg) => { return (typeof arg === "boolean") ? JSON.parse(JSON.stringify(arg)) : undefined })($self$)
     *
     * @returns a boolean.
     */
    tryAsBool(): boolean | undefined;
    /**
     * Removes the specified element from a map.
     *
     * @macro (delete ($self$)[$args$])
     *
     * @param key The key
     * @returns true if the given key is no longer present
     */
    delete(key: string): boolean;
    /**
     * Checks if a Json object has a given key
     *
     * @macro ((obj, key) => { return obj.hasOwnProperty(key); })($self$,$args$)
     *
     * @param key The key to check
     * @returns Boolean value corresponding to whether the key exists
     */
    has(key: string): boolean;
}
