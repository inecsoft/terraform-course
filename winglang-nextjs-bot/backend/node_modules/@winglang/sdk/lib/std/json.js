"use strict";
var _a, _b;
Object.defineProperty(exports, "__esModule", { value: true });
exports.MutJson = exports.Json = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const core_1 = require("../core");
/**
 * Immutable Json
 */
class Json {
    /**
     * @internal
     */
    static _toInflightType() {
        return core_1.InflightClient.forType(__filename, this.name);
    }
    /**
     * Returns the keys from the Json.
     *
     * @macro Object.keys($args$)
     *
     * @param json map to get the keys from
     * @returns the keys as Array<String>
     */
    static keys(json) {
        json;
        throw new Error("Macro");
    }
    /**
     * Returns the values from the Json.
     *
     * @macro Object.values($args$)
     *
     * @param json map to get the values from
     * @returns the values as Array<Json>
     */
    static values(json) {
        json;
        throw new Error("Macro");
    }
    /**
     * Returns the entries from the Json.
     *
     * @param json map to get the entries from
     * @returns the entries as Array<JsonEntry>
     */
    static entries(json) {
        return Object.entries(json).map(([key, value]) => ({ key, value }));
    }
    /**
     * Deletes a key in a given Json
     *
     * @macro ((json, key) => { delete json[key]; })($args$)
     *
     * @param json to delete key from
     * @param key the key to delete
     */
    static delete(json, key) {
        json;
        key;
        throw new Error("Macro");
    }
    /**
     * Formats Json as string
     *
     * @macro ((json, opts) => { return JSON.stringify(json, null, opts?.indent) })($args$)
     *
     * @param json to format as string
     * @returns string representation of the Json
     */
    static stringify(json, options) {
        json;
        options;
        throw new Error("Macro");
    }
    /**
     * Creates an immutable deep copy of the Json.
     *
     * @macro JSON.parse(JSON.stringify($args$))
     *
     * @param json to copy
     * @returns the immutable copy of the Json
     */
    static deepCopy(json) {
        json;
        throw new Error("Macro");
    }
    /**
     * Creates a mutable deep copy of the Json.
     *
     * @macro JSON.parse(JSON.stringify($args$))
     *
     * @param json to copy
     * @returns the mutable copy of the Json
     */
    static deepCopyMut(json) {
        json;
        throw new Error("Macro");
    }
    /**
     * Parse a string into a Json
     *
     * @macro JSON.parse($args$)
     *
     * @param str to parse as Json
     * @returns Json representation of the string
     */
    static parse(str) {
        str;
        throw new Error("Macro");
    }
    /**
     * Try to parse a string into a Json
     *
     * @macro ((args) => { try { return (args === undefined) ? undefined : JSON.parse(args); } catch (err) { return undefined; } })($args$)
     *
     * @param str to parse as Json
     * @returns Json representation of the string or undefined if string is not parsable
     */
    static tryParse(str) {
        str;
        throw new Error("Macro");
    }
    constructor() { }
    /**
     * Checks if a Json object has a given key
     *
     * @macro ((obj, key) => { return obj.hasOwnProperty(key); })($self$,$args$)
     *
     * @param key The key to check
     * @returns Boolean value corresponding to whether the key exists
     */
    has(key) {
        key;
        throw new Error("Macro");
    }
    /**
     * Returns the value associated with the specified Json key
     *
     * @macro ((obj, args) => { if (obj[args] === undefined) throw new Error(`Json property "${args}" does not exist`); return obj[args] })($self$, $args$)
     *
     * @param key The key of the Json property
     * @returns The value associated with the specified Json key
     * @throws Json property does not exist if the given key is not part of an existing property
     */
    get(key) {
        key;
        throw new Error("Macro");
    }
    /**
     * Returns a specified element at a given index from Json Array
     *
     * @macro ((obj, args) => { if (obj[args] === undefined) throw new Error("Index out of bounds"); return obj[args] })($self$, $args$)
     *
     * @param index The index of the element in the Json Array to return
     * @returns The element at given index in Json Array
     * @throws index out of bounds error if the given index does not exist for the Json Array
     */
    getAt(index) {
        index;
        throw new Error("Macro");
    }
    /**
     * Optionally returns an specified element from the Json.
     *
     * @macro ($self$)?.[$args$]
     *
     * @param key The key of the element to return
     * @returns The element associated with the specified key, or undefined if the key can't be found
     */
    tryGet(key) {
        key;
        throw new Error("Macro");
    }
    /**
     * Optionally returns a specified element at a given index from Json Array
     *
     * @macro ($self$)?.[$args$]
     *
     * @param index The index of the element in the Json Array to return
     * @returns The element at given index in Json Array, or undefined if index is not valid
     */
    tryGetAt(index) {
        index;
        throw new Error("Macro");
    }
    /**
     * Convert Json element to string if possible.
     *
     * @macro ((arg) => { if (typeof arg !== "string") {throw new Error("unable to parse " + typeof arg + " " + arg + " as a string")}; return JSON.parse(JSON.stringify(arg)) })($self$)
     *
     * @returns a string.
     */
    asStr() {
        throw new Error("Macro");
    }
    /**
     * Convert Json element to string if possible.
     *
     * @macro ((arg) => { return (typeof arg === "string") ? JSON.parse(JSON.stringify(arg)) : undefined })($self$)
     *
     * @returns a string.
     */
    tryAsStr() {
        throw new Error("Macro");
    }
    /**
     * Convert Json element to number if possible.
     *
     * @macro ((arg) => { if (typeof arg !== "number") {throw new Error("unable to parse " + typeof arg + " " + arg + " as a number")}; return JSON.parse(JSON.stringify(arg)) })($self$)
     *
     * @returns a number.
     */
    asNum() {
        throw new Error("Macro");
    }
    /**
     * Convert Json element to number if possible.
     *
     * @macro ((arg) => { return (typeof arg === "number") ? JSON.parse(JSON.stringify(arg)) : undefined })($self$)
     *
     * @returns a number.
     */
    tryAsNum() {
        throw new Error("Macro");
    }
    /**
     * Convert Json element to boolean if possible.
     *
     * @macro ((arg) => { if (typeof arg !== "boolean") {throw new Error("unable to parse " + typeof arg + " " + arg + " as a boolean")}; return JSON.parse(JSON.stringify(arg)) })($self$)
     *
     * @returns a boolean.
     */
    asBool() {
        throw new Error("Macro");
    }
    /**
     * Convert Json element to boolean if possible.
     *
     * @macro ((arg) => { return (typeof arg === "boolean") ? JSON.parse(JSON.stringify(arg)) : undefined })($self$)
     *
     * @returns a boolean.
     */
    tryAsBool() {
        throw new Error("Macro");
    }
}
exports.Json = Json;
_a = JSII_RTTI_SYMBOL_1;
Json[_a] = { fqn: "@winglang/sdk.std.Json", version: "0.0.0" };
/**
 * Mutable Json
 */
class MutJson {
    /**
     * @internal
     */
    static _toInflightType() {
        return core_1.InflightClient.forType(__filename, this.name);
    }
    constructor() { }
    /**
     * Returns the value associated with the specified Json key
     *
     * @macro ((obj, args) => { if (obj[args] === undefined) throw new Error(`Json property "${args}" does not exist`); return obj[args] })($self$, $args$)
     *
     * @param key The key of the Json property
     * @returns The value associated with the specified Json key
     * @throws Json property does not exist if the given key is not part of an existing property
     */
    get(key) {
        key;
        throw new Error("Macro");
    }
    /**
     * Returns a specified element at a given index from MutJson Array
     *
     * @macro ((obj, args) => { if (obj[args] === undefined) throw new Error("Index out of bounds"); return obj[args] })($self$, $args$)
     *
     * @param index The index of the element in the MutJson Array to return
     * @returns The element at given index in MutJson Array
     * @throws index out of bounds error if the given index does not exist for the MutJson Array
     */
    getAt(index) {
        index;
        throw new Error("Macro");
    }
    /**
     * Adds or updates an element in MutJson with a specific key and value
     *
     * @macro ((obj, key, value) => { obj[key] = value; })($self$, $args$)
     *
     * @param key The key of the element to add
     * @param value The value of the element to add
     */
    set(key, value) {
        key;
        value;
        throw new Error("Macro");
    }
    /**
     * Set element in MutJson Array with a specific key and value
     *
     * @macro ((obj, idx, value) => { obj[idx] = value; })($self$, $args$)
     *
     * @param value The value of the element to set
     */
    setAt(index, value) {
        index;
        value;
        throw new Error("Macro");
    }
    /**
     * Optionally returns an specified element from the Json.
     *
     * @macro ($self$)?.[$args$]
     *
     * @param key The key of the element to return
     * @returns The element associated with the specified key, or undefined if the key can't be found
     */
    tryGet(key) {
        key;
        throw new Error("Macro");
    }
    /**
     * Optionally returns a specified element at a given index from Json Array
     *
     * @macro ($self$)?.[$args$]
     *
     * @param index The index of the element in the Json Array to return
     * @returns The element at given index in Json Array, or undefined if index is not valid
     */
    tryGetAt(index) {
        index;
        throw new Error("Macro");
    }
    /**
     * Convert Json element to string if possible.
     *
     * @macro ((arg) => { if (typeof arg !== "string") {throw new Error("unable to parse " + typeof arg + " " + arg + " as a string")}; return JSON.parse(JSON.stringify(arg)) })($self$)
     *
     * @returns a string.
     */
    asStr() {
        throw new Error("Macro");
    }
    /**
     * Convert Json element to string if possible.
     *
     * @macro ((arg) => { return (typeof arg === "string") ? JSON.parse(JSON.stringify(arg)) : undefined })($self$)
     *
     * @returns a string.
     */
    tryAsStr() {
        throw new Error("Macro");
    }
    /**
     * Convert Json element to number if possible.
     *
     * @macro ((arg) => { if (typeof arg !== "number") {throw new Error("unable to parse " + typeof arg + " " + arg + " as a number")}; return JSON.parse(JSON.stringify(arg)) })($self$)
     *
     * @returns a number.
     */
    asNum() {
        throw new Error("Macro");
    }
    /**
     * Convert Json element to number if possible.
     *
     * @macro ((arg) => { return (typeof arg === "number") ? JSON.parse(JSON.stringify(arg)) : undefined })($self$)
     *
     * @returns a number.
     */
    tryAsNum() {
        throw new Error("Macro");
    }
    /**
     * Convert Json element to boolean if possible.
     *
     * @macro ((arg) => { if (typeof arg !== "boolean") {throw new Error("unable to parse " + typeof arg + " " + arg + " as a boolean")}; return JSON.parse(JSON.stringify(arg)) })($self$)
     *
     * @returns a boolean.
     */
    asBool() {
        throw new Error("Macro");
    }
    /**
     * Convert Json element to boolean if possible.
     *
     * @macro ((arg) => { return (typeof arg === "boolean") ? JSON.parse(JSON.stringify(arg)) : undefined })($self$)
     *
     * @returns a boolean.
     */
    tryAsBool() {
        throw new Error("Macro");
    }
    /**
     * Removes the specified element from a map.
     *
     * @macro (delete ($self$)[$args$])
     *
     * @param key The key
     * @returns true if the given key is no longer present
     */
    delete(key) {
        key;
        throw new Error("Macro");
    }
    /**
     * Checks if a Json object has a given key
     *
     * @macro ((obj, key) => { return obj.hasOwnProperty(key); })($self$,$args$)
     *
     * @param key The key to check
     * @returns Boolean value corresponding to whether the key exists
     */
    has(key) {
        key;
        throw new Error("Macro");
    }
}
exports.MutJson = MutJson;
_b = JSII_RTTI_SYMBOL_1;
MutJson[_b] = { fqn: "@winglang/sdk.std.MutJson", version: "0.0.0" };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoianNvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zdGQvanNvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLGtDQUF5QztBQTRCekM7O0dBRUc7QUFDSCxNQUFhLElBQUk7SUFDZjs7T0FFRztJQUNJLE1BQU0sQ0FBQyxlQUFlO1FBQzNCLE9BQU8scUJBQWMsQ0FBQyxPQUFPLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN2RCxDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNJLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBb0I7UUFDckMsSUFBSSxDQUFDO1FBQ0wsTUFBTSxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUMzQixDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNJLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBVTtRQUM3QixJQUFJLENBQUM7UUFDTCxNQUFNLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQzNCLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNJLE1BQU0sQ0FBQyxPQUFPLENBQUMsSUFBVTtRQUM5QixPQUFPLE1BQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3RFLENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0ksTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFhLEVBQUUsR0FBVztRQUM3QyxJQUFJLENBQUM7UUFDTCxHQUFHLENBQUM7UUFDSixNQUFNLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQzNCLENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0ksTUFBTSxDQUFDLFNBQVMsQ0FDckIsSUFBb0IsRUFDcEIsT0FBOEI7UUFFOUIsSUFBSSxDQUFD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QUMsT0FBTyxDQUFDLENBQUM7SUFDM0IsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNJLFNBQVM7UUFDZCxNQUFNLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQzNCLENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBRUksTUFBTSxDQUFDLEdBQVc7UUFDdkIsR0FBRyxDQUFDO1FBQ0osTUFBTSxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUMzQixDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNJLEdBQUcsQ0FBQyxHQUFXO1FBQ3BCLEdBQUcsQ0FBQztRQUNKLE1BQU0sSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDM0IsQ0FBQzs7QUF0TEgsMEJBdUxDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5mbGlnaHRDbGllbnQgfSBmcm9tIFwiLi4vY29yZVwiO1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIHN0cmluZ2lmeSgpIG1ldGhvZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBKc29uU3RyaW5naWZ5T3B0aW9ucyB7XG4gIC8qKiBJbmRlbnRhdGlvbiBzcGFjZXMgbnVtYmVyICovXG4gIHJlYWRvbmx5IGluZGVudDogbnVtYmVyO1xufVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIHZhbGlkYXRpbmcgSnNvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIEpzb25WYWxpZGF0aW9uT3B0aW9ucyB7XG4gIC8qKiBVbnNhZmUgbW9kZSB0byBza2lwIHZhbGlkYXRpb24gKG1heSBsZWFkIHRvIHJ1bnRpbWUgZXJyb3JzKSAqL1xuICByZWFkb25seSB1bnNhZmU/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIEpzb24gZW50cnkgcmVwcmVzZW50YXRpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBKc29uRW50cnkge1xuICAvKiogVGhlIGVudHJ5IGtleSAqL1xuICByZWFkb25seSBrZXk6IHN0cmluZztcbiAgLyoqIFRoZSBlbnRyeSB2YWx1ZSAqL1xuICByZWFkb25seSB2YWx1ZTogSnNvbjtcbn1cblxuLyoqXG4gKiBJbW11dGFibGUgSnNvblxuICovXG5leHBvcnQgY2xhc3MgSnNvbiB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgX3RvSW5mbGlnaHRUeXBlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIEluZmxpZ2h0Q2xpZW50LmZvclR5cGUoX19maWxlbmFtZSwgdGhpcy5uYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBrZXlzIGZyb20gdGhlIEpzb24uXG4gICAqXG4gICAqIEBtYWNybyBPYmplY3Qua2V5cygkYXJncyQpXG4gICAqXG4gICAqIEBwYXJhbSBqc29uIG1hcCB0byBnZXQgdGhlIGtleXMgZnJvbVxuICAgKiBAcmV0dXJucyB0aGUga2V5cyBhcyBBcnJheTxTdHJpbmc+XG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGtleXMoanNvbjogSnNvbiB8IE11dEpzb24pOiBzdHJpbmdbXSB7XG4gICAganNvbjtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWNyb1wiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB2YWx1ZXMgZnJvbSB0aGUgSnNvbi5cbiAgICpcbiAgICogQG1hY3JvIE9iamVjdC52YWx1ZXMoJGFyZ3MkKVxuICAgKlxuICAgKiBAcGFyYW0ganNvbiBtYXAgdG8gZ2V0IHRoZSB2YWx1ZXMgZnJvbVxuICAgKiBAcmV0dXJucyB0aGUgdmFsdWVzIGFzIEFycmF5PEpzb24+XG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHZhbHVlcyhqc29uOiBKc29uKTogSnNvbltdIHtcbiAgICBqc29uO1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1hY3JvXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVudHJpZXMgZnJvbSB0aGUgSnNvbi5cbiAgICpcbiAgICogQHBhcmFtIGpzb24gbWFwIHRvIGdldCB0aGUgZW50cmllcyBmcm9tXG4gICAqIEByZXR1cm5zIHRoZSBlbnRyaWVzIGFzIEFycmF5PEpzb25FbnRyeT5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZW50cmllcyhqc29uOiBKc29uKTogSnNvbkVudHJ5W10ge1xuICAgIHJldHVybiBPYmplY3QuZW50cmllcyhqc29uKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gKHsga2V5LCB2YWx1ZSB9KSk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyBhIGtleSBpbiBhIGdpdmVuIEpzb25cbiAgICpcbiAgICogQG1hY3JvICgoanNvbiwga2V5KSA9PiB7IGRlbGV0ZSBqc29uW2tleV07IH0pKCRhcmdzJClcbiAgICpcbiAgICogQHBhcmFtIGpzb24gdG8gZGVsZXRlIGtleSBmcm9tXG4gICAqIEBwYXJhbSBrZXkgdGhlIGtleSB0byBkZWxldGVcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZGVsZXRlKGpzb246IE11dEpzb24sIGtleTogc3RyaW5nKTogdm9pZCB7XG4gICAganNvbjtcbiAgICBrZXk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWFjcm9cIik7XG4gIH1cblxuICAvKipcbiAgICogRm9ybWF0cyBKc29uIGFzIHN0cmluZ1xuICAgKlxuICAgKiBAbWFjcm8gKChqc29uLCBvcHRzKSA9PiB7IHJldHVybiBKU09OLnN0cmluZ2lmeShqc29uLCBudWxsLCBvcHRzPy5pbmRlbnQpIH0pKCRhcmdzJClcbiAgICpcbiAgICogQHBhcmFtIGpzb24gdG8gZm9ybWF0IGFzIHN0cmluZ1xuICAgKiBAcmV0dXJucyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIEpzb25cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgc3RyaW5naWZ5KFxuICAgIGpzb246IEpzb24gfCBNdXRKc29uLFxuICAgIG9wdGlvbnM/OiBKc29uU3RyaW5naWZ5T3B0aW9uc1xuICApOiBzdHJpbmcge1xuICAgIGpzb247XG4gICAgb3B0aW9ucztcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWNyb1wiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGltbXV0YWJsZSBkZWVwIGNvcHkgb2YgdGhlIEpzb24uXG4gICAqXG4gICAqIEBtYWNybyBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KCRhcmdzJCkpXG4gICAqXG4gICAqIEBwYXJhbSBqc29uIHRvIGNvcHlcbiAgICogQHJldHVybnMgdGhlIGltbXV0YWJsZSBjb3B5IG9mIHRoZSBKc29uXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGRlZXBDb3B5KGpzb246IE11dEpzb24pOiBKc29uIHtcbiAgICBqc29uO1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1hY3JvXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBtdXRhYmxlIGRlZXAgY29weSBvZiB0aGUgSnNvbi5cbiAgICpcbiAgICogQG1hY3JvIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoJGFyZ3MkKSlcbiAgICpcbiAgICogQHBhcmFtIGpzb24gdG8gY29weVxuICAgKiBAcmV0dXJucyB0aGUgbXV0YWJsZSBjb3B5IG9mIHRoZSBKc29uXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGRlZXBDb3B5TXV0KGpzb246IEpzb24pOiBNdXRKc29uIHtcbiAgICBqc29uO1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1hY3JvXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGEgc3RyaW5nIGludG8gYSBKc29uXG4gICAqXG4gICAqIEBtYWNybyBKU09OLnBhcnNlKCRhcmdzJClcbiAgICpcbiAgICogQHBhcmFtIHN0ciB0byBwYXJzZSBhcyBKc29uXG4gICAqIEByZXR1cm5zIEpzb24gcmVwcmVzZW50YXRpb24gb2YgdGhlIHN0cmluZ1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBwYXJzZShzdHI6IHN0cmluZyk6IEpzb24ge1xuICAgIHN0cjtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWNyb1wiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcnkgdG8gcGFyc2UgYSBzdHJpbmcgaW50byBhIEpzb25cbiAgICpcbiAgICogQG1hY3JvICgoYXJncykgPT4geyB0cnkgeyByZXR1cm4gKGFyZ3MgPT09IHVuZGVmaW5lZCkgPyB1bmRlZmluZWQgOiBKU09OLnBhcnNlKGFyZ3MpOyB9IGNhdGNoIChlcnIpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSB9KSgkYXJncyQpXG4gICAqXG4gICAqIEBwYXJhbSBzdHIgdG8gcGFyc2UgYXMgSnNvblxuICAgKiBAcmV0dXJucyBKc29uIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzdHJpbmcgb3IgdW5kZWZpbmVkIGlmIHN0cmluZyBpcyBub3QgcGFyc2FibGVcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgdHJ5UGFyc2Uoc3RyPzogc3RyaW5nKTogSnNvbiB8IHVuZGVmaW5lZCB7XG4gICAgc3RyO1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1hY3JvXCIpO1xuICB9XG4gIHByaXZhdGUgY29uc3RydWN0b3IoKSB7fVxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgSnNvbiBvYmplY3QgaGFzIGEgZ2l2ZW4ga2V5XG4gICAqXG4gICAqIEBtYWNybyAoKG9iaiwga2V5KSA9PiB7IHJldHVybiBvYmouaGFzT3duUHJvcGVydHkoa2V5KTsgfSkoJHNlbGYkLCRhcmdzJClcbiAgICpcbiAgICogQHBhcmFtIGtleSBUaGUga2V5IHRvIGNoZWNrXG4gICAqIEByZXR1cm5zIEJvb2xlYW4gdmFsdWUgY29ycmVzcG9uZGluZyB0byB3aGV0aGVyIHRoZSBrZXkgZXhpc3RzXG4gICAqL1xuICBwdWJsaWMgaGFzKGtleTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAga2V5O1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1hY3JvXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIEpzb24ga2V5XG4gICAqXG4gICAqIEBtYWNybyAoKG9iaiwgYXJncykgPT4geyBpZiAob2JqW2FyZ3NdID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihgSnNvbiBwcm9wZXJ0eSBcIiR7YXJnc31cIiBkb2VzIG5vdCBleGlzdGApOyByZXR1cm4gb2JqW2FyZ3NdIH0pKCRzZWxmJCwgJGFyZ3MkKVxuICAgKlxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIEpzb24gcHJvcGVydHlcbiAgICogQHJldHVybnMgVGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIEpzb24ga2V5XG4gICAqIEB0aHJvd3MgSnNvbiBwcm9wZXJ0eSBkb2VzIG5vdCBleGlzdCBpZiB0aGUgZ2l2ZW4ga2V5IGlzIG5vdCBwYXJ0IG9mIGFuIGV4aXN0aW5nIHByb3BlcnR5XG4gICAqL1xuICBwdWJsaWMgZ2V0KGtleTogc3RyaW5nKTogSnNvbiB7XG4gICAga2V5O1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1hY3JvXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzcGVjaWZpZWQgZWxlbWVudCBhdCBhIGdpdmVuIGluZGV4IGZyb20gSnNvbiBBcnJheVxuICAgKlxuICAgKiBAbWFjcm8gKChvYmosIGFyZ3MpID0+IHsgaWYgKG9ialthcmdzXSA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoXCJJbmRleCBvdXQgb2YgYm91bmRzXCIpOyByZXR1cm4gb2JqW2FyZ3NdIH0pKCRzZWxmJCwgJGFyZ3MkKVxuICAgKlxuICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IGluIHRoZSBKc29uIEFycmF5IHRvIHJldHVyblxuICAgKiBAcmV0dXJucyBUaGUgZWxlbWVudCBhdCBnaXZlbiBpbmRleCBpbiBKc29uIEFycmF5XG4gICAqIEB0aHJvd3MgaW5kZXggb3V0IG9mIGJvdW5kcyBlcnJvciBpZiB0aGUgZ2l2ZW4gaW5kZXggZG9lcyBub3QgZXhpc3QgZm9yIHRoZSBKc29uIEFycmF5XG4gICAqL1xuICBwdWJsaWMgZ2V0QXQoaW5kZXg6IG51bWJlcik6IEpzb24ge1xuICAgIGluZGV4O1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1hY3JvXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsbHkgcmV0dXJucyBhbiBzcGVjaWZpZWQgZWxlbWVudCBmcm9tIHRoZSBKc29uLlxuICAgKlxuICAgKiBAbWFjcm8gKCRzZWxmJCk/LlskYXJncyRdXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgZWxlbWVudCB0byByZXR1cm5cbiAgICogQHJldHVybnMgVGhlIGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5LCBvciB1bmRlZmluZWQgaWYgdGhlIGtleSBjYW4ndCBiZSBmb3VuZFxuICAgKi9cbiAgcHVibGljIHRyeUdldChrZXk6IHN0cmluZyk6IEpzb24gfCB1bmRlZmluZWQge1xuICAgIGtleTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWNyb1wiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPcHRpb25hbGx5IHJldHVybnMgYSBzcGVjaWZpZWQgZWxlbWVudCBhdCBhIGdpdmVuIGluZGV4IGZyb20gSnNvbiBBcnJheVxuICAgKlxuICAgKiBAbWFjcm8gKCRzZWxmJCk/LlskYXJncyRdXG4gICAqXG4gICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgaW4gdGhlIEpzb24gQXJyYXkgdG8gcmV0dXJuXG4gICAqIEByZXR1cm5zIFRoZSBlbGVtZW50IGF0IGdpdmVuIGluZGV4IGluIEpzb24gQXJyYXksIG9yIHVuZGVmaW5lZCBpZiBpbmRleCBpcyBub3QgdmFsaWRcbiAgICovXG4gIHB1YmxpYyB0cnlHZXRBdChpbmRleDogbnVtYmVyKTogSnNvbiB8IHVuZGVmaW5lZCB7XG4gICAgaW5kZXg7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWFjcm9cIik7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBKc29uIGVsZW1lbnQgdG8gc3RyaW5nIGlmIHBvc3NpYmxlLlxuICAgKlxuICAgKiBAbWFjcm8gKChhcmcpID0+IHsgaWYgKHR5cGVvZiBhcmcgIT09IFwic3RyaW5nXCIpIHt0aHJvdyBuZXcgRXJyb3IoXCJ1bmFibGUgdG8gcGFyc2UgXCIgKyB0eXBlb2YgYXJnICsgXCIgXCIgKyBhcmcgKyBcIiBhcyBhIHN0cmluZ1wiKX07IHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGFyZykpIH0pKCRzZWxmJClcbiAgICpcbiAgICogQHJldHVybnMgYSBzdHJpbmcuXG4gICAqL1xuICBwdWJsaWMgYXNTdHIoKTogc3RyaW5nIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWNyb1wiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IEpzb24gZWxlbWVudCB0byBzdHJpbmcgaWYgcG9zc2libGUuXG4gICAqXG4gICAqIEBtYWNybyAoKGFyZykgPT4geyByZXR1cm4gKHR5cGVvZiBhcmcgPT09IFwic3RyaW5nXCIpID8gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShhcmcpKSA6IHVuZGVmaW5lZCB9KSgkc2VsZiQpXG4gICAqXG4gICAqIEByZXR1cm5zIGEgc3RyaW5nLlxuICAgKi9cbiAgcHVibGljIHRyeUFzU3RyKCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWFjcm9cIik7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBKc29uIGVsZW1lbnQgdG8gbnVtYmVyIGlmIHBvc3NpYmxlLlxuICAgKlxuICAgKiBAbWFjcm8gKChhcmcpID0+IHsgaWYgKHR5cGVvZiBhcmcgIT09IFwibnVtYmVyXCIpIHt0aHJvdyBuZXcgRXJyb3IoXCJ1bmFibGUgdG8gcGFyc2UgXCIgKyB0eXBlb2YgYXJnICsgXCIgXCIgKyBhcmcgKyBcIiBhcyBhIG51bWJlclwiKX07IHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGFyZykpIH0pKCRzZWxmJClcbiAgICpcbiAgICogQHJldHVybnMgYSBudW1iZXIuXG4gICAqL1xuICBwdWJsaWMgYXNOdW0oKTogbnVtYmVyIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWNyb1wiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IEpzb24gZWxlbWVudCB0byBudW1iZXIgaWYgcG9zc2libGUuXG4gICAqXG4gICAqIEBtYWNybyAoKGFyZykgPT4geyByZXR1cm4gKHR5cGVvZiBhcmcgPT09IFwibnVtYmVyXCIpID8gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShhcmcpKSA6IHVuZGVmaW5lZCB9KSgkc2VsZiQpXG4gICAqXG4gICAqIEByZXR1cm5zIGEgbnVtYmVyLlxuICAgKi9cbiAgcHVibGljIHRyeUFzTnVtKCk6IG51bWJlciB8IHVuZGVmaW5lZCB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWFjcm9cIik7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBKc29uIGVsZW1lbnQgdG8gYm9vbGVhbiBpZiBwb3NzaWJsZS5cbiAgICpcbiAgICogQG1hY3JvICgoYXJnKSA9PiB7IGlmICh0eXBlb2YgYXJnICE9PSBcImJvb2xlYW5cIikge3Rocm93IG5ldyBFcnJvcihcInVuYWJsZSB0byBwYXJzZSBcIiArIHR5cGVvZiBhcmcgKyBcIiBcIiArIGFyZyArIFwiIGFzIGEgYm9vbGVhblwiKX07IHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGFyZykpIH0pKCRzZWxmJClcbiAgICpcbiAgICogQHJldHVybnMgYSBib29sZWFuLlxuICAgKi9cbiAgcHVibGljIGFzQm9vbCgpOiBib29sZWFuIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWNyb1wiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IEpzb24gZWxlbWVudCB0byBib29sZWFuIGlmIHBvc3NpYmxlLlxuICAgKlxuICAgKiBAbWFjcm8gKChhcmcpID0+IHsgcmV0dXJuICh0eXBlb2YgYXJnID09PSBcImJvb2xlYW5cIikgPyBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGFyZykpIDogdW5kZWZpbmVkIH0pKCRzZWxmJClcbiAgICpcbiAgICogQHJldHVybnMgYSBib29sZWFuLlxuICAgKi9cbiAgcHVibGljIHRyeUFzQm9vbCgpOiBib29sZWFuIHwgdW5kZWZpbmVkIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWNyb1wiKTtcbiAgfVxufVxuXG4vKipcbiAqIE11dGFibGUgSnNvblxuICovXG5leHBvcnQgY2xhc3MgTXV0SnNvbiB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgX3RvSW5mbGlnaHRUeXBlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIEluZmxpZ2h0Q2xpZW50LmZvclR5cGUoX19maWxlbmFtZSwgdGhpcy5uYW1lKTtcbiAgfVxuXG4gIHByaXZhdGUgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIHNwZWNpZmllZCBKc29uIGtleVxuICAgKlxuICAgKiBAbWFjcm8gKChvYmosIGFyZ3MpID0+IHsgaWYgKG9ialthcmdzXSA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoYEpzb24gcHJvcGVydHkgXCIke2FyZ3N9XCIgZG9lcyBub3QgZXhpc3RgKTsgcmV0dXJuIG9ialthcmdzXSB9KSgkc2VsZiQsICRhcmdzJClcbiAgICpcbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBKc29uIHByb3BlcnR5XG4gICAqIEByZXR1cm5zIFRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIHNwZWNpZmllZCBKc29uIGtleVxuICAgKiBAdGhyb3dzIEpzb24gcHJvcGVydHkgZG9lcyBub3QgZXhpc3QgaWYgdGhlIGdpdmVuIGtleSBpcyBub3QgcGFydCBvZiBhbiBleGlzdGluZyBwcm9wZXJ0eVxuICAgKi9cbiAgcHVibGljIGdldChrZXk6IHN0cmluZyk6IE11dEpzb24ge1xuICAgIGtleTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWNyb1wiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3BlY2lmaWVkIGVsZW1lbnQgYXQgYSBnaXZlbiBpbmRleCBmcm9tIE11dEpzb24gQXJyYXlcbiAgICpcbiAgICogQG1hY3JvICgob2JqLCBhcmdzKSA9PiB7IGlmIChvYmpbYXJnc10gPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKFwiSW5kZXggb3V0IG9mIGJvdW5kc1wiKTsgcmV0dXJuIG9ialthcmdzXSB9KSgkc2VsZiQsICRhcmdzJClcbiAgICpcbiAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCBpbiB0aGUgTXV0SnNvbiBBcnJheSB0byByZXR1cm5cbiAgICogQHJldHVybnMgVGhlIGVsZW1lbnQgYXQgZ2l2ZW4gaW5kZXggaW4gTXV0SnNvbiBBcnJheVxuICAgKiBAdGhyb3dzIGluZGV4IG91dCBvZiBib3VuZHMgZXJyb3IgaWYgdGhlIGdpdmVuIGluZGV4IGRvZXMgbm90IGV4aXN0IGZvciB0aGUgTXV0SnNvbiBBcnJheVxuICAgKi9cbiAgcHVibGljIGdldEF0KGluZGV4OiBudW1iZXIpOiBNdXRKc29uIHtcbiAgICBpbmRleDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWNyb1wiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIG9yIHVwZGF0ZXMgYW4gZWxlbWVudCBpbiBNdXRKc29uIHdpdGggYSBzcGVjaWZpYyBrZXkgYW5kIHZhbHVlXG4gICAqXG4gICAqIEBtYWNybyAoKG9iaiwga2V5LCB2YWx1ZSkgPT4geyBvYmpba2V5XSA9IHZhbHVlOyB9KSgkc2VsZiQsICRhcmdzJClcbiAgICpcbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBlbGVtZW50IHRvIGFkZFxuICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50IHRvIGFkZFxuICAgKi9cbiAgcHVibGljIHNldChrZXk6IHN0cmluZywgdmFsdWU6IE11dEpzb24pOiB2b2lkIHtcbiAgICBrZXk7XG4gICAgdmFsdWU7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWFjcm9cIik7XG4gIH1cblxuICAvKipcbiAgICogU2V0IGVsZW1lbnQgaW4gTXV0SnNvbiBBcnJheSB3aXRoIGEgc3BlY2lmaWMga2V5IGFuZCB2YWx1ZVxuICAgKlxuICAgKiBAbWFjcm8gKChvYmosIGlkeCwgdmFsdWUpID0+IHsgb2JqW2lkeF0gPSB2YWx1ZTsgfSkoJHNlbGYkLCAkYXJncyQpXG4gICAqXG4gICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQgdG8gc2V0XG4gICAqL1xuICBwdWJsaWMgc2V0QXQoaW5kZXg6IG51bWJlciwgdmFsdWU6IE11dEpzb24pOiB2b2lkIHtcbiAgICBpbmRleDtcbiAgICB2YWx1ZTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWNyb1wiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPcHRpb25hbGx5IHJldHVybnMgYW4gc3BlY2lmaWVkIGVsZW1lbnQgZnJvbSB0aGUgSnNvbi5cbiAgICpcbiAgICogQG1hY3JvICgkc2VsZiQpPy5bJGFyZ3MkXVxuICAgKlxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGVsZW1lbnQgdG8gcmV0dXJuXG4gICAqIEByZXR1cm5zIFRoZSBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSwgb3IgdW5kZWZpbmVkIGlmIHRoZSBrZXkgY2FuJ3QgYmUgZm91bmRcbiAgICovXG4gIHB1YmxpYyB0cnlHZXQoa2V5OiBzdHJpbmcpOiBNdXRKc29uIHwgdW5kZWZpbmVkIHtcbiAgICBrZXk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWFjcm9cIik7XG4gIH1cblxuICAvKipcbiAgICogT3B0aW9uYWxseSByZXR1cm5zIGEgc3BlY2lmaWVkIGVsZW1lbnQgYXQgYSBnaXZlbiBpbmRleCBmcm9tIEpzb24gQXJyYXlcbiAgICpcbiAgICogQG1hY3JvICgkc2VsZiQpPy5bJGFyZ3MkXVxuICAgKlxuICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IGluIHRoZSBKc29uIEFycmF5IHRvIHJldHVyblxuICAgKiBAcmV0dXJucyBUaGUgZWxlbWVudCBhdCBnaXZlbiBpbmRleCBpbiBKc29uIEFycmF5LCBvciB1bmRlZmluZWQgaWYgaW5kZXggaXMgbm90IHZhbGlkXG4gICAqL1xuICBwdWJsaWMgdHJ5R2V0QXQoaW5kZXg6IG51bWJlcik6IE11dEpzb24gfCB1bmRlZmluZWQge1xuICAgIGluZGV4O1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1hY3JvXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgSnNvbiBlbGVtZW50IHRvIHN0cmluZyBpZiBwb3NzaWJsZS5cbiAgICpcbiAgICogQG1hY3JvICgoYXJnKSA9PiB7IGlmICh0eXBlb2YgYXJnICE9PSBcInN0cmluZ1wiKSB7dGhyb3cgbmV3IEVycm9yKFwidW5hYmxlIHRvIHBhcnNlIFwiICsgdHlwZW9mIGFyZyArIFwiIFwiICsgYXJnICsgXCIgYXMgYSBzdHJpbmdcIil9OyByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShhcmcpKSB9KSgkc2VsZiQpXG4gICAqXG4gICAqIEByZXR1cm5zIGEgc3RyaW5nLlxuICAgKi9cbiAgcHVibGljIGFzU3RyKCk6IHN0cmluZyB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWFjcm9cIik7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBKc29uIGVsZW1lbnQgdG8gc3RyaW5nIGlmIHBvc3NpYmxlLlxuICAgKlxuICAgKiBAbWFjcm8gKChhcmcpID0+IHsgcmV0dXJuICh0eXBlb2YgYXJnID09PSBcInN0cmluZ1wiKSA/IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoYXJnKSkgOiB1bmRlZmluZWQgfSkoJHNlbGYkKVxuICAgKlxuICAgKiBAcmV0dXJucyBhIHN0cmluZy5cbiAgICovXG4gIHB1YmxpYyB0cnlBc1N0cigpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1hY3JvXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgSnNvbiBlbGVtZW50IHRvIG51bWJlciBpZiBwb3NzaWJsZS5cbiAgICpcbiAgICogQG1hY3JvICgoYXJnKSA9PiB7IGlmICh0eXBlb2YgYXJnICE9PSBcIm51bWJlclwiKSB7dGhyb3cgbmV3IEVycm9yKFwidW5hYmxlIHRvIHBhcnNlIFwiICsgdHlwZW9mIGFyZyArIFwiIFwiICsgYXJnICsgXCIgYXMgYSBudW1iZXJcIil9OyByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShhcmcpKSB9KSgkc2VsZiQpXG4gICAqXG4gICAqIEByZXR1cm5zIGEgbnVtYmVyLlxuICAgKi9cbiAgcHVibGljIGFzTnVtKCk6IG51bWJlciB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWFjcm9cIik7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBKc29uIGVsZW1lbnQgdG8gbnVtYmVyIGlmIHBvc3NpYmxlLlxuICAgKlxuICAgKiBAbWFjcm8gKChhcmcpID0+IHsgcmV0dXJuICh0eXBlb2YgYXJnID09PSBcIm51bWJlclwiKSA/IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoYXJnKSkgOiB1bmRlZmluZWQgfSkoJHNlbGYkKVxuICAgKlxuICAgKiBAcmV0dXJucyBhIG51bWJlci5cbiAgICovXG4gIHB1YmxpYyB0cnlBc051bSgpOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1hY3JvXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgSnNvbiBlbGVtZW50IHRvIGJvb2xlYW4gaWYgcG9zc2libGUuXG4gICAqXG4gICAqIEBtYWNybyAoKGFyZykgPT4geyBpZiAodHlwZW9mIGFyZyAhPT0gXCJib29sZWFuXCIpIHt0aHJvdyBuZXcgRXJyb3IoXCJ1bmFibGUgdG8gcGFyc2UgXCIgKyB0eXBlb2YgYXJnICsgXCIgXCIgKyBhcmcgKyBcIiBhcyBhIGJvb2xlYW5cIil9OyByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShhcmcpKSB9KSgkc2VsZiQpXG4gICAqXG4gICAqIEByZXR1cm5zIGEgYm9vbGVhbi5cbiAgICovXG4gIHB1YmxpYyBhc0Jvb2woKTogYm9vbGVhbiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWFjcm9cIik7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBKc29uIGVsZW1lbnQgdG8gYm9vbGVhbiBpZiBwb3NzaWJsZS5cbiAgICpcbiAgICogQG1hY3JvICgoYXJnKSA9PiB7IHJldHVybiAodHlwZW9mIGFyZyA9PT0gXCJib29sZWFuXCIpID8gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShhcmcpKSA6IHVuZGVmaW5lZCB9KSgkc2VsZiQpXG4gICAqXG4gICAqIEByZXR1cm5zIGEgYm9vbGVhbi5cbiAgICovXG4gIHB1YmxpYyB0cnlBc0Jvb2woKTogYm9vbGVhbiB8IHVuZGVmaW5lZCB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWFjcm9cIik7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgc3BlY2lmaWVkIGVsZW1lbnQgZnJvbSBhIG1hcC5cbiAgICpcbiAgICogQG1hY3JvIChkZWxldGUgKCRzZWxmJClbJGFyZ3MkXSlcbiAgICpcbiAgICogQHBhcmFtIGtleSBUaGUga2V5XG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGtleSBpcyBubyBsb25nZXIgcHJlc2VudFxuICAgKi9cblxuICBwdWJsaWMgZGVsZXRlKGtleTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAga2V5O1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1hY3JvXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIEpzb24gb2JqZWN0IGhhcyBhIGdpdmVuIGtleVxuICAgKlxuICAgKiBAbWFjcm8gKChvYmosIGtleSkgPT4geyByZXR1cm4gb2JqLmhhc093blByb3BlcnR5KGtleSk7IH0pKCRzZWxmJCwkYXJncyQpXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byBjaGVja1xuICAgKiBAcmV0dXJucyBCb29sZWFuIHZhbHVlIGNvcnJlc3BvbmRpbmcgdG8gd2hldGhlciB0aGUga2V5IGV4aXN0c1xuICAgKi9cbiAgcHVibGljIGhhcyhrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGtleTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWNyb1wiKTtcbiAgfVxufVxuIl19