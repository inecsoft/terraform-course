"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Util = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const strict_1 = __importStar(require("node:assert/strict"));
const core_1 = require("../core");
const std_1 = require("../std");
/**
 * The Util class provides methods for making assertions in tests,
 * such as comparing two strings for equality with rich error messages.
 * @inflight
 */
class Util {
    /**
     * @internal
     */
    static _toInflightType() {
        return core_1.InflightClient.forType(__filename, this.name);
    }
    /**
     * Compares two values for equality.
     * @param expected The expected value.
     * @param actual The value to test.
     * @throws Will throw an error if the actual value does not match the expected value.
     * @returns void
     */
    static equal(actual, expected) {
        strict_1.default.deepStrictEqual(actual, expected);
    }
    /**
     * Compares two values for inequality.
     * @param expected The expected value.
     * @param actual The value to test.
     * @throws Will throw an error if the actual value matches the expected value.
     * @returns void
     */
    static notEqual(actual, expected) {
        strict_1.default.notDeepStrictEqual(actual, expected);
    }
    /**
     * Checks if a value is nil.
     * @param actual The value to test.
     * @throws Will throw an error if the actual value is not nil.
     * @returns void
     */
    static nil(actual) {
        strict_1.default.ok(actual === null || actual === undefined, `Expected "${actual}" to be nil`);
    }
    /**
     * Checks if a value is not nil.
     * @param actual The value to test.
     * @throws Will throw an error if the actual value is nil.
     * @returns void
     */
    static notNil(actual) {
        strict_1.default.ok(actual !== null && actual !== undefined, `Expected "${actual}" to be not nil`);
    }
    /**
     * Checks if a string matches a regular expression pattern.
     * @param actual The string to test.
     * @param expected The regular expression pattern to match against.
     * @throws Will throw an error if the actual value does not match the expected regular expression pattern.
     * @returns void
     */
    static match(actual, expected) {
        const regex = std_1.Regex.compile(expected);
        const matches = regex.test(actual);
        if (!matches) {
            throw new strict_1.AssertionError({
                message: `The input did not match the regular expression ${expected}`,
            });
        }
    }
    /**
     * Checks if a string does not match a regular expression pattern.
     * @param actual The string to test.
     * @param expected The regular expression pattern to check against.
     * @throws Will throw an error if the actual value matches the expected regular expression pattern.
     * @returns void
     */
    static doesNotMatch(actual, expected) {
        const regex = std_1.Regex.compile(expected);
        const matches = regex.test(actual);
        if (matches) {
            throw new strict_1.AssertionError({
                message: `The input should not match the regular expression ${expected}`,
            });
        }
    }
    /**
     * Marks a test as failed.
     * @param message An optional message to include with the failure.
     * @throws Always throws an error with the provided message.
     * @returns void
     */
    static fail(message) {
        strict_1.default.fail(message);
    }
    /**
     * Asserts that a condition is truthy.
     * @param condition The condition to test.
     * @param message An optional message to include if the condition is falsy.
     * @throws Will throw an error if the condition is falsy.
     * @returns void
     */
    static ok(condition, message) {
        strict_1.default.ok(condition, message);
    }
    constructor() { }
}
exports.Util = Util;
_a = JSII_RTTI_SYMBOL_1;
Util[_a] = { fqn: "@winglang/sdk.expect.Util", version: "0.0.0" };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhwZWN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2V4cGVjdC9leHBlY3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDZEQUFnRTtBQUNoRSxrQ0FBeUM7QUFDekMsZ0NBQStCO0FBRS9COzs7O0dBSUc7QUFDSCxNQUFhLElBQUk7SUFDZjs7T0FFRztJQUNJLE1BQU0sQ0FBQyxlQUFlO1FBQzNCLE9BQU8scUJBQWMsQ0FBQyxPQUFPLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN2RCxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ksTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFlLEVBQUUsUUFBaUI7UUFDcEQsZ0JBQVUsQ0FBQyxlQUFlLENBQUMsTUFBTSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQy9DLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSSxNQUFNLENBQUMsUUFBUSxDQUFDLE1BQWUsRUFBRSxRQUFpQjtRQUN2RCxnQkFBVSxDQUFDLGtCQUFrQixDQUFDLE1BQU0sRUFBRSxRQUFRLENBQUMsQ0FBQztJQUNsRCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxNQUFNLENBQUMsR0FBRyxDQUFDLE1BQWU7UUFDL0IsZ0JBQVUsQ0FBQyxFQUFFLENBQ1gsTUFBTSxLQUFLLElBQUksSUFBSSxNQUFNLEtBQUssU0FBUyxFQUN2QyxhQUFhLE1BQU0sYUFBYSxDQUNqQyxDQUFDO0lBQ0osQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0ksTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFlO1FBQ2xDLGdCQUFVLENBQUMsRUFBRSxDQUNYLE1BQU0sS0FBSyxJQUFJLElBQUksTUFBTSxLQUFLLFNBQVMsRUFDdkMsYUFBYSxNQUFNLGlCQUFpQixDQUNyQyxDQUFDO0lBQ0osQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNJLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBYyxFQUFFLFFBQWdCO1FBQ2xELE1BQU0sS0FBSyxHQUFHLFdBQUssQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDdEMsTUFBTSxPQUFPLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUNuQyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDYixNQUFNLElBQUksdUJBQWMsQ0FBQztnQkFDdkIsT0FBTyxFQUFFLGtEQUFrRCxRQUFRLEVBQUU7YUFDdEUsQ0FBQyxDQUFDO1FBQ0wsQ0FBQztJQUNILENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSSxNQUFNLENBQUMsWUFBWSxDQUFDLE1BQWMsRUFBRSxRQUFnQjtRQUN6RCxNQUFNLEtBQUssR0FBRyxXQUFLLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ3RDLE1BQU0sT0FBTyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDbkMsSUFBSSxPQUFPLEVBQUUsQ0FBQztZQUNaLE1BQU0sSUFBSSx1QkFBYyxDQUFDO2dCQUN2QixPQUFPLEVBQUUscURBQXFELFFBQVEsRUFBRTthQUN6RSxDQUFDLENBQUM7UUFDTCxDQUFDO0lBQ0gsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0ksTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFnQjtRQUNqQyxnQkFBVSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUMzQixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ksTUFBTSxDQUFDLEVBQUUsQ0FBQyxTQUFrQixFQUFFLE9BQWdCO1FBQ25ELGdCQUFVLENBQUMsRUFBRSxDQUFDLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUNwQyxDQUFDO0lBRUQsZ0JBQXVCLENBQUM7O0FBL0cxQixvQkFnSEMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbm9kZUFzc2VydCwgeyBBc3NlcnRpb25FcnJvciB9IGZyb20gXCJub2RlOmFzc2VydC9zdHJpY3RcIjtcbmltcG9ydCB7IEluZmxpZ2h0Q2xpZW50IH0gZnJvbSBcIi4uL2NvcmVcIjtcbmltcG9ydCB7IFJlZ2V4IH0gZnJvbSBcIi4uL3N0ZFwiO1xuXG4vKipcbiAqIFRoZSBVdGlsIGNsYXNzIHByb3ZpZGVzIG1ldGhvZHMgZm9yIG1ha2luZyBhc3NlcnRpb25zIGluIHRlc3RzLFxuICogc3VjaCBhcyBjb21wYXJpbmcgdHdvIHN0cmluZ3MgZm9yIGVxdWFsaXR5IHdpdGggcmljaCBlcnJvciBtZXNzYWdlcy5cbiAqIEBpbmZsaWdodFxuICovXG5leHBvcnQgY2xhc3MgVXRpbCB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgX3RvSW5mbGlnaHRUeXBlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIEluZmxpZ2h0Q2xpZW50LmZvclR5cGUoX19maWxlbmFtZSwgdGhpcy5uYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wYXJlcyB0d28gdmFsdWVzIGZvciBlcXVhbGl0eS5cbiAgICogQHBhcmFtIGV4cGVjdGVkIFRoZSBleHBlY3RlZCB2YWx1ZS5cbiAgICogQHBhcmFtIGFjdHVhbCBUaGUgdmFsdWUgdG8gdGVzdC5cbiAgICogQHRocm93cyBXaWxsIHRocm93IGFuIGVycm9yIGlmIHRoZSBhY3R1YWwgdmFsdWUgZG9lcyBub3QgbWF0Y2ggdGhlIGV4cGVjdGVkIHZhbHVlLlxuICAgKiBAcmV0dXJucyB2b2lkXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGVxdWFsKGFjdHVhbDogdW5rbm93biwgZXhwZWN0ZWQ6IHVua25vd24pOiB2b2lkIHtcbiAgICBub2RlQXNzZXJ0LmRlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wYXJlcyB0d28gdmFsdWVzIGZvciBpbmVxdWFsaXR5LlxuICAgKiBAcGFyYW0gZXhwZWN0ZWQgVGhlIGV4cGVjdGVkIHZhbHVlLlxuICAgKiBAcGFyYW0gYWN0dWFsIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICAgKiBAdGhyb3dzIFdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGFjdHVhbCB2YWx1ZSBtYXRjaGVzIHRoZSBleHBlY3RlZCB2YWx1ZS5cbiAgICogQHJldHVybnMgdm9pZFxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBub3RFcXVhbChhY3R1YWw6IHVua25vd24sIGV4cGVjdGVkOiB1bmtub3duKTogdm9pZCB7XG4gICAgbm9kZUFzc2VydC5ub3REZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgdmFsdWUgaXMgbmlsLlxuICAgKiBAcGFyYW0gYWN0dWFsIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICAgKiBAdGhyb3dzIFdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGFjdHVhbCB2YWx1ZSBpcyBub3QgbmlsLlxuICAgKiBAcmV0dXJucyB2b2lkXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG5pbChhY3R1YWw6IHVua25vd24pOiB2b2lkIHtcbiAgICBub2RlQXNzZXJ0Lm9rKFxuICAgICAgYWN0dWFsID09PSBudWxsIHx8IGFjdHVhbCA9PT0gdW5kZWZpbmVkLFxuICAgICAgYEV4cGVjdGVkIFwiJHthY3R1YWx9XCIgdG8gYmUgbmlsYFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgdmFsdWUgaXMgbm90IG5pbC5cbiAgICogQHBhcmFtIGFjdHVhbCBUaGUgdmFsdWUgdG8gdGVzdC5cbiAgICogQHRocm93cyBXaWxsIHRocm93IGFuIGVycm9yIGlmIHRoZSBhY3R1YWwgdmFsdWUgaXMgbmlsLlxuICAgKiBAcmV0dXJucyB2b2lkXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG5vdE5pbChhY3R1YWw6IHVua25vd24pOiB2b2lkIHtcbiAgICBub2RlQXNzZXJ0Lm9rKFxuICAgICAgYWN0dWFsICE9PSBudWxsICYmIGFjdHVhbCAhPT0gdW5kZWZpbmVkLFxuICAgICAgYEV4cGVjdGVkIFwiJHthY3R1YWx9XCIgdG8gYmUgbm90IG5pbGBcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIHN0cmluZyBtYXRjaGVzIGEgcmVndWxhciBleHByZXNzaW9uIHBhdHRlcm4uXG4gICAqIEBwYXJhbSBhY3R1YWwgVGhlIHN0cmluZyB0byB0ZXN0LlxuICAgKiBAcGFyYW0gZXhwZWN0ZWQgVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBwYXR0ZXJuIHRvIG1hdGNoIGFnYWluc3QuXG4gICAqIEB0aHJvd3MgV2lsbCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgYWN0dWFsIHZhbHVlIGRvZXMgbm90IG1hdGNoIHRoZSBleHBlY3RlZCByZWd1bGFyIGV4cHJlc3Npb24gcGF0dGVybi5cbiAgICogQHJldHVybnMgdm9pZFxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBtYXRjaChhY3R1YWw6IHN0cmluZywgZXhwZWN0ZWQ6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IHJlZ2V4ID0gUmVnZXguY29tcGlsZShleHBlY3RlZCk7XG4gICAgY29uc3QgbWF0Y2hlcyA9IHJlZ2V4LnRlc3QoYWN0dWFsKTtcbiAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IGBUaGUgaW5wdXQgZGlkIG5vdCBtYXRjaCB0aGUgcmVndWxhciBleHByZXNzaW9uICR7ZXhwZWN0ZWR9YCxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBzdHJpbmcgZG9lcyBub3QgbWF0Y2ggYSByZWd1bGFyIGV4cHJlc3Npb24gcGF0dGVybi5cbiAgICogQHBhcmFtIGFjdHVhbCBUaGUgc3RyaW5nIHRvIHRlc3QuXG4gICAqIEBwYXJhbSBleHBlY3RlZCBUaGUgcmVndWxhciBleHByZXNzaW9uIHBhdHRlcm4gdG8gY2hlY2sgYWdhaW5zdC5cbiAgICogQHRocm93cyBXaWxsIHRocm93IGFuIGVycm9yIGlmIHRoZSBhY3R1YWwgdmFsdWUgbWF0Y2hlcyB0aGUgZXhwZWN0ZWQgcmVndWxhciBleHByZXNzaW9uIHBhdHRlcm4uXG4gICAqIEByZXR1cm5zIHZvaWRcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZG9lc05vdE1hdGNoKGFjdHVhbDogc3RyaW5nLCBleHBlY3RlZDogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc3QgcmVnZXggPSBSZWdleC5jb21waWxlKGV4cGVjdGVkKTtcbiAgICBjb25zdCBtYXRjaGVzID0gcmVnZXgudGVzdChhY3R1YWwpO1xuICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBgVGhlIGlucHV0IHNob3VsZCBub3QgbWF0Y2ggdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiAke2V4cGVjdGVkfWAsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWFya3MgYSB0ZXN0IGFzIGZhaWxlZC5cbiAgICogQHBhcmFtIG1lc3NhZ2UgQW4gb3B0aW9uYWwgbWVzc2FnZSB0byBpbmNsdWRlIHdpdGggdGhlIGZhaWx1cmUuXG4gICAqIEB0aHJvd3MgQWx3YXlzIHRocm93cyBhbiBlcnJvciB3aXRoIHRoZSBwcm92aWRlZCBtZXNzYWdlLlxuICAgKiBAcmV0dXJucyB2b2lkXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGZhaWwobWVzc2FnZT86IHN0cmluZyk6IHZvaWQge1xuICAgIG5vZGVBc3NlcnQuZmFpbChtZXNzYWdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NlcnRzIHRoYXQgYSBjb25kaXRpb24gaXMgdHJ1dGh5LlxuICAgKiBAcGFyYW0gY29uZGl0aW9uIFRoZSBjb25kaXRpb24gdG8gdGVzdC5cbiAgICogQHBhcmFtIG1lc3NhZ2UgQW4gb3B0aW9uYWwgbWVzc2FnZSB0byBpbmNsdWRlIGlmIHRoZSBjb25kaXRpb24gaXMgZmFsc3kuXG4gICAqIEB0aHJvd3MgV2lsbCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgY29uZGl0aW9uIGlzIGZhbHN5LlxuICAgKiBAcmV0dXJucyB2b2lkXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG9rKGNvbmRpdGlvbjogYm9vbGVhbiwgbWVzc2FnZT86IHN0cmluZyk6IHZvaWQge1xuICAgIG5vZGVBc3NlcnQub2soY29uZGl0aW9uLCBtZXNzYWdlKTtcbiAgfVxuXG4gIHByaXZhdGUgY29uc3RydWN0b3IoKSB7fVxufVxuIl19