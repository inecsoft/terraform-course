"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SandboxMultipleConcurrentCallsError = exports.SandboxTimeoutError = exports.Sandbox = void 0;
const cp = __importStar(require("child_process"));
const fs_1 = require("fs");
const promises_1 = require("fs/promises");
const inspector_1 = require("inspector");
const bundling_1 = require("./bundling");
const stream_processor_1 = require("./stream-processor");
const std_1 = require("../std");
class Sandbox {
    static async createBundle(entrypoint, log) {
        let contents = await (0, promises_1.readFile)(entrypoint, "utf-8");
        // log a warning if contents includes __dirname or __filename
        if (contents.includes("__dirname") || contents.includes("__filename")) {
            log?.(`Warning: __dirname and __filename cannot be used within bundled cloud functions. There may be unexpected behavior.`, std_1.LogLevel.WARNING);
        }
        let debugShim = "";
        if ((0, inspector_1.url)?.()) {
            // If we're debugging, we need to make sure the debugger has enough time to attach
            // to the child process. This gives enough time for the debugger load sourcemaps and set breakpoints.
            // See https://github.com/microsoft/vscode-js-debug/issues/1510
            debugShim =
                "\n  await new Promise((resolve) => setTimeout(resolve, 25));";
        }
        // wrap contents with a shim that handles the communication with the parent process
        // we insert this shim before bundling to ensure source maps are generated correctly
        contents += `
process.on("uncaughtException", (reason) => {
  process.send({ type: "error", reason });
});

process.on("message", async (message) => {${debugShim}
  const { fn, args } = message;
  const value = await exports[fn](...args);
  process.send({ type: "ok", value });
});
`;
        const wrappedPath = entrypoint.replace(/\.cjs$/, ".sandbox.cjs");
        (0, fs_1.writeFileSync)(wrappedPath, contents); // async fsPromises.writeFile "flush" option is not available in Node 20
        const bundle = (0, bundling_1.createBundle)(wrappedPath);
        if (process.env.DEBUG) {
            const fileStats = await (0, promises_1.stat)(entrypoint);
            log?.(`Bundled code (${fileStats.size} bytes).`, std_1.LogLevel.VERBOSE);
        }
        return bundle;
    }
    constructor(entrypoint, options = {}) {
        // Tracks whether the sandbox is available to process a new request
        // When call() is called, it sets this to false, and when it's returning
        // a response or error, it sets it back to true.
        this.available = true;
        this.cleaningUp = false;
        this.entrypoint = entrypoint;
        this.options = options;
    }
    async cleanup() {
        this.cleaningUp = true;
        if (this.timeout) {
            clearTimeout(this.timeout);
        }
        else {
        }
        if (this.child) {
            this.debugLog(`Terminating sandbox child process (PID ${this.childPid}).`);
            this.child.kill("SIGTERM");
            this.child = undefined;
            this.available = true;
        }
    }
    isAvailable() {
        return this.available;
    }
    async initialize() {
        const childEnv = this.options.env ?? {};
        if ((0, inspector_1.url)?.()) {
            // We're exposing a debugger, let's attempt to ensure the child process automatically attaches
            childEnv.NODE_OPTIONS =
                (childEnv.NODE_OPTIONS ?? "") + (process.env.NODE_OPTIONS ?? "");
            // If the child process is not already configured to attach a debugger, add a flag to do so
            if (!childEnv.NODE_OPTIONS.includes("--inspect") &&
                !process.execArgv.includes("--inspect")) {
                childEnv.NODE_OPTIONS += " --inspect=0";
            }
            // VSCode's debugger adds some environment variables that we want to pass to the child process
            for (const key in process.env) {
                if (key.startsWith("VSCODE_")) {
                    childEnv[key] = process.env[key];
                }
            }
        }
        // start a Node.js process that runs the inflight code
        // note: unlike the fork(2) POSIX system call, child_process.fork()
        // does not clone the current process
        this.child = cp.fork(this.entrypoint, {
            env: childEnv,
            stdio: "pipe",
            // keep the process detached so in the case of cloud.Service, if the parent process is killed
            // (e.g. someone presses Ctrl+C while using Wing Console),
            // we can gracefully call any cleanup code in the child process
            detached: true,
            // this option allows complex objects like Error to be sent from the child process to the parent
            serialization: "advanced",
        });
        this.childPid = this.child.pid;
        this.debugLog(`Initialized sandbox (PID ${this.childPid}).`);
        const log = (message) => {
            let level = std_1.LogLevel.INFO;
            if (message.startsWith("info:")) {
                message = message.slice(5);
            }
            else if (message.startsWith("error:")) {
                message = message.slice(6);
                level = std_1.LogLevel.ERROR;
            }
            else if (message.startsWith("warning:")) {
                message = message.slice(8);
                level = std_1.LogLevel.WARNING;
            }
            else if (message.startsWith("verbose:")) {
                message = message.slice(8);
                level = std_1.LogLevel.VERBOSE;
            }
            this.options.log?.(false, level, message);
        };
        const logError = (message) => this.options.log?.(false, std_1.LogLevel.ERROR, message);
        // pipe stdout and stderr from the child process
        if (this.child.stdout) {
            (0, stream_processor_1.processStream)(this.child.stdout, log);
        }
        if (this.child.stderr) {
            (0, stream_processor_1.processStream)(this.child.stderr, logError);
        }
        this.child.on("message", (message) => {
            this.onChildMessage?.(message);
        });
        this.child.on("error", (error) => {
            this.onChildError?.(error);
        });
        this.child.on("exit", (code, signal) => {
            this.onChildExit?.(code, signal);
        });
    }
    async call(fn, ...args) {
        if (!this.available) {
            throw new SandboxMultipleConcurrentCallsError();
        }
        // Prevent multiple calls to the same sandbox running concurrently.
        this.available = false;
        // If this sandbox doesn't have a child process running (because it
        // just got created, OR because the previous child process was killed due
        // to timeout or an unexpected error), initialize one.
        if (!this.child) {
            await this.initialize();
        }
        // Send the function name and arguments to the child process.
        // When a message is received, resolve or reject the promise.
        return new Promise((resolve, reject) => {
            this.child.send({ fn, args });
            this.debugLog(`Sent a message to the sandbox (PID ${this.childPid}): ${JSON.stringify({
                fn,
                args,
            })}`);
            this.onChildMessage = (message) => {
                this.debugLog(`Received a message from the sandbox (PID ${this.childPid}): ${JSON.stringify(message)}`);
                this.available = true;
                if (this.timeout) {
                    clearTimeout(this.timeout);
                }
                if (message.type === "ok") {
                    resolve(message.value);
                }
                else if (message.type === "error") {
                    reject(message.reason);
                }
                else {
                    reject(new Error(`Unexpected message from the sandbox (PID ${this.childPid}): ${message}`));
                }
            };
            // "error" could be emitted for any number of reasons
            // (e.g. the process couldn't be spawned or killed, or a message couldn't be sent).
            // Since this is unexpected, we kill the process with SIGKILL to ensure it's dead, and reject the promise.
            this.onChildError = (error) => {
                this.debugLog(`Unexpected error from the sandbox (PID ${this.childPid}).`);
                this.child?.kill("SIGKILL");
                this.child = undefined;
                this.available = true;
                if (this.timeout) {
                    clearTimeout(this.timeout);
                }
                if (this.cleaningUp) {
                    resolve(undefined);
                }
                else {
                    reject(error);
                }
            };
            // "exit" could be emitted if the user code called process.exit(), or if we killed the process
            // due to a timeout or unexpected error. In any case, we reject the promise.
            this.onChildExit = (code, signal) => {
                this.debugLog(`Sandbox (PID ${this.childPid}) stopped.`);
                this.child = undefined;
                this.available = true;
                if (this.timeout) {
                    clearTimeout(this.timeout);
                }
                if (this.cleaningUp) {
                    resolve(undefined);
                }
                else {
                    reject(new Error(`Process exited with code ${code}, signal ${signal}`));
                }
            };
            if (this.options.timeout && !(0, inspector_1.url)?.()) {
                this.timeout = setTimeout(() => {
                    this.debugLog(`Killing sandbox (PID ${this.childPid}) after timeout.`);
                    this.child?.kill("SIGTERM");
                    this.child = undefined;
                    this.available = true;
                    if (this.cleaningUp) {
                        resolve(undefined);
                    }
                    else {
                        reject(new SandboxTimeoutError(this.options.timeout ?? 0));
                    }
                }, this.options.timeout);
            }
        });
    }
    debugLog(message) {
        if (process.env.DEBUG) {
            this.options.log?.(true, std_1.LogLevel.VERBOSE, message);
        }
    }
}
exports.Sandbox = Sandbox;
class SandboxTimeoutError extends Error {
    constructor(timeout) {
        super("Timed out after " + timeout + "ms.");
        this.timeout = timeout;
    }
}
exports.SandboxTimeoutError = SandboxTimeoutError;
class SandboxMultipleConcurrentCallsError extends Error {
    constructor() {
        super("Cannot process multiple requests in parallel.");
    }
}
exports.SandboxMultipleConcurrentCallsError = SandboxMultipleConcurrentCallsError;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2FuZGJveC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zaGFyZWQvc2FuZGJveC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGtEQUFvQztBQUNwQywyQkFBbUM7QUFDbkMsMENBQTZDO0FBQzdDLHlDQUFnRDtBQUNoRCx5Q0FBa0Q7QUFDbEQseURBQW1EO0FBQ25ELGdDQUFrQztBQXFDbEMsTUFBYSxPQUFPO0lBQ1gsTUFBTSxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQzlCLFVBQWtCLEVBQ2xCLEdBQWdEO1FBRWhELElBQUksUUFBUSxHQUFHLE1BQU0sSUFBQSxtQkFBUSxFQUFDLFVBQVUsRUFBRSxPQUFPLENBQUMsQ0FBQztRQUVuRCw2REFBNkQ7UUFDN0QsSUFBSSxRQUFRLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQztZQUN0RSxHQUFHLEVBQUUsQ0FDSCxvSEFBb0gsRUFDcEgsY0FBUSxDQUFDLE9BQU8sQ0FDakIsQ0FBQztRQUNKLENBQUM7UUFFRCxJQUFJLFNBQVMsR0FBRyxFQUFFLENBQUM7UUFDbkIsSUFBSSxJQUFBLGVBQVksQ0FBQSxFQUFFLEVBQUUsRUFBRSxDQUFDO1lBQ3JCLGtGQUFrRjtZQUNsRixxR0FBcUc7WUFDckcsK0RBQStEO1lBQy9ELFNBQVM7Z0JBQ1AsOERBQThELENBQUM7UUFDbkUsQ0FBQztRQUVELG1GQUFtRjtRQUNuRixvRkFBb0Y7UUFDcEYsUUFBUSxJQUFJOzs7Ozs0Q0FLNEIsU0FBUzs7Ozs7Q0FLcEQsQ0FBQztRQUVFLE1BQU0sV0FBVyxHQUFHLFVBQVUsQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLGNBQWMsQ0FBQyxDQUFDO1FBRWpFLElBQUEsa0JBQWEsRUFBQyxXQUFXLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQyx3RUFBd0U7UUFDOUcsTUFBTSxN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QyxPQUFlO1FBQzlCLElBQUksT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsQ0FBQztZQUN0QixJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksRUFBRSxjQUFRLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQ3RELENBQUM7SUFDSCxDQUFDO0NBQ0Y7QUE5UkQsMEJBOFJDO0FBRUQsTUFBYSxtQkFBb0IsU0FBUSxLQUFLO0lBQzVDLFlBQTRCLE9BQWU7UUFDekMsS0FBSyxDQUFDLGtCQUFrQixHQUFHLE9BQU8sR0FBRyxLQUFLLENBQUMsQ0FBQztRQURsQixZQUFPLEdBQVAsT0FBTyxDQUFRO0lBRTNDLENBQUM7Q0FDRjtBQUpELGtEQUlDO0FBRUQsTUFBYSxtQ0FBb0MsU0FBUSxLQUFLO0lBQzVEO1FBQ0UsS0FBSyxDQUFDLCtDQUErQyxDQUFDLENBQUM7SUFDekQsQ0FBQztDQUNGO0FBSkQsa0ZBSUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBjcCBmcm9tIFwiY2hpbGRfcHJvY2Vzc1wiO1xuaW1wb3J0IHsgd3JpdGVGaWxlU3luYyB9IGZyb20gXCJmc1wiO1xuaW1wb3J0IHsgcmVhZEZpbGUsIHN0YXQgfSBmcm9tIFwiZnMvcHJvbWlzZXNcIjtcbmltcG9ydCB7IHVybCBhcyBpbnNwZWN0b3JVcmwgfSBmcm9tIFwiaW5zcGVjdG9yXCI7XG5pbXBvcnQgeyBCdW5kbGUsIGNyZWF0ZUJ1bmRsZSB9IGZyb20gXCIuL2J1bmRsaW5nXCI7XG5pbXBvcnQgeyBwcm9jZXNzU3RyZWFtIH0gZnJvbSBcIi4vc3RyZWFtLXByb2Nlc3NvclwiO1xuaW1wb3J0IHsgTG9nTGV2ZWwgfSBmcm9tIFwiLi4vc3RkXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2FuZGJveE9wdGlvbnMge1xuICByZWFkb25seSBlbnY/OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xuICByZWFkb25seSBjb250ZXh0PzogeyBba2V5OiBzdHJpbmddOiBhbnkgfTtcbiAgLyoqXG4gICAqIEhvdyBsb25nIHRoZSBzYW5kYm94IGlzIGFsbG93ZWQgdG8gcnVuIGNvZGUgd2hlbiBgc2FuZGJveC5jYWxsKClgIGlzIGNhbGxlZFxuICAgKiBiZWZvcmUgdGhlIGNoaWxkIHByb2Nlc3Mgc2hvdWxkIGJlIHN0b3BwZWQgKGtpbGxlZCksIGluIG1pbGxpc2Vjb25kcy5cbiAgICpcbiAgICogSWYgYW4gaW52b2NhdGlvbiByZXR1cm5zIHN1Y2Nlc3NmdWxseSwgdGhlIGNoaWxkIHByb2Nlc3MgY29udGludWVzIHJ1bm5pbmdcbiAgICogYW5kIGNhbiBiZSByZXVzZWQgZm9yIHN1YnNlcXVlbnQgaW52b2NhdGlvbnMuXG4gICAqL1xuICByZWFkb25seSB0aW1lb3V0PzogbnVtYmVyO1xuICByZWFkb25seSBsb2c/OiAoaW50ZXJuYWw6IGJvb2xlYW4sIGxldmVsOiBMb2dMZXZlbCwgbWVzc2FnZTogc3RyaW5nKSA9PiB2b2lkO1xufVxuXG4vKipcbiAqIFNoYXBlIG9mIHRoZSBtZXNzYWdlcyBzZW50IHRvIHRoZSBjaGlsZCBwcm9jZXNzLlxuICovXG50eXBlIFByb2Nlc3NSZXF1ZXN0ID0ge1xuICBmbjogc3RyaW5nO1xuICBhcmdzOiBhbnlbXTtcbn07XG5cbi8qKlxuICogU2hhcGUgb2YgdGhlIG1lc3NhZ2VzIHJldHVybmVkIGJ5IHRoZSBjaGlsZCBwcm9jZXNzLlxuICovXG50eXBlIFByb2Nlc3NSZXNwb25zZSA9XG4gIHwge1xuICAgICAgdHlwZTogXCJva1wiO1xuICAgICAgdmFsdWU6IGFueTtcbiAgICB9XG4gIHwge1xuICAgICAgdHlwZTogXCJlcnJvclwiO1xuICAgICAgcmVhc29uOiBFcnJvcjtcbiAgICB9O1xuXG5leHBvcnQgY2xhc3MgU2FuZGJveCB7XG4gIHB1YmxpYyBzdGF0aWMgYXN5bmMgY3JlYXRlQnVuZGxlKFxuICAgIGVudHJ5cG9pbnQ6IHN0cmluZyxcbiAgICBsb2c/OiAobWVzc2FnZTogc3RyaW5nLCBsZXZlbDogTG9nTGV2ZWwpID0+IHZvaWRcbiAgKTogUHJvbWlzZTxCdW5kbGU+IHtcbiAgICBsZXQgY29udGVudHMgPSBhd2FpdCByZWFkRmlsZShlbnRyeXBvaW50LCBcInV0Zi04XCIpO1xuXG4gICAgLy8gbG9nIGEgd2FybmluZyBpZiBjb250ZW50cyBpbmNsdWRlcyBfX2Rpcm5hbWUgb3IgX19maWxlbmFtZVxuICAgIGlmIChjb250ZW50cy5pbmNsdWRlcyhcIl9fZGlybmFtZVwiKSB8fCBjb250ZW50cy5pbmNsdWRlcyhcIl9fZmlsZW5hbWVcIikpIHtcbiAgICAgIGxvZz8uKFxuICAgICAgICBgV2FybmluZzogX19kaXJuYW1lIGFuZCBfX2ZpbGVuYW1lIGNhbm5vdCBiZSB1c2VkIHdpdGhpbiBidW5kbGVkIGNsb3VkIGZ1bmN0aW9ucy4gVGhlcmUgbWF5IGJlIHVuZXhwZWN0ZWQgYmVoYXZpb3IuYCxcbiAgICAgICAgTG9nTGV2ZWwuV0FSTklOR1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgZGVidWdTaGltID0gXCJcIjtcbiAgICBpZiAoaW5zcGVjdG9yVXJsPy4oKSkge1xuICAgICAgLy8gSWYgd2UncmUgZGVidWdnaW5nLCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGUgZGVidWdnZXIgaGFzIGVub3VnaCB0aW1lIHRvIGF0dGFjaFxuICAgICAgLy8gdG8gdGhlIGNoaWxkIHByb2Nlc3MuIFRoaXMgZ2l2ZXMgZW5vdWdoIHRpbWUgZm9yIHRoZSBkZWJ1Z2dlciBsb2FkIHNvdXJjZW1hcHMgYW5kIHNldCBicmVha3BvaW50cy5cbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L3ZzY29kZS1qcy1kZWJ1Zy9pc3N1ZXMvMTUxMFxuICAgICAgZGVidWdTaGltID1cbiAgICAgICAgXCJcXG4gIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDI1KSk7XCI7XG4gICAgfVxuXG4gICAgLy8gd3JhcCBjb250ZW50cyB3aXRoIGEgc2hpbSB0aGF0IGhhbmRsZXMgdGhlIGNvbW11bmljYXRpb24gd2l0aCB0aGUgcGFyZW50IHByb2Nlc3NcbiAgICAvLyB3ZSBpbnNlcnQgdGhpcyBzaGltIGJlZm9yZSBidW5kbGluZyB0byBlbnN1cmUgc291cmNlIG1hcHMgYXJlIGdlbmVyYXRlZCBjb3JyZWN0bHlcbiAgICBjb250ZW50cyArPSBgXG5wcm9jZXNzLm9uKFwidW5jYXVnaHRFeGNlcHRpb25cIiwgKHJlYXNvbikgPT4ge1xuICBwcm9jZXNzLnNlbmQoeyB0eXBlOiBcImVycm9yXCIsIHJlYXNvbiB9KTtcbn0pO1xuXG5wcm9jZXNzLm9uKFwibWVzc2FnZVwiLCBhc3luYyAobWVzc2FnZSkgPT4geyR7ZGVidWdTaGltfVxuICBjb25zdCB7IGZuLCBhcmdzIH0gPSBtZXNzYWdlO1xuICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4cG9ydHNbZm5dKC4uLmFyZ3MpO1xuICBwcm9jZXNzLnNlbmQoeyB0eXBlOiBcIm9rXCIsIHZhbHVlIH0pO1xufSk7XG5gO1xuXG4gICAgY29uc3Qgd3JhcHBlZFBhdGggPSBlbnRyeXBvaW50LnJlcGxhY2UoL1xcLmNqcyQvLCBcIi5zYW5kYm94LmNqc1wiKTtcblxuICAgIHdyaXRlRmlsZVN5bmMod3JhcHBlZFBhdGgsIGNvbnRlbnRzKTsgLy8gYXN5bmMgZnNQcm9taXNlcy53cml0ZUZpbGUgXCJmbHVzaFwiIG9wdGlvbiBpcyBub3QgYXZhaWxhYmxlIGluIE5vZGUgMjBcbiAgICBjb25zdCBidW5kbGUgPSBjcmVhdGVCdW5kbGUod3JhcHBlZFBhdGgpO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52LkRFQlVHKSB7XG4gICAgICBjb25zdCBmaWxlU3RhdHMgPSBhd2FpdCBzdGF0KGVudHJ5cG9pbnQpO1xuICAgICAgbG9nPy4oYEJ1bmRsZWQgY29kZSAoJHtmaWxlU3RhdHMuc2l6ZX0gYnl0ZXMpLmAsIExvZ0xldmVsLlZFUkJPU0UpO1xuICAgIH1cblxuICAgIHJldHVybiBidW5kbGU7XG4gIH1cblxuICBwcml2YXRlIHJlYWRvbmx5IGVudHJ5cG9pbnQ6IHN0cmluZztcbiAgcHJpdmF0ZSByZWFkb25seSBvcHRpb25zOiBTYW5kYm94T3B0aW9ucztcblxuICBwcml2YXRlIGNoaWxkOiBjcC5DaGlsZFByb2Nlc3MgfCB1bmRlZmluZWQ7XG4gIHByaXZhdGUgY2hpbGRQaWQ6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgcHJpdmF0ZSBvbkNoaWxkTWVzc2FnZTogKChtZXNzYWdlOiBQcm9jZXNzUmVzcG9uc2UpID0+IHZvaWQpIHwgdW5kZWZpbmVkO1xuICBwcml2YXRlIG9uQ2hpbGRFcnJvcjogKChlcnJvcjogRXJyb3IpID0+IHZvaWQpIHwgdW5kZWZpbmVkO1xuICBwcml2YXRlIG9uQ2hpbGRFeGl0OlxuICAgIHwgKChjb2RlOiBudW1iZXIgfCBudWxsLCBzaWduYWw6IE5vZGVKUy5TaWduYWxzIHwgbnVsbCkgPT4gdm9pZClcbiAgICB8IHVuZGVmaW5lZDtcblxuICBwcml2YXRlIHRpbWVvdXQ6IE5vZGVKUy5UaW1lb3V0IHwgdW5kZWZpbmVkO1xuXG4gIC8vIFRyYWNrcyB3aGV0aGVyIHRoZSBzYW5kYm94IGlzIGF2YWlsYWJsZSB0byBwcm9jZXNzIGEgbmV3IHJlcXVlc3RcbiAgLy8gV2hlbiBjYWxsKCkgaXMgY2FsbGVkLCBpdCBzZXRzIHRoaXMgdG8gZmFsc2UsIGFuZCB3aGVuIGl0J3MgcmV0dXJuaW5nXG4gIC8vIGEgcmVzcG9uc2Ugb3IgZXJyb3IsIGl0IHNldHMgaXQgYmFjayB0byB0cnVlLlxuICBwcml2YXRlIGF2YWlsYWJsZSA9IHRydWU7XG4gIHByaXZhdGUgY2xlYW5pbmdVcCA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKGVudHJ5cG9pbnQ6IHN0cmluZywgb3B0aW9uczogU2FuZGJveE9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuZW50cnlwb2ludCA9IGVudHJ5cG9pbnQ7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBjbGVhbnVwKCkge1xuICAgIHRoaXMuY2xlYW5pbmdVcCA9IHRydWU7XG4gICAgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XG4gICAgfSBlbHNlIHtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jaGlsZCkge1xuICAgICAgdGhpcy5kZWJ1Z0xvZyhcbiAgICAgICAgYFRlcm1pbmF0aW5nIHNhbmRib3ggY2hpbGQgcHJvY2VzcyAoUElEICR7dGhpcy5jaGlsZFBpZH0pLmBcbiAgICAgICk7XG4gICAgICB0aGlzLmNoaWxkLmtpbGwoXCJTSUdURVJNXCIpO1xuICAgICAgdGhpcy5jaGlsZCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuYXZhaWxhYmxlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgaXNBdmFpbGFibGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuYXZhaWxhYmxlO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGluaXRpYWxpemUoKSB7XG4gICAgY29uc3QgY2hpbGRFbnYgPSB0aGlzLm9wdGlvbnMuZW52ID8/IHt9O1xuICAgIGlmIChpbnNwZWN0b3JVcmw/LigpKSB7XG4gICAgICAvLyBXZSdyZSBleHBvc2luZyBhIGRlYnVnZ2VyLCBsZXQncyBhdHRlbXB0IHRvIGVuc3VyZSB0aGUgY2hpbGQgcHJvY2VzcyBhdXRvbWF0aWNhbGx5IGF0dGFjaGVzXG4gICAgICBjaGlsZEVudi5OT0RFX09QVElPTlMgPVxuICAgICAgICAoY2hpbGRFbnYuTk9ERV9PUFRJT05TID8/IFwiXCIpICsgKHByb2Nlc3MuZW52Lk5PREVfT1BUSU9OUyA/PyBcIlwiKTtcblxuICAgICAgLy8gSWYgdGhlIGNoaWxkIHByb2Nlc3MgaXMgbm90IGFscmVhZHkgY29uZmlndXJlZCB0byBhdHRhY2ggYSBkZWJ1Z2dlciwgYWRkIGEgZmxhZyB0byBkbyBzb1xuICAgICAgaWYgKFxuICAgICAgICAhY2hpbGRFbnYuTk9ERV9PUFRJT05TLmluY2x1ZGVzKFwiLS1pbnNwZWN0XCIpICYmXG4gICAgICAgICFwcm9jZXNzLmV4ZWNBcmd2LmluY2x1ZGVzKFwiLS1pbnNwZWN0XCIpXG4gICAgICApIHtcbiAgICAgICAgY2hpbGRFbnYuTk9ERV9PUFRJT05TICs9IFwiIC0taW5zcGVjdD0wXCI7XG4gICAgICB9XG5cbiAgICAgIC8vIFZTQ29kZSdzIGRlYnVnZ2VyIGFkZHMgc29tZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgdGhhdCB3ZSB3YW50IHRvIHBhc3MgdG8gdGhlIGNoaWxkIHByb2Nlc3NcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb2Nlc3MuZW52KSB7XG4gICAgICAgIGlmIChrZXkuc3RhcnRzV2l0aChcIlZTQ09ERV9cIikpIHtcbiAgICAgICAgICBjaGlsZEVudltrZXldID0gcHJvY2Vzcy5lbnZba2V5XSE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzdGFydCBhIE5vZGUuanMgcHJvY2VzcyB0aGF0IHJ1bnMgdGhlIGluZmxpZ2h0IGNvZGVcbiAgICAvLyBub3RlOiB1bmxpa2UgdGhlIGZvcmsoMikgUE9TSVggc3lzdGVtIGNhbGwsIGNoaWxkX3Byb2Nlc3MuZm9yaygpXG4gICAgLy8gZG9lcyBub3QgY2xvbmUgdGhlIGN1cnJlbnQgcHJvY2Vzc1xuICAgIHRoaXMuY2hpbGQgPSBjcC5mb3JrKHRoaXMuZW50cnlwb2ludCwge1xuICAgICAgZW52OiBjaGlsZEVudixcbiAgICAgIHN0ZGlvOiBcInBpcGVcIixcbiAgICAgIC8vIGtlZXAgdGhlIHByb2Nlc3MgZGV0YWNoZWQgc28gaW4gdGhlIGNhc2Ugb2YgY2xvdWQuU2VydmljZSwgaWYgdGhlIHBhcmVudCBwcm9jZXNzIGlzIGtpbGxlZFxuICAgICAgLy8gKGUuZy4gc29tZW9uZSBwcmVzc2VzIEN0cmwrQyB3aGlsZSB1c2luZyBXaW5nIENvbnNvbGUpLFxuICAgICAgLy8gd2UgY2FuIGdyYWNlZnVsbHkgY2FsbCBhbnkgY2xlYW51cCBjb2RlIGluIHRoZSBjaGlsZCBwcm9jZXNzXG4gICAgICBkZXRhY2hlZDogdHJ1ZSxcbiAgICAgIC8vIHRoaXMgb3B0aW9uIGFsbG93cyBjb21wbGV4IG9iamVjdHMgbGlrZSBFcnJvciB0byBiZSBzZW50IGZyb20gdGhlIGNoaWxkIHByb2Nlc3MgdG8gdGhlIHBhcmVudFxuICAgICAgc2VyaWFsaXphdGlvbjogXCJhZHZhbmNlZFwiLFxuICAgIH0pO1xuICAgIHRoaXMuY2hpbGRQaWQgPSB0aGlzLmNoaWxkLnBpZDtcblxuICAgIHRoaXMuZGVidWdMb2coYEluaXRpYWxpemVkIHNhbmRib3ggKFBJRCAke3RoaXMuY2hpbGRQaWR9KS5gKTtcblxuICAgIGNvbnN0IGxvZyA9IChtZXNzYWdlOiBzdHJpbmcpID0+IHtcbiAgICAgIGxldCBsZXZlbCA9IExvZ0xldmVsLklORk87XG4gICAgICBpZiAobWVzc2FnZS5zdGFydHNXaXRoKFwiaW5mbzpcIikpIHtcbiAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2Uuc2xpY2UoNSk7XG4gICAgICB9IGVsc2UgaWYgKG1lc3NhZ2Uuc3RhcnRzV2l0aChcImVycm9yOlwiKSkge1xuICAgICAgICBtZXNzYWdlID0gbWVzc2FnZS5zbGljZSg2KTtcbiAgICAgICAgbGV2ZWwgPSBMb2dMZXZlbC5FUlJPUjtcbiAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS5zdGFydHNXaXRoKFwid2FybmluZzpcIikpIHtcbiAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2Uuc2xpY2UoOCk7XG4gICAgICAgIGxldmVsID0gTG9nTGV2ZWwuV0FSTklORztcbiAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS5zdGFydHNXaXRoKFwidmVyYm9zZTpcIikpIHtcbiAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2Uuc2xpY2UoOCk7XG4gICAgICAgIGxldmVsID0gTG9nTGV2ZWwuVkVSQk9TRTtcbiAgICAgIH1cbiAgICAgIHRoaXMub3B0aW9ucy5sb2c/LihmYWxzZSwgbGV2ZWwsIG1lc3NhZ2UpO1xuICAgIH07XG4gICAgY29uc3QgbG9nRXJyb3IgPSAobWVzc2FnZTogc3RyaW5nKSA9PlxuICAgICAgdGhpcy5vcHRpb25zLmxvZz8uKGZhbHNlLCBMb2dMZXZlbC5FUlJPUiwgbWVzc2FnZSk7XG5cbiAgICAvLyBwaXBlIHN0ZG91dCBhbmQgc3RkZXJyIGZyb20gdGhlIGNoaWxkIHByb2Nlc3NcbiAgICBpZiAodGhpcy5jaGlsZC5zdGRvdXQpIHtcbiAgICAgIHByb2Nlc3NTdHJlYW0odGhpcy5jaGlsZC5zdGRvdXQsIGxvZyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmNoaWxkLnN0ZGVycikge1xuICAgICAgcHJvY2Vzc1N0cmVhbSh0aGlzLmNoaWxkLnN0ZGVyciwgbG9nRXJyb3IpO1xuICAgIH1cblxuICAgIHRoaXMuY2hpbGQub24oXCJtZXNzYWdlXCIsIChtZXNzYWdlOiBQcm9jZXNzUmVzcG9uc2UpID0+IHtcbiAgICAgIHRoaXMub25DaGlsZE1lc3NhZ2U/LihtZXNzYWdlKTtcbiAgICB9KTtcbiAgICB0aGlzLmNoaWxkIS5vbihcImVycm9yXCIsIChlcnJvcikgPT4ge1xuICAgICAgdGhpcy5vbkNoaWxkRXJyb3I/LihlcnJvcik7XG4gICAgfSk7XG4gICAgdGhpcy5jaGlsZCEub24oXCJleGl0XCIsIChjb2RlLCBzaWduYWwpID0+IHtcbiAgICAgIHRoaXMub25DaGlsZEV4aXQ/Lihjb2RlLCBzaWduYWwpO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGNhbGwoZm46IHN0cmluZywgLi4uYXJnczogYW55W10pOiBQcm9taXNlPGFueT4ge1xuICAgIGlmICghdGhpcy5hdmFpbGFibGUpIHtcbiAgICAgIHRocm93IG5ldyBTYW5kYm94TXVsdGlwbGVDb25jdXJyZW50Q2FsbHNFcnJvcigpO1xuICAgIH1cblxuICAgIC8vIFByZXZlbnQgbXVsdGlwbGUgY2FsbHMgdG8gdGhlIHNhbWUgc2FuZGJveCBydW5uaW5nIGNvbmN1cnJlbnRseS5cbiAgICB0aGlzLmF2YWlsYWJsZSA9IGZhbHNlO1xuXG4gICAgLy8gSWYgdGhpcyBzYW5kYm94IGRvZXNuJ3QgaGF2ZSBhIGNoaWxkIHByb2Nlc3MgcnVubmluZyAoYmVjYXVzZSBpdFxuICAgIC8vIGp1c3QgZ290IGNyZWF0ZWQsIE9SIGJlY2F1c2UgdGhlIHByZXZpb3VzIGNoaWxkIHByb2Nlc3Mgd2FzIGtpbGxlZCBkdWVcbiAgICAvLyB0byB0aW1lb3V0IG9yIGFuIHVuZXhwZWN0ZWQgZXJyb3IpLCBpbml0aWFsaXplIG9uZS5cbiAgICBpZiAoIXRoaXMuY2hpbGQpIHtcbiAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgIH1cblxuICAgIC8vIFNlbmQgdGhlIGZ1bmN0aW9uIG5hbWUgYW5kIGFyZ3VtZW50cyB0byB0aGUgY2hpbGQgcHJvY2Vzcy5cbiAgICAvLyBXaGVuIGEgbWVzc2FnZSBpcyByZWNlaXZlZCwgcmVzb2x2ZSBvciByZWplY3QgdGhlIHByb21pc2UuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuY2hpbGQhLnNlbmQoeyBmbiwgYXJncyB9IGFzIFByb2Nlc3NSZXF1ZXN0KTtcbiAgICAgIHRoaXMuZGVidWdMb2coXG4gICAgICAgIGBTZW50IGEgbWVzc2FnZSB0byB0aGUgc2FuZGJveCAoUElEICR7dGhpcy5jaGlsZFBpZH0pOiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGZuLFxuICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICB9XG4gICAgICAgICl9YFxuICAgICAgKTtcblxuICAgICAgdGhpcy5vbkNoaWxkTWVzc2FnZSA9IChtZXNzYWdlOiBQcm9jZXNzUmVzcG9uc2UpID0+IHtcbiAgICAgICAgdGhpcy5kZWJ1Z0xvZyhcbiAgICAgICAgICBgUmVjZWl2ZWQgYSBtZXNzYWdlIGZyb20gdGhlIHNhbmRib3ggKFBJRCAke1xuICAgICAgICAgICAgdGhpcy5jaGlsZFBpZFxuICAgICAgICAgIH0pOiAke0pTT04uc3RyaW5naWZ5KG1lc3NhZ2UpfWBcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5hdmFpbGFibGUgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy50aW1lb3V0KSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSA9PT0gXCJva1wiKSB7XG4gICAgICAgICAgcmVzb2x2ZShtZXNzYWdlLnZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChtZXNzYWdlLnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgIHJlamVjdChtZXNzYWdlLnJlYXNvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgVW5leHBlY3RlZCBtZXNzYWdlIGZyb20gdGhlIHNhbmRib3ggKFBJRCAke3RoaXMuY2hpbGRQaWR9KTogJHttZXNzYWdlfWBcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBcImVycm9yXCIgY291bGQgYmUgZW1pdHRlZCBmb3IgYW55IG51bWJlciBvZiByZWFzb25zXG4gICAgICAvLyAoZS5nLiB0aGUgcHJvY2VzcyBjb3VsZG4ndCBiZSBzcGF3bmVkIG9yIGtpbGxlZCwgb3IgYSBtZXNzYWdlIGNvdWxkbid0IGJlIHNlbnQpLlxuICAgICAgLy8gU2luY2UgdGhpcyBpcyB1bmV4cGVjdGVkLCB3ZSBraWxsIHRoZSBwcm9jZXNzIHdpdGggU0lHS0lMTCB0byBlbnN1cmUgaXQncyBkZWFkLCBhbmQgcmVqZWN0IHRoZSBwcm9taXNlLlxuICAgICAgdGhpcy5vbkNoaWxkRXJyb3IgPSAoZXJyb3I6IEVycm9yKSA9PiB7XG4gICAgICAgIHRoaXMuZGVidWdMb2coXG4gICAgICAgICAgYFVuZXhwZWN0ZWQgZXJyb3IgZnJvbSB0aGUgc2FuZGJveCAoUElEICR7dGhpcy5jaGlsZFBpZH0pLmBcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5jaGlsZD8ua2lsbChcIlNJR0tJTExcIik7XG4gICAgICAgIHRoaXMuY2hpbGQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuYXZhaWxhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNsZWFuaW5nVXApIHtcbiAgICAgICAgICByZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gXCJleGl0XCIgY291bGQgYmUgZW1pdHRlZCBpZiB0aGUgdXNlciBjb2RlIGNhbGxlZCBwcm9jZXNzLmV4aXQoKSwgb3IgaWYgd2Uga2lsbGVkIHRoZSBwcm9jZXNzXG4gICAgICAvLyBkdWUgdG8gYSB0aW1lb3V0IG9yIHVuZXhwZWN0ZWQgZXJyb3IuIEluIGFueSBjYXNlLCB3ZSByZWplY3QgdGhlIHByb21pc2UuXG4gICAgICB0aGlzLm9uQ2hpbGRFeGl0ID0gKGNvZGU6IG51bWJlciB8IG51bGwsIHNpZ25hbDogdW5rbm93bikgPT4ge1xuICAgICAgICB0aGlzLmRlYnVnTG9nKGBTYW5kYm94IChQSUQgJHt0aGlzLmNoaWxkUGlkfSkgc3RvcHBlZC5gKTtcbiAgICAgICAgdGhpcy5jaGlsZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5hdmFpbGFibGUgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy50aW1lb3V0KSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2xlYW5pbmdVcCkge1xuICAgICAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICBuZXcgRXJyb3IoYFByb2Nlc3MgZXhpdGVkIHdpdGggY29kZSAke2NvZGV9LCBzaWduYWwgJHtzaWduYWx9YClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnRpbWVvdXQgJiYgIWluc3BlY3RvclVybD8uKCkpIHtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5kZWJ1Z0xvZyhcbiAgICAgICAgICAgIGBLaWxsaW5nIHNhbmRib3ggKFBJRCAke3RoaXMuY2hpbGRQaWR9KSBhZnRlciB0aW1lb3V0LmBcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuY2hpbGQ/LmtpbGwoXCJTSUdURVJNXCIpO1xuICAgICAgICAgIHRoaXMuY2hpbGQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgdGhpcy5hdmFpbGFibGUgPSB0cnVlO1xuICAgICAgICAgIGlmICh0aGlzLmNsZWFuaW5nVXApIHtcbiAgICAgICAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBTYW5kYm94VGltZW91dEVycm9yKHRoaXMub3B0aW9ucy50aW1lb3V0ID8/IDApKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMub3B0aW9ucy50aW1lb3V0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgZGVidWdMb2cobWVzc2FnZTogc3RyaW5nKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52LkRFQlVHKSB7XG4gICAgICB0aGlzLm9wdGlvbnMubG9nPy4odHJ1ZSwgTG9nTGV2ZWwuVkVSQk9TRSwgbWVzc2FnZSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTYW5kYm94VGltZW91dEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgdGltZW91dDogbnVtYmVyKSB7XG4gICAgc3VwZXIoXCJUaW1lZCBvdXQgYWZ0ZXIgXCIgKyB0aW1lb3V0ICsgXCJtcy5cIik7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFNhbmRib3hNdWx0aXBsZUNvbmN1cnJlbnRDYWxsc0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcIkNhbm5vdCBwcm9jZXNzIG11bHRpcGxlIHJlcXVlc3RzIGluIHBhcmFsbGVsLlwiKTtcbiAgfVxufVxuIl19