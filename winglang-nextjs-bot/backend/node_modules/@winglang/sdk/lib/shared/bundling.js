"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isBundleInvalidated = exports.filesModifiedSince = exports.fixSourcemaps = exports.createBundle = void 0;
const crypto = __importStar(require("crypto"));
const fs_1 = require("fs");
const promises_1 = require("fs/promises");
const path_1 = require("path");
const vlq_1 = require("vlq");
const misc_1 = require("./misc");
const SDK_PATH = (0, misc_1.normalPath)((0, path_1.resolve)(__dirname, "..", ".."));
/**
 * Bundles a javascript entrypoint into a single file.
 * @param entrypoint The javascript entrypoint
 * @param outputDir Defaults to `${entrypoint}.bundle`
 * @param external external packages
 * @returns Bundle information
 */
function createBundle(entrypoint, external = [], outputDir) {
    const normalEntrypoint = (0, misc_1.normalPath)((0, fs_1.realpathSync)(entrypoint));
    const outdir = outputDir
        ? (0, misc_1.normalPath)((0, fs_1.realpathSync)(outputDir))
        : `${normalEntrypoint}.bundle`;
    (0, fs_1.mkdirSync)(outdir, { recursive: true });
    const outfileName = "index.cjs";
    const soucemapFilename = `${outfileName}.map`;
    const outfile = path_1.posix.join(outdir, outfileName);
    const outfileMap = path_1.posix.join(outdir, soucemapFilename);
    const stats = (0, fs_1.statSync)(normalEntrypoint);
    // Track what time we started bundling so we can invalidate the bundle if any
    // of the source files are modified after this time.
    let startTime = new Date();
    // For unknown reasons, the date created here by JavaScript can sometimes be a
    // few milliseconds before the last modification date of the entrypoint file.
    // This can cause the bundle to be invalidated when it shouldn't be. To
    // prevent this flakiness in unit tests, we check if the modification date of the
    // entrypoint file and update the start time if it's newer.
    if (stats.mtime > startTime) {
        startTime = stats.mtime;
    }
    // eslint-disable-next-line import/no-extraneous-dependencies,@typescript-eslint/no-require-imports
    const esbuilder = require("esbuild");
    let esbuild = esbuilder.buildSync({
        bundle: true,
        entryPoints: [normalEntrypoint],
        outfile,
        // otherwise there are problems with running azure cloud functions:
        // https://stackoverflow.com/questions/70332883/webpack-azure-storage-blob-node-fetch-abortsignal-issue
        keepNames: true,
        // if the user has specified a node_modules directory to resolve from
        nodePaths: process.env.WING_NODE_MODULES
            ? [(0, misc_1.normalPath)(process.env.WING_NODE_MODULES)]
            : undefined,
        alias: {
            "@winglang/sdk": SDK_PATH,
        },
        minify: false,
        sourcemap: "linked",
        platform: "node",
        target: "node20",
        format: "cjs",
        external,
        metafile: true,
        write: false,
    });
    if (esbuild.errors.length > 0) {
        const errors = esbuild.errors.map((e) => e.text).join("\n");
        throw new Error(`Failed to bundle function: ${errors}`);
    }
    const bundleOutput = esbuild.outputFiles[1];
    // ensure source paths have posix path separators
    const sourcemapData = JSON.parse(new TextDecoder().decode(esbuild.outputFiles[0].contents));
    fixSourcemaps(sourcemapData);
    (0, fs_1.writeFileSync)(outfile, bundleOutput.contents);
    (0, fs_1.writeFileSync)(outfileMap, JSON.stringify(sourcemapData));
    // calculate a md5 hash of the contents of asset.path
    const codeHash = crypto
        .createHash("md5")
        .update(bundleOutput.contents)
        .digest("hex");
    const outKeys = Object.keys(esbuild.metafile?.outputs ?? {});
    const outKey = outKeys.find((k) => k.endsWith(outfileName));
    if (!outKey) {
        throw new Error(`Couldn't find metadata for ${outfileName} from esbuild.`);
    }
    const inputFiles = Object.keys(esbuild.metafile?.outputs[outKey].inputs);
    return {
        directory: outdir,
        hash: codeHash,
        outfilePath: outfile,
        sourcemapPath: outfileMap,
        inputFiles,
        time: startTime,
    };
}
exports.createBundle = createBundle;
/**
 * Takes a bundled sourcemap and does the following fixes:
 * - Normalizes paths in sources and sourceRoot
 * - Removes duplicate sources and sourcesContent
 * - Updates mappings to reflect the new source indices
 *
 * The duplicate sources come from esbuild's strange handling of multiple files being bundled that point to the same source (e.g. inflights that point to one .w file)
 * See https://github.com/evanw/esbuild/issues/933
 */
function fixSourcemaps(sourcemapData) {
    // normalize sourceRoot
    if (sourcemapData.sourceRoot) {
        sourcemapData.sourceRoot = (0, misc_1.normalPath)(sourcemapData.sourceRoot);
    }
    // normalize sources and remove duplicates
    const sourceSet = [];
    const newSourceContents = [];
    const sourceIndexMap = {};
    let hasSourceDupes = false;
    sourcemapData.sources.forEach((source, idx) => {
        const newPath = (0, misc_1.normalPath)(source);
        sourcemapData.sources[idx] = newPath;
        const existingIndex = sourceSet.indexOf(newPath);
        if (existingIndex === -1) {
            sourceSet.push(newPath);
            newSourceContents.push(sourcemapData.sourcesContent[idx]);
            sourceIndexMap[idx] = sourceSet.length - 1;
        }
        else {
            hasSourceDupes = true;
            sourceIndexMap[idx] = existingIndex;
        }
    });
    sourcemapData.sources = sourceSet;
    sourcemapData.sourcesContent = newSourceContents;
    // fast path: No source duplicates so no need to update mappings
    if (!hasSourceDupes) {
        return;
    }
    // update mappings
    let newMapping = "";
    let characterIndex = 0;
    let lastFile = 0;
    let lastTrueFile = 0;
    while (characterIndex < sourcemapData.mappings.length) {
        const char = sourcemapData.mappings[characterIndex];
        // `;` and `,` are separators between the segments of interest
        if (char === ";" || char === ",") {
            newMapping += char;
            characterIndex++;
            continue;
        }
        // get next slice of segment data
        let segment = "";
        let nextChar = char;
        while (nextChar !== undefined && nextChar !== "," && nextChar !== ";") {
            segment += nextChar;
            nextChar = sourcemapData.mappings[++characterIndex];
        }
        const decoded = (0, vlq_1.decode)(segment);
        if (decoded.length === 1) {
            newMapping += segment;
            continue;
        }
        const sourceRelative = decoded[1];
        const originalSource = lastTrueFile + sourceRelative;
        const newSourceIndex = sourceIndexMap[originalSource];
        lastTrueFile = originalSource;
        const newRelativeValue = newSourceIndex - lastFile;
        lastFile = newSourceIndex;
        if (newRelativeValue === decoded[1]) {
            // no change was made, avoid re-encoding
            newMapping += segment;
        }
        else {
            decoded[1] = newRelativeValue;
            newMapping += (0, vlq_1.encode)(decoded);
        }
    }
    sourcemapData.mappings = newMapping;
}
exports.fixSourcemaps = fixSourcemaps;
async function filesModifiedSince(filePaths, directory, dateTime) {
    const absolutePaths = filePaths.map((filePath) => (0, path_1.resolve)(directory, filePath));
    try {
        const statsPromises = absolutePaths.map((filePath) => (0, promises_1.stat)(filePath));
        const stats = await Promise.all(statsPromises);
        const changedFiles = new Array();
        for (let i = 0; i < absolutePaths.length; i++) {
            if (stats[i].mtime > dateTime) {
                console.error(`File ${absolutePaths[i]} has been modified since the last bundle`, stats[i].mtime, dateTime);
                changedFiles.push(absolutePaths[i]);
            }
        }
        return changedFiles;
    }
    catch (error) {
        console.error("Error checking file modification times:", error);
        throw error;
    }
}
exports.filesModifiedSince = filesModifiedSince;
async function isBundleInvalidated(entrypoint, bundle, log) {
    const modifiedFiles = await filesModifiedSince([entrypoint, ...bundle.inputFiles], process.cwd(), bundle.time);
    if (modifiedFiles.length === 0) {
        return false;
    }
    if (process.env.DEBUG) {
        log?.(`Files modified since last bundling: [${modifiedFiles
            .map((x) => `"${x}"`)
            .join(", ")}]`);
    }
    return true;
}
exports.isBundleInvalidated = isBundleInvalidated;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxpbmcuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvc2hhcmVkL2J1bmRsaW5nLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsK0NBQWlDO0FBQ2pDLDJCQUFzRTtBQUN0RSwwQ0FBbUM7QUFDbkMsK0JBQXNDO0FBQ3RDLDZCQUFxQztBQUNyQyxpQ0FBb0M7QUFFcEMsTUFBTSxRQUFRLEdBQUcsSUFBQSxpQkFBVSxFQUFDLElBQUEsY0FBTyxFQUFDLFNBQVMsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQztBQXFCNUQ7Ozs7OztHQU1HO0FBQ0gsU0FBZ0IsWUFBWSxDQUMxQixVQUFrQixFQUNsQixXQUFxQixFQUFFLEVBQ3ZCLFNBQWtCO0lBRWxCLE1BQU0sZ0JBQWdCLEdBQUcsSUFBQSxpQkFBVSxFQUFDLElBQUEsaUJBQVksRUFBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO0lBQzlELE1BQU0sTUFBTSxHQUFHLFNBQVM7UUFDdEIsQ0FBQyxDQUFDLElBQUEsaUJBQVUsRUFBQyxJQUFBLGlCQUFZLEVBQUMsU0FBUyxDQUFDLENBQUM7UUFDckMsQ0FBQyxDQUFDLEdBQUcsZ0JBQWdCLFNBQVMsQ0FBQztJQUNqQyxJQUFBLGNBQVMsRUFBQyxNQUFNLEVBQUUsRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztJQUV2QyxNQUFNLFdBQVcsR0FBRyxXQUFXLENBQUM7SUFDaEMsTUFBTSxnQkFBZ0IsR0FBRyxHQUFHLFdBQVcsTUFBTSxDQUFDO0lBRTlDLE1BQU0sT0FBTyxHQUFHLFlBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLFdBQVcsQ0FBQyxDQUFDO0lBQ2hELE1BQU0sVUFBVSxHQUFHLFlBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLGdCQUFnQixDQUFDLENBQUM7SUFFeEQsTUFBTSxLQUFLLEdBQUcsSUFBQSxhQUFRLEVBQUMsZ0JBQWdCLENBQUMsQ0FBQztJQUV6Qyw2RUFBNkU7SUFDN0Usb0RBQW9EO0lBQ3BELElBQUksU0FBUyxHQUFHLElBQUksSUFBSSxFQUFFLENBQUM7SUFFM0IsOEVBQThFO0lBQzlFLDZFQUE2RTtJQUM3RSx1RUFBdUU7SUFDdkUsaUZBQWlGO0lBQ2pGLDJEQUEyRDtJQUMzRCxJQUFJLEtBQUssQ0FBQyxLQUFLLEdBQUcsU0FBUyxFQUFFLENBQUM7UUFDNUIsU0FBUyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUM7SUFDMUIsQ0FBQztJQUVELG1HQUFtRztJQUNuRyxNQUFNLFNBQVMsR0FBNkIsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBRS9ELElBQUksT0FBTyxHQUFHLFNBQVMsQ0FBQyxTQUFTLENBQUM7UUFDaEMsTUFBTSxFQUFFLElBQUk7UUFDWixXQUFXLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQztRQUMvQixPQUFPO1FBQ1AsbUVBQW1FO1FBQ25FLHVHQUF1RztRQUN2RyxTQUFTLEVBQUUsSUFBSTtRQUNmLHFFQUFxRTtRQUNyRSxTQUFTLEVBQUUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxpQkFBaUI7WUFDdEMsQ0FBQyxDQUFDLENBQUMsSUFBQSxpQkFBVSxFQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsaUJBQTJCLENBQUMsQ0FBQztZQUN2RCxDQUFDLENBQUMsU0FBUztRQUNiLEtBQUssRUFBRTtZQUNMLGVBQWUsRUFBRSxRQUFRO1NBQzFCO1FBQ0QsTUFBTSxFQUFFLEtBQUs7UUFDYixTQUFTLEVBQUUsUUFBUTtRQUNuQixRQUFRLEVBQUUsTUFBTTtRQUNoQixNQUFNLEVBQUUsUUFBUTtRQUNoQixNQUFNLEVBQUUsS0FBSztRQUNiLFFBQVE7UUFDUixRQUFRLEVBQUUsSUFBSTtRQUNkLEtBQUssRUFBRSxLQUFLO0tBQ2IsQ0FBQyxDQUFDO0lBRUgsSUFBSSxPQUFPLENBQUMsTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQztRQUM5QixNQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUM1RCxNQUFNLElBQUksS0FBSyxDQUFDLDhCQUE4QixNQUFNLEVBQUUsQ0FBQyxDQUFDO0lBQzFELENBQUM7SUFFRCxNQUFNLFlBQVksR0FBRyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRTVDLGlEQUFpRDtJQUNqRCxNQUFNLGFBQWEsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUM5QixJQUFJLFdBQVcsRUFBRSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUMxRCxDQUFDO0lBQ0YsYUFBYSxDQUFDLGFBQWEsQ0FBQyxDQUFDO0lBRTdCLElBQUEsa0JBQWEsRUFBQyxPQUFPLEVBQUUsWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzlDLElBQUEsa0JBQWEsRUFBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDO0lBRXpELHFEQUFxRDtJQUNyRCxNQUFNLFFBQVEsR0FBRyxNQUFNO1NBQ3BCLFVBQVUsQ0FBQyxLQUFLLENBQUM7U0FDakIsTUFBTSxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUM7U0FDN0IsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBRWpCLE1BQU0sT0FBTyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxPQUFPLElBQUksRUFBRSxDQUFDLENBQUM7SUFDN0QsTUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDO0lBQzVELElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUNaLE1BQU0sSUFBSSxLQUFLLENBQUMsOEJBQThCLFdBQVcsZ0JBQWdCLENBQUMsQ0FBQztJQUM3RSxDQUFDO0lBRUQsTUFBTSxVQUFVLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUV6RSxPQUFPO1FBQ0wsU0FBUyxFQUFFLE1BQU07UUFDakIsSUFBSSxFQUFFLFFBQVE7UUFDZCxXQUFXLEVBQUUsT0FBTztRQUNwQixhQUFhLEVBQUUsVUFBVTtRQUN6QixVQUFVO1FBQ1YsSUFBSSxFQUFFLFNBQVM7S0FDaEIsQ0FBQztBQUNKLENBQUM7QUFqR0Qsb0NBaUdDO0FBU0Q7Ozs7Ozs7O0dBUUc7QUFDSCxTQUFnQixhQUFhLENBQUMsYUFBd0I7SUFDcEQsdUJBQXVCO0lBQ3ZCLElBQUksYUFBYSxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBQzdCLGFBQWEsQ0FBQyxVQUFVLEdBQUcsSUFBQSxpQkFBVSxFQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUNsRSxDQUFDO0lBRUQsMENBQTBDO0lBQzFDLE1BQU0sU0FBUyxHQUFhLEVBQUUsQ0FBQztJQUMvQixNQUFNLGlCQUFpQixHQUFhLEVBQUUsQ0FBQztJQUN2QyxNQUFNLGNBQWMsR0FBMkIsRUFBRSxDQUFDO0lBQ2xELElBQUksY0FBYyxHQUFHLEtBQUssQ0FBQztJQUMzQixhQUFhLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sRUFBRSxHQUFHLEVBQUUsRUFBRTtRQUM1QyxNQUFNLE9BQU8sR0FBRyxJQUFBLGlCQUFVLEVBQUMsTUFBTSxDQUFDLENBQUM7UUFDbkMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsR0FBRyxPQUFPLENBQUM7UUFFckMsTUFBTSxhQUFhLEdBQUcsU0FBUyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUNqRCxJQUFJLGFBQWEsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDO1lBQ3pCLFNBQVMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDeEIsaUJBQWlCLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUMxRCxjQUFjLENBQUMsR0FBRyxDQUFDLEdBQUcsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7UUFDN0MsQ0FBQzthQUFNLENBQUM7WUFDTixjQUFjLEdBQUcsSUFBSSxDQUFDO1lBQ3RCLGNBQWMsQ0FBQyxHQUFHLENBQUMsR0FBRyxhQUFhLENBQUM7UUFDdEMsQ0FBQztJQUNILENBQUMsQ0FBQyxDQUFDO0lBRUgsYUFBYSxDQUFDLE9BQU8sR0FBRyxTQUFTLENBQUM7SUFDbEMsYUFBYSxDQUFDLGNBQWMsR0FBRyxpQkFBaUIsQ0FBQztJQUVqRCxnRUFBZ0U7SUFDaEUsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDO1FBQ3BCLE9BQU87SUFDVCxDQUFDO0lBRUQsa0JBQWtCO0lBQ2xCLElBQUksVUFBVSxHQUFHLEVBQUUsQ0FBQztJQUNwQixJQUFJLGNBQWMsR0FBRyxDQUFDLENBQUM7SUFDdkIsSUFBSSxRQUFRLEdBQUcsQ0FBQyxDQUFDO0lBQ2pCLElBQUksWUFBWSxHQUFHLENBQUMsQ0FBQztJQUNyQixPQUFPLGNBQWMsR0FBRyxhQUFhLENBQUMsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQ3RELE1BQU0sSUFBSSxHQUFHLGFBQWEsQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUFDLENBQUM7UUFDcEQsOERBQThEO1FBQzlELElBQUksSUFBSSxLQUFLLEdBQUcsSUFBSSxJQUFJLEtBQUssR0FBRyxFQUFFLENBQUM7WUFDakMsVUFBVSxJQUFJLElBQUksQ0FBQztZQUNuQixjQUFjLEVBQUUsQ0FBQztZQUNqQixTQUFTO1FBQ1gsQ0FBQztRQUVELGlDQUFpQztRQUNqQyxJQUFJLE9BQU8sR0FBRyxFQUFFLENBQUM7UUFDakIsSUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDO1FBQ3BCLE9BQU8sUUFBUSxLQUFLLFNBQVMsSUFBSSxRQUFRLEtBQUssR0FBRyxJQUFJLFFBQVEsS0FBSyxHQUFHLEVBQUUsQ0FBQztZQUN0RSxPQUFPLElBQUksUUFBUSxDQUFDO1lBQ3BCLFFBQVEsR0FBRyxhQUFhLENBQUMsUUFBUSxDQUFDLEVBQUUsY0FBYyxDQUFDLENBQUM7UUFDdEQsQ0FBQztRQUNELE1BQU0sT0FBTyxHQUFHLElBQUEsWUFBTSxFQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ2hDLElBQUksT0FBTyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUUsQ0FBQztZQUN6QixVQUFVLElBQUksT0FBTyxDQUFDO1lBQ3RCLFNBQVM7UUFDWCxDQUFDO1FBRUQsTUFBTSxjQUFjLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2xDLE1BQU0sY0FBYyxHQUFHLFlBQVksR0FBRyxjQUFjLENBQUM7UUFDckQsTUFBTSxjQUFjLEdBQUcsY0FBYyxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBQ3RELFlBQVksR0FBRyxjQUFjLENBQUM7UUFFOUIsTUFBTSxnQkFBZ0IsR0FBRyxjQUFjLEdBQUcsUUFBUSxDQUFDO1FBQ25ELFFBQVEsR0FBRyxjQUFjLENBQUM7UUFFMUIsSUFBSSxnQkFBZ0IsS0FBSyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztZQUNwQyx3Q0FBd0M7WUFDeEMsVUFBVSxJQUFJLE9BQU8sQ0FBQztRQUN4QixDQUFDO2FBQU0sQ0FBQztZQUNOLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxnQkFBZ0IsQ0FBQztZQUM5QixVQUFVLElBQUksSUFBQSxZQUFNLEVBQUMsT0FBTyxDQUFDLENBQUM7UUFDaEMsQ0FBQztJQUNILENBQUM7SUFFRCxhQUFhLENBQUMsUUFBUSxHQUFHLFVBQVUsQ0FBQztBQUN0QyxDQUFDO0FBL0VELHNDQStFQztBQUVNLEtBQUssVUFBVSxrQkFBa0IsQ0FDdEMsU0FBbUIsRUFDbkIsU0FBaUIsRUFDakIsUUFBYztJQUVkLE1BQU0sYUFBYSxHQUFHLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxRQUFRLEVBQUUsRUFBRSxDQUMvQyxJQUFBLGNBQU8sRUFBQyxTQUFTLEVBQUUsUUFBUSxDQUFDLENBQzdCLENBQUM7SUFFRixJQUFJLENBQUM7UUFDSCxNQUFNLGFBQWEsR0FBRyxhQUFhLENBQUMsR0FBRyxDQUFDLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQyxJQUFBLGVBQUksRUFBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1FBQ3RFLE1BQU0sS0FBSyxHQUFHLE1BQU0sT0FBTyxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUMvQyxNQUFNLFlBQVksR0FBRyxJQUFJLEtBQUssRUFBVSxDQUFDO1FBRXpDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxhQUFhLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7WUFDOUMsSUFBSSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxHQUFHLFFBQVEsRUFBRSxDQUFDO2dCQUM5QixPQUFPLENBQUMsS0FBSyxDQUNYLFFBQVEsYUFBYSxDQUFDLENBQUMsQ0FBQywwQ0FBMEMsRUFDbEUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFDZCxRQUFRLENBQ1QsQ0FBQztnQkFDRixZQUFZLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3RDLENBQUM7UUFDSCxDQUFDO1FBRUQsT0FBTyxZQUFZLENBQUM7SUFDdEIsQ0FBQztJQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7UUFDZixPQUFPLENBQUMsS0FBSyxDQUFDLHlDQUF5QyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQ2hFLE1BQU0sS0FBSyxDQUFDO0lBQ2QsQ0FBQztBQUNILENBQUM7QUE5QkQsZ0RBOEJDO0FBRU0sS0FBSyxVQUFVLG1CQUFtQixDQUN2QyxVQUFrQixFQUNsQixNQUFjLEVBQ2QsR0FBMkI7SUFFM0IsTUFBTSxhQUFhLEdBQUcsTUFBTSxrQkFBa0IsQ0FDNUMsQ0FBQyxVQUFVLEVBQUUsR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDLEVBQ2xDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsRUFDYixNQUFNLENBQUMsSUFBSSxDQUNaLENBQUM7SUFDRixJQUFJLGFBQWEsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFLENBQUM7UUFDL0IsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQsSUFBSSxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ3RCLEdBQUcsRUFBRSxDQUNILHdDQUF3QyxhQUFhO2FBQ2xELEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQzthQUNwQixJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FDakIsQ0FBQztJQUNKLENBQUM7SUFFRCxPQUFPLElBQUksQ0FBQztBQUNkLENBQUM7QUF2QkQsa0RBdUJDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgY3J5cHRvIGZyb20gXCJjcnlwdG9cIjtcbmltcG9ydCB7IG1rZGlyU3luYywgcmVhbHBhdGhTeW5jLCBzdGF0U3luYywgd3JpdGVGaWxlU3luYyB9IGZyb20gXCJmc1wiO1xuaW1wb3J0IHsgc3RhdCB9IGZyb20gXCJmcy9wcm9taXNlc1wiO1xuaW1wb3J0IHsgcG9zaXgsIHJlc29sdmUgfSBmcm9tIFwicGF0aFwiO1xuaW1wb3J0IHsgZGVjb2RlLCBlbmNvZGUgfSBmcm9tIFwidmxxXCI7XG5pbXBvcnQgeyBub3JtYWxQYXRoIH0gZnJvbSBcIi4vbWlzY1wiO1xuXG5jb25zdCBTREtfUEFUSCA9IG5vcm1hbFBhdGgocmVzb2x2ZShfX2Rpcm5hbWUsIFwiLi5cIiwgXCIuLlwiKSk7XG5cbi8vIFRPRE86IHJlZmFjdG9yIEJ1bmRsZSBpbnRvIGEgZGVkaWNhdGVkIGNsYXNzIHdpdGggbWV0aG9kcyB0byBjaGVjayBpZiB0aGUgYnVuZGxpbmcgaXNcbi8vIGZpbmlzaGVkLCBpbnZhbGlkYXRlZCwgZXRjLlxuXG5leHBvcnQgaW50ZXJmYWNlIEJ1bmRsZSB7XG4gIGRpcmVjdG9yeTogc3RyaW5nO1xuICBoYXNoOiBzdHJpbmc7XG4gIG91dGZpbGVQYXRoOiBzdHJpbmc7XG4gIHNvdXJjZW1hcFBhdGg6IHN0cmluZztcbiAgLyoqXG4gICAqIEEgbGlzdCBvZiBmaWxlcyB0aGF0IHdlcmUgdXNlZCB0byBjcmVhdGUgdGhlIGJ1bmRsZSAoZGlyZWN0bHkgb3IgaW5kaXJlY3RseSkuXG4gICAqIElmIG5vbmUgb2YgdGhlIGxpc3RlZCBmaWxlcyBoYXZlIGJlZW4gbW9kaWZpZWQgc2luY2UgdGhlIGxhc3QgYnVuZGxlLCBpdCdzICpwcm9iYWJseSogc2FmZSB0byByZXVzZSB0aGUgYnVuZGxlLlxuICAgKlxuICAgKiBOb3RlOiB0aGlzIGlzbid0IGZ1bGx5IHJlbGlhYmxlIHNpbmNlIHRoZXJlIGNhbiBiZSBlZGdlIGNhc2VzIHdoZXJlIG5vbmUgb2YgdGhlIGZpbGVzIGhhdmUgYmVlbiBtb2RpZmllZFxuICAgKiBidXQgYSBkaWZmZXJlbnQgYnVuZGxlIHdvdWxkIGJlIGdlbmVyYXRlZCBieSBlc2J1aWxkLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2V2YW53L2VzYnVpbGQvaXNzdWVzLzY3M1xuICAgKi9cbiAgaW5wdXRGaWxlczogc3RyaW5nW107XG4gIHRpbWU6IERhdGU7XG59XG5cbi8qKlxuICogQnVuZGxlcyBhIGphdmFzY3JpcHQgZW50cnlwb2ludCBpbnRvIGEgc2luZ2xlIGZpbGUuXG4gKiBAcGFyYW0gZW50cnlwb2ludCBUaGUgamF2YXNjcmlwdCBlbnRyeXBvaW50XG4gKiBAcGFyYW0gb3V0cHV0RGlyIERlZmF1bHRzIHRvIGAke2VudHJ5cG9pbnR9LmJ1bmRsZWBcbiAqIEBwYXJhbSBleHRlcm5hbCBleHRlcm5hbCBwYWNrYWdlc1xuICogQHJldHVybnMgQnVuZGxlIGluZm9ybWF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVCdW5kbGUoXG4gIGVudHJ5cG9pbnQ6IHN0cmluZyxcbiAgZXh0ZXJuYWw6IHN0cmluZ1tdID0gW10sXG4gIG91dHB1dERpcj86IHN0cmluZ1xuKTogQnVuZGxlIHtcbiAgY29uc3Qgbm9ybWFsRW50cnlwb2ludCA9IG5vcm1hbFBhdGgocmVhbHBhdGhTeW5jKGVudHJ5cG9pbnQpKTtcbiAgY29uc3Qgb3V0ZGlyID0gb3V0cHV0RGlyXG4gICAgPyBub3JtYWxQYXRoKHJlYWxwYXRoU3luYyhvdXRwdXREaXIpKVxuICAgIDogYCR7bm9ybWFsRW50cnlwb2ludH0uYnVuZGxlYDtcbiAgbWtkaXJTeW5jKG91dGRpciwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG5cbiAgY29uc3Qgb3V0ZmlsZU5hbWUgPSBcImluZGV4LmNqc1wiO1xuICBjb25zdCBzb3VjZW1hcEZpbGVuYW1lID0gYCR7b3V0ZmlsZU5hbWV9Lm1hcGA7XG5cbiAgY29uc3Qgb3V0ZmlsZSA9IHBvc2l4LmpvaW4ob3V0ZGlyLCBvdXRmaWxlTmFtZSk7XG4gIGNvbnN0IG91dGZpbGVNYXAgPSBwb3NpeC5qb2luKG91dGRpciwgc291Y2VtYXBGaWxlbmFtZSk7XG5cbiAgY29uc3Qgc3RhdHMgPSBzdGF0U3luYyhub3JtYWxFbnRyeXBvaW50KTtcblxuICAvLyBUcmFjayB3aGF0IHRpbWUgd2Ugc3RhcnRlZCBidW5kbGluZyBzbyB3ZSBjYW4gaW52YWxpZGF0ZSB0aGUgYnVuZGxlIGlmIGFueVxuICAvLyBvZiB0aGUgc291cmNlIGZpbGVzIGFyZSBtb2RpZmllZCBhZnRlciB0aGlzIHRpbWUuXG4gIGxldCBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpO1xuXG4gIC8vIEZvciB1bmtub3duIHJlYXNvbnMsIHRoZSBkYXRlIGNyZWF0ZWQgaGVyZSBieSBKYXZhU2NyaXB0IGNhbiBzb21ldGltZXMgYmUgYVxuICAvLyBmZXcgbWlsbGlzZWNvbmRzIGJlZm9yZSB0aGUgbGFzdCBtb2RpZmljYXRpb24gZGF0ZSBvZiB0aGUgZW50cnlwb2ludCBmaWxlLlxuICAvLyBUaGlzIGNhbiBjYXVzZSB0aGUgYnVuZGxlIHRvIGJlIGludmFsaWRhdGVkIHdoZW4gaXQgc2hvdWxkbid0IGJlLiBUb1xuICAvLyBwcmV2ZW50IHRoaXMgZmxha2luZXNzIGluIHVuaXQgdGVzdHMsIHdlIGNoZWNrIGlmIHRoZSBtb2RpZmljYXRpb24gZGF0ZSBvZiB0aGVcbiAgLy8gZW50cnlwb2ludCBmaWxlIGFuZCB1cGRhdGUgdGhlIHN0YXJ0IHRpbWUgaWYgaXQncyBuZXdlci5cbiAgaWYgKHN0YXRzLm10aW1lID4gc3RhcnRUaW1lKSB7XG4gICAgc3RhcnRUaW1lID0gc3RhdHMubXRpbWU7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzLEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHNcbiAgY29uc3QgZXNidWlsZGVyOiB0eXBlb2YgaW1wb3J0KFwiZXNidWlsZFwiKSA9IHJlcXVpcmUoXCJlc2J1aWxkXCIpO1xuXG4gIGxldCBlc2J1aWxkID0gZXNidWlsZGVyLmJ1aWxkU3luYyh7XG4gICAgYnVuZGxlOiB0cnVlLFxuICAgIGVudHJ5UG9pbnRzOiBbbm9ybWFsRW50cnlwb2ludF0sXG4gICAgb3V0ZmlsZSxcbiAgICAvLyBvdGhlcndpc2UgdGhlcmUgYXJlIHByb2JsZW1zIHdpdGggcnVubmluZyBhenVyZSBjbG91ZCBmdW5jdGlvbnM6XG4gICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzAzMzI4ODMvd2VicGFjay1henVyZS1zdG9yYWdlLWJsb2Itbm9kZS1mZXRjaC1hYm9ydHNpZ25hbC1pc3N1ZVxuICAgIGtlZXBOYW1lczogdHJ1ZSxcbiAgICAvLyBpZiB0aGUgdXNlciBoYXMgc3BlY2lmaWVkIGEgbm9kZV9tb2R1bGVzIGRpcmVjdG9yeSB0byByZXNvbHZlIGZyb21cbiAgICBub2RlUGF0aHM6IHByb2Nlc3MuZW52LldJTkdfTk9ERV9NT0RVTEVTXG4gICAgICA/IFtub3JtYWxQYXRoKHByb2Nlc3MuZW52LldJTkdfTk9ERV9NT0RVTEVTIGFzIHN0cmluZyldXG4gICAgICA6IHVuZGVmaW5lZCxcbiAgICBhbGlhczoge1xuICAgICAgXCJAd2luZ2xhbmcvc2RrXCI6IFNES19QQVRILFxuICAgIH0sXG4gICAgbWluaWZ5OiBmYWxzZSxcbiAgICBzb3VyY2VtYXA6IFwibGlua2VkXCIsXG4gICAgcGxhdGZvcm06IFwibm9kZVwiLFxuICAgIHRhcmdldDogXCJub2RlMjBcIixcbiAgICBmb3JtYXQ6IFwiY2pzXCIsXG4gICAgZXh0ZXJuYWwsXG4gICAgbWV0YWZpbGU6IHRydWUsXG4gICAgd3JpdGU6IGZhbHNlLFxuICB9KTtcblxuICBpZiAoZXNidWlsZC5lcnJvcnMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGVycm9ycyA9IGVzYnVpbGQuZXJyb3JzLm1hcCgoZSkgPT4gZS50ZXh0KS5qb2luKFwiXFxuXCIpO1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGJ1bmRsZSBmdW5jdGlvbjogJHtlcnJvcnN9YCk7XG4gIH1cblxuICBjb25zdCBidW5kbGVPdXRwdXQgPSBlc2J1aWxkLm91dHB1dEZpbGVzWzFdO1xuXG4gIC8vIGVuc3VyZSBzb3VyY2UgcGF0aHMgaGF2ZSBwb3NpeCBwYXRoIHNlcGFyYXRvcnNcbiAgY29uc3Qgc291cmNlbWFwRGF0YSA9IEpTT04ucGFyc2UoXG4gICAgbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGVzYnVpbGQub3V0cHV0RmlsZXNbMF0uY29udGVudHMpXG4gICk7XG4gIGZpeFNvdXJjZW1hcHMoc291cmNlbWFwRGF0YSk7XG5cbiAgd3JpdGVGaWxlU3luYyhvdXRmaWxlLCBidW5kbGVPdXRwdXQuY29udGVudHMpO1xuICB3cml0ZUZpbGVTeW5jKG91dGZpbGVNYXAsIEpTT04uc3RyaW5naWZ5KHNvdXJjZW1hcERhdGEpKTtcblxuICAvLyBjYWxjdWxhdGUgYSBtZDUgaGFzaCBvZiB0aGUgY29udGVudHMgb2YgYXNzZXQucGF0aFxuICBjb25zdCBjb2RlSGFzaCA9IGNyeXB0b1xuICAgIC5jcmVhdGVIYXNoKFwibWQ1XCIpXG4gICAgLnVwZGF0ZShidW5kbGVPdXRwdXQuY29udGVudHMpXG4gICAgLmRpZ2VzdChcImhleFwiKTtcblxuICBjb25zdCBvdXRLZXlzID0gT2JqZWN0LmtleXMoZXNidWlsZC5tZXRhZmlsZT8ub3V0cHV0cyA/PyB7fSk7XG4gIGNvbnN0IG91dEtleSA9IG91dEtleXMuZmluZCgoaykgPT4gay5lbmRzV2l0aChvdXRmaWxlTmFtZSkpO1xuICBpZiAoIW91dEtleSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ291bGRuJ3QgZmluZCBtZXRhZGF0YSBmb3IgJHtvdXRmaWxlTmFtZX0gZnJvbSBlc2J1aWxkLmApO1xuICB9XG5cbiAgY29uc3QgaW5wdXRGaWxlcyA9IE9iamVjdC5rZXlzKGVzYnVpbGQubWV0YWZpbGU/Lm91dHB1dHNbb3V0S2V5XS5pbnB1dHMpO1xuXG4gIHJldHVybiB7XG4gICAgZGlyZWN0b3J5OiBvdXRkaXIsXG4gICAgaGFzaDogY29kZUhhc2gsXG4gICAgb3V0ZmlsZVBhdGg6IG91dGZpbGUsXG4gICAgc291cmNlbWFwUGF0aDogb3V0ZmlsZU1hcCxcbiAgICBpbnB1dEZpbGVzLFxuICAgIHRpbWU6IHN0YXJ0VGltZSxcbiAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTb3VyY2VNYXAge1xuICBzb3VyY2VSb290Pzogc3RyaW5nO1xuICBzb3VyY2VzOiBzdHJpbmdbXTtcbiAgc291cmNlc0NvbnRlbnQ6IHN0cmluZ1tdO1xuICBtYXBwaW5nczogc3RyaW5nO1xufVxuXG4vKipcbiAqIFRha2VzIGEgYnVuZGxlZCBzb3VyY2VtYXAgYW5kIGRvZXMgdGhlIGZvbGxvd2luZyBmaXhlczpcbiAqIC0gTm9ybWFsaXplcyBwYXRocyBpbiBzb3VyY2VzIGFuZCBzb3VyY2VSb290XG4gKiAtIFJlbW92ZXMgZHVwbGljYXRlIHNvdXJjZXMgYW5kIHNvdXJjZXNDb250ZW50XG4gKiAtIFVwZGF0ZXMgbWFwcGluZ3MgdG8gcmVmbGVjdCB0aGUgbmV3IHNvdXJjZSBpbmRpY2VzXG4gKlxuICogVGhlIGR1cGxpY2F0ZSBzb3VyY2VzIGNvbWUgZnJvbSBlc2J1aWxkJ3Mgc3RyYW5nZSBoYW5kbGluZyBvZiBtdWx0aXBsZSBmaWxlcyBiZWluZyBidW5kbGVkIHRoYXQgcG9pbnQgdG8gdGhlIHNhbWUgc291cmNlIChlLmcuIGluZmxpZ2h0cyB0aGF0IHBvaW50IHRvIG9uZSAudyBmaWxlKVxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ldmFudy9lc2J1aWxkL2lzc3Vlcy85MzNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpeFNvdXJjZW1hcHMoc291cmNlbWFwRGF0YTogU291cmNlTWFwKTogdm9pZCB7XG4gIC8vIG5vcm1hbGl6ZSBzb3VyY2VSb290XG4gIGlmIChzb3VyY2VtYXBEYXRhLnNvdXJjZVJvb3QpIHtcbiAgICBzb3VyY2VtYXBEYXRhLnNvdXJjZVJvb3QgPSBub3JtYWxQYXRoKHNvdXJjZW1hcERhdGEuc291cmNlUm9vdCk7XG4gIH1cblxuICAvLyBub3JtYWxpemUgc291cmNlcyBhbmQgcmVtb3ZlIGR1cGxpY2F0ZXNcbiAgY29uc3Qgc291cmNlU2V0OiBzdHJpbmdbXSA9IFtdO1xuICBjb25zdCBuZXdTb3VyY2VDb250ZW50czogc3RyaW5nW10gPSBbXTtcbiAgY29uc3Qgc291cmNlSW5kZXhNYXA6IFJlY29yZDxudW1iZXIsIG51bWJlcj4gPSB7fTtcbiAgbGV0IGhhc1NvdXJjZUR1cGVzID0gZmFsc2U7XG4gIHNvdXJjZW1hcERhdGEuc291cmNlcy5mb3JFYWNoKChzb3VyY2UsIGlkeCkgPT4ge1xuICAgIGNvbnN0IG5ld1BhdGggPSBub3JtYWxQYXRoKHNvdXJjZSk7XG4gICAgc291cmNlbWFwRGF0YS5zb3VyY2VzW2lkeF0gPSBuZXdQYXRoO1xuXG4gICAgY29uc3QgZXhpc3RpbmdJbmRleCA9IHNvdXJjZVNldC5pbmRleE9mKG5ld1BhdGgpO1xuICAgIGlmIChleGlzdGluZ0luZGV4ID09PSAtMSkge1xuICAgICAgc291cmNlU2V0LnB1c2gobmV3UGF0aCk7XG4gICAgICBuZXdTb3VyY2VDb250ZW50cy5wdXNoKHNvdXJjZW1hcERhdGEuc291cmNlc0NvbnRlbnRbaWR4XSk7XG4gICAgICBzb3VyY2VJbmRleE1hcFtpZHhdID0gc291cmNlU2V0Lmxlbmd0aCAtIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhhc1NvdXJjZUR1cGVzID0gdHJ1ZTtcbiAgICAgIHNvdXJjZUluZGV4TWFwW2lkeF0gPSBleGlzdGluZ0luZGV4O1xuICAgIH1cbiAgfSk7XG5cbiAgc291cmNlbWFwRGF0YS5zb3VyY2VzID0gc291cmNlU2V0O1xuICBzb3VyY2VtYXBEYXRhLnNvdXJjZXNDb250ZW50ID0gbmV3U291cmNlQ29udGVudHM7XG5cbiAgLy8gZmFzdCBwYXRoOiBObyBzb3VyY2UgZHVwbGljYXRlcyBzbyBubyBuZWVkIHRvIHVwZGF0ZSBtYXBwaW5nc1xuICBpZiAoIWhhc1NvdXJjZUR1cGVzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gdXBkYXRlIG1hcHBpbmdzXG4gIGxldCBuZXdNYXBwaW5nID0gXCJcIjtcbiAgbGV0IGNoYXJhY3RlckluZGV4ID0gMDtcbiAgbGV0IGxhc3RGaWxlID0gMDtcbiAgbGV0IGxhc3RUcnVlRmlsZSA9IDA7XG4gIHdoaWxlIChjaGFyYWN0ZXJJbmRleCA8IHNvdXJjZW1hcERhdGEubWFwcGluZ3MubGVuZ3RoKSB7XG4gICAgY29uc3QgY2hhciA9IHNvdXJjZW1hcERhdGEubWFwcGluZ3NbY2hhcmFjdGVySW5kZXhdO1xuICAgIC8vIGA7YCBhbmQgYCxgIGFyZSBzZXBhcmF0b3JzIGJldHdlZW4gdGhlIHNlZ21lbnRzIG9mIGludGVyZXN0XG4gICAgaWYgKGNoYXIgPT09IFwiO1wiIHx8IGNoYXIgPT09IFwiLFwiKSB7XG4gICAgICBuZXdNYXBwaW5nICs9IGNoYXI7XG4gICAgICBjaGFyYWN0ZXJJbmRleCsrO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gZ2V0IG5leHQgc2xpY2Ugb2Ygc2VnbWVudCBkYXRhXG4gICAgbGV0IHNlZ21lbnQgPSBcIlwiO1xuICAgIGxldCBuZXh0Q2hhciA9IGNoYXI7XG4gICAgd2hpbGUgKG5leHRDaGFyICE9PSB1bmRlZmluZWQgJiYgbmV4dENoYXIgIT09IFwiLFwiICYmIG5leHRDaGFyICE9PSBcIjtcIikge1xuICAgICAgc2VnbWVudCArPSBuZXh0Q2hhcjtcbiAgICAgIG5leHRDaGFyID0gc291cmNlbWFwRGF0YS5tYXBwaW5nc1srK2NoYXJhY3RlckluZGV4XTtcbiAgICB9XG4gICAgY29uc3QgZGVjb2RlZCA9IGRlY29kZShzZWdtZW50KTtcbiAgICBpZiAoZGVjb2RlZC5sZW5ndGggPT09IDEpIHtcbiAgICAgIG5ld01hcHBpbmcgKz0gc2VnbWVudDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHNvdXJjZVJlbGF0aXZlID0gZGVjb2RlZFsxXTtcbiAgICBjb25zdCBvcmlnaW5hbFNvdXJjZSA9IGxhc3RUcnVlRmlsZSArIHNvdXJjZVJlbGF0aXZlO1xuICAgIGNvbnN0IG5ld1NvdXJjZUluZGV4ID0gc291cmNlSW5kZXhNYXBbb3JpZ2luYWxTb3VyY2VdO1xuICAgIGxhc3RUcnVlRmlsZSA9IG9yaWdpbmFsU291cmNlO1xuXG4gICAgY29uc3QgbmV3UmVsYXRpdmVWYWx1ZSA9IG5ld1NvdXJjZUluZGV4IC0gbGFzdEZpbGU7XG4gICAgbGFzdEZpbGUgPSBuZXdTb3VyY2VJbmRleDtcblxuICAgIGlmIChuZXdSZWxhdGl2ZVZhbHVlID09PSBkZWNvZGVkWzFdKSB7XG4gICAgICAvLyBubyBjaGFuZ2Ugd2FzIG1hZGUsIGF2b2lkIHJlLWVuY29kaW5nXG4gICAgICBuZXdNYXBwaW5nICs9IHNlZ21lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlY29kZWRbMV0gPSBuZXdSZWxhdGl2ZVZhbHVlO1xuICAgICAgbmV3TWFwcGluZyArPSBlbmNvZGUoZGVjb2RlZCk7XG4gICAgfVxuICB9XG5cbiAgc291cmNlbWFwRGF0YS5tYXBwaW5ncyA9IG5ld01hcHBpbmc7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmaWxlc01vZGlmaWVkU2luY2UoXG4gIGZpbGVQYXRoczogc3RyaW5nW10sXG4gIGRpcmVjdG9yeTogc3RyaW5nLFxuICBkYXRlVGltZTogRGF0ZVxuKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICBjb25zdCBhYnNvbHV0ZVBhdGhzID0gZmlsZVBhdGhzLm1hcCgoZmlsZVBhdGgpID0+XG4gICAgcmVzb2x2ZShkaXJlY3RvcnksIGZpbGVQYXRoKVxuICApO1xuXG4gIHRyeSB7XG4gICAgY29uc3Qgc3RhdHNQcm9taXNlcyA9IGFic29sdXRlUGF0aHMubWFwKChmaWxlUGF0aCkgPT4gc3RhdChmaWxlUGF0aCkpO1xuICAgIGNvbnN0IHN0YXRzID0gYXdhaXQgUHJvbWlzZS5hbGwoc3RhdHNQcm9taXNlcyk7XG4gICAgY29uc3QgY2hhbmdlZEZpbGVzID0gbmV3IEFycmF5PHN0cmluZz4oKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWJzb2x1dGVQYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHN0YXRzW2ldLm10aW1lID4gZGF0ZVRpbWUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBgRmlsZSAke2Fic29sdXRlUGF0aHNbaV19IGhhcyBiZWVuIG1vZGlmaWVkIHNpbmNlIHRoZSBsYXN0IGJ1bmRsZWAsXG4gICAgICAgICAgc3RhdHNbaV0ubXRpbWUsXG4gICAgICAgICAgZGF0ZVRpbWVcbiAgICAgICAgKTtcbiAgICAgICAgY2hhbmdlZEZpbGVzLnB1c2goYWJzb2x1dGVQYXRoc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoYW5nZWRGaWxlcztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY2hlY2tpbmcgZmlsZSBtb2RpZmljYXRpb24gdGltZXM6XCIsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaXNCdW5kbGVJbnZhbGlkYXRlZChcbiAgZW50cnlwb2ludDogc3RyaW5nLFxuICBidW5kbGU6IEJ1bmRsZSxcbiAgbG9nPzogKG1zZzogc3RyaW5nKSA9PiB2b2lkXG4pOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgY29uc3QgbW9kaWZpZWRGaWxlcyA9IGF3YWl0IGZpbGVzTW9kaWZpZWRTaW5jZShcbiAgICBbZW50cnlwb2ludCwgLi4uYnVuZGxlLmlucHV0RmlsZXNdLFxuICAgIHByb2Nlc3MuY3dkKCksXG4gICAgYnVuZGxlLnRpbWVcbiAgKTtcbiAgaWYgKG1vZGlmaWVkRmlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52LkRFQlVHKSB7XG4gICAgbG9nPy4oXG4gICAgICBgRmlsZXMgbW9kaWZpZWQgc2luY2UgbGFzdCBidW5kbGluZzogWyR7bW9kaWZpZWRGaWxlc1xuICAgICAgICAubWFwKCh4KSA9PiBgXCIke3h9XCJgKVxuICAgICAgICAuam9pbihcIiwgXCIpfV1gXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuIl19