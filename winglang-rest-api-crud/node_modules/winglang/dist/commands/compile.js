"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.compile = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const wingCompiler = __importStar(require("@winglang/compiler"));
const enhanced_error_1 = require("@winglang/sdk/lib/util/enhanced-error");
const chalk_1 = __importDefault(require("chalk"));
const codespan_wasm_1 = require("codespan-wasm");
const debug_1 = __importDefault(require("debug"));
const glob_1 = require("glob");
const env_1 = require("../env");
// increase the stack trace limit to 50, useful for debugging Rust panics
// (not setting the limit too high in case of infinite recursion)
Error.stackTraceLimit = 50;
const log = (0, debug_1.default)("wing:compile");
/**
 * Compiles a Wing program. Throws an error if compilation fails.
 * @param entrypoint The program .w entrypoint.
 * @param options Compile options.
 * @returns the output directory
 */
async function compile(entrypoint, options) {
    if (!entrypoint) {
        const wingFiles = (await (0, glob_1.glob)("{main,*.main}.{w,ts}")).sort();
        if (wingFiles.length === 0) {
            throw new Error("Cannot find an entrypoint file (main.w, main.ts, *.main.w, *.main.ts) in the current directory.");
        }
        if (wingFiles.length > 1) {
            throw new Error(`Multiple entrypoints found in the current directory (${wingFiles.join(", ")}). Please specify which one to use.`);
        }
        entrypoint = wingFiles[0];
    }
    (0, env_1.loadEnvVariables)({ cwd: (0, path_1.resolve)((0, path_1.dirname)(entrypoint)) });
    const coloring = chalk_1.default.supportsColor ? chalk_1.default.supportsColor.hasBasic : false;
    try {
        return await wingCompiler.compile(entrypoint, {
            ...options,
            log,
            color: coloring,
            platform: options?.platform ?? ["sim"],
        });
    }
    catch (error) {
        if (error instanceof wingCompiler.CompileError) {
            // This is a bug in the user's code. Print the compiler diagnostics.
            const diagnostics = error.diagnostics;
            const cwd = process.cwd();
            const result = [];
            for (const diagnostic of diagnostics) {
                const { message, span, annotations, hints } = diagnostic;
                const files = [];
                const labels = [];
                // file_id might be "" if the span is synthetic (see #2521)
                if (span?.file_id) {
                    // `span` should only be null if source file couldn't be read etc.
                    const source = await fs_1.promises.readFile(span.file_id, "utf8");
                    const start = span.start_offset;
                    const end = span.end_offset;
                    const filePath = (0, path_1.relative)(cwd, span.file_id);
                    files.push({ name: filePath, source });
                    labels.push({
                        fileId: filePath,
                        rangeStart: start,
                        rangeEnd: end,
                        message: "",
                        style: "primary",
                    });
                }
                for (const annotation of annotations) {
                    // file_id might be "" if the span is synthetic (see #2521)
                    if (!annotation.span?.file_id) {
                        continue;
                    }
                    const source = await fs_1.promises.readFile(annotation.span.file_id, "utf8");
                    const start = annotation.span.start_offset;
                    const end = annotation.span.end_offset;
                    const filePath = (0, path_1.relative)(cwd, annotation.span.file_id);
                    files.push({ name: filePath, source });
                    labels.push({
                        fileId: filePath,
                        rangeStart: start,
                        rangeEnd: end,
                        message: annotation.message,
                        style: "secondary",
                    });
                }
                const diagnosticText = (0, codespan_wasm_1.emitDiagnostic)(files, {
                    message,
                    severity: "error",
                    labels,
                    notes: hints.map((hint) => `hint: ${hint}`),
                }, {
                    chars: codespan_wasm_1.CHARS_ASCII,
                }, coloring);
                result.push(diagnosticText);
            }
            throw new Error(result.join("\n"));
        }
        else if (error instanceof wingCompiler.PreflightError) {
            let output = await (0, enhanced_error_1.prettyPrintError)(error.causedBy, {
                chalk: chalk_1.default,
                sourceEntrypoint: (0, path_1.resolve)(entrypoint ?? "."),
            });
            if (process.env.DEBUG) {
                output +=
                    "\n--------------------------------- ORIGINAL STACK TRACE ---------------------------------\n" +
                        (error.causedBy.stack ?? "(no stacktrace available)");
            }
            error.causedBy.message = output;
            throw error.causedBy;
        }
        else {
            throw error;
        }
    }
}
exports.compile = compile;
//# sourceMappingURL=compile.js.map