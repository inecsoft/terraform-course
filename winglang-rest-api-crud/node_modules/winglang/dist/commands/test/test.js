"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.terraformInit = exports.awsCdkDestroy = exports.awsCdkDeploy = exports.filterTests = exports.renderTestReport = exports.test = exports.collectTestFiles = void 0;
const cp = __importStar(require("child_process"));
const fs_1 = require("fs");
const path_1 = require("path");
const util_1 = require("util");
const promise_pool_1 = require("@supercharge/promise-pool");
const compiler_1 = require("@winglang/compiler");
const sdk_1 = require("@winglang/sdk");
const std_1 = require("@winglang/sdk/lib/std");
const util_2 = require("@winglang/sdk/lib/util");
const enhanced_error_1 = require("@winglang/sdk/lib/util/enhanced-error");
const chalk_1 = __importDefault(require("chalk"));
const debug_1 = __importDefault(require("debug"));
const glob_1 = require("glob");
const nanoid_1 = require("nanoid");
const results_1 = require("./results");
const snapshots_1 = require("./snapshots");
const snapshots_help_1 = require("./snapshots-help");
const trace_processor_1 = require("./trace-processor");
const util_3 = require("./util");
const util_4 = require("../../util");
const compile_1 = require("../compile");
const spinner_stream_1 = require("../spinner-stream");
const log = (0, debug_1.default)("wing:test");
const ENV_WING_TEST_RUNNER_FUNCTION_IDENTIFIERS = "WING_TEST_RUNNER_FUNCTION_IDENTIFIERS";
const ENV_WING_TEST_RUNNER_FUNCTION_IDENTIFIERS_AWSCDK = "WingTestRunnerFunctionArns";
const TEST_FILE_PATTERNS = ["**/*.test.w", "**/{main,*.main}.{w,ts}"];
const TEST_FILE_IGNORE = ["**/node_modules/**", "**/target/**"];
/**
 * Collects all the test files that should be run.
 * If no entrypoints are specified, all the entrypoint files in the current directory (recursive) are collected.
 * This excludes node_modules and target directories.
 *
 * If entrypoints are specified, only the files that contain the entrypoint string are collected.
 */
async function collectTestFiles(entrypoints = []) {
    const expandedEntrypoints = await (0, glob_1.glob)(TEST_FILE_PATTERNS, {
        ignore: TEST_FILE_IGNORE,
        absolute: false,
        posix: true,
    });
    // check if any of the entrypoints are exact files
    const exactEntrypoints = entrypoints.filter((e) => (0, fs_1.statSync)(e, { throwIfNoEntry: false })?.isFile() === true);
    const fuzzyEntrypoints = entrypoints.filter((e) => !exactEntrypoints.includes(e));
    let finalEntrypoints = exactEntrypoints;
    if (fuzzyEntrypoints.length > 0) {
        // if entrypoints are specified, filter the expanded entrypoints to ones that contain them
        finalEntrypoints = finalEntrypoints.concat(expandedEntrypoints.filter((e) => fuzzyEntrypoints.some((f) => e.includes(f))));
    }
    else if (exactEntrypoints.length === 0) {
        finalEntrypoints = finalEntrypoints.concat(expandedEntrypoints);
    }
    // dedupe based on real path, then get all paths as relative to cwd
    const cwd = process.cwd();
    return [...new Set(finalEntrypoints.map((e) => (0, fs_1.realpathSync)(e)))].map((e) => (0, path_1.relative)(cwd, e));
}
exports.collectTestFiles = collectTestFiles;
async function test(entrypoints, options) {
    if (options.outputFile) {
        (0, results_1.validateOutputFilePath)(options.outputFile);
    }
    const selectedEntrypoints = await collectTestFiles(entrypoints);
    if (selectedEntrypoints.length === 0) {
        throw new Error(`No matching test or entrypoint files found: [${entrypoints.join(", ")}]`);
    }
    const startTime = Date.now();
    const results = [];
    process.env.WING_TARGET = (0, compiler_1.determineTargetFromPlatforms)(options.platform ?? []);
    const testFile = async (entrypoint) => {
        const testName = (0, util_3.renderTestName)(entrypoint);
        try {
            const singleTestResults = await testOne(testName, entrypoint, options);
            results.push(singleTestResults);
        }
        catch (error) {
            console.log(error.message);
            const snapshot = error.message?.startsWith(snapshots_help_1.SNAPSHOT_ERROR_PREFIX)
                ? snapshots_1.SnapshotResult.MISMATCH
                : snapshots_1.SnapshotResult.SKIPPED;
            results.push({
                testName,
                snapshot,
                results: [
                    {
                        pass: false,
                        unsupported: error.name === "NotImplementedError",
                        unsupportedResource: error.resource,
                        unsupportedOperation: error.operation,
                        path: "*",
                        error: error.message,
                        traces: [],
                    },
                ],
            });
        }
    };
    await promise_pool_1.PromisePool.withConcurrency(options.parallel || selectedEntrypoints.length)
        .for(selectedEntrypoints)
        .process(testFile);
    const testDuration = Date.now() - startTime;
    (0, results_1.printResults)(results, testDuration);
    if (options.outputFile) {
        await (0, results_1.writeResultsToFile)(results, testDuration, options.outputFile, options.platform);
    }
    // if we have any failures, exit with 1
    for (const testSuite of results) {
        for (const r of testSuite.results) {
            if (!r.pass && !r.unsupported) {
                return 1;
            }
        }
    }
    return 0;
}
exports.test = test;
async function testOne(testName, entrypoint, options) {
    const target = (0, compiler_1.determineTargetFromPlatforms)(options.platform);
    // determine snapshot behavior
    const snapshotMode = (0, snapshots_1.determineSnapshotMode)(target, options);
    const shouldExecute = snapshotMode === snapshots_1.SnapshotMode.NEVER || snapshotMode === snapshots_1.SnapshotMode.DEPLOY;
    let results = [];
    if (shouldExecute) {
        const synthDir = await (0, util_4.withSpinner)(`Compiling ${(0, util_3.renderTestName)(entrypoint)} to ${target}...`, async () => (0, compile_1.compile)(entrypoint, {
            ...options,
            rootId: options.rootId ?? `Test.${(0, nanoid_1.nanoid)(10)}`,
            testing: true,
        }));
        results = await executeTest(synthDir, target, options);
    }
    // if one of the tests failed, return the results without updating any snapshots.
    const success = !results.some((r) => !r.pass);
    let snapshot = snapshots_1.SnapshotResult.SKIPPED;
    // if all tests pass, capture snapshots
    if (success) {
        snapshot = await (0, snapshots_1.captureSnapshot)(entrypoint, target, options);
    }
    return {
        testName,
        results: results,
        snapshot,
    };
}
async function executeTest(synthDir, target, options) {
    switch (target) {
        case compiler_1.BuiltinPlatform.SIM:
            return testSimulator(synthDir, options);
        case compiler_1.BuiltinPlatform.TF_AZURE:
        case compiler_1.BuiltinPlatform.TF_AWS:
        case compiler_1.BuiltinPlatform.TF_GCP:
            return testTf(synthDir, options);
        case compiler_1.BuiltinPlatform.AWSCDK:
            return testAwsCdk(synthDir, options);
        default:
            throw new Error(`unsupported target ${target}`);
    }
}
/**
 * Render a test report for printing out to the console.
 */
async function renderTestReport(entrypoint, results, includeLogs = true) {
    const out = new Array();
    // find the longest `path` of all the tests
    const longestPath = results.reduce((longest, result) => (result.path.length > longest ? result.path.length : longest), 0);
    // if there are no inflight tests, add a dummy "pass" result
    // to indicate that compilation and preflight checks passed
    if (results.length === 0) {
        results.push({
            pass: true,
            path: "",
            traces: [],
        });
    }
    for (const result of results.sort(sortTests)) {
        const status = result.pass ? chalk_1.default.green("pass") : chalk_1.default.red("fail");
        const details = new Array();
        if (includeLogs) {
            for (const trace of result.traces) {
                if (shouldSkipTrace(trace)) {
                    continue;
                }
                details.push(chalk_1.default.gray(trace.data.message));
            }
        }
        // if the test failed, add the error message and trace
        if (result.error) {
            const err = await (0, enhanced_error_1.prettyPrintError)(result.error, { chalk: chalk_1.default });
            details.push(...err.split("\n"));
        }
        // construct the first row of the test result by collecting the various components and joining
        // them with spaces.
        const firstRow = new Array();
        firstRow.push(status);
        // if we have details, surround the rows with a box, otherwise, just print a line
        if (details.length > 0) {
            firstRow.push(chalk_1.default.gray("┌"));
        }
        else {
            firstRow.push(chalk_1.default.gray("─"));
        }
        firstRow.push((0, path_1.basename)(entrypoint));
        if (result.path?.length > 0) {
            firstRow.push(chalk_1.default.gray("»"));
            firstRow.push(chalk_1.default.whiteBright(result.path.padEnd(longestPath)));
        }
        else {
            firstRow.push(chalk_1.default.gray("(no tests)"));
        }
        // okay we are ready to print the test result
        // print the primary description of the test
        out.push(firstRow.join(" "));
        // print additional rows that are related to this test
        for (let i = 0; i < details.length; i++) {
            const left = i === details.length - 1 ? "└" : "│";
            out.push(`    ${chalk_1.default.gray(` ${left} `)}${details[i]}`);
        }
    }
    return out.join("\n");
}
exports.renderTestReport = renderTestReport;
function testResultsContainsFailure(results) {
    return results.some((r) => !r.pass);
}
function noCleanUp(synthDir) {
    console.log(chalk_1.default.yellowBright.bold(`Cleanup is disabled!\nOutput files available at ${(0, path_1.resolve)(synthDir)}`));
}
function filterTests(tests, regexString) {
    if (regexString) {
        const regex = new RegExp(regexString);
        return tests.filter((t) => {
            // Extract test name from the string
            // root/env0/test:<testName>
            const firstColonIndex = t.indexOf(":");
            const testName = t.substring(firstColonIndex + 1);
            return testName ? regex.test(testName) : false;
        });
    }
    else {
        return tests;
    }
}
exports.filterTests = filterTests;
async function runTestsWithRetry(testRunner, tests, retries) {
    let runCount = retries + 1;
    let remainingTests = tests;
    const results = [];
    while (runCount > 0 && remainingTests.length > 0) {
        const failedTests = [];
        for (const testPath of remainingTests) {
            const result = await testRunner.runTest(testPath);
            results.push(result);
            if (!result.pass) {
                failedTests.push(testPath);
            }
        }
        remainingTests = failedTests;
        if (remainingTests.length > 0 && runCount > 1) {
            console.log(`Retrying failed tests. ${runCount - 1} retries left.`);
        }
        runCount--;
    }
    return results;
}
const SEVERITY_STRING = {
    [std_1.LogLevel.ERROR]: "[ERROR]",
    [std_1.LogLevel.WARNING]: "[WARNING]",
    [std_1.LogLevel.INFO]: "[INFO]",
    [std_1.LogLevel.VERBOSE]: "[VERBOSE]",
};
const LOG_STREAM_COLORS = {
    [std_1.LogLevel.ERROR]: chalk_1.default.red,
    [std_1.LogLevel.WARNING]: chalk_1.default.yellow,
    [std_1.LogLevel.INFO]: chalk_1.default.green,
    [std_1.LogLevel.VERBOSE]: chalk_1.default.gray,
};
async function formatTrace(trace, testName, mode) {
    const level = trace.level;
    const date = new Date(trace.timestamp);
    const hours = date.getHours().toString().padStart(2, "0");
    const minutes = date.getMinutes().toString().padStart(2, "0");
    const seconds = date.getSeconds().toString().padStart(2, "0");
    const milliseconds = date.getMilliseconds().toString().padStart(3, "0");
    const timestamp = `${hours}:${minutes}:${seconds}.${milliseconds}`;
    let msg = "";
    if (mode === "full") {
        msg += chalk_1.default.dim(`[${timestamp}]`);
        msg += LOG_STREAM_COLORS[level](` ${SEVERITY_STRING[level]}`);
        msg += chalk_1.default.dim(` ${testName} » ${trace.sourcePath}`);
        msg += "\n";
        if (level === std_1.LogLevel.ERROR) {
            msg += await (0, enhanced_error_1.prettyPrintError)(trace.data.error ?? trace.data.message ?? trace.data, {
                chalk: chalk_1.default,
            });
        }
        else {
            msg += trace.data.message;
        }
        msg += "\n\n";
        return msg;
    }
    else if (mode === "short") {
        msg += LOG_STREAM_COLORS[level](`${SEVERITY_STRING[level]}`);
        msg += chalk_1.default.dim(` ${testName} | `);
        if (level === std_1.LogLevel.ERROR) {
            msg += await (0, enhanced_error_1.prettyPrintError)(trace.data.error ?? trace.data.message ?? trace.data, {
                chalk: chalk_1.default,
            });
        }
        else {
            msg += trace.data.message;
        }
        msg += "\n";
        return msg;
    }
    else {
        throw new Error(`Unknown mode: ${mode}`);
    }
}
function shouldSkipTrace(trace) {
    switch (trace.level) {
        // show VERBOSE only in debug mode
        case std_1.LogLevel.VERBOSE:
            return !process.env.DEBUG;
        // show INFO, WARNING, ERROR in all cases
        case std_1.LogLevel.INFO:
        case std_1.LogLevel.WARNING:
        case std_1.LogLevel.ERROR:
            return false;
    }
}
async function testSimulator(synthDir, options) {
    const s = new sdk_1.simulator.Simulator({ simfile: synthDir });
    const { clean, testFilter, retry } = options;
    let outputStream;
    let traceProcessor;
    if (options.stream) {
        // As of this comment, each Wing test is associated with an isolated environment.
        // (All resources for test #0 are in root/env0/..., etc.)
        // This means we can use the environment number to map each environment # to a test name,
        // so when we receive a trace from the simulator, we can infer which test it's associated with.
        const testMappings = extractTestMappings(s.listResources());
        const printEvent = async (event) => {
            const env = extractTestEnvFromPath(event.sourcePath);
            let testName = "(no test)";
            if (env !== undefined) {
                testName = testMappings[env] ?? testName;
            }
            if (testFilter && !testName.includes(testFilter) && testName !== "(no test)") {
                // This test does not match the filter, so skip it.
                return;
            }
            if (shouldSkipTrace(event)) {
                return;
            }
            const formatStyle = process.env.DEBUG ? "full" : "short";
            const formatted = await formatTrace(event, testName, formatStyle);
            outputStream.write(formatted);
        };
        // The simulator emits events synchronously, but formatting them needs to
        // happen asynchronously since e.g. files have to be read to format stack
        // traces. If we performed this async work inside of the `onTrace` callback,
        // we might end up with out-of-order traces, or traces getting printed (or
        // dropped) after the test has finished. TraceProcessor allows events to be
        // added to a queue and processed serially, and provides a way to safely
        // "await" the completion of the processing.
        traceProcessor = new trace_processor_1.TraceProcessor((event) => printEvent(event));
        // SpinnerStream is responsible for taking in lines of text and streaming
        // them to a TTY with a spinner, making sure to clear and re-print the
        // spinner when new lines are added.
        outputStream = new spinner_stream_1.SpinnerStream(process.stdout, "Running tests...");
        s.onTrace({
            callback: (event) => {
                traceProcessor.addEvent(event);
            },
        });
    }
    try {
        await s.start();
    }
    catch (e) {
        outputStream?.stopSpinner();
        throw e;
    }
    const testRunner = s.getResource("root/cloud.TestRunner");
    const tests = await testRunner.listTests();
    const filteredTests = filterTests(tests, testFilter);
    const results = await runTestsWithRetry(testRunner, filteredTests, retry ?? 0);
    await s.stop();
    if (options.stream) {
        await traceProcessor.finish();
        outputStream.stopSpinner();
    }
    const testReport = await renderTestReport(synthDir, results, !options.stream);
    if (testReport.length > 0) {
        console.log(testReport);
    }
    let args;
    if ((0, fs_1.existsSync)((0, path_1.join)(synthDir, "usage_context.json"))) {
        args = { methods: JSON.parse((0, fs_1.readFileSync)((0, path_1.join)(synthDir, "usage_context.json")).toString()) };
    }
    if (clean) {
        try {
            (0, fs_1.rmSync)(synthDir, { recursive: true, force: true });
        }
        catch (err) {
            console.warn(`Warning: unable to clean up test directory: ${err}`);
        }
    }
    else {
        noCleanUp(synthDir);
    }
    return results.map((r) => ({ ...r, args }));
}
async function testTf(synthDir, options) {
    const { clean, testFilter, retry, platform = [compiler_1.BuiltinPlatform.SIM] } = options;
    try {
        const installed = await isTerraformInstalled(synthDir);
        if (!installed) {
            throw new Error("Terraform is not installed. Please install Terraform to run tests in the cloud.");
        }
        await (0, util_4.withSpinner)("terraform init", async () => terraformInit(synthDir));
        await (0, util_4.withSpinner)("terraform apply", () => terraformApply(synthDir));
        const [testRunner, tests] = await (0, util_4.withSpinner)("Setting up test runner...", async () => {
            const target = (0, compiler_1.determineTargetFromPlatforms)(platform);
            const testRunnerPath = `@winglang/sdk/lib/${targetFolder[target]}/test-runner.inflight`;
            const testArns = await terraformOutput(synthDir, ENV_WING_TEST_RUNNER_FUNCTION_IDENTIFIERS);
            const { TestRunnerClient } = await Promise.resolve(`${testRunnerPath}`).then(s => __importStar(require(s)));
            const runner = new TestRunnerClient(testArns);
            const allTests = await runner.listTests();
            const filteredTests = filterTests(allTests, testFilter);
            return [runner, filteredTests];
        });
        const results = await (0, util_4.withSpinner)("Running tests...", async () => {
            return runTestsWithRetry(testRunner, tests, retry ?? 0);
        });
        const testReport = await renderTestReport(synthDir, results);
        if (testReport.length > 0) {
            console.log(testReport);
        }
        if (testResultsContainsFailure(results)) {
            console.log("One or more tests failed. Cleaning up resources...");
        }
        let args;
        if ((0, fs_1.existsSync)((0, path_1.join)(synthDir, "usage_context.json"))) {
            args = { methods: JSON.parse((0, fs_1.readFileSync)((0, path_1.join)(synthDir, "usage_context.json")).toString()) };
        }
        return results.map((r) => ({ ...r, args }));
    }
    catch (err) {
        console.warn(err.message);
        return [{ pass: false, path: "", error: err.message, traces: [] }];
    }
    finally {
        if (clean) {
            await cleanupTf(synthDir);
        }
        else {
            noCleanUp(synthDir);
        }
    }
}
async function testAwsCdk(synthDir, options) {
    const { clean, testFilter, retry } = options;
    try {
        await isAwsCdkInstalled(synthDir);
        await (0, util_4.withSpinner)("cdk deploy", () => awsCdkDeploy(synthDir));
        const [testRunner, tests] = await (0, util_4.withSpinner)("Setting up test runner...", async () => {
            const stackName = process.env.CDK_STACK_NAME + util_2.Util.sha256(synthDir).slice(-8);
            const testArns = await awsCdkOutput(synthDir, ENV_WING_TEST_RUNNER_FUNCTION_IDENTIFIERS_AWSCDK, stackName);
            const { TestRunnerClient } = await Promise.resolve().then(() => __importStar(require("@winglang/sdk/lib/shared-aws/test-runner.inflight")));
            const runner = new TestRunnerClient(testArns);
            const allTests = await runner.listTests();
            const filteredTests = filterTests(allTests, testFilter);
            return [runner, filteredTests];
        });
        const results = await (0, util_4.withSpinner)("Running tests...", async () => {
            return runTestsWithRetry(testRunner, tests, retry ?? 0);
        });
        const testReport = await renderTestReport(synthDir, results);
        if (testReport.length > 0) {
            console.log(testReport);
        }
        if (testResultsContainsFailure(results)) {
            console.log("One or more tests failed. Cleaning up resources...");
        }
        return results;
    }
    catch (err) {
        console.warn(err.message);
        return [{ pass: false, path: "", error: err.message, traces: [] }];
    }
    finally {
        if (clean) {
            await cleanupCdk(synthDir);
        }
        else {
            noCleanUp(synthDir);
        }
    }
}
async function cleanupCdk(synthDir) {
    await (0, util_4.withSpinner)("aws-cdk destroy", () => awsCdkDestroy(synthDir));
    (0, fs_1.rmSync)(synthDir, { recursive: true, force: true });
}
async function isAwsCdkInstalled(synthDir) {
    try {
        await execCapture("cdk version --ci true", { cwd: synthDir });
    }
    catch (err) {
        throw new Error("AWS-CDK is not installed. Please install AWS-CDK to run tests in the cloud (npm i -g aws-cdk).");
    }
}
async function awsCdkDeploy(synthDir) {
    await execCapture("cdk deploy --require-approval never --ci true -O ./output.json --app . ", {
        cwd: synthDir,
    });
}
exports.awsCdkDeploy = awsCdkDeploy;
async function awsCdkDestroy(synthDir) {
    const removeFile = (0, util_1.promisify)(fs_1.rm);
    await removeFile(synthDir.concat("/output.json"));
    await execCapture("cdk destroy -f --ci true --app ./", { cwd: synthDir });
}
exports.awsCdkDestroy = awsCdkDestroy;
async function awsCdkOutput(synthDir, name, stackName) {
    const readFileCmd = (0, util_1.promisify)(fs_1.readFile);
    const file = await readFileCmd(synthDir.concat("/output.json"));
    const parsed = JSON.parse(Buffer.from(file).toString());
    return parsed[stackName][name];
}
const targetFolder = {
    [compiler_1.BuiltinPlatform.TF_AWS]: "shared-aws",
    [compiler_1.BuiltinPlatform.TF_AZURE]: "shared-azure",
    [compiler_1.BuiltinPlatform.TF_GCP]: "shared-gcp",
};
async function cleanupTf(synthDir) {
    await (0, util_4.withSpinner)("terraform destroy", () => terraformDestroy(synthDir));
    (0, fs_1.rmSync)(synthDir, { recursive: true, force: true });
}
async function isTerraformInstalled(synthDir) {
    const output = await execCapture("terraform version", { cwd: synthDir });
    return output.startsWith("Terraform v");
}
async function terraformInit(synthDir) {
    return execCapture("terraform init", { cwd: synthDir });
}
exports.terraformInit = terraformInit;
async function terraformApply(synthDir) {
    return execCapture("terraform apply -auto-approve", { cwd: synthDir });
}
async function terraformDestroy(synthDir) {
    return execCapture("terraform destroy -auto-approve", { cwd: synthDir });
}
async function terraformOutput(synthDir, name) {
    const output = await execCapture("terraform output -json", { cwd: synthDir });
    const parsed = JSON.parse(output);
    if (!parsed[name]) {
        throw new Error(`terraform output ${name} not found`);
    }
    return parsed[name].value;
}
function sortTests(a, b) {
    if (a.pass && !b.pass) {
        return -1;
    }
    if (!a.pass && b.pass) {
        return 1;
    }
    return a.path.localeCompare(b.path);
}
/**
 * Take a path like "root/env123/foo/bar" and return the environment number (123).
 */
function extractTestEnvFromPath(path) {
    const parts = path.split("/");
    const envPart = parts[1] ?? parts[0];
    if (!envPart.startsWith("env")) {
        return undefined;
    }
    return parseInt(envPart.substring(3));
}
/*
 * Take a path like "root/env123/foo/test:first test/bar" and return "first test".
 */
function extractTestNameFromPath(path) {
    const parts = path.split("/");
    for (const part of parts) {
        if (part.startsWith("test:")) {
            return part.substring(5);
        }
    }
    return undefined;
}
/*
 * Take a list of paths like:
 *
 * root/env0/foo
 * root/env0/test:first test        <-- this is a test
 * root/env1/bar/test:second test   <-- this is a test
 * root/env1/bar
 *
 * and extract the mapping from environment indices to test names:
 *
 * { 0: "first test", 1: "second test" }
 */
function extractTestMappings(paths) {
    const mappings = {};
    for (const path of paths) {
        const parts = path.split("/");
        if (parts.some((p) => p.startsWith("test:"))) {
            const env = extractTestEnvFromPath(path);
            if (env === undefined) {
                continue;
            }
            const testName = extractTestNameFromPath(path);
            if (testName === undefined) {
                continue;
            }
            mappings[env] = testName;
        }
    }
    return mappings;
}
const MAX_BUFFER = 10 * 1024 * 1024;
/**
 * Executes command and returns STDOUT. If the command fails (non-zero), throws an error.
 */
async function execCapture(command, options) {
    log(command);
    const exec = (0, util_1.promisify)(cp.exec);
    const { stdout, stderr } = await exec(command, {
        cwd: options.cwd,
        maxBuffer: MAX_BUFFER,
    });
    if (stderr) {
        throw new Error(stderr);
    }
    log(stdout);
    return stdout;
}
//# sourceMappingURL=test.js.map