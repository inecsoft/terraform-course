"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const promises_1 = __importDefault(require("fs/promises"));
const os_1 = require("os");
const path_1 = require("path");
const compiler_1 = require("@winglang/compiler");
const std_1 = require("@winglang/sdk/lib/std");
const chalk_1 = __importDefault(require("chalk"));
const vitest_1 = require("vitest");
const _1 = require(".");
const resultsFn = __importStar(require("./results"));
const snapshots_1 = require("./snapshots");
const defaultChalkLevel = chalk_1.default.level;
const cwd = process.cwd();
(0, vitest_1.describe)("printing test reports", () => {
    (0, vitest_1.beforeEach)(() => {
        chalk_1.default.level = 0;
    });
    (0, vitest_1.afterEach)(() => {
        chalk_1.default.level = defaultChalkLevel;
        process.chdir(cwd);
    });
    (0, vitest_1.test)("verbose traces are not shown if debug mode is disabled", async () => {
        const testReport = await (0, _1.renderTestReport)("hello.w", EXAMPLE_TEST_RESULTS);
        (0, vitest_1.expect)(testReport).toMatchSnapshot();
        (0, vitest_1.expect)(testReport).not.toContain("Push (message=cool)");
    });
    (0, vitest_1.test)("verbose traces are shown if debug mode is enabled", async () => {
        const oldDebug = process.env.DEBUG;
        process.env.DEBUG = "1";
        const testReport = await (0, _1.renderTestReport)("hello.w", EXAMPLE_TEST_RESULTS);
        if (oldDebug) {
            process.env.DEBUG = oldDebug;
        }
        else {
            delete process.env.DEBUG;
        }
        (0, vitest_1.expect)(testReport).toMatchSnapshot();
        (0, vitest_1.expect)(testReport).toContain("Push (message=cool)");
    });
});
(0, vitest_1.describe)("wing test (custom platform)", () => {
    let logSpy;
    (0, vitest_1.beforeEach)(() => {
        chalk_1.default.level = 0;
        logSpy = vitest_1.vi.spyOn(console, "log");
    });
    (0, vitest_1.afterEach)(() => {
        chalk_1.default.level = defaultChalkLevel;
        process.chdir(cwd);
        logSpy.mockRestore();
    });
    (0, vitest_1.test)("test runner is loaded properly for customized tf-aws platform", async () => {
        const outDir = await promises_1.default.mkdtemp((0, path_1.join)((0, os_1.tmpdir)(), "-wing-compile-test"));
        // can't be resolved within tmp directory
        const targetTfAws = require.resolve("@winglang/sdk/lib/target-tf-aws");
        process.chdir(outDir);
        fs_1.default.writeFileSync("foo.test.w", `bring cloud;`);
        fs_1.default.writeFileSync("custom-platform.js", `
      const tfaws = require("${targetTfAws}");
      class Platform {
        target = "tf-aws";

        newApp(appProps) {
          return new tfaws.App(appProps);
        }
      }
      module.exports = { Platform }`);
        await (0, _1.test)([], {
            clean: true,
            platform: ["./custom-platform.js"],
            snapshots: snapshots_1.SnapshotMode.NEVER,
        });
        (0, vitest_1.expect)(logSpy).toHaveBeenCalledWith(vitest_1.expect.stringMatching(/^pass â”€ foo\.test\.tfaws\.\d+ \(no tests\)$/));
    });
});
(0, vitest_1.describe)("collectTestFiles", () => {
    (0, vitest_1.test)("default entrypoints", async () => {
        const outDir = await promises_1.default.mkdtemp((0, path_1.join)((0, os_1.tmpdir)(), "-wing-compile-test"));
        process.chdir(outDir);
        fs_1.default.writeFileSync("foo.test.w", "");
        fs_1.default.writeFileSync("bar.test.w", "");
        fs_1.default.writeFileSync("baz.test.w", "");
        fs_1.default.writeFileSync("main.ts", "");
        const files = await (0, _1.collectTestFiles)([]);
        (0, vitest_1.expect)(files).toMatchInlineSnapshot(`
      [
        "main.ts",
        "foo.test.w",
        "baz.test.w",
        "bar.test.w",
      ]
    `);
    });
    (0, vitest_1.test)("specific entrypoint", async () => {
        const outDir = await promises_1.default.mkdtemp((0, path_1.join)((0, os_1.tmpdir)(), "-wing-compile-test"));
        process.chdir(outDir);
        fs_1.default.writeFileSync("foo.test.w", "");
        fs_1.default.writeFileSync("bar.test.w", "");
        fs_1.default.writeFileSync("baz.test.w", "");
        const files = await (0, _1.collectTestFiles)(["foo.test.w"]);
        (0, vitest_1.expect)(files).toMatchInlineSnapshot(`
      [
        "foo.test.w",
      ]
    `);
    });
    (0, vitest_1.test)("fuzzy match dir", async () => {
        const outDir = await promises_1.default.mkdtemp((0, path_1.join)((0, os_1.tmpdir)(), "-wing-compile-test"));
        process.chdir(outDir);
        fs_1.default.mkdirSync("foo");
        fs_1.default.writeFileSync("foo/a.test.w", "");
        fs_1.default.writeFileSync("foo/b.test.w", "");
        fs_1.default.writeFileSync("foo.test.w", "");
        fs_1.default.writeFileSync("baz.test.w", "");
        const files = await (0, _1.collectTestFiles)(["foo"]);
        (0, vitest_1.expect)(files).toMatchInlineSnapshot(`
      [
        "foo.test.w",
        "foo/b.test.w",
        "foo/a.test.w",
      ]
    `);
    });
    (0, vitest_1.test)("absolute path dedupe", async () => {
        const outDir = await promises_1.default.mkdtemp((0, path_1.join)((0, os_1.tmpdir)(), "-wing-compile-test"));
        process.chdir(outDir);
        fs_1.default.mkdirSync("foo");
        fs_1.default.writeFileSync("foo/a.test.w", "");
        fs_1.default.writeFileSync("foo/b.test.w", "");
        fs_1.default.writeFileSync("foo.test.w", "");
        fs_1.default.writeFileSync("baz.test.w", "");
        const files = await (0, _1.collectTestFiles)(["foo"]);
        (0, vitest_1.expect)(files).toMatchInlineSnapshot(`
    [
      "foo.test.w",
      "foo/b.test.w",
      "foo/a.test.w",
    ]
  `);
    });
    (0, vitest_1.test)("testing file outside current dir", async () => {
        const outDir = await promises_1.default.mkdtemp((0, path_1.join)((0, os_1.tmpdir)(), "-wing-compile-test"));
        const subDir = (0, path_1.join)(outDir, "subdir");
        process.chdir(outDir);
        fs_1.default.writeFileSync("foo.test.w", "");
        fs_1.default.mkdirSync(subDir);
        process.chdir(subDir);
        fs_1.default.writeFileSync("main.w", "");
        const files = await (0, _1.collectTestFiles)(["../foo.test.w"]);
        (0, vitest_1.expect)(files).toMatchInlineSnapshot(`
      [
        "../foo.test.w",
      ]
    `);
    });
});
(0, vitest_1.describe)("output-file option", () => {
    let writeResultsSpy;
    (0, vitest_1.beforeEach)(() => {
        chalk_1.default.level = 0;
        writeResultsSpy = vitest_1.vi.spyOn(resultsFn, "writeResultsToFile");
    });
    (0, vitest_1.afterEach)(() => {
        chalk_1.default.level = defaultChalkLevel;
        process.chdir(cwd);
        writeResultsSpy.mockRestore();
    });
    (0, vitest_1.test)("wing test with output file calls writeResultsToFile", async () => {
        const outDir = await promises_1.default.mkdtemp((0, path_1.join)((0, os_1.tmpdir)(), "-wing-compile-test"));
        process.chdir(outDir);
        fs_1.default.writeFileSync("test.test.w", EXAMPLE_TEST);
        console.log(outDir);
        const outputFile = "out.json";
        await (0, _1.test)(["test.test.w"], {
            clean: true,
            platform: [compiler_1.BuiltinPlatform.SIM],
            outputFile,
        });
        (0, vitest_1.expect)(writeResultsSpy).toBeCalledTimes(1);
        const { testName, results } = writeResultsSpy.mock.calls[0][0][0];
        (0, vitest_1.expect)(results).toMatchObject(BUCKET_TEST_RESULT);
        (0, vitest_1.expect)(testName).toBe("test.test.w");
        (0, vitest_1.expect)(writeResultsSpy.mock.calls[0][2]).toBe(outputFile);
        const outputFileExists = fs_1.default.existsSync(outputFile);
        (0, vitest_1.expect)(outputFileExists).toBe(true);
        const outputContents = fs_1.default.readFileSync(outputFile, "utf-8");
        (0, vitest_1.expect)(JSON.parse(outputContents)).toMatchObject(OUTPUT_FILE);
    });
    (0, vitest_1.test)("wing test without output file calls writeResultsToFile", async () => {
        const outDir = await promises_1.default.mkdtemp((0, path_1.join)((0, os_1.tmpdir)(), "-wing-compile-test"));
        process.chdir(outDir);
        fs_1.default.writeFileSync("test.test.w", EXAMPLE_TEST);
        await (0, _1.test)(["test.test.w"], {
            clean: true,
            platform: [compiler_1.BuiltinPlatform.SIM],
        });
        (0, vitest_1.expect)(writeResultsSpy).toBeCalledTimes(0);
    });
    (0, vitest_1.test)("validate output file", () => {
        (0, vitest_1.expect)(resultsFn.validateOutputFilePath("/path/out.json")).toBeUndefined();
        (0, vitest_1.expect)(resultsFn.validateOutputFilePath("out.json")).toBeUndefined();
        (0, vitest_1.expect)(() => resultsFn.validateOutputFilePath("/path/out.csv")).toThrow('only .json output files are supported. (found ".csv")');
        (0, vitest_1.expect)(() => resultsFn.validateOutputFilePath("/path/json")).toThrow('only .json output files are supported. (found "")');
    });
});
(0, vitest_1.describe)("test-filter option", () => {
    (0, vitest_1.beforeEach)(() => {
        chalk_1.default.level = 0;
    });
    (0, vitest_1.afterEach)(() => {
        chalk_1.default.level = defaultChalkLevel;
    });
    (0, vitest_1.test)("wing test (no test-filter)", () => {
        const filteredTests = (0, _1.filterTests)(EXAMPLE_UNFILTERED_TESTS);
        (0, vitest_1.expect)(filteredTests.length).toBe(3);
        (0, vitest_1.expect)(filteredTests[0]).toBe("root/env0/test:get()");
        (0, vitest_1.expect)(filteredTests[1]).toBe("root/env1/test:get:At()");
        (0, vitest_1.expect)(filteredTests[2]).toBe("root/env2/test:stringify()");
    });
    (0, vitest_1.test)("wing test --test-filter <regex>", () => {
        const filteredTests = (0, _1.filterTests)(EXAMPLE_UNFILTERED_TESTS, "get");
        (0, vitest_1.expect)(filteredTests.length).toBe(2);
        (0, vitest_1.expect)(filteredTests[0]).toBe("root/env0/test:get()");
        (0, vitest_1.expect)(filteredTests[1]).toBe("root/env1/test:get:At()");
    });
});
(0, vitest_1.describe)("retry and parallel options", () => {
    let logSpy;
    (0, vitest_1.beforeEach)(() => {
        chalk_1.default.level = 0;
        logSpy = vitest_1.vi.spyOn(console, "log");
    });
    (0, vitest_1.afterEach)(() => {
        chalk_1.default.level = defaultChalkLevel;
        process.chdir(cwd);
        logSpy.mockRestore();
    });
    (0, vitest_1.test)("wing test (no retry)", async () => {
        const outDir = await promises_1.default.mkdtemp((0, path_1.join)((0, os_1.tmpdir)(), "-wing-retry-test"));
        process.chdir(outDir);
        // Create a test that will consistently fail
        fs_1.default.writeFileSync("fail.test.w", `
        bring cloud;
        test "alwaysFail" {
          assert(false);
        }
      `);
        await (0, _1.test)(["fail.test.w"], {
            clean: true,
            platform: [compiler_1.BuiltinPlatform.SIM],
        });
        const retryLogs = logSpy.mock.calls.filter((args) => args[0].includes("Retrying"));
        (0, vitest_1.expect)(retryLogs.length).toBe(0);
    });
    (0, vitest_1.test)("wing test --retry [retries]", async () => {
        const outDir = await promises_1.default.mkdtemp((0, path_1.join)((0, os_1.tmpdir)(), "-wing-retry-test"));
        process.chdir(outDir);
        // Create a test that will consistently fail
        fs_1.default.writeFileSync("fail.test.w", `
        bring cloud;
        test "alwaysFail" {
          assert(false);
        }
      `);
        // Equivalent to `wing test --retry` (default 3 retries)
        await (0, _1.test)(["fail.test.w"], {
            clean: true,
            platform: [compiler_1.BuiltinPlatform.SIM],
            retry: 3,
        });
        const retryLogs = logSpy.mock.calls.filter((args) => args[0].includes("Retrying"));
        (0, vitest_1.expect)(retryLogs.length).toBe(3);
    });
    (0, vitest_1.test)("wing test --parallel [batch]", async () => {
        const outDir = await promises_1.default.mkdtemp((0, path_1.join)((0, os_1.tmpdir)(), "-wing-batch-test"));
        process.chdir(outDir);
        fs_1.default.writeFileSync("t1.test.w", `
bring util;

test "t1" {
  util.sleep(1s);
  log("t1 ends");
  assert(true);
}
  `);
        fs_1.default.writeFileSync("t2.test.w", `
bring util;

test "t2" {
  log("t2 ends");
  assert(true);
}
  `);
        await (0, _1.test)(["t1.test.w", "t2.test.w"], {
            clean: true,
            platform: [compiler_1.BuiltinPlatform.SIM],
            parallel: 1,
        });
        // we are running the tests one by one so first t1 should log and then t2
        const t1Ends = logSpy.mock.calls.findIndex((args) => args[0].includes("t1 ends"));
        const t2Ends = logSpy.mock.calls.findIndex((args) => args[0].includes("t2 ends"));
        (0, vitest_1.expect)(t2Ends).toBeGreaterThan(t1Ends);
    });
    (0, vitest_1.test)("wing test --parallel 2", async () => {
        const outDir = await promises_1.default.mkdtemp((0, path_1.join)((0, os_1.tmpdir)(), "-wing-batch-test"));
        process.chdir(outDir);
        fs_1.default.writeFileSync("t1.test.w", `
bring util;

test "t1" {
util.sleep(1s);
log("t1 ends");
assert(true);
}
  `);
        fs_1.default.writeFileSync("t2.test.w", `
bring util;

test "t2" {
  log("t2 ends");
  assert(true);
}
  `);
        await (0, _1.test)(["t1.test.w", "t2.test.w"], {
            clean: true,
            platform: [compiler_1.BuiltinPlatform.SIM],
            parallel: 2,
        });
        // we are running the tests in parallel so first t2 should log and then t1
        const t2Ends = logSpy.mock.calls.findIndex((args) => args[0].includes("t2 ends"));
        const t1Ends = logSpy.mock.calls.findIndex((args) => args[0].includes("t1 ends"));
        (0, vitest_1.expect)(t2Ends).toBeLessThan(t1Ends);
    });
});
const EXAMPLE_TEST_RESULTS = [
    {
        path: "root/env0/test:test",
        pass: false,
        error: "Error: Object does not exist (key=file.txt)",
        traces: [
            {
                data: { message: "Push (message=cool).", status: "success" },
                type: std_1.TraceType.RESOURCE,
                level: std_1.LogLevel.VERBOSE,
                sourcePath: "root/env0/MyProcessor/cloud.Queue",
                sourceType: "@winglang/sdk.cloud.Queue",
                timestamp: "2023-05-15T16:20:46.886Z",
            },
            {
                data: { message: "sleeping for 500 ms" },
                type: std_1.TraceType.LOG,
                level: std_1.LogLevel.INFO,
                sourcePath: "root/env0/test:test/Handler",
                sourceType: "@winglang/sdk.cloud.Function",
                timestamp: "2023-05-15T16:20:46.887Z",
            },
            {
                type: std_1.TraceType.RESOURCE,
                data: { message: 'Sending messages (messages=["cool"], subscriber=sim-4).' },
                level: std_1.LogLevel.VERBOSE,
                sourcePath: "root/env0/MyProcessor/cloud.Queue",
                sourceType: "@winglang/sdk.cloud.Queue",
                timestamp: "2023-05-15T16:20:46.961Z",
            },
            {
                data: {
                    message: 'Invoke (payload="{\\"messages\\":[\\"cool\\"]}").',
                },
                type: std_1.TraceType.RESOURCE,
                level: std_1.LogLevel.VERBOSE,
                sourcePath: "root/env0/MyProcessor/cloud.Queue-AddConsumer-0088483a",
                sourceType: "@winglang/sdk.cloud.Function",
                timestamp: "2023-05-15T16:20:46.966Z",
            },
            {
                data: {
                    message: "Subscriber error - returning 1 messages to queue: Missing environment variable: QUEUE_HANDLE_7164aec4",
                },
                sourcePath: "root/env0/MyProcessor/cloud.Queue",
                sourceType: "@winglang/sdk.cloud.Queue",
                type: std_1.TraceType.RESOURCE,
                level: std_1.LogLevel.ERROR,
                timestamp: "2023-05-15T16:20:46.966Z",
            },
            {
                data: { message: "Get (key=file.txt)." },
                type: std_1.TraceType.RESOURCE,
                level: std_1.LogLevel.VERBOSE,
                sourcePath: "root/env0/MyProcessor/Bucket",
                sourceType: "@winglang/sdk.cloud.Bucket",
                timestamp: "2023-05-15T16:20:47.388Z",
            },
            {
                data: { message: 'Invoke (payload="").' },
                type: std_1.TraceType.RESOURCE,
                level: std_1.LogLevel.VERBOSE,
                sourcePath: "root/env0/test:test/Handler",
                sourceType: "@winglang/sdk.cloud.Function",
                timestamp: "2023-05-15T16:20:47.388Z",
            },
        ],
    },
];
const EXAMPLE_TEST = `
bring cloud;
let b = new cloud.Bucket();

test "put" {
  b.put("test1.txt", "Foo");
  assert(b.get("test1.txt") == "Foo");
}
`;
const BUCKET_TEST_RESULT = [
    {
        path: "root/env0/test:put",
        pass: true,
        traces: [
            {
                data: { message: "Put (key=test1.txt).", status: "success" },
                type: "resource",
                sourcePath: "root/env0/Bucket",
                sourceType: "@winglang/sdk.cloud.Bucket",
            },
            {
                data: { message: "Get (key=test1.txt).", status: "success", result: '"Foo"' },
                type: "resource",
                sourcePath: "root/env0/Bucket",
                sourceType: "@winglang/sdk.cloud.Bucket",
            },
            {
                data: { message: "Invoke (payload=undefined).", status: "success" },
                type: "resource",
                sourcePath: "root/env0/test:put/Handler",
                sourceType: "@winglang/sdk.cloud.Function",
            },
        ],
    },
];
const OUTPUT_FILE = {
    results: {
        "test.test.w": {
            put: {
                path: "root/env0/test:put",
                pass: true,
                traces: [
                    {
                        data: {
                            message: "Put (key=test1.txt).",
                            status: "success",
                        },
                        type: "resource",
                        sourcePath: "root/env0/Bucket",
                        sourceType: "@winglang/sdk.cloud.Bucket",
                    },
                    {
                        data: {
                            message: "Get (key=test1.txt).",
                            status: "success",
                            result: '"Foo"',
                        },
                        type: "resource",
                        sourcePath: "root/env0/Bucket",
                        sourceType: "@winglang/sdk.cloud.Bucket",
                    },
                    {
                        data: {
                            message: "Invoke (payload=undefined).",
                            status: "success",
                        },
                        type: "resource",
                        sourcePath: "root/env0/test:put/Handler",
                        sourceType: "@winglang/sdk.cloud.Function",
                    },
                ],
            },
        },
    },
};
const EXAMPLE_UNFILTERED_TESTS = [
    "root/env0/test:get()",
    "root/env1/test:get:At()",
    "root/env2/test:stringify()",
];
//# sourceMappingURL=test.test.js.map