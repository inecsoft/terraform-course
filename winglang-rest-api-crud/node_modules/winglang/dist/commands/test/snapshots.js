"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.captureSnapshot = exports.SnapshotResult = exports.determineSnapshotMode = exports.SnapshotMode = void 0;
const cp = __importStar(require("child_process"));
const fs = __importStar(require("fs/promises"));
const path_1 = require("path");
const compiler_1 = require("@winglang/compiler");
const glob = __importStar(require("glob"));
const snapshots_help_1 = require("./snapshots-help");
const util_1 = require("./util");
const util_2 = require("../../util");
const compile_1 = require("../compile");
var SnapshotMode;
(function (SnapshotMode) {
    /**
     * Auto-detect. If CI=1, SnapshotMode.ASSERT otherwise SnapshotMode.DEPLOY.
     */
    SnapshotMode["AUTO"] = "auto";
    /**
     * Snapshots are disabled.
     */
    SnapshotMode["NEVER"] = "never";
    /**
     * Deploy and test in the cloud and update the snapshot only if all tests passed.
     */
    SnapshotMode["DEPLOY"] = "deploy";
    /**
     * Update the snapshots without deploying (dry run).
     */
    SnapshotMode["UPDATE"] = "update";
    /**
     * Just verify that the snapshots are correct.
     */
    SnapshotMode["ASSERT"] = "assert";
})(SnapshotMode || (exports.SnapshotMode = SnapshotMode = {}));
function determineSnapshotMode(target, options) {
    // no snapshots for sim, ever!
    if (target === compiler_1.BuiltinPlatform.SIM) {
        return SnapshotMode.NEVER;
    }
    // if AUTO or unset, determine behavior based on CI flag
    if (!options.snapshots || options.snapshots === SnapshotMode.AUTO) {
        // determine behavior based on CI
        if (process.env.CI) {
            return SnapshotMode.ASSERT;
        }
        else {
            return SnapshotMode.DEPLOY;
        }
    }
    return options.snapshots;
}
exports.determineSnapshotMode = determineSnapshotMode;
var SnapshotResult;
(function (SnapshotResult) {
    SnapshotResult["SKIPPED"] = "skipped";
    SnapshotResult["NEW"] = "new";
    SnapshotResult["UPDATED"] = "updated";
    SnapshotResult["MISMATCH"] = "mismatched";
    SnapshotResult["VERIFIED"] = "verified";
})(SnapshotResult || (exports.SnapshotResult = SnapshotResult = {}));
async function captureSnapshot(entrypoint, target, options) {
    const snapshotMode = determineSnapshotMode(target, options);
    // skip if snapshots are disabled
    if (snapshotMode === SnapshotMode.NEVER) {
        return SnapshotResult.SKIPPED;
    }
    const snapshotFile = `${entrypoint}.${target}.snap.md`;
    const oldSnapshot = await tryReadFile(snapshotFile);
    return (0, util_2.withSpinner)(`Snapshot ${(0, util_1.renderTestName)(snapshotFile)}...`, async () => {
        // we need to compile again in order for snapshots because we can't afford the snapshot to be
        // based on a random root id (which is the default for tests)
        const snapshotDir = await (0, compile_1.compile)(entrypoint, options);
        // take a snapshot of the synthesis output
        const newSnapshot = await createMarkdownSnapshot((0, path_1.basename)(snapshotFile), snapshotDir);
        // if the snapshot is the same, we're done
        if (oldSnapshot === newSnapshot) {
            return SnapshotResult.VERIFIED;
        }
        // snapshot are mismatched, decide if we want to update or assert based on the mode
        switch (snapshotMode) {
            case SnapshotMode.DEPLOY:
            case SnapshotMode.UPDATE:
                await fs.writeFile(snapshotFile, newSnapshot);
                return !oldSnapshot ? SnapshotResult.NEW : SnapshotResult.UPDATED;
            case SnapshotMode.ASSERT:
                if (!oldSnapshot) {
                    throw new Error([
                        snapshots_help_1.SNAPSHOT_ERROR_PREFIX,
                        `Snapshot file does not exist: ${snapshotFile}`,
                        "",
                        snapshots_help_1.SNAPSHOTS_ERROR_HELP,
                    ].join("\n"));
                }
                const actualFile = `${snapshotFile}.actual`;
                await fs.writeFile(actualFile, newSnapshot);
                const diff = tryRenderDiff(snapshotFile, actualFile) ??
                    [` - Expected: ${snapshotFile}`, ` - Actual: ${actualFile}`].join("\n");
                // don't keep the actual file around
                await fs.rm(actualFile);
                throw new Error([snapshots_help_1.SNAPSHOT_ERROR_PREFIX, "", diff, "", snapshots_help_1.SNAPSHOTS_ERROR_HELP].join("\n"));
        }
        throw new Error(`Unexpected snapshot mode: ${snapshotMode}`);
    });
}
exports.captureSnapshot = captureSnapshot;
/**
 * Uses the "diff" command to render a diff between two files. Returns `undefined` if the diff command
 * is not available or if there was an error.
 *
 * @param expectedFile A snapshot file with the expected content
 * @param actualFile The actual snapshot content
 * @returns The diff output or `undefined`
 */
function tryRenderDiff(expectedFile, actualFile) {
    const color = process.env.CI ? "never" : "always";
    const out = cp.spawnSync("diff", ["-u", expectedFile, actualFile, `--color=${color}`]);
    if (out.error) {
        return undefined;
    }
    return out.stdout?.toString();
}
async function tryReadFile(file) {
    try {
        return await fs.readFile(file, "utf-8");
    }
    catch {
        return undefined;
    }
}
/**
 * Creates a markdown snapshot of the synthesis output.
 *
 * @param baseName The base name of the test
 * @param synthDir The directory containing the synthesis output
 * @returns The snapshot content in markdown format
 */
async function createMarkdownSnapshot(baseName, synthDir) {
    const fileMap = {};
    const exclude = ["connections.json", "tree.json", "**/*.zip", "**/*.map"];
    const include = ["**/*.js", "**/*.json", "**/*.tf", "**/*.ts", "**/*.yaml", "**/*.yml"];
    for await (const subpath of glob.iterate(include, {
        cwd: synthDir,
        nodir: true,
        dot: false, // don't include the `.wing` directory
        ignore: exclude,
    })) {
        const abspath = (0, path_1.join)(synthDir, subpath);
        const fileContents = await fs.readFile(abspath, "utf8");
        // ensure no absolute requires are included in the snapshot
        if (/require\("(\/|\w:).*\/(.+)"\)/g.test(fileContents)) {
            throw new Error(`Unable to capture snapshot. Found absolute path in ${abspath}`);
        }
        fileMap[subpath] = fileContents;
    }
    return createMarkdown(baseName, fileMap);
}
function createMarkdown(baseName, fileMap) {
    const files = Object.keys(fileMap);
    files.sort();
    const lines = [];
    lines.push(`# \`${baseName}\``);
    lines.push("");
    for (const file of files) {
        const extension = (0, path_1.extname)(file).replace(".", "");
        lines.push(`## ${file}`);
        lines.push("");
        lines.push("```" + extension);
        lines.push(fileMap[file]);
        lines.push("```");
        lines.push("");
    }
    return lines.join("\n");
}
//# sourceMappingURL=snapshots.js.map