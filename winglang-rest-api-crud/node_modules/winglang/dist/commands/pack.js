"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.exists = exports.pack = void 0;
const fs_1 = require("fs");
const fs = __importStar(require("fs/promises"));
const os = __importStar(require("os"));
const path = __importStar(require("path"));
const path_1 = require("path");
const arborist_1 = __importDefault(require("@npmcli/arborist"));
const compiler_1 = require("@winglang/compiler");
const npm_packlist_1 = __importDefault(require("npm-packlist"));
const tar = __importStar(require("tar"));
const compile_1 = require("./compile");
const env_1 = require("../env");
// TODO: add --dry-run option?
// TODO: let the user specify library's supported targets in package.json, and compile to each before packaging
// TODO: print information about the generated library? (e.g. size, dependencies, number of public APIs)
const defaultGlobs = [
    "**/*.js",
    "**/*.cjs",
    "**/*.mjs",
    "**/*.ts",
    "**/*.cts",
    "**/*.mts",
    "**/*.w",
    "README*",
    "LICENSE*",
    "!target",
    "!**/main.w",
    "!**/*.main.w",
    "!**/*.test.w",
];
const compilerOutputFolder = "$lib";
const dotWingDir = ".wing";
async function containsWingFile(dir) {
    const files = await fs.readdir(dir);
    return files.some((file) => file.endsWith(".w"));
}
/**
 * This recursive function validates that all directories that contain wing files
 * have valid naming conventions.
 *
 * @param dir The name of the directory to validate
 */
async function validateWingDir(dir) {
    const dirEntries = await fs.readdir(dir);
    for (const entry of dirEntries) {
        const entryPath = path.join(dir, entry);
        const stat = await fs.stat(entryPath);
        if (stat.isDirectory()) {
            if (entry === "node_modules") {
                continue;
            }
            // if the directory contains a wing file, validate its name
            if (await containsWingFile(entryPath)) {
                if (!/^([A-Za-z_][A-Za-z_0-9]*|[A-Z][A-Z0-9_]*)$/.test(entry)) {
                    throw new Error(`Directories that contain wing files cannot contain non-symbolic characters: ${entryPath}`);
                }
                await validateWingDir(entryPath);
            }
        }
    }
}
async function pack(options = {}) {
    const userDir = process.cwd();
    const outfile = options.outFile ? (0, path_1.resolve)(options.outFile) : undefined;
    const outdir = outfile ? path.dirname(outfile) : userDir;
    (0, env_1.loadEnvVariables)({ cwd: userDir });
    // check package.json exists
    const originalPkgJsonPath = path.join(userDir, "package.json");
    if (!(await exists(originalPkgJsonPath))) {
        throw new Error(`No package.json found in the current directory. Run \`npm init\` first.`);
    }
    // check that all wing directories are valid (for now that just means named correctly)
    await validateWingDir(userDir);
    // collect a list of files to copy to the staging directory.
    // only the files that will be included in the tarball will be copied
    // this way we can run `wing compile .` in the staging directory and be sure
    // that someone consuming the library will be able to compile it.
    const filesToCopy = await listFilesToCopy(userDir, defaultGlobs);
    // perform our work in a staging directory to avoid making a mess in the user's current directory
    return withTempDir(async (workdir) => {
        // copy staged files to the staging directory
        await copyFiles(userDir, workdir, filesToCopy);
        // symlink the user's node_modules to the staging directory
        const nodeModulesPath = path.join(workdir, "node_modules");
        await fs.symlink(path.join(userDir, "node_modules"), nodeModulesPath);
        // check that the library compiles to the "sim" target
        console.log('Compiling to the "sim" target...');
        const compilerOutputDir = await (0, compile_1.compile)(workdir, {
            platform: [compiler_1.BuiltinPlatform.SIM],
        });
        const pkgJsonPath = path.join(workdir, "package.json");
        const pkgJson = JSON.parse(await fs.readFile(pkgJsonPath, "utf8"));
        // check package.json has required fields
        const requiredFields = ["name", "version", "description", "author", "license"];
        for (const field of requiredFields) {
            if (pkgJson[field] === undefined) {
                throw new Error(`Missing required field "${field}" in package.json.`);
            }
        }
        // Check if package.json has non-empty "dependencies"
        if (pkgJson.dependencies && Object.keys(pkgJson.dependencies).length > 0) {
            throw new Error(`Cannot create package with "dependencies" in package.json. Use "peerDependencies" instead.`);
        }
        // move compiler output
        await fs.rename(compilerOutputDir, path.join(workdir, compilerOutputFolder));
        // add default globs to "files" so that Wing files are included in the tarball
        const pkgJsonFiles = new Set(pkgJson.files ?? []);
        const expectedGlobs = [
            compilerOutputFolder,
            // exclude the unnecessary .manifest file
            "!" + path.join(compilerOutputFolder, ".manifest"),
            ...defaultGlobs,
        ];
        for (const pat of expectedGlobs) {
            if (!pkgJsonFiles.has(pat)) {
                pkgJsonFiles.add(pat);
            }
        }
        pkgJson.files = [...pkgJsonFiles];
        pkgJson.main = path.join(compilerOutputFolder, dotWingDir, "preflight.cjs");
        // add "winglang" to "keywords"
        const keywords = new Set(pkgJson.keywords ?? []);
        keywords.add("winglang");
        pkgJson.keywords = [...keywords];
        // add "wing" to "engines"
        pkgJson.engines = { wing: "*" };
        // add "wing" top-level field
        pkgJson.wing = true;
        // write package.json
        await fs.writeFile(pkgJsonPath, JSON.stringify(pkgJson, null, 2) + "\n");
        // make the tarball
        const arborist = new arborist_1.default({ path: workdir });
        const tree = await arborist.loadActual();
        const pkg = tree.package;
        const files = await (0, npm_packlist_1.default)(tree);
        const tarballPath = outfile ??
            path.join(outdir, `${pkg.name?.replace(/^@/, "")?.replace(/\//, "-")}-${pkg.version}.tgz`);
        await tar.create({
            gzip: true,
            file: tarballPath,
            cwd: workdir,
            prefix: "package/",
            portable: true,
            noPax: true,
        }, files);
        console.log("Created tarball:", tarballPath);
        return tarballPath;
    });
}
exports.pack = pack;
/**
 * Determine a list of files to copy to the staging directory, based on what npm says
 * it would include in the tarball, given the user's package.json and a set of
 * additional files that we want to include.
 */
async function listFilesToCopy(dir, extraGlobs) {
    const arborist = new arborist_1.default({ path: dir });
    const tree = await arborist.loadActual();
    tree.package.files?.push(...extraGlobs);
    return (0, npm_packlist_1.default)(tree);
}
async function copyFiles(srcDir, destDir, files) {
    for (const file of files) {
        const srcPath = path.join(srcDir, file);
        const destPath = path.join(destDir, file);
        await fs.mkdir(path.dirname(destPath), { recursive: true });
        await fs.copyFile(srcPath, destPath);
    }
}
/**
 * Run some work in a temporary directory.
 */
async function withTempDir(work) {
    const workdir = await fs.mkdtemp(path.join(os.tmpdir(), "wing-pack-"));
    const cwd = process.cwd();
    try {
        process.chdir(workdir);
        // wait for the work to be completed before
        // we cleanup the work environment.
        return await work(workdir);
    }
    finally {
        process.chdir(cwd);
        // if you want to debug this you can keep the workdir around
        if (!process.env.WING_PACK_KEEP_WORKDIR) {
            await fs.rm(workdir, { recursive: true });
        }
        else {
            console.debug(`Keeping pack workdir ${workdir}`);
        }
    }
}
/**
 * Check if a file exists at a specific path with the given permissions
 * @param filePath The path to the file
 * @param permissions The permissions to check for. Defaults to checking for existence, readability, and writability.
 */
async function exists(filePath, permissions = fs_1.constants.R_OK | fs_1.constants.W_OK // eslint-disable-line no-bitwise
) {
    try {
        await fs.access(filePath, permissions);
        return true;
    }
    catch (er) {
        return false;
    }
}
exports.exists = exists;
//# sourceMappingURL=pack.js.map