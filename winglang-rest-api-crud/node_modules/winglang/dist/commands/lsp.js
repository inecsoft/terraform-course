"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.lsp = void 0;
const wingCompiler = __importStar(require("@winglang/compiler"));
const node_1 = require("vscode-languageserver/node");
async function lsp() {
    let wingc = await wingCompiler.load({
        imports: {
            env: {
                send_diagnostic,
            },
        },
    });
    let badState = false;
    const seenFiles = new Set();
    const raw_diagnostics = [];
    function send_diagnostic(data_ptr, data_len) {
        const data_buf = Buffer.from(wingc.exports.memory.buffer, data_ptr, data_len);
        const data_str = new TextDecoder().decode(data_buf);
        raw_diagnostics.push(JSON.parse(data_str));
    }
    const callWing = (func, args) => {
        if (badState) {
            return null;
        }
        try {
            const result = wingCompiler.invoke(wingc, func, JSON.stringify(args));
            if (typeof result === "number") {
                if (result === 0) {
                    return null;
                }
                else {
                    return result;
                }
            }
            else {
                return JSON.parse(result);
            }
        }
        catch (e) {
            // set status in ide
            void connection.sendDiagnostics({
                uri: args.textDocument.uri,
                diagnostics: [
                    {
                        severity: node_1.DiagnosticSeverity.Error,
                        message: `Wing language server crashed and will resume when changes are made. See logs for details.`,
                        source: "Wing",
                        range: {
                            start: {
                                line: 0,
                                character: 0,
                            },
                            end: {
                                line: 0,
                                character: 0,
                            },
                        },
                    },
                ],
            });
            badState = true;
            return null;
        }
    };
    let connection = (0, node_1.createConnection)(process.stdin, process.stdout);
    connection.onInitialize((params) => {
        // certain IDEs don't internally respect a `parameterHints` option, so we must check it ourselves
        const signatureHelpProvider = params.initializationOptions?.parameterHints ?? true
            ? {
                triggerCharacters: ["(", ",", ")"],
            }
            : undefined;
        const result = {
            capabilities: {
                textDocumentSync: node_1.TextDocumentSyncKind.Full,
                completionProvider: {
                    triggerCharacters: [".", ":"],
                },
                signatureHelpProvider,
                codeActionProvider: true,
                hoverProvider: true,
                documentSymbolProvider: true,
                definitionProvider: true,
                renameProvider: { prepareProvider: true },
            },
        };
        return result;
    });
    async function handle_event_and_update_diagnostics(wingc_handler_name, params, _uri) {
        if (badState) {
            wingc = await wingCompiler.load({
                imports: {
                    env: {
                        send_diagnostic,
                    },
                },
            });
            badState = false;
        }
        // Reset diagnostics list
        raw_diagnostics.length = 0;
        // Call wingc handler
        callWing(wingc_handler_name, params);
        const allDiagnostics = new Map();
        // set empty list of diagnostics for files that have been seen before
        // this way even if we don't get a diagnostic for a file, we clear out the old ones
        for (const uri of seenFiles) {
            allDiagnostics.set(uri, []);
        }
        for (const rd of raw_diagnostics) {
            if (rd.span) {
                const diagnosticUri = "file://" + rd.span.file_id;
                let message = rd.message;
                if (rd.hints.length > 0) {
                    message += `\n${rd.hints.map((hint) => `hint: ${hint}`).join("\n")}`;
                }
                const diag = node_1.Diagnostic.create(node_1.Range.create(rd.span.start.line, rd.span.start.col, rd.span.end.line, rd.span.end.col), message, undefined, undefined, undefined, rd.annotations.map((a) => ({
                    location: node_1.Location.create("file://" + a.span.file_id, node_1.Range.create(a.span.start.line, a.span.start.col, a.span.end.line, a.span.end.col)),
                    message: a.message,
                })));
                // Add annotations as notes hinting back to the original diagnostic
                const extraNotes = rd.annotations.map((a) => node_1.Diagnostic.create(node_1.Range.create(a.span.start.line, a.span.start.col, a.span.end.line, a.span.end.col), a.message, node_1.DiagnosticSeverity.Hint, undefined, undefined, [
                    {
                        location: node_1.Location.create(diagnosticUri, diag.range),
                        message: `(source) ${diag.message}`,
                    },
                ]));
                if (!allDiagnostics.has(diagnosticUri)) {
                    allDiagnostics.set(diagnosticUri, []);
                    seenFiles.add(diagnosticUri);
                }
                allDiagnostics.get(diagnosticUri).push(diag, ...extraNotes);
            }
            else {
                // skip if diagnostic is not associated with any file
            }
        }
        // purposely not awaiting these calls, notifications are fire-and-forget
        for (const [uri, diagnostics] of allDiagnostics.entries()) {
            void connection.sendDiagnostics({ uri, diagnostics });
        }
    }
    connection.onDidOpenTextDocument((params) => {
        void handle_event_and_update_diagnostics("wingc_on_did_open_text_document", params, params.textDocument.uri);
    });
    connection.onDidChangeTextDocument((params) => {
        void handle_event_and_update_diagnostics("wingc_on_did_change_text_document", params, params.textDocument.uri);
    });
    connection.onCompletion(async (params) => {
        return callWing("wingc_on_completion", params);
    });
    connection.onSignatureHelp(async (params) => {
        return callWing("wingc_on_signature_help", params);
    });
    connection.onDefinition(async (params) => {
        return callWing("wingc_on_goto_definition", params);
    });
    connection.onDocumentSymbol(async (params) => {
        return callWing("wingc_on_document_symbol", params);
    });
    connection.onRenameRequest(async (params) => {
        return callWing("wingc_on_rename", params);
    });
    connection.onPrepareRename(async (params) => {
        return callWing("wingc_on_prepare_rename", params);
    });
    connection.onHover(async (params) => {
        return callWing("wingc_on_hover", params);
    });
    connection.onCodeAction(async (params) => {
        return callWing("wingc_on_code_action", params);
    });
    connection.listen();
}
exports.lsp = lsp;
//# sourceMappingURL=lsp.js.map