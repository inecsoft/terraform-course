"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = __importStar(require("fs/promises"));
const path_1 = require("path");
const vitest_1 = require("vitest");
const pack_1 = require("./pack");
const util_1 = require("../util");
const fixturesDir = (0, path_1.join)(__dirname, "..", "..", "fixtures");
const goodFixtureDir = (0, path_1.join)(__dirname, "..", "..", "..", "..", "examples", "wing-fixture");
console.log = vitest_1.vi.fn();
(0, vitest_1.describe)("wing pack", () => {
    (0, vitest_1.afterEach)(() => {
        vitest_1.vi.restoreAllMocks();
    });
    (0, vitest_1.it)("throws an error if a project is missing package.json", async () => {
        const projectDir = (0, path_1.join)(fixturesDir, "invalid1");
        const outdir = await (0, util_1.generateTmpDir)();
        process.chdir(projectDir);
        await (0, vitest_1.expect)((0, pack_1.pack)({ outFile: (0, path_1.join)(outdir, "tarball.tgz") })).rejects.toThrow(/No package.json found in the current directory./);
        await expectNoTarball(outdir);
    });
    (0, vitest_1.it)("throws an error if package.json is missing a required field", async () => {
        const projectDir = (0, path_1.join)(fixturesDir, "invalid2");
        const outdir = await (0, util_1.generateTmpDir)();
        process.chdir(projectDir);
        await (0, vitest_1.expect)((0, pack_1.pack)({ outFile: (0, path_1.join)(outdir, "tarball.tgz") })).rejects.toThrow(/Missing required field "license" in package.json/);
        await expectNoTarball(outdir);
    });
    (0, vitest_1.it)("throws an error if the project doesn't compile", async () => {
        const projectDir = (0, path_1.join)(fixturesDir, "invalid3");
        const outdir = await (0, util_1.generateTmpDir)();
        process.chdir(projectDir);
        await (0, vitest_1.expect)((0, pack_1.pack)({ outFile: (0, path_1.join)(outdir, "tarball.tgz") })).rejects.toThrow(/Expected ';'/);
        await expectNoTarball(outdir);
    });
    (0, vitest_1.it)("throws an error if necessary wing files are excluded by package.json", async () => {
        // invalid4's package.json contains this:
        // {
        //   ...
        //   "files": [
        //     "!file1.w"
        //   ]
        // }
        const projectDir = (0, path_1.join)(fixturesDir, "invalid4");
        const outdir = await (0, util_1.generateTmpDir)();
        process.chdir(projectDir);
        await (0, vitest_1.expect)((0, pack_1.pack)()).rejects.toThrow(/Cannot find module ".\/file1.w"/);
        await expectNoTarball(outdir);
    });
    (0, vitest_1.it)("throws an error if wing files are located in invalid directories", async () => {
        const projectDir = (0, path_1.join)(fixturesDir, "invalid5");
        const outdir = await (0, util_1.generateTmpDir)();
        process.chdir(projectDir);
        await (0, vitest_1.expect)((0, pack_1.pack)({ outFile: (0, path_1.join)(outdir, "tarball.tgz") })).rejects.toThrow();
        await expectNoTarball(outdir);
    });
    (0, vitest_1.it)("throws an error if package.json uses dependencies instead of peerDependencies", async () => {
        // GIVEN
        const projectDir = (0, path_1.join)(fixturesDir, "invalid6");
        const outdir = await (0, util_1.generateTmpDir)();
        process.chdir(projectDir);
        // WHEN
        await (0, vitest_1.expect)((0, pack_1.pack)({ outFile: (0, path_1.join)(outdir, "tarball.tgz") })).rejects.toThrow(/Cannot create package with "dependencies" in package.json. Use "peerDependencies" instead./);
        // THEN
        await expectNoTarball(outdir);
    });
    (0, vitest_1.it)("includes empty dependencies in package.json", async () => {
        // valid1's package.json contains this:
        // {
        //   ...
        //   "dependencies": {}
        // }
        // GIVEN
        const projectDir = (0, path_1.join)(fixturesDir, "valid1");
        const outdir = await (0, util_1.generateTmpDir)();
        process.chdir(projectDir);
        // WHEN
        await (0, vitest_1.expect)((0, pack_1.pack)({ outFile: (0, path_1.join)(outdir, "tarball.tgz") })).resolves.not.toThrow();
        // THEN
        const tarballContents = await extractTarball((0, path_1.join)(outdir, "tarball.tgz"), outdir);
        (0, vitest_1.expect)(tarballContents).toBeDefined();
    });
    (0, vitest_1.it)("includes extra files specified by package.json", async () => {
        // valid1's package.json contains this:
        // {
        //   ...
        //   "files": [
        //     "**/*.ts"
        //   ]
        // }
        // GIVEN
        const projectDir = (0, path_1.join)(fixturesDir, "valid1");
        const outdir = await (0, util_1.generateTmpDir)();
        process.chdir(projectDir);
        // WHEN
        await (0, pack_1.pack)({ outFile: (0, path_1.join)(outdir, "tarball.tgz") });
        // THEN
        const tarballContents = await extractTarball((0, path_1.join)(outdir, "tarball.tgz"), outdir);
        (0, vitest_1.expect)(tarballContents["util.ts"]).toBeDefined();
    });
    (0, vitest_1.it)("excludes files in /target from the packaged tarball", async () => {
        const projectDir = (0, path_1.join)(fixturesDir, "valid1");
        const outdir = await (0, util_1.generateTmpDir)();
        // copy everything to the output directory to sandbox this test
        await (0, util_1.exec)(`cp -r ${projectDir}/* ${outdir}`);
        process.chdir(outdir);
        // create a file in /target
        await fs.mkdir("target");
        await fs.writeFile("target/index.js", "console.log('hello world');");
        await (0, pack_1.pack)({ outFile: (0, path_1.join)(outdir, "tarball.tgz") });
        const tarballContents = await extractTarball((0, path_1.join)(outdir, "tarball.tgz"), outdir);
        (0, vitest_1.expect)(tarballContents["target/index.js"]).toBeUndefined();
    });
    (0, vitest_1.it)("packages a valid Wing project to a default path", async () => {
        // GIVEN
        const outdir = await (0, util_1.generateTmpDir)();
        // WHEN
        process.chdir(goodFixtureDir);
        await (0, pack_1.pack)({ outFile: (0, path_1.join)(outdir, "tarball.tgz") });
        process.chdir(outdir);
        // THEN
        const files = await fs.readdir(outdir);
        (0, vitest_1.expect)(files.filter((path) => path.endsWith(".tgz")).length).toEqual(1);
        const tarballPath = files.find((path) => path.endsWith(".tgz"));
        const tarballContents = await extractTarball((0, path_1.join)(outdir, tarballPath), outdir);
        const expectedFiles = ["README.md", "package.json", "store.w"];
        for (const file of expectedFiles) {
            (0, vitest_1.expect)(tarballContents[file]).toBeDefined();
        }
        const pkgJson = JSON.parse(tarballContents["package.json"]);
        (0, vitest_1.expect)(pkgJson.name).toEqual("@winglibs/testfixture");
        (0, vitest_1.expect)(pkgJson.keywords.includes("winglang")).toBe(true);
        (0, vitest_1.expect)(pkgJson.engines.wing).toEqual("*");
        (0, vitest_1.expect)(pkgJson.wing).toEqual(true);
    });
    (0, vitest_1.it)("can consume a Wing project from JS", async () => {
        // GIVEN
        const outdir = await (0, util_1.generateTmpDir)();
        // WHEN
        process.chdir(goodFixtureDir);
        await (0, pack_1.pack)({ outFile: (0, path_1.join)(outdir, "tarball.tgz") });
        process.chdir(outdir);
        // THEN
        const files = await fs.readdir(outdir);
        (0, vitest_1.expect)(files.filter((path) => path.endsWith(".tgz")).length).toEqual(1);
        const tarballPath = files.find((path) => path.endsWith(".tgz"));
        await extractTarball((0, path_1.join)(outdir, tarballPath), outdir);
        // symlink node_modules/@winglang/sdk to our version of the sdk so the import works
        await fs.mkdir((0, path_1.join)(outdir, "package", "node_modules", "@winglang"), { recursive: true });
        await fs.symlink(require.resolve("@winglang/sdk"), (0, path_1.join)(outdir, "package", "node_modules", "@winglang", "sdk"));
        const packagePath = (0, path_1.join)(outdir, "package");
        const modPackage = await Promise.resolve(`${(0, path_1.join)(packagePath, "package.json")}`).then(s => __importStar(require(s)));
        const mod = await Promise.resolve(`${(0, path_1.join)(packagePath, modPackage.main)}`).then(s => __importStar(require(s)));
        (0, vitest_1.expect)(mod).toBeDefined();
        (0, vitest_1.expect)(Object.keys(mod).sort()).toMatchInlineSnapshot(`
      [
        "FavoriteNumbers",
        "Store",
        "default",
        "subdir",
      ]
    `);
    });
    (0, vitest_1.it)("packages a valid Wing project to a user-specified path", async () => {
        // GIVEN
        const outdir = await (0, util_1.generateTmpDir)();
        // WHEN
        process.chdir(goodFixtureDir);
        await (0, pack_1.pack)({ outFile: (0, path_1.join)(outdir, "tarball.tgz") });
        process.chdir(outdir);
        // THEN
        const files = await fs.readdir(outdir);
        (0, vitest_1.expect)(files.filter((path) => path.endsWith(".tgz")).length).toEqual(1);
        const tarballPath = files.find((path) => path.endsWith(".tgz"));
        const tarballContents = await extractTarball((0, path_1.join)(outdir, tarballPath), outdir);
        (0, vitest_1.expect)(Object.keys(tarballContents).sort()).toMatchInlineSnapshot(`
      [
        "$lib/.wing/inflight.Store-2.cjs",
        "$lib/.wing/inflight.Store-2.cjs.map",
        "$lib/.wing/inflight.Util-1.cjs",
        "$lib/.wing/inflight.Util-1.cjs.map",
        "$lib/.wing/preflight.cjs",
        "$lib/.wing/preflight.cjs.map",
        "$lib/.wing/preflight.d.cts",
        "$lib/.wing/preflight.enums-1.cjs",
        "$lib/.wing/preflight.enums-1.cjs.map",
        "$lib/.wing/preflight.enums-1.d.cts",
        "$lib/.wing/preflight.store-3.cjs",
        "$lib/.wing/preflight.store-3.cjs.map",
        "$lib/.wing/preflight.store-3.d.cts",
        "$lib/.wing/preflight.subdir-4.cjs",
        "$lib/.wing/preflight.subdir-4.cjs.map",
        "$lib/.wing/preflight.subdir-4.d.cts",
        "$lib/.wing/preflight.util-2.cjs",
        "$lib/.wing/preflight.util-2.cjs.map",
        "$lib/.wing/preflight.util-2.d.cts",
        "LICENSE",
        "README.md",
        "enums.w",
        "package.json",
        "store.w",
        "subdir/util.w",
        "util.extern.d.ts",
        "util.js",
        "util.ts",
      ]
    `);
        const pkgJson = JSON.parse(tarballContents["package.json"]);
        (0, vitest_1.expect)(pkgJson.name).toEqual("@winglibs/testfixture");
        (0, vitest_1.expect)(pkgJson.keywords.includes("winglang")).toBe(true);
        (0, vitest_1.expect)(pkgJson.engines.wing).toEqual("*");
        (0, vitest_1.expect)(pkgJson.wing).toEqual(true);
    });
    (0, vitest_1.it)("creates a tarball with a custom filename when using the out-file option", async () => {
        // GIVEN
        const projectDir = goodFixtureDir;
        const outdir = await (0, util_1.generateTmpDir)();
        process.chdir(projectDir);
        const customFilename = "custom-tarball.tgz";
        // WHEN
        await (0, pack_1.pack)({ outFile: (0, path_1.join)(outdir, customFilename) });
        // THEN
        const files = await fs.readdir(outdir);
        (0, vitest_1.expect)(files.includes(customFilename)).toBe(true);
    });
});
/**
 * Asserts that no tarball was created in the specified directory.
 */
async function expectNoTarball(projectDir) {
    const files = await fs.readdir(projectDir);
    (0, vitest_1.expect)(files.findIndex((path) => path.endsWith(".tgz"))).toEqual(-1);
}
async function extractTarball(src, outdir) {
    await (0, util_1.exec)(`tar -xzf ${src} -C ${outdir}`);
    const contents = {};
    // when you extract an npm tarball, it creates a directory called "package"
    const base = (0, path_1.join)(outdir, "package");
    async function readDir(dir) {
        const files = await fs.readdir((0, path_1.join)(base, dir));
        for (const file of files) {
            const path = (0, path_1.join)(base, dir, file);
            const stat = await fs.stat(path);
            if (stat.isDirectory()) {
                await readDir((0, path_1.join)(dir, file));
            }
            else {
                contents[(0, path_1.join)(dir, file)] = (await fs.readFile(path)).toString();
            }
        }
    }
    await readDir(".");
    return contents;
}
//# sourceMappingURL=pack.test.js.map