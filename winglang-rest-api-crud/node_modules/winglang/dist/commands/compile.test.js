"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const promises_1 = require("fs/promises");
const os_1 = require("os");
const path_1 = require("path");
const compiler_1 = require("@winglang/compiler");
const vitest_1 = require("vitest");
const compile_1 = require("./compile");
const exampleDir = (0, path_1.resolve)("../../examples/tests/valid");
const exampleErrorDir = (0, path_1.resolve)("../../examples/tests/error");
const exampleSmallDir = (0, path_1.resolve)("../../examples/tests/valid/subdir2");
const exampleFilePath = (0, path_1.join)(exampleDir, "captures.test.w");
function rndTargetDir() {
    return `./target/wingtest-${Math.random().toString(36).substring(7)}`;
}
(0, vitest_1.describe)("compile command tests", () => {
    (0, vitest_1.test)("should be able to compile the SDK capture test to sim", async () => {
        const outDir = await (0, compile_1.compile)(exampleFilePath, {
            platform: [compiler_1.BuiltinPlatform.SIM],
            targetDir: rndTargetDir(),
        });
        const stats = await (0, promises_1.stat)(outDir);
        (0, vitest_1.expect)(stats.isDirectory()).toBeTruthy();
        const files = (await (0, promises_1.readdir)(outDir)).sort();
        (0, vitest_1.expect)(files.length).toBeGreaterThan(0);
        (0, vitest_1.expect)(files).toMatchInlineSnapshot(`
        [
          ".wing",
          "connections.json",
          "simulator.json",
          "tree.json",
        ]
      `);
    });
    (0, vitest_1.test)("should be able to compile the SDK capture test to tf-aws", async () => {
        const artifactDir = await (0, compile_1.compile)(exampleFilePath, {
            platform: [compiler_1.BuiltinPlatform.TF_AWS],
            targetDir: rndTargetDir(),
        });
        const expectedFiles = ["main.tf.json", "tree.json", "connections.json"];
        const stats = await (0, promises_1.stat)(artifactDir);
        (0, vitest_1.expect)(stats.isDirectory()).toBeTruthy();
        const files = await (0, promises_1.readdir)(artifactDir);
        (0, vitest_1.expect)(files.length).toBeGreaterThan(0);
        expectedFiles.forEach((file) => (0, vitest_1.expect)(files).toContain(file));
    });
    (0, vitest_1.test)("should be able to compile to default target sim", async () => {
        const outDir = await (0, compile_1.compile)(exampleFilePath, {
            platform: [compiler_1.BuiltinPlatform.SIM],
            targetDir: rndTargetDir(),
        });
        const stats = await (0, promises_1.stat)(outDir);
        (0, vitest_1.expect)(stats.isDirectory()).toBeTruthy();
        const files = (await (0, promises_1.readdir)(outDir)).sort();
        (0, vitest_1.expect)(files.length).toBeGreaterThan(0);
        (0, vitest_1.expect)(files).toMatchInlineSnapshot(`
        [
          ".wing",
          "connections.json",
          "simulator.json",
          "tree.json",
        ]
      `);
    });
    (0, vitest_1.test)("should be able to compile the only entrypoint file in current directory", async () => {
        const outDir = await (0, promises_1.mkdtemp)((0, path_1.join)((0, os_1.tmpdir)(), "-wing-compile-test"));
        const prevdir = process.cwd();
        try {
            process.chdir(outDir);
            await (0, promises_1.writeFile)("main.w", "bring cloud;");
            await (0, compile_1.compile)();
            const stats = await (0, promises_1.stat)(outDir);
            (0, vitest_1.expect)(stats.isDirectory()).toBeTruthy();
            const files = (await (0, promises_1.readdir)(outDir)).sort();
            (0, vitest_1.expect)(files.length).toBeGreaterThan(0);
            (0, vitest_1.expect)(files).toEqual(["main.w", "target"]);
        }
        finally {
            process.chdir(prevdir);
        }
    });
    (0, vitest_1.test)("should error if a nonexistent file is compiled", async () => {
        return (0, vitest_1.expect)((0, compile_1.compile)("non-existent-file.w", { platform: [compiler_1.BuiltinPlatform.SIM] })).rejects.toThrowError(/Source file cannot be found/);
    });
    (0, vitest_1.test)("should create verbose stacktrace with DEBUG env set", async () => {
        const exampleErrorFile = (0, path_1.join)(exampleErrorDir, "bool_from_json.test.w");
        await (0, vitest_1.expect)((0, compile_1.compile)(exampleErrorFile, { platform: [compiler_1.BuiltinPlatform.SIM] })).rejects.not.toThrowError(/wingsdk/);
        const prevDebug = process.env.DEBUG;
        process.env.DEBUG = "true";
        await (0, vitest_1.expect)((0, compile_1.compile)(exampleErrorFile, { platform: [compiler_1.BuiltinPlatform.SIM] })).rejects.toThrowError(/wingsdk/);
        process.env.DEBUG = prevDebug;
    });
    (0, vitest_1.test)("should be able to compile a directory", async () => {
        const artifactDir = await (0, compile_1.compile)(exampleSmallDir, {
            platform: [compiler_1.BuiltinPlatform.SIM],
            targetDir: rndTargetDir(),
        });
        const stats = await (0, promises_1.stat)(artifactDir);
        (0, vitest_1.expect)(stats.isDirectory()).toBeTruthy();
    });
    (0, vitest_1.test)("should be able to compile a directory to tf-aws", async () => {
        const artifactDir = await (0, compile_1.compile)(exampleSmallDir, {
            platform: [compiler_1.BuiltinPlatform.TF_AWS],
            targetDir: rndTargetDir(),
        });
        const stats = await (0, promises_1.stat)(artifactDir);
        (0, vitest_1.expect)(stats.isDirectory()).toBeTruthy();
    });
    // https://github.com/winglang/wing/issues/2081
    (0, vitest_1.test)("should be able to compile extern file from same directory", async () => {
        // temporarily change cwd to the example directory
        const oldCwd = process.cwd();
        try {
            process.chdir(exampleDir);
            // because we changed to the example directory, we can just pass the filename
            const outDir = await (0, compile_1.compile)("extern_implementation.test.w", {
                platform: [compiler_1.BuiltinPlatform.SIM],
                targetDir: rndTargetDir(),
            });
            const stats = await (0, promises_1.stat)(outDir);
            (0, vitest_1.expect)(stats.isDirectory()).toBeTruthy();
            const files = (await (0, promises_1.readdir)(outDir)).sort();
            (0, vitest_1.expect)(files.length).toBeGreaterThan(0);
            (0, vitest_1.expect)(files).toMatchInlineSnapshot(`
          [
            ".wing",
            "connections.json",
            "simulator.json",
            "tree.json",
          ]
        `);
        }
        finally {
            process.chdir(oldCwd);
        }
    });
    (0, vitest_1.test)("should not delete files in the output directory if they are not generated by the compiler", async () => {
        const targetDir = rndTargetDir();
        const artifactDir = await (0, compile_1.compile)(exampleFilePath, {
            platform: [compiler_1.BuiltinPlatform.TF_AWS],
            targetDir,
        });
        const expectedFiles = ["main.tf.json", "tree.json", "connections.json"];
        const files = await (0, promises_1.readdir)(artifactDir);
        (0, vitest_1.expect)(files.length).toBeGreaterThan(0);
        expectedFiles.forEach((file) => (0, vitest_1.expect)(files).toContain(file));
        // create a file in the output directory
        const extraFile = (0, path_1.join)(artifactDir, "terraform.tfstate");
        await (0, promises_1.writeFile)(extraFile, "hello world");
        // recompile
        const artifactDir2 = await (0, compile_1.compile)(exampleFilePath, {
            platform: [compiler_1.BuiltinPlatform.TF_AWS],
            targetDir,
        });
        (0, vitest_1.expect)(artifactDir2).toBe(artifactDir);
        const files2 = await (0, promises_1.readdir)(artifactDir2);
        (0, vitest_1.expect)(files2.length).toBeGreaterThan(0);
        expectedFiles.forEach((file) => (0, vitest_1.expect)(files2).toContain(file));
    });
}, { timeout: 1000 * 60 * 5 });
//# sourceMappingURL=compile.test.js.map