"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const promises_1 = require("fs/promises");
const path_1 = require("path");
const inquirer_1 = __importDefault(require("inquirer"));
const vitest_1 = require("vitest");
const test_1 = require("./test/test");
const init_1 = require("../commands/init");
const util_1 = require("../util");
vitest_1.vitest.mock("inquirer");
const templates = (0, util_1.projectTemplateNames)();
vitest_1.describe.each(templates)("new %s --language=wing", (template) => {
    let log;
    (0, vitest_1.beforeEach)(() => {
        log = console.log;
        console.log = vitest_1.vi.fn();
    });
    (0, vitest_1.afterEach)(() => {
        console.log = log;
    });
    (0, vitest_1.test)(`wing new ${template} && wing test main.w`, async () => {
        const workdir = await (0, util_1.generateTmpDir)();
        process.chdir(workdir);
        await (0, init_1.init)(template, { language: "wing" });
        await (0, test_1.test)(["main.w"], {
            platform: ["sim"],
            clean: false,
        });
    });
});
(0, vitest_1.describe)("new --list-templates", () => {
    let log;
    (0, vitest_1.beforeEach)(() => {
        log = console.log;
        console.log = vitest_1.vi.fn();
    });
    (0, vitest_1.afterEach)(() => {
        console.log = log;
    });
    (0, vitest_1.test)("does not contain duplicate template names", async () => {
        await (0, init_1.init)("", { listTemplates: true });
        (0, vitest_1.expect)(console.log).toHaveBeenCalledWith(templates.join("\n"));
        const outputLines = console.log.mock.calls[0][0].split("\n");
        const outputLinesAsSet = new Set(outputLines);
        (0, vitest_1.expect)(outputLines.length).toBeGreaterThan(0);
        // Check there are no duplicate lines
        (0, vitest_1.expect)(outputLinesAsSet.size).toBe(outputLines.length);
    });
});
(0, vitest_1.describe)("new empty --language=ts", () => {
    let log;
    (0, vitest_1.beforeEach)(() => {
        log = console.log;
        console.log = vitest_1.vi.fn();
    });
    (0, vitest_1.afterEach)(() => {
        console.log = log;
    });
    (0, vitest_1.test)(`wing new empty --language ts && wing test main.w`, async () => {
        const workdir = await (0, util_1.generateTmpDir)();
        process.chdir(workdir);
        await (0, init_1.init)("empty", { language: "typescript" });
        await (0, test_1.test)(["main.ts"], {
            platform: ["sim"],
            clean: false,
        });
    });
});
(0, vitest_1.describe)("new", () => {
    let log;
    (0, vitest_1.beforeEach)(() => {
        log = console.log;
        console.log = vitest_1.vi.fn();
    });
    (0, vitest_1.afterEach)(() => {
        console.log = log;
    });
    (0, vitest_1.test)("wing new invalid-template", async () => {
        const workdir = await (0, util_1.generateTmpDir)();
        process.chdir(workdir);
        await (0, vitest_1.expect)((0, init_1.init)("invalid-template")).rejects.toThrow(/Template "invalid-template" is not available/);
    });
    // test an invalid language
    (0, vitest_1.test)("wing new http-api --language=python", async () => {
        const workdir = await (0, util_1.generateTmpDir)();
        process.chdir(workdir);
        await (0, vitest_1.expect)((0, init_1.init)("http-api", { language: "python" })).rejects.toThrow(/Unknown language/);
    });
    // test an unavailable language
    (0, vitest_1.test)("wing new http-api --language=typescript", async () => {
        const workdir = await (0, util_1.generateTmpDir)();
        process.chdir(workdir);
        await (0, vitest_1.expect)((0, init_1.init)("http-api", { language: "typescript" })).rejects.toThrow(/Template "http-api" is not available in typescript/);
    });
    (0, vitest_1.test)("wing new with conflicting file", async () => {
        const workdir = await (0, util_1.generateTmpDir)();
        process.chdir(workdir);
        // write a conflicting file
        await (0, promises_1.writeFile)((0, path_1.join)(workdir, "main.w"), "hello");
        await (0, vitest_1.expect)((0, init_1.init)("http-api", { language: "wing" })).rejects.toThrow(/The following files already exist in the current directory and will be overwritten/);
    });
    (0, vitest_1.test)("wing new with interactive prompt", async () => {
        const workdir = await (0, util_1.generateTmpDir)();
        process.chdir(workdir);
        inquirer_1.default.prompt = vitest_1.vitest.fn().mockResolvedValue({
            template: "http-api",
            language: "wing",
        });
        await (0, init_1.init)(undefined);
        const files = await (0, promises_1.readdir)(workdir);
        (0, vitest_1.expect)(files).toEqual(["main.w", "package-lock.json", "package.json"]);
    });
});
//# sourceMappingURL=init.test.js.map