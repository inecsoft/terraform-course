"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnalyticsStorage = void 0;
const crypto_1 = require("crypto");
const fs_1 = require("fs");
const os = __importStar(require("os"));
const path_1 = __importDefault(require("path"));
const uuid_1 = require("uuid");
const WING_HOME_DIR = path_1.default.join(os.homedir(), ".wing");
/**
 * Storage class used to encapsulate the storage and retrieval of analytics events
 * and configuration. Errors are ignored for the most part unless in debug mode.
 */
class AnalyticsStorage {
    analyticsStorageDir;
    analyticsConfigFile;
    analyticsConfig;
    debug;
    constructor(props) {
        this.analyticsConfigFile =
            props?.configFile ?? path_1.default.join(path_1.default.join(WING_HOME_DIR, "wing-analytics-config.json"));
        this.analyticsStorageDir =
            props?.analyticsStorageDir ?? path_1.default.join(os.tmpdir(), "wing-analytics");
        this.debug = props?.debug;
        this.analyticsConfig = this.loadConfig();
    }
    /**
     * Stores a single analytic event to disk
     *
     * @param event the analytic event to save
     * @returns the path to the saved event or undefined if there was an error
     */
    storeAnalyticEvent(event) {
        try {
            if (this.analyticsConfig.optOut == true) {
                return undefined;
            }
            const eventId = (0, uuid_1.v4)();
            if (!(0, fs_1.existsSync)(this.analyticsStorageDir)) {
                (0, fs_1.mkdirSync)(this.analyticsStorageDir);
            }
            const analyticReportFile = path_1.default.join(this.analyticsStorageDir, `${eventId}.json`);
            // attach timestamp and anonymousId to event
            event.timestamp = event.timestamp ?? new Date().toISOString();
            // We add the anonymousId only if we are not in a CI environment
            if (event.properties.ci) {
                const anonymousId = this.getAnonymousId();
                event.anonymousId = anonymousId;
            }
            this.saveEvent(analyticReportFile, event);
            return analyticReportFile;
        }
        catch (error) {
            return undefined;
        }
    }
    /**
     * Retrieves an analytic event from disk
     *
     * @param filePath the path the event was saved to
     * @returns the event or undefined if there was an error
     */
    loadEvent(filePath) {
        try {
            const fileContents = (0, fs_1.readFileSync)(filePath, "utf-8");
            return JSON.parse(fileContents);
        }
        catch (error) {
            // ignore
            return undefined;
        }
    }
    /**
     * Reads the analytics config for the user's anonymous id,
     * if an id does not exist, one is generated and saved to disk
     *
     * @returns the anonymous id for the user
     */
    getAnonymousId() {
        let config = this.loadConfig();
        if (!config.anonymousId) {
            config.anonymousId = this.generateAnonymousId();
            this.saveConfig(config);
        }
        return config.anonymousId;
    }
    generateAnonymousId() {
        return (0, crypto_1.randomBytes)(16).toString("hex");
    }
    /**
     * Retrieves the analytics config from disk, if one does not exist
     * a new one is created and saved to disk
     *
     * @returns the analytics config for the user
     */
    loadConfig() {
        try {
            const fileContents = (0, fs_1.readFileSync)(this.analyticsConfigFile, "utf-8");
            return JSON.parse(fileContents);
        }
        catch (error) {
            if (this.debug) {
                console.log(`Error loading analytics config: ${error}`);
            }
            const analyticsConfig = {
                anonymousId: this.generateAnonymousId(),
                optOut: false,
            };
            this.saveConfig(analyticsConfig);
            return analyticsConfig;
        }
    }
    /**
     * Saves the analytics config to disk
     *
     * @param config the analytics config to save to disk
     */
    saveConfig(config) {
        try {
            if (!(0, fs_1.existsSync)(WING_HOME_DIR)) {
                (0, fs_1.mkdirSync)(WING_HOME_DIR);
            }
            (0, fs_1.writeFileSync)(this.analyticsConfigFile, JSON.stringify(config));
        }
        catch (error) {
            if (this.debug) {
                console.log(`Error saving config file ${error}`);
            }
        }
    }
    /**
     * Helper method to flatten objects
     *
     * @param properties The properties to flatten
     * @param parentKey The key of the parent (defaults to "")
     * @returns
     */
    flattenProperties(properties, parentKey = "") {
        return Object.keys(properties).reduce((accumulated, key) => {
            const newKey = parentKey ? `${parentKey}_${key}` : key;
            if (typeof properties[key] === "object" &&
                properties[key] !== null &&
                !Array.isArray(properties[key])) {
                Object.assign(accumulated, this.flattenProperties(properties[key], newKey));
            }
            else {
                accumulated[newKey] = properties[key];
            }
            return accumulated;
        }, {});
    }
    saveEvent(filePath, event) {
        try {
            event.properties = this.flattenProperties(event.properties);
            (0, fs_1.writeFileSync)(filePath, JSON.stringify(event));
            if (this.debug) {
                console.log(`Analytics event stored at ${filePath}`);
            }
        }
        catch (error) {
            if (this.debug) {
                console.log(`Error storing analytics event: ${error}`);
            }
        }
    }
}
exports.AnalyticsStorage = AnalyticsStorage;
//# sourceMappingURL=storage.js.map