"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PACKAGE_VERSION = void 0;
const commander_1 = require("commander");
const compare_versions_1 = require("compare-versions");
const disclaimer_1 = require("./analytics/disclaimer");
const export_1 = require("./analytics/export");
const snapshots_help_1 = require("./commands/test/snapshots-help");
const util_1 = require("./util");
exports.PACKAGE_VERSION = util_1.currentPackage.version;
if (exports.PACKAGE_VERSION == "0.0.0" && !process.env.DEBUG) {
    process.env.WING_DISABLE_ANALYTICS = "1";
}
const SUPPORTED_NODE_VERSION = util_1.currentPackage.engines.node;
if (!SUPPORTED_NODE_VERSION) {
    throw new Error("couldn't parse engines.node version from package.json");
}
const DEFAULT_PLATFORM = ["sim"];
let analyticsExportFile;
function runSubCommand(subCommand, path = subCommand) {
    return async (...args) => {
        try {
            // paths other than the root path aren't working unless specified in the path arg
            const exitCode = await Promise.resolve(`${`./commands/${path}`}`).then(s => __importStar(require(s))).then((m) => m[subCommand](...args));
            if (exitCode === 1) {
                await exportAnalyticsHook();
                process.exitCode = 1;
            }
        }
        catch (err) {
            console.error(err?.message ?? err);
            process.exitCode = 1;
        }
    };
}
let platformOptionCount = 0;
// Removes default if a platform option is provided by user
function collectPlatformVariadic(value, previous) {
    return platformOptionCount++ == 0 ? [value] : collectVariadic(value, previous);
}
// Required to support --option x --option y --option z rather than --option x y z
function collectVariadic(value, previous) {
    return previous.concat([value]);
}
async function collectAnalyticsHook(cmd) {
    if (process.env.WING_DISABLE_ANALYTICS) {
        return;
    }
    // Fail silently if collection fails
    try {
        (0, disclaimer_1.optionallyDisplayDisclaimer)();
        const analyticsModule = await Promise.resolve().then(() => __importStar(require("./analytics/collect")));
        analyticsExportFile = analyticsModule.collectCommandAnalytics(cmd).catch((err) => {
            if (process.env.DEBUG) {
                console.error(err);
            }
            return undefined;
        });
    }
    catch (err) {
        if (process.env.DEBUG) {
            console.error(err);
        }
    }
}
async function exportAnalyticsHook() {
    if (process.env.WING_DISABLE_ANALYTICS) {
        return;
    }
    // Fail silently if export fails
    try {
        if (analyticsExportFile) {
            await (0, export_1.exportAnalytics)(analyticsExportFile);
        }
    }
    catch (err) {
        if (process.env.DEBUG) {
            console.error(err);
        }
    }
}
async function main() {
    checkNodeVersion();
    const program = new commander_1.Command();
    program.configureHelp({
        sortOptions: true,
        showGlobalOptions: true,
    });
    program.name("wing").version(exports.PACKAGE_VERSION);
    program
        .option("--debug", "Enable debug logging (same as DEBUG=1)", () => {
        process.env.DEBUG = "1";
    })
        .option("--progress", "Show compilation progress", () => {
        process.env.PROGRESS = "1";
    })
        .option("--no-progress", "Hide show compilation progress")
        .option("--no-update-check", "Skip checking for toolchain updates")
        .option("--no-analytics", "Disable analytics collection (same as WING_DISABLE_ANALYTICS=1)", () => {
        process.env.WING_DISABLE_ANALYTICS = "1";
    })
        .option("--no-color", "Disable colors for all output", () => {
        process.env.NO_COLOR = "1";
    });
    async function progressHook(cmd) {
        const progress = program.opts().progress;
        if (progress !== false && cmd.opts().platform[0] !== "sim") {
            process.env.PROGRESS = "1";
        }
    }
    async function updateHook(cmd) {
        const updateCheck = cmd.opts().updateCheck;
        if (updateCheck) {
            // most of the update check is network bound, so we don't want to block the rest of the CLI
            void Promise.resolve().then(() => __importStar(require("./commands/upgrade"))).then((m) => m.checkForUpdates());
        }
    }
    function addValue(value, previous) {
        previous.push(value);
        return previous;
    }
    program.hook("preAction", updateHook);
    program
        .command("run")
        .alias("it")
        .description("Runs a Wing program in the Wing Console")
        .argument("[entrypoint]", "program .w entrypoint")
        .option("-p, --port <port>", "specify port")
        .option("--no-open", "Do not open the Wing Console in the browser")
        .option("-w, --watch <globs...>", "Watch additional paths for changes. Supports globs and '!' for negations.")
        .option("-t, --platform <platform> --platform <platform>", "Target platform provider (builtin: sim)", collectPlatformVariadic, DEFAULT_PLATFORM)
        .hook("preAction", collectAnalyticsHook)
        .action(runSubCommand("run"));
    program
        .command("lsp")
        .description("Run the Wing language server on stdio")
        .hook("preAction", collectAnalyticsHook)
        .action(runSubCommand("lsp"));
    program
        .command("compile")
        .description("Compiles a Wing program")
        .argument("[entrypoint]", "program .w entrypoint")
        .option("-t, --platform <platform> --platform <platform>", "Target platform provider (builtin: sim, tf-aws, tf-azure, tf-gcp, awscdk)", collectPlatformVariadic, DEFAULT_PLATFORM)
        .option("-r, --rootId <rootId>", "App root id")
        .option("-o, --output <output>", 'path to the output directory- default is "./target/<entrypoint>.<target>"')
        .option("-v, --value <value>", "Platform-specific value in the form KEY=VALUE", addValue, [])
        .option("--values <file>", "File with platform-specific values (TOML|YAML|JSON)")
        .hook("preAction", progressHook)
        .hook("preAction", collectAnalyticsHook)
        .action(runSubCommand("compile"));
    program
        .command("secrets")
        .description("Manage secrets")
        .argument("[entrypoint]", "program .w entrypoint")
        .option("-t, --platform <platform> --platform <platform>", "Target platform provider (builtin: sim, tf-aws, tf-azure, tf-gcp, awscdk)", collectPlatformVariadic, DEFAULT_PLATFORM)
        .option("-v, --value <value>", "Platform-specific value in the form KEY=VALUE", addValue, [])
        .option("--values <file>", "File with platform-specific values (TOML|YAML|JSON)")
        .addOption(new commander_1.Option("--list", "List required application secrets"))
        .hook("preAction", progressHook)
        .hook("preAction", collectAnalyticsHook)
        .action(runSubCommand("secrets"));
    program
        .command("test")
        .description("Compiles a Wing program and runs all functions with the word 'test' or start with 'test:' in their resource identifiers")
        .argument("[entrypoint...]", "all files to test (globs are supported)")
        .option("-t, --platform <platform> --platform <platform>", "Target platform provider (builtin: sim, tf-aws, tf-azure, tf-gcp, awscdk)", collectPlatformVariadic, DEFAULT_PLATFORM)
        .addOption(new commander_1.Option("-s, --snapshots <mode>", "Capture snapshots of compiler output")
        .choices(["auto", "never", "update", "deploy", "assert"])
        .default("auto"))
        .addHelpText("afterAll", snapshots_help_1.SNAPSHOTS_HELP)
        .option("-r, --rootId <rootId>", "App root id")
        .option("-f, --test-filter <regex>", "Run tests that match the provided regex pattern within the selected entrypoint files")
        .option("--no-clean", "Keep build output")
        .option("--no-stream", "Do not stream logs")
        .option("-o, --output-file <outputFile>", "File name to write test results to (file extension is required, supports only .json at the moment)")
        .addOption(new commander_1.Option("-R, --retry [retries]", "Number of times to retry failed tests")
        .preset(3)
        .argParser(parseInt))
        .addOption(new commander_1.Option("-p, --parallel [batch]", `Number of tests to be executed on parallel- if not specified- ${util_1.DEFAULT_PARALLEL_SIZE} will run on parallel, 0 to run all at once`)
        .preset(util_1.DEFAULT_PARALLEL_SIZE)
        .argParser(parseInt))
        .hook("preAction", progressHook)
        .hook("preAction", collectAnalyticsHook)
        .action(runSubCommand("test", "test/test"));
    program
        .command("pack")
        .description("Package the current directory into an npm library (gzipped tarball).")
        .addOption(new commander_1.Option("-o --out-file <filename>", "Output filename"))
        .hook("preAction", collectAnalyticsHook)
        .action(runSubCommand("pack"));
    program
        .command("new")
        .description("Create a new Wing project")
        .addArgument(new commander_1.Argument("<template>", "Template name").choices((0, util_1.projectTemplateNames)()).argOptional())
        .addOption(new commander_1.Option("-l --language [language]", "Language")
        .choices(["wing", "typescript"])
        .argParser((value) => value ?? "wing"))
        .addOption(new commander_1.Option("--list-templates", "List available templates"))
        .hook("postAction", collectAnalyticsHook) // to catch the options that are added later
        .action(runSubCommand("init"));
    program
        .command("docs")
        .description("Open the Wing documentation")
        .hook("preAction", collectAnalyticsHook)
        .action(runSubCommand("docs"));
    program.hook("postAction", exportAnalyticsHook);
    program.parse();
}
function checkNodeVersion() {
    const supportedVersion = SUPPORTED_NODE_VERSION;
    if (!(0, compare_versions_1.satisfies)(process.version, supportedVersion)) {
        console.warn(`WARNING: You are running an incompatible node.js version ${process.version}. Compatible engine is: ${supportedVersion}.`);
    }
}
main().catch((err) => {
    console.error(err);
    process.exitCode = 1;
});
//# sourceMappingURL=cli.js.map