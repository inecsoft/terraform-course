{"version":3,"sources":["../src/transformer.ts","../src/index.ts","../src/main.ts","../src/internal.ts"],"sourcesContent":["import { dirname, join } from \"path\";\nimport ts from \"typescript\";\n\n/**\n * This transformer finds all usages of `inflight` and does the following with the functions passed to it:\n * 1. Replaces references to top-level imports with inline `require` calls\n * 2. Throws an error if a reference to a non-import variable declared in an outer scope is used\n */\nexport class InflightTransformer {\n  private program: ts.Program;\n  public readonly extraErrors: ts.Diagnostic[] = [];\n\n  constructor(program: ts.Program) {\n    this.program = program;\n  }\n\n  public transform(context: ts.TransformationContext) {\n    const typeChecker = this.program.getTypeChecker();\n\n    function isInBlock(node: ts.Node, block: ts.Block) {\n      while (node) {\n        if (node === block) {\n          return true;\n        }\n        node = node.parent;\n      }\n      return false;\n    }\n\n    /**\n     * Checks if the given node is a reference to special `inflight` symbol\n     * This will be any symbol that has a jsdoc tag `@wing inflight`\n     */\n    function isInflightSymbol(node: ts.Node) {\n      let sym = typeChecker.getTypeAtLocation(node).symbol;\n      const docs = sym.getJsDocTags(typeChecker);\n      const wingDoc = docs?.find((doc) => doc.name === \"wing\");\n      return wingDoc?.text?.[0]?.text === \"inflight\";\n    }\n\n    return (sourceFile: ts.SourceFile) => {\n      let inflightClosureScope: ts.ConciseBody | undefined;\n\n      /**\n       * Converts `import a from \"module\"` to `require(\"module\")`\n       */\n      function requireFromClause(importClause: ts.ImportClause) {\n        let moduleSpecifier = importClause.parent.moduleSpecifier;\n        if (ts.isStringLiteral(moduleSpecifier)) {\n          const text = moduleSpecifier.text;\n          if (text.startsWith(\".\")) {\n            const resolved = join(\n              dirname(sourceFile.fileName),\n              text\n            ).replaceAll(\"\\\\\", \"/\");\n            moduleSpecifier = context.factory.createStringLiteral(resolved);\n          }\n        }\n\n        return context.factory.createCallExpression(\n          context.factory.createIdentifier(\"require\"),\n          undefined,\n          [moduleSpecifier]\n        );\n      }\n\n      /**\n       * Converts `import { a } from \"module\"` to `require(\"module\").a`\n       */\n      function requireImportSpec(importSpec: ts.ImportSpecifier) {\n        const importName = importSpec.propertyName || importSpec.name;\n        return context.factory.createPropertyAccessExpression(\n          requireFromClause(importSpec.parent.parent),\n          importName\n        );\n      }\n\n      const visitor = (node: ts.Node): ts.Node => {\n        // check if the call is to the special inflight function\n        if (\n          (ts.isArrowFunction(node) || ts.isFunctionExpression(node)) &&\n          ts.isCallExpression(node.parent) &&\n          isInflightSymbol(node.parent.expression)\n        ) {\n          // we are in a node that looks like this;\n          // inflight(async () => {})\n          // let's get to the scope of the inner ArrowFunction\n          inflightClosureScope = node.body;\n          const result = ts.visitEachChild(node, visitor, context);\n          inflightClosureScope = undefined;\n          return result;\n        }\n\n        const result = ts.visitEachChild(node, visitor, context);\n\n        if (inflightClosureScope && ts.isIdentifier(node)) {\n          const sym = typeChecker.getSymbolAtLocation(node);\n          if (!sym) return result;\n\n          // if this symbol was declared from an import statement, we need to recreate that inline\n          const mostRecentDecl = sym.declarations?.at(0);\n          if (mostRecentDecl?.getSourceFile() === sourceFile) {\n            if (ts.isImportClause(mostRecentDecl)) {\n              return requireFromClause(mostRecentDecl);\n            } else if (ts.isImportSpecifier(mostRecentDecl)) {\n              return requireImportSpec(mostRecentDecl);\n            } else if (ts.isNamespaceImport(mostRecentDecl)) {\n              return requireFromClause(mostRecentDecl.parent);\n            } else if (ts.isVariableDeclaration(mostRecentDecl)) {\n              if (\n                !isInBlock(mostRecentDecl, inflightClosureScope as ts.Block)\n              ) {\n                this.extraErrors.push({\n                  messageText: `Unable to access \"${sym.escapedName}\" in inflight closure. Use 'lift( { ${sym.escapedName} } )' before 'inflight' and reference through ctx.`,\n                  code: 0,\n                  category: ts.DiagnosticCategory.Error,\n                  file: sourceFile,\n                  start: node.getStart(),\n                  length: node.getEnd() - node.getStart(),\n                });\n              }\n            }\n          }\n        }\n\n        return result;\n      };\n\n      return ts.visitNode(sourceFile, visitor) as ts.SourceFile;\n    };\n  }\n}\n","// re-exporting useful types from the sdk\nexport { cloud, ex } from \"@winglang/sdk\";\nexport { Construct } from \"@winglang/sdk/lib/core/types\";\n\n// typescript workflow primitives\nexport { inflight, lift } from \"@winglang/sdk/lib/core\";\nexport { main } from \"./main\";\n\n// used internally by wing compiler\nexport * as internal from \"./internal\";\n","import { platform, std } from \"@winglang/sdk\";\nimport type { Construct } from \"@winglang/sdk/lib/core/types\";\n\n/**\n * Properties for a Wing app.\n */\nexport interface AppProps {\n  /**\n   * The name and id of the app.\n   * @default \"main\"\n   */\n  name?: string;\n}\n\n/**\n * Create a Wing app.\n *\n * ```ts\n * import { main, cloud } from \"@wingcloud/framework\";\n *\n * main((root) => {\n *   new cloud.Bucket(root, \"Bucket\");\n * });\n * ```\n *\n * Tests can be added using the second argument:\n *\n * ```ts\n * import { main, cloud } from \"@wingcloud/framework\";\n *\n * main((root, test) => {\n *   new cloud.Bucket(root, \"Bucket\");\n *\n *   test(\"bucket holds stuff\", async () => {\n *     lift({ bucket }).inflight(async ({ bucket }) => {\n *       await bucket.put(\"key\", \"value\");\n *     });\n *   });\n *\n * });\n * ```\n *\n * @param fn Define your application using the provided root construct.\n *           Note that this function may be called multiple times when used with `wing test`.\n */\nexport function main(\n  fn: (\n    root: Construct,\n    test: (\n      name: string,\n      handler: std.ITestHandler,\n      props?: std.TestProps\n    ) => void\n  ) => void,\n  props: AppProps = {}\n) {\n  // check if we have everything we need\n  const requiredEnvVars = [\n    \"WING_PLATFORMS\",\n    \"WING_SYNTH_DIR\",\n    \"WING_SOURCE_DIR\",\n    \"WING_IS_TEST\",\n  ];\n  for (const envVar of requiredEnvVars) {\n    if (process.env[envVar] === undefined) {\n      throw new Error(`\\\nMissing environment variable: ${envVar}\nThis is a Wing app and must be run through the Wing CLI (npm install -f winglang).`);\n    }\n  }\n\n  class $Root extends std.Resource {\n    constructor(scope: Construct, id: string) {\n      super(scope, id);\n      fn(this, (name, handler, props) => {\n        new std.Test(this, name, handler, props);\n      });\n    }\n  }\n\n  const platformPaths = ((s) => (!s ? [] : s.split(\";\")))(\n    process.env.WING_PLATFORMS\n  );\n  const outdir = process.env.WING_SYNTH_DIR;\n  const name = props.name ?? \"main\";\n  const rootConstruct = $Root;\n  const isTestEnvironment = process.env.WING_IS_TEST === \"true\";\n  const entrypointDir = process.env.WING_SOURCE_DIR!;\n  const rootId = process.env.WING_ROOT_ID;\n\n  const $PlatformManager = new platform.PlatformManager({ platformPaths });\n  const app = $PlatformManager.createApp({\n    outdir,\n    name,\n    rootConstruct,\n    isTestEnvironment,\n    entrypointDir,\n    rootId,\n  });\n\n  app.synth();\n}\n","import { dirname, join } from \"path\";\nimport type ts from \"typescript\";\n\nexport interface CompileOptions {\n  workDir: string;\n  entrypoint: string;\n}\n\nexport async function compile(options: CompileOptions) {\n  const entrypointDir = dirname(options.entrypoint);\n  const ts = (await import(\"typescript\")).default;\n  const outDir = join(options.workDir, \"ts\");\n  const wingsdkDir = dirname(require.resolve(\"@winglang/sdk\"));\n\n  const tsconfigPath = ts.findConfigFile(entrypointDir, ts.sys.fileExists);\n  const mandatoryCompilerOptions: ts.CompilerOptions = {\n    // Managed options\n    target: ts.ScriptTarget.ES2022,\n    module: ts.ModuleKind.CommonJS,\n    moduleResolution: ts.ModuleResolutionKind.Node10,\n    paths: {\n      \"@winglang/sdk\": [wingsdkDir],\n      \"@winglang/sdk/*\": [wingsdkDir + \"/*\"],\n    },\n    outDir,\n    listEmittedFiles: true,\n    noEmitOnError: true,\n  };\n\n  const defaultCompilerOptions: ts.CompilerOptions = {\n    sourceMap: true,\n    declaration: false,\n    skipLibCheck: true,\n    isolatedModules: true,\n    esModuleInterop: true,\n  };\n\n  let compilerOptions: ts.CompilerOptions = defaultCompilerOptions;\n\n  if (tsconfigPath) {\n    const { config, error } = ts.readConfigFile(tsconfigPath, ts.sys.readFile);\n    if (error) {\n      throw new Error(\n        `Failed to read tsconfig at ${tsconfigPath}: ${error.messageText}`\n      );\n    }\n\n    const { options, errors } = ts.parseJsonConfigFileContent(\n      config,\n      ts.sys,\n      dirname(tsconfigPath),\n      compilerOptions\n    );\n    compilerOptions = options;\n\n    if (errors.length > 0) {\n      throw new Error(\n        `Failed to parse tsconfig at ${tsconfigPath}: ${errors\n          .map((e) => e.messageText)\n          .join(\"\\n\")}`\n      );\n    }\n\n    let attemptedOverride = false;\n    for (const managedOption of Object.keys(mandatoryCompilerOptions)) {\n      if (config?.compilerOptions?.[managedOption] !== undefined) {\n        console.warn(\n          `'${managedOption}' is managed by wing and will be ignored from ${tsconfigPath}`\n        );\n        attemptedOverride = true;\n        delete options[managedOption];\n      }\n    }\n\n    if (attemptedOverride) {\n      console.warn(`tsconfig options used:`);\n      console.warn(compilerOptions);\n    }\n  }\n\n  Object.assign(compilerOptions, mandatoryCompilerOptions);\n\n  const program = ts.createProgram([options.entrypoint], compilerOptions);\n\n  const { InflightTransformer } = await import(\"./transformer\");\n  const transformer = new InflightTransformer(program);\n\n  const emitResult = program.emit(undefined, undefined, undefined, undefined, {\n    before: [(sourceFile) => transformer.transform(sourceFile)],\n  });\n\n  const allDiagnostics = emitResult.diagnostics.concat(transformer.extraErrors);\n\n  if (\n    emitResult.emitSkipped ||\n    allDiagnostics.filter((d) => d.category === ts.DiagnosticCategory.Error)\n      .length > 0\n  ) {\n    const fullError = ts.formatDiagnosticsWithColorAndContext(allDiagnostics, {\n      getCanonicalFileName: (f) => f,\n      getCurrentDirectory: () => process.cwd(),\n      getNewLine: () => \"\\n\",\n    });\n\n    throw new Error(`TS compilation failed:\\n${fullError}`);\n  }\n\n  // get the last .js file emitted, this should be the entrypoint\n  const emittedFiles = emitResult.emittedFiles?.filter((f) =>\n    f.endsWith(\".js\")\n  );\n  const emittedFile = emittedFiles?.[emittedFiles.length - 1];\n\n  if (!emittedFile) {\n    throw new Error(\n      `TS compilation failed: Could not find emitted file in ${outDir}`\n    );\n  }\n\n  return emittedFile;\n}\n"],"mappings":"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","names":["ts","result","import_sdk","name","props","import_path","ts","options","InflightTransformer"]}