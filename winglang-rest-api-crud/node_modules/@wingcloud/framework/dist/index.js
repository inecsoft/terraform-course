"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/transformer.ts
var transformer_exports = {};
__export(transformer_exports, {
  InflightTransformer: () => InflightTransformer
});
var import_path, import_typescript, InflightTransformer;
var init_transformer = __esm({
  "src/transformer.ts"() {
    "use strict";
    import_path = require("path");
    import_typescript = __toESM(require("typescript"));
    InflightTransformer = class {
      program;
      extraErrors = [];
      constructor(program) {
        this.program = program;
      }
      transform(context) {
        const typeChecker = this.program.getTypeChecker();
        function isInBlock(node, block) {
          while (node) {
            if (node === block) {
              return true;
            }
            node = node.parent;
          }
          return false;
        }
        function isInflightSymbol(node) {
          let sym = typeChecker.getTypeAtLocation(node).symbol;
          const docs = sym.getJsDocTags(typeChecker);
          const wingDoc = docs?.find((doc) => doc.name === "wing");
          return wingDoc?.text?.[0]?.text === "inflight";
        }
        return (sourceFile) => {
          let inflightClosureScope;
          function requireFromClause(importClause) {
            let moduleSpecifier = importClause.parent.moduleSpecifier;
            if (import_typescript.default.isStringLiteral(moduleSpecifier)) {
              const text = moduleSpecifier.text;
              if (text.startsWith(".")) {
                const resolved = (0, import_path.join)(
                  (0, import_path.dirname)(sourceFile.fileName),
                  text
                ).replaceAll("\\", "/");
                moduleSpecifier = context.factory.createStringLiteral(resolved);
              }
            }
            return context.factory.createCallExpression(
              context.factory.createIdentifier("require"),
              void 0,
              [moduleSpecifier]
            );
          }
          function requireImportSpec(importSpec) {
            const importName = importSpec.propertyName || importSpec.name;
            return context.factory.createPropertyAccessExpression(
              requireFromClause(importSpec.parent.parent),
              importName
            );
          }
          const visitor = (node) => {
            if ((import_typescript.default.isArrowFunction(node) || import_typescript.default.isFunctionExpression(node)) && import_typescript.default.isCallExpression(node.parent) && isInflightSymbol(node.parent.expression)) {
              inflightClosureScope = node.body;
              const result2 = import_typescript.default.visitEachChild(node, visitor, context);
              inflightClosureScope = void 0;
              return result2;
            }
            const result = import_typescript.default.visitEachChild(node, visitor, context);
            if (inflightClosureScope && import_typescript.default.isIdentifier(node)) {
              const sym = typeChecker.getSymbolAtLocation(node);
              if (!sym)
                return result;
              const mostRecentDecl = sym.declarations?.at(0);
              if (mostRecentDecl?.getSourceFile() === sourceFile) {
                if (import_typescript.default.isImportClause(mostRecentDecl)) {
                  return requireFromClause(mostRecentDecl);
                } else if (import_typescript.default.isImportSpecifier(mostRecentDecl)) {
                  return requireImportSpec(mostRecentDecl);
                } else if (import_typescript.default.isNamespaceImport(mostRecentDecl)) {
                  return requireFromClause(mostRecentDecl.parent);
                } else if (import_typescript.default.isVariableDeclaration(mostRecentDecl)) {
                  if (!isInBlock(mostRecentDecl, inflightClosureScope)) {
                    this.extraErrors.push({
                      messageText: `Unable to access "${sym.escapedName}" in inflight closure. Use 'lift( { ${sym.escapedName} } )' before 'inflight' and reference through ctx.`,
                      code: 0,
                      category: import_typescript.default.DiagnosticCategory.Error,
                      file: sourceFile,
                      start: node.getStart(),
                      length: node.getEnd() - node.getStart()
                    });
                  }
                }
              }
            }
            return result;
          };
          return import_typescript.default.visitNode(sourceFile, visitor);
        };
      }
    };
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Construct: () => import_types.Construct,
  cloud: () => import_sdk2.cloud,
  ex: () => import_sdk2.ex,
  inflight: () => import_core.inflight,
  internal: () => internal_exports,
  lift: () => import_core.lift,
  main: () => main
});
module.exports = __toCommonJS(src_exports);
var import_sdk2 = require("@winglang/sdk");
var import_types = require("@winglang/sdk/lib/core/types");
var import_core = require("@winglang/sdk/lib/core");

// src/main.ts
var import_sdk = require("@winglang/sdk");
function main(fn, props = {}) {
  const requiredEnvVars = [
    "WING_PLATFORMS",
    "WING_SYNTH_DIR",
    "WING_SOURCE_DIR",
    "WING_IS_TEST"
  ];
  for (const envVar of requiredEnvVars) {
    if (process.env[envVar] === void 0) {
      throw new Error(`Missing environment variable: ${envVar}
This is a Wing app and must be run through the Wing CLI (npm install -f winglang).`);
    }
  }
  class $Root extends import_sdk.std.Resource {
    constructor(scope, id) {
      super(scope, id);
      fn(this, (name2, handler, props2) => {
        new import_sdk.std.Test(this, name2, handler, props2);
      });
    }
  }
  const platformPaths = ((s) => !s ? [] : s.split(";"))(
    process.env.WING_PLATFORMS
  );
  const outdir = process.env.WING_SYNTH_DIR;
  const name = props.name ?? "main";
  const rootConstruct = $Root;
  const isTestEnvironment = process.env.WING_IS_TEST === "true";
  const entrypointDir = process.env.WING_SOURCE_DIR;
  const rootId = process.env.WING_ROOT_ID;
  const $PlatformManager = new import_sdk.platform.PlatformManager({ platformPaths });
  const app = $PlatformManager.createApp({
    outdir,
    name,
    rootConstruct,
    isTestEnvironment,
    entrypointDir,
    rootId
  });
  app.synth();
}

// src/internal.ts
var internal_exports = {};
__export(internal_exports, {
  compile: () => compile
});
var import_path2 = require("path");
async function compile(options) {
  const entrypointDir = (0, import_path2.dirname)(options.entrypoint);
  const ts2 = (await import("typescript")).default;
  const outDir = (0, import_path2.join)(options.workDir, "ts");
  const wingsdkDir = (0, import_path2.dirname)(require.resolve("@winglang/sdk"));
  const tsconfigPath = ts2.findConfigFile(entrypointDir, ts2.sys.fileExists);
  const mandatoryCompilerOptions = {
    // Managed options
    target: ts2.ScriptTarget.ES2022,
    module: ts2.ModuleKind.CommonJS,
    moduleResolution: ts2.ModuleResolutionKind.Node10,
    paths: {
      "@winglang/sdk": [wingsdkDir],
      "@winglang/sdk/*": [wingsdkDir + "/*"]
    },
    outDir,
    listEmittedFiles: true,
    noEmitOnError: true
  };
  const defaultCompilerOptions = {
    sourceMap: true,
    declaration: false,
    skipLibCheck: true,
    isolatedModules: true,
    esModuleInterop: true
  };
  let compilerOptions = defaultCompilerOptions;
  if (tsconfigPath) {
    const { config, error } = ts2.readConfigFile(tsconfigPath, ts2.sys.readFile);
    if (error) {
      throw new Error(
        `Failed to read tsconfig at ${tsconfigPath}: ${error.messageText}`
      );
    }
    const { options: options2, errors } = ts2.parseJsonConfigFileContent(
      config,
      ts2.sys,
      (0, import_path2.dirname)(tsconfigPath),
      compilerOptions
    );
    compilerOptions = options2;
    if (errors.length > 0) {
      throw new Error(
        `Failed to parse tsconfig at ${tsconfigPath}: ${errors.map((e) => e.messageText).join("\n")}`
      );
    }
    let attemptedOverride = false;
    for (const managedOption of Object.keys(mandatoryCompilerOptions)) {
      if (config?.compilerOptions?.[managedOption] !== void 0) {
        console.warn(
          `'${managedOption}' is managed by wing and will be ignored from ${tsconfigPath}`
        );
        attemptedOverride = true;
        delete options2[managedOption];
      }
    }
    if (attemptedOverride) {
      console.warn(`tsconfig options used:`);
      console.warn(compilerOptions);
    }
  }
  Object.assign(compilerOptions, mandatoryCompilerOptions);
  const program = ts2.createProgram([options.entrypoint], compilerOptions);
  const { InflightTransformer: InflightTransformer2 } = await Promise.resolve().then(() => (init_transformer(), transformer_exports));
  const transformer = new InflightTransformer2(program);
  const emitResult = program.emit(void 0, void 0, void 0, void 0, {
    before: [(sourceFile) => transformer.transform(sourceFile)]
  });
  const allDiagnostics = emitResult.diagnostics.concat(transformer.extraErrors);
  if (emitResult.emitSkipped || allDiagnostics.filter((d) => d.category === ts2.DiagnosticCategory.Error).length > 0) {
    const fullError = ts2.formatDiagnosticsWithColorAndContext(allDiagnostics, {
      getCanonicalFileName: (f) => f,
      getCurrentDirectory: () => process.cwd(),
      getNewLine: () => "\n"
    });
    throw new Error(`TS compilation failed:
${fullError}`);
  }
  const emittedFiles = emitResult.emittedFiles?.filter(
    (f) => f.endsWith(".js")
  );
  const emittedFile = emittedFiles?.[emittedFiles.length - 1];
  if (!emittedFile) {
    throw new Error(
      `TS compilation failed: Could not find emitted file in ${outDir}`
    );
  }
  return emittedFile;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Construct,
  cloud,
  ex,
  inflight,
  internal,
  lift,
  main
});
//# sourceMappingURL=index.js.map