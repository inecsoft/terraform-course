"use strict";
var _a, _b, _c, _d, _e;
Object.defineProperty(exports, "__esModule", { value: true });
exports.DynamicListTerraformIterator = exports.ResourceTerraformIterator = exports.MapTerraformIterator = exports.ListTerraformIterator = exports.TerraformIterator = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const errors_1 = require("./errors");
const terraform_dynamic_expression_1 = require("./terraform-dynamic-expression");
const terraform_functions_1 = require("./terraform-functions");
const tfExpression_1 = require("./tfExpression");
const tokens_1 = require("./tokens");
// eslint-disable-next-line jsdoc/require-jsdoc
class TerraformIterator {
    /**
     * Creates a new iterator from a list
     */
    static fromList(list) {
        // TODO: this could return different iterators depending on the type of the list
        // for example it could return a NumberListIterator whose iterator.key would be a number
        return new ListTerraformIterator(list);
    }
    /**
     * Creates a new iterator from a complex list. One example for this would be a list of maps.
     * The list will be converted into a map with the mapKeyAttributeName as the key.
     * @param list the list to iterate over
     * @param mapKeyAttributeName the name of the attribute that should be used as the key in the map
     *
     * Visit https://developer.hashicorp.com/terraform/cdktf/concepts/iterators#using-iterators-on-complex-lists for more information.
     *
     * @example
     * const cert = new AcmCertificate(this, "cert", {
     *    domainName: "example.com",
     *    validationMethod: "DNS",
     *  });
     *
     * const dvoIterator = TerraformIterator.fromComplexList(
     *   cert.domainValidationOptions,
     *   "domain_name"
     * );
     *
     * new Route53Record(this, "record", {
     *   allowOverwrite: true,
     *   name: dvoIterator.getString("name"),
     *   records: [dvoIterator.getString("record")],
     *   ttl: 60,
     *   type: dvoIterator.getString("type"),
     *   zoneId: Token.asString(dataAwsRoute53ZoneExample.zoneId),
     *   forEach: dvoIterator,
     * });
     */
    static fromComplexList(list, mapKeyAttributeName) {
        return new DynamicListTerraformIterator(list, mapKeyAttributeName);
    }
    /**
     * Creates a new iterator from a map
     */
    static fromMap(map) {
        return new MapTerraformIterator(map);
    }
    /**
     * Creates a new iterator from a resource that
     * has been created with the `for_each` argument.
     */
    static fromResources(resource) {
        return new ResourceTerraformIterator(resource);
    }
    /**
     * Creates a new iterator from a data source that
     * has been created with the `for_each` argument.
     */
    static fromDataSources(resource) {
        return new ResourceTerraformIterator(resource);
    }
    /**
     * @param attribute name of the property to retrieve
     * @returns the given attribute of the current item iterated over as a string
     */
    getString(attribute) {
        return tokens_1.Token.asString((0, tfExpression_1.propertyAccess)(this._getValue(), [attribute]));
    }
    /**
     * @param attribute name of the property to retrieve
     * @returns the given attribute of the current item iterated over as a number
     */
    getNumber(attribute) {
        return tokens_1.Token.asNumber((0, tfExpression_1.propertyAccess)(this._getValue(), [attribute]));
    }
    /**
     * @param attribute name of the property to retrieve
     * @returns the given attribute of the current item iterated over as a boolean
     */
    getBoolean(attribute) {
        return tokens_1.Token.asAny((0, tfExpression_1.propertyAccess)(this._getValue(), [attribute]));
    }
    /**
     * @param attribute name of the property to retrieve
     * @returns the given attribute of the current item iterated over as any
     */
    getAny(attribute) {
        return tokens_1.Token.asAny((0, tfExpression_1.propertyAccess)(this._getValue(), [attribute]));
    }
    /**
     * @param attribute name of the property to retrieve
     * @returns the given attribute of the current item iterated over as a (string) list
     */
    getList(attribute) {
        return tokens_1.Token.asList((0, tfExpression_1.propertyAccess)(this._getValue(), [attribute]));
    }
    /**
     * @param attribute name of the property to retrieve
     * @returns the given attribute of the current item iterated over as a number list
     */
    getNumberList(attribute) {
        return tokens_1.Token.asNumberList((0, tfExpression_1.propertyAccess)(this._getValue(), [attribute]));
    }
    /**
     * @param attribute name of the property to retrieve
     * @returns the given attribute of the current item iterated over as a map
     */
    getMap(attribute) {
        return tokens_1.Token.asAnyMap((0, tfExpression_1.propertyAccess)(this._getValue(), [attribute]));
    }
    /**
     * @param attribute name of the property to retrieve
     * @returns the given attribute of the current item iterated over as a map of strings
     */
    getStringMap(attribute) {
        return tokens_1.Token.asStringMap((0, tfExpression_1.propertyAccess)(this._getValue(), [attribute]));
    }
    /**
     * @param attribute name of the property to retrieve
     * @returns the given attribute of the current item iterated over as a map of numbers
     */
    getNumberMap(attribute) {
        return tokens_1.Token.asNumberMap((0, tfExpression_1.propertyAccess)(this._getValue(), [attribute]));
    }
    /**
     * @param attribute name of the property to retrieve
     * @returns the given attribute of the current item iterated over as a map of booleans
     */
    getBooleanMap(attribute) {
        return tokens_1.Token.asBooleanMap((0, tfExpression_1.propertyAccess)(this._getValue(), [attribute]));
    }
    /**
     * @param attribute name of the property to retrieve
     * @returns the given attribute of the current item iterated over as a map of any
     */
    getAnyMap(attribute) {
        return tokens_1.Token.asAnyMap((0, tfExpression_1.propertyAccess)(this._getValue(), [attribute]));
    }
    /**
     * @internal
     */
    _getValue() {
        // uses a Lazy value to be able to access the current TerraformStack and pass it to ref()
        return tokens_1.Lazy.anyValue({
            produce: (context) => {
                switch (context.iteratorContext) {
                    case "DYNAMIC_BLOCK":
                        return (0, tfExpression_1.ref)("each.value");
                    case "FOR_EXPRESSION":
                        return tfExpression_1.FOR_EXPRESSION_VALUE;
                    default:
                        // same as dynamic block, as this is the case when a iterator is passed to the root level of e.g. a resource
                        return (0, tfExpression_1.ref)("each.value");
                }
            },
        }, { displayHint: "<iterator value>" });
    }
    /**
     * @internal
     */
    _getKey() {
        // uses a Lazy value to be able to access the current TerraformStack and pass it to ref()
        return tokens_1.Lazy.anyValue({
            produce: (context) => {
                switch (context.iteratorContext) {
                    case "DYNAMIC_BLOCK":
                        return (0, tfExpression_1.ref)("each.key");
                    case "FOR_EXPRESSION":
                        return tfExpression_1.FOR_EXPRESSION_KEY;
                    default:
                        // same as dynamic block, as this is the case when a iterator is passed to the root level of e.g. a resource
                        return (0, tfExpression_1.ref)("each.key");
                }
            },
        }, { displayHint: "<iterator key>" });
    }
    /**
     * Creates a dynamic expression that can be used to loop over this iterator
     * in a dynamic block.
     * As this returns an IResolvable you might need to wrap the output in
     * a Token, e.g. `Token.asString`.
     * See https://developer.hashicorp.com/terraform/cdktf/concepts/iterators#using-iterators-for-list-attributes
     */
    dynamic(attributes) {
        return tokens_1.Token.asAny(new terraform_dynamic_expression_1.TerraformDynamicExpression({
            iterator: this,
            content: attributes,
        }));
    }
    /**
     * Creates a for expression that maps the iterators to its keys.
     * For lists these would be the indices, for maps the keys.
     * As this returns an IResolvable you might need to wrap the output in
     * a Token, e.g. `Token.asString`.
     */
    keys() {
        return tokens_1.Token.asAny((0, tfExpression_1.forExpression)(this._getForEachExpression(), tfExpression_1.FOR_EXPRESSION_KEY));
    }
    /**
     * Creates a for expression that maps the iterators to its value in case it is a map.
     * For lists these would stay the same.
     * As this returns an IResolvable you might need to wrap the output in
     * a Token, e.g. `Token.asString`.
     */
    values() {
        return tokens_1.Token.asAny((0, tfExpression_1.forExpression)(this._getForEachExpression(), tfExpression_1.FOR_EXPRESSION_VALUE));
    }
    /**
     * Creates a for expression that accesses the key on each element of the iterator.
     * As this returns an IResolvable you might need to wrap the output in
     * a Token, e.g. `Token.asString`.
     * @param property The property of the iterators values to map to
     */
    pluckProperty(property) {
        return tokens_1.Token.asAny((0, tfExpression_1.forExpression)(this._getForEachExpression(), (0, tfExpression_1.propertyAccess)(tfExpression_1.FOR_EXPRESSION_VALUE, [property])));
    }
    /**
     * Creates a for expression that results in a list.
     * This method allows you to create every possible for expression, but requires more knowledge about
     * Terraform's for expression syntax.
     * For the most common use cases you can use keys(), values(), and pluckProperty() instead.
     *
     * You may write any valid Terraform for each expression, e.g.
     * `TerraformIterator.fromList(myIteratorSourceVar).forExpressionForList("val.foo if val.bar == true")`
     * will result in `[ for key, val in var.myIteratorSource: val.foo if val.bar == true ]`.
     *
     * As this returns an IResolvable you might need to wrap the output in
     * a Token, e.g. `Token.asString`.
     * @param expression The expression to use in the for mapping
     */
    forExpressionForList(expression) {
        return tokens_1.Token.asAny((0, tfExpression_1.forExpression)(this._getForEachExpression(), expression));
    }
    /**
     * Creates a for expression that results in a map.
     * This method allows you to create every possible for expression, but requires more knowledge about
     * Terraforms for expression syntax.
     * For the most common use cases you can use keys(), values(), and pluckProperty instead.
     *
     * You may write any valid Terraform for each expression, e.g.
     * `TerraformIterator.fromMap(myIteratorSourceVar).forExpressionForMap("key", "val.foo if val.bar == true")`
     * will result in `{ for key, val in var.myIteratorSource: key => val.foo if val.bar == true }`.
     *
     * As this returns an IResolvable you might need to wrap the output in
     * a Token, e.g. `Token.asString`.
     * @param keyExpression The expression to use as key in the for mapping
     * @param valueExpression The expression to use as value in the for mapping
     */
    forExpressionForMap(keyExpression, valueExpression) {
        return tokens_1.Token.asAny((0, tfExpression_1.forExpression)(this._getForEachExpression(), valueExpression, keyExpression));
    }
}
exports.TerraformIterator = TerraformIterator;
_a = JSII_RTTI_SYMBOL_1;
TerraformIterator[_a] = { fqn: "cdktf.TerraformIterator", version: "0.20.3" };
// eslint-disable-next-line jsdoc/require-jsdoc
class ListTerraformIterator extends TerraformIterator {
    constructor(list) {
        super();
        this.list = list;
    }
    /**
     * Returns the currently entry in the list or set that is being iterated over.
     * For lists this is the same as `iterator.value`. If you need the index,
     * use count via `TerraformCount`:
     * https://developer.hashicorp.com/terraform/cdktf/concepts/iterators#using-count
     */
    get key() {
        return this._getKey();
    }
    /**
     * Returns the value of the current item iterated over.
     */
    get value() {
        return this._getValue();
    }
    /**
     * @internal used by TerraformResource to set the for_each expression
     */
    _getForEachExpression() {
        // needs to be wrapped in a set as Terraform only allows sets in for_each
        return terraform_functions_1.Fn.toset(this.list);
    }
}
exports.ListTerraformIterator = ListTerraformIterator;
_b = JSII_RTTI_SYMBOL_1;
ListTerraformIterator[_b] = { fqn: "cdktf.ListTerraformIterator", version: "0.20.3" };
// eslint-disable-next-line jsdoc/require-jsdoc
class MapTerraformIterator extends TerraformIterator {
    constructor(map) {
        super();
        this.map = map;
    }
    /**
     * @internal used by TerraformResource to set the for_each expression
     */
    _getForEachExpression() {
        // explicit wrapping to circumvent "Found an encoded map token in a scalar string context." error
        return tokens_1.Token.asString(this.map);
    }
    /**
     * Returns the key of the current entry in the map that is being iterated over.
     */
    get key() {
        return tokens_1.Token.asString(this._getKey());
    }
    /**
     * Returns the value of the current item iterated over.
     */
    get value() {
        return this._getValue();
    }
}
exports.MapTerraformIterator = MapTerraformIterator;
_c = JSII_RTTI_SYMBOL_1;
MapTerraformIterator[_c] = { fqn: "cdktf.MapTerraformIterator", version: "0.20.3" };
// eslint-disable-next-line jsdoc/require-jsdoc
class ResourceTerraformIterator extends TerraformIterator {
    constructor(element) {
        super();
        this.element = element;
        if (element.count) {
            throw (0, errors_1.iteratorOnResourceWithCount)();
        }
        if (!element.forEach) {
            throw (0, errors_1.iteratorOnResourceWithoutForEach)();
        }
    }
    /**
     * Returns the current entry in the list or set that is being iterated over.
     * For lists this is the same as `iterator.value`. If you need the index,
     * use count via `TerraformCount`:
     * https://developer.hashicorp.com/terraform/cdktf/concepts/iterators#using-count
     */
    get key() {
        return this._getKey();
    }
    /**
     * Returns the value of the current item iterated over.
     */
    get value() {
        return this._getValue();
    }
    /**
     * @internal used by TerraformResource to set the for_each expression
     */
    _getForEachExpression() {
        return this.element.fqn; // no wrapping necessary for resources
    }
}
exports.ResourceTerraformIterator = ResourceTerraformIterator;
_d = JSII_RTTI_SYMBOL_1;
ResourceTerraformIterator[_d] = { fqn: "cdktf.ResourceTerraformIterator", version: "0.20.3" };
// eslint-disable-next-line jsdoc/require-jsdoc
class DynamicListTerraformIterator extends MapTerraformIterator {
    constructor(list, mapKeyAttributeName) {
        super(list);
        this.list = list;
        this.mapKeyAttributeName = mapKeyAttributeName;
    }
    /**
     * @internal used by TerraformResource to set the for_each expression
     */
    _getForEachExpression() {
        // uses a Lazy value to be able to render a conversion into a map in the context of a TerraformResource
        return tokens_1.Lazy.anyValue({
            produce: (context) => {
                switch (context.iteratorContext) {
                    case "FOR_EXPRESSION":
                        return this.list;
                    case "DYNAMIC_BLOCK": // fallthrough
                    default: // same as dynamic block, as this is the case when a iterator is passed to the root level of e.g. a resource
                        // Turn list into a map
                        // { for k,v in <input> : <keyExpression> => <valueExpression>}
                        return (0, tfExpression_1.forExpression)(this.list, // input
                        tfExpression_1.FOR_EXPRESSION_VALUE, // valueExpression
                        terraform_functions_1.Fn.lookupNested(tfExpression_1.FOR_EXPRESSION_VALUE, [
                            this.mapKeyAttributeName,
                        ]) // keyExpression
                        );
                }
            },
        }, { displayHint: "<iterator value>" });
    }
}
exports.DynamicListTerraformIterator = DynamicListTerraformIterator;
_e = JSII_RTTI_SYMBOL_1;
DynamicListTerraformIterator[_e] = { fqn: "cdktf.DynamicListTerraformIterator", version: "0.20.3" };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVycmFmb3JtLWl0ZXJhdG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsidGVycmFmb3JtLWl0ZXJhdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBY0EscUNBR2tCO0FBQ2xCLGlGQUE0RTtBQUM1RSwrREFBMkM7QUFFM0MsaURBTXdCO0FBQ3hCLHFDQUFvRDtBQWlDcEQsK0NBQStDO0FBQy9DLE1BQXNCLGlCQUFpQjtJQU1yQzs7T0FFRztJQUNJLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBYztRQUNuQyxnRkFBZ0Y7UUFDaEYsd0ZBQXdGO1FBQ3hGLE9BQU8sSUFBSSxxQkFBcUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN6QyxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0E0Qkc7SUFDSSxNQUFNLENBQUMsZUFBZSxDQUMzQixJQUFxQixFQUNyQixtQkFBMkI7UUFFM0IsT0FBTyxJQUFJLDRCQUE0QixDQUFDLElBQUksRUFBRSxtQkFBbUIsQ0FBQyxDQUFDO0lBQ3JFLENBQUM7SUFFRDs7T0FFRztJQUNJLE1BQU0sQ0FBQyxPQUFPLENBQ25CLEdBSzhCO1FBRTlCLE9BQU8sSUFBSSxvQkFBb0IsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUN2QyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksTUFBTSxDQUFDLGFBQWEsQ0FDekIsUUFBNEI7UUFFNUIsT0FBTyxJQUFJLHlCQUF5QixDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ2pELENBQUM7SUFFRDs7O09BR0c7SUFDSSxNQUFNLENBQUMsZUFBZSxDQUMzQixRQUE0QjtRQUU1QixPQUFPLElBQUkseUJBQXlCLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDakQsQ0FBQztJQUVEOzs7T0FHRztJQUNILFNBQVMsQ0FBQyxTQUFpQjtRQUN6QixPQUFPLGNBQUssQ0FBQyxRQUFRLENBQUMsSUFBQSw2QkFBYyxFQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsRUFBRSxDQUFDLFNBQVMs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akUsQ0FBQzs7QUFuQ0gsOERBb0NDOzs7QUFFRCwrQ0FBK0M7QUFDL0MsTUFBYSw0QkFBNkIsU0FBUSxvQkFBb0I7SUFDcEUsWUFDbUIsSUFBYyxFQUNkLG1CQUEyQjtRQUU1QyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7UUFISyxTQUFJLEdBQUosSUFBSSxDQUFVO1FBQ2Qsd0JBQW1CLEdBQW5CLG1CQUFtQixDQUFRO0lBRzlDLENBQUM7SUFFRDs7T0FFRztJQUNJLHFCQUFxQjtRQUMxQix1R0FBdUc7UUFDdkcsT0FBTyxhQUFJLENBQUMsUUFBUSxDQUNsQjtZQUNFLE9BQU8sRUFBRSxDQUFDLE9BQU8sRUFBRSxFQUFFO2dCQUNuQixRQUFRLE9BQU8sQ0FBQyxlQUFlLEVBQUUsQ0FBQztvQkFDaEMsS0FBSyxnQkFBZ0I7d0JBQ25CLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQztvQkFDbkIsS0FBSyxlQUFlLENBQUMsQ0FBQyxjQUFjO29CQUNwQyxTQUFTLDRHQUE0Rzt3QkFDbkgsdUJBQXVCO3dCQUN2QiwrREFBK0Q7d0JBQy9ELE9BQU8sSUFBQSw0QkFBYSxFQUNsQixJQUFJLENBQUMsSUFBSSxFQUFFLFFBQVE7d0JBQ25CLG1DQUFvQixFQUFFLGtCQUFrQjt3QkFDeEMsd0JBQUUsQ0FBQyxZQUFZLENBQUMsbUNBQW9CLEVBQUU7NEJBQ3BDLElBQUksQ0FBQyxtQkFBbUI7eUJBQ3pCLENBQUMsQ0FBQyxnQkFBZ0I7eUJBQ3BCLENBQUM7Z0JBQ04sQ0FBQztZQUNILENBQUM7U0FDRixFQUNELEVBQUUsV0FBVyxFQUFFLGtCQUFrQixFQUFFLENBQ3BDLENBQUM7SUFDSixDQUFDOztBQW5DSCxvRUFvQ0MiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIEhhc2hpQ29ycCwgSW5jXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTVBMLTIuMFxuaW1wb3J0IHtcbiAgQW55TWFwLFxuICBBbnlNYXBMaXN0LFxuICBCb29sZWFuTWFwLFxuICBCb29sZWFuTWFwTGlzdCxcbiAgQ29tcGxleExpc3QsXG4gIENvbXBsZXhNYXAsXG4gIE51bWJlck1hcCxcbiAgTnVtYmVyTWFwTGlzdCxcbiAgU3RyaW5nTWFwLFxuICBTdHJpbmdNYXBMaXN0LFxufSBmcm9tIFwiLi9jb21wbGV4LWNvbXB1dGVkLWxpc3RcIjtcbmltcG9ydCB7XG4gIGl0ZXJhdG9yT25SZXNvdXJjZVdpdGhDb3VudCxcbiAgaXRlcmF0b3JPblJlc291cmNlV2l0aG91dEZvckVhY2gsXG59IGZyb20gXCIuL2Vycm9yc1wiO1xuaW1wb3J0IHsgVGVycmFmb3JtRHluYW1pY0V4cHJlc3Npb24gfSBmcm9tIFwiLi90ZXJyYWZvcm0tZHluYW1pYy1leHByZXNzaW9uXCI7XG5pbXBvcnQgeyBGbiB9IGZyb20gXCIuL3RlcnJhZm9ybS1mdW5jdGlvbnNcIjtcbmltcG9ydCB7IElUZXJyYWZvcm1SZXNvdXJjZSB9IGZyb20gXCIuL3RlcnJhZm9ybS1yZXNvdXJjZVwiO1xuaW1wb3J0IHtcbiAgRk9SX0VYUFJFU1NJT05fS0VZLFxuICBGT1JfRVhQUkVTU0lPTl9WQUxVRSxcbiAgZm9yRXhwcmVzc2lvbixcbiAgcHJvcGVydHlBY2Nlc3MsXG4gIHJlZixcbn0gZnJvbSBcIi4vdGZFeHByZXNzaW9uXCI7XG5pbXBvcnQgeyBJUmVzb2x2YWJsZSwgTGF6eSwgVG9rZW4gfSBmcm9tIFwiLi90b2tlbnNcIjtcblxuZXhwb3J0IGludGVyZmFjZSBJVGVycmFmb3JtSXRlcmF0b3Ige1xuICAvKipcbiAgICogQGludGVybmFsIHVzZWQgYnkgVGVycmFmb3JtUmVzb3VyY2UgdG8gc2V0IHRoZSBmb3JfZWFjaCBleHByZXNzaW9uXG4gICAqL1xuICBfZ2V0Rm9yRWFjaEV4cHJlc3Npb24oKTogYW55O1xufVxuXG50eXBlIExpc3RUeXBlID1cbiAgfCBBcnJheTxzdHJpbmc+XG4gIHwgQXJyYXk8bnVtYmVyPlxuICB8IEFycmF5PGJvb2xlYW4gfCBJUmVzb2x2YWJsZT5cbiAgfCBJUmVzb2x2YWJsZTsgLy8gZS5nLiBhcnJheSBvZiBib29sZWFuc1xuXG50eXBlIENvbXBsZXhMaXN0VHlwZSA9XG4gIHwgQ29tcGxleExpc3RcbiAgfCBTdHJpbmdNYXBMaXN0XG4gIHwgTnVtYmVyTWFwTGlzdFxuICB8IEJvb2xlYW5NYXBMaXN0XG4gIHwgQW55TWFwTGlzdFxuICB8IElSZXNvbHZhYmxlOyAvLyBlLmcuIGEgcmVmZXJlbmNlIHRvIGEgY29tcGxleCBsaXN0IChlLmcuIHZpYSBhIHZhcmlhYmxlKVxuXG50eXBlIE1hcFR5cGUgPVxuICB8IHsgW2tleTogc3RyaW5nXTogYW55IH1cbiAgfCB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9XG4gIHwgeyBba2V5OiBzdHJpbmddOiBudW1iZXIgfVxuICB8IFN0cmluZ01hcFxuICB8IE51bWJlck1hcFxuICB8IEJvb2xlYW5NYXBcbiAgfCBBbnlNYXBcbiAgfCBDb21wbGV4TWFwO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvY1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFRlcnJhZm9ybUl0ZXJhdG9yIGltcGxlbWVudHMgSVRlcnJhZm9ybUl0ZXJhdG9yIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbCB1c2VkIGJ5IFRlcnJhZm9ybVJlc291cmNlIHRvIHNldCB0aGUgZm9yX2VhY2ggZXhwcmVzc2lvblxuICAgKi9cbiAgYWJzdHJhY3QgX2dldEZvckVhY2hFeHByZXNzaW9uKCk6IGFueTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpdGVyYXRvciBmcm9tIGEgbGlzdFxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBmcm9tTGlzdChsaXN0OiBMaXN0VHlwZSk6IExpc3RUZXJyYWZvcm1JdGVyYXRvciB7XG4gICAgLy8gVE9ETzogdGhpcyBjb3VsZCByZXR1cm4gZGlmZmVyZW50IGl0ZXJhdG9ycyBkZXBlbmRpbmcgb24gdGhlIHR5cGUgb2YgdGhlIGxpc3RcbiAgICAvLyBmb3IgZXhhbXBsZSBpdCBjb3VsZCByZXR1cm4gYSBOdW1iZXJMaXN0SXRlcmF0b3Igd2hvc2UgaXRlcmF0b3Iua2V5IHdvdWxkIGJlIGEgbnVtYmVyXG4gICAgcmV0dXJuIG5ldyBMaXN0VGVycmFmb3JtSXRlcmF0b3IobGlzdCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpdGVyYXRvciBmcm9tIGEgY29tcGxleCBsaXN0LiBPbmUgZXhhbXBsZSBmb3IgdGhpcyB3b3VsZCBiZSBhIGxpc3Qgb2YgbWFwcy5cbiAgICogVGhlIGxpc3Qgd2lsbCBiZSBjb252ZXJ0ZWQgaW50byBhIG1hcCB3aXRoIHRoZSBtYXBLZXlBdHRyaWJ1dGVOYW1lIGFzIHRoZSBrZXkuXG4gICAqIEBwYXJhbSBsaXN0IHRoZSBsaXN0IHRvIGl0ZXJhdGUgb3ZlclxuICAgKiBAcGFyYW0gbWFwS2V5QXR0cmlidXRlTmFtZSB0aGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIHRoYXQgc2hvdWxkIGJlIHVzZWQgYXMgdGhlIGtleSBpbiB0aGUgbWFwXG4gICAqXG4gICAqIFZpc2l0IGh0dHBzOi8vZGV2ZWxvcGVyLmhhc2hpY29ycC5jb20vdGVycmFmb3JtL2Nka3RmL2NvbmNlcHRzL2l0ZXJhdG9ycyN1c2luZy1pdGVyYXRvcnMtb24tY29tcGxleC1saXN0cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgY2VydCA9IG5ldyBBY21DZXJ0aWZpY2F0ZSh0aGlzLCBcImNlcnRcIiwge1xuICAgKiAgICBkb21haW5OYW1lOiBcImV4YW1wbGUuY29tXCIsXG4gICAqICAgIHZhbGlkYXRpb25NZXRob2Q6IFwiRE5TXCIsXG4gICAqICB9KTtcbiAgICpcbiAgICogY29uc3QgZHZvSXRlcmF0b3IgPSBUZXJyYWZvcm1JdGVyYXRvci5mcm9tQ29tcGxleExpc3QoXG4gICAqICAgY2VydC5kb21haW5WYWxpZGF0aW9uT3B0aW9ucyxcbiAgICogICBcImRvbWFpbl9uYW1lXCJcbiAgICogKTtcbiAgICpcbiAgICogbmV3IFJvdXRlNTNSZWNvcmQodGhpcywgXCJyZWNvcmRcIiwge1xuICAgKiAgIGFsbG93T3ZlcndyaXRlOiB0cnVlLFxuICAgKiAgIG5hbWU6IGR2b0l0ZXJhdG9yLmdldFN0cmluZyhcIm5hbWVcIiksXG4gICAqICAgcmVjb3JkczogW2R2b0l0ZXJhdG9yLmdldFN0cmluZyhcInJlY29yZFwiKV0sXG4gICAqICAgdHRsOiA2MCxcbiAgICogICB0eXBlOiBkdm9JdGVyYXRvci5nZXRTdHJpbmcoXCJ0eXBlXCIpLFxuICAgKiAgIHpvbmVJZDogVG9rZW4uYXNTdHJpbmcoZGF0YUF3c1JvdXRlNTNab25lRXhhbXBsZS56b25lSWQpLFxuICAgKiAgIGZvckVhY2g6IGR2b0l0ZXJhdG9yLFxuICAgKiB9KTtcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZnJvbUNvbXBsZXhMaXN0KFxuICAgIGxpc3Q6IENvbXBsZXhMaXN0VHlwZSxcbiAgICBtYXBLZXlBdHRyaWJ1dGVOYW1lOiBzdHJpbmdcbiAgKTogRHluYW1pY0xpc3RUZXJyYWZvcm1JdGVyYXRvciB7XG4gICAgcmV0dXJuIG5ldyBEeW5hbWljTGlzdFRlcnJhZm9ybUl0ZXJhdG9yKGxpc3QsIG1hcEtleUF0dHJpYnV0ZU5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgaXRlcmF0b3IgZnJvbSBhIG1hcFxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBmcm9tTWFwKFxuICAgIG1hcDpcbiAgICAgIHwgQ29tcGxleE1hcFxuICAgICAgfCB7IFtrZXk6IHN0cmluZ106IGFueSB9XG4gICAgICB8IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH1cbiAgICAgIHwgeyBba2V5OiBzdHJpbmddOiBudW1iZXIgfVxuICAgICAgfCB7IFtrZXk6IHN0cmluZ106IGJvb2xlYW4gfVxuICApOiBNYXBUZXJyYWZvcm1JdGVyYXRvciB7XG4gICAgcmV0dXJuIG5ldyBNYXBUZXJyYWZvcm1JdGVyYXRvcihtYXApO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgaXRlcmF0b3IgZnJvbSBhIHJlc291cmNlIHRoYXRcbiAgICogaGFzIGJlZW4gY3JlYXRlZCB3aXRoIHRoZSBgZm9yX2VhY2hgIGFyZ3VtZW50LlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBmcm9tUmVzb3VyY2VzKFxuICAgIHJlc291cmNlOiBJVGVycmFmb3JtUmVzb3VyY2VcbiAgKTogUmVzb3VyY2VUZXJyYWZvcm1JdGVyYXRvciB7XG4gICAgcmV0dXJuIG5ldyBSZXNvdXJjZVRlcnJhZm9ybUl0ZXJhdG9yKHJlc291cmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGl0ZXJhdG9yIGZyb20gYSBkYXRhIHNvdXJjZSB0aGF0XG4gICAqIGhhcyBiZWVuIGNyZWF0ZWQgd2l0aCB0aGUgYGZvcl9lYWNoYCBhcmd1bWVudC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZnJvbURhdGFTb3VyY2VzKFxuICAgIHJlc291cmNlOiBJVGVycmFmb3JtUmVzb3VyY2VcbiAgKTogUmVzb3VyY2VUZXJyYWZvcm1JdGVyYXRvciB7XG4gICAgcmV0dXJuIG5ldyBSZXNvdXJjZVRlcnJhZm9ybUl0ZXJhdG9yKHJlc291cmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gYXR0cmlidXRlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIHJldHJpZXZlXG4gICAqIEByZXR1cm5zIHRoZSBnaXZlbiBhdHRyaWJ1dGUgb2YgdGhlIGN1cnJlbnQgaXRlbSBpdGVyYXRlZCBvdmVyIGFzIGEgc3RyaW5nXG4gICAqL1xuICBnZXRTdHJpbmcoYXR0cmlidXRlOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBUb2tlbi5hc1N0cmluZyhwcm9wZXJ0eUFjY2Vzcyh0aGlzLl9nZXRWYWx1ZSgpLCBbYXR0cmlidXRlXSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBhdHRyaWJ1dGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gcmV0cmlldmVcbiAgICogQHJldHVybnMgdGhlIGdpdmVuIGF0dHJpYnV0ZSBvZiB0aGUgY3VycmVudCBpdGVtIGl0ZXJhdGVkIG92ZXIgYXMgYSBudW1iZXJcbiAgICovXG4gIGdldE51bWJlcihhdHRyaWJ1dGU6IHN0cmluZyk6IG51bWJlciB7XG4gICAgcmV0dXJuIFRva2VuLmFzTnVtYmVyKHByb3BlcnR5QWNjZXNzKHRoaXMuX2dldFZhbHVlKCksIFthdHRyaWJ1dGVdKSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIGF0dHJpYnV0ZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byByZXRyaWV2ZVxuICAgKiBAcmV0dXJucyB0aGUgZ2l2ZW4gYXR0cmlidXRlIG9mIHRoZSBjdXJyZW50IGl0ZW0gaXRlcmF0ZWQgb3ZlciBhcyBhIGJvb2xlYW5cbiAgICovXG4gIGdldEJvb2xlYW4oYXR0cmlidXRlOiBzdHJpbmcpOiBJUmVzb2x2YWJsZSB7XG4gICAgcmV0dXJuIFRva2VuLmFzQW55KHByb3BlcnR5QWNjZXNzKHRoaXMuX2dldFZhbHVlKCksIFthdHRyaWJ1dGVdKSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIGF0dHJpYnV0ZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byByZXRyaWV2ZVxuICAgKiBAcmV0dXJucyB0aGUgZ2l2ZW4gYXR0cmlidXRlIG9mIHRoZSBjdXJyZW50IGl0ZW0gaXRlcmF0ZWQgb3ZlciBhcyBhbnlcbiAgICovXG4gIGdldEFueShhdHRyaWJ1dGU6IHN0cmluZyk6IElSZXNvbHZhYmxlIHtcbiAgICByZXR1cm4gVG9rZW4uYXNBbnkocHJvcGVydHlBY2Nlc3ModGhpcy5fZ2V0VmFsdWUoKSwgW2F0dHJpYnV0ZV0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gYXR0cmlidXRlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIHJldHJpZXZlXG4gICAqIEByZXR1cm5zIHRoZSBnaXZlbiBhdHRyaWJ1dGUgb2YgdGhlIGN1cnJlbnQgaXRlbSBpdGVyYXRlZCBvdmVyIGFzIGEgKHN0cmluZykgbGlzdFxuICAgKi9cbiAgZ2V0TGlzdChhdHRyaWJ1dGU6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gVG9rZW4uYXNMaXN0KHByb3BlcnR5QWNjZXNzKHRoaXMuX2dldFZhbHVlKCksIFthdHRyaWJ1dGVdKSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIGF0dHJpYnV0ZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byByZXRyaWV2ZVxuICAgKiBAcmV0dXJucyB0aGUgZ2l2ZW4gYXR0cmlidXRlIG9mIHRoZSBjdXJyZW50IGl0ZW0gaXRlcmF0ZWQgb3ZlciBhcyBhIG51bWJlciBsaXN0XG4gICAqL1xuICBnZXROdW1iZXJMaXN0KGF0dHJpYnV0ZTogc3RyaW5nKTogbnVtYmVyW10ge1xuICAgIHJldHVybiBUb2tlbi5hc051bWJlckxpc3QocHJvcGVydHlBY2Nlc3ModGhpcy5fZ2V0VmFsdWUoKSwgW2F0dHJpYnV0ZV0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gYXR0cmlidXRlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIHJldHJpZXZlXG4gICAqIEByZXR1cm5zIHRoZSBnaXZlbiBhdHRyaWJ1dGUgb2YgdGhlIGN1cnJlbnQgaXRlbSBpdGVyYXRlZCBvdmVyIGFzIGEgbWFwXG4gICAqL1xuICBnZXRNYXAoYXR0cmlidXRlOiBzdHJpbmcpOiB7IFtrZXk6IHN0cmluZ106IGFueSB9IHtcbiAgICByZXR1cm4gVG9rZW4uYXNBbnlNYXAocHJvcGVydHlBY2Nlc3ModGhpcy5fZ2V0VmFsdWUoKSwgW2F0dHJpYnV0ZV0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gYXR0cmlidXRlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIHJldHJpZXZlXG4gICAqIEByZXR1cm5zIHRoZSBnaXZlbiBhdHRyaWJ1dGUgb2YgdGhlIGN1cnJlbnQgaXRlbSBpdGVyYXRlZCBvdmVyIGFzIGEgbWFwIG9mIHN0cmluZ3NcbiAgICovXG4gIGdldFN0cmluZ01hcChhdHRyaWJ1dGU6IHN0cmluZyk6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0ge1xuICAgIHJldHVybiBUb2tlbi5hc1N0cmluZ01hcChwcm9wZXJ0eUFjY2Vzcyh0aGlzLl9nZXRWYWx1ZSgpLCBbYXR0cmlidXRlXSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBhdHRyaWJ1dGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gcmV0cmlldmVcbiAgICogQHJldHVybnMgdGhlIGdpdmVuIGF0dHJpYnV0ZSBvZiB0aGUgY3VycmVudCBpdGVtIGl0ZXJhdGVkIG92ZXIgYXMgYSBtYXAgb2YgbnVtYmVyc1xuICAgKi9cbiAgZ2V0TnVtYmVyTWFwKGF0dHJpYnV0ZTogc3RyaW5nKTogeyBba2V5OiBzdHJpbmddOiBudW1iZXIgfSB7XG4gICAgcmV0dXJuIFRva2VuLmFzTnVtYmVyTWFwKHByb3BlcnR5QWNjZXNzKHRoaXMuX2dldFZhbHVlKCksIFthdHRyaWJ1dGVdKSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIGF0dHJpYnV0ZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byByZXRyaWV2ZVxuICAgKiBAcmV0dXJucyB0aGUgZ2l2ZW4gYXR0cmlidXRlIG9mIHRoZSBjdXJyZW50IGl0ZW0gaXRlcmF0ZWQgb3ZlciBhcyBhIG1hcCBvZiBib29sZWFuc1xuICAgKi9cbiAgZ2V0Qm9vbGVhbk1hcChhdHRyaWJ1dGU6IHN0cmluZyk6IHsgW2tleTogc3RyaW5nXTogYm9vbGVhbiB9IHtcbiAgICByZXR1cm4gVG9rZW4uYXNCb29sZWFuTWFwKHByb3BlcnR5QWNjZXNzKHRoaXMuX2dldFZhbHVlKCksIFthdHRyaWJ1dGVdKSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIGF0dHJpYnV0ZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byByZXRyaWV2ZVxuICAgKiBAcmV0dXJucyB0aGUgZ2l2ZW4gYXR0cmlidXRlIG9mIHRoZSBjdXJyZW50IGl0ZW0gaXRlcmF0ZWQgb3ZlciBhcyBhIG1hcCBvZiBhbnlcbiAgICovXG4gIGdldEFueU1hcChhdHRyaWJ1dGU6IHN0cmluZyk6IHsgW2tleTogc3RyaW5nXTogYW55IH0ge1xuICAgIHJldHVybiBUb2tlbi5hc0FueU1hcChwcm9wZXJ0eUFjY2Vzcyh0aGlzLl9nZXRWYWx1ZSgpLCBbYXR0cmlidXRlXSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJvdGVjdGVkIF9nZXRWYWx1ZSgpOiBhbnkge1xuICAgIC8vIHVzZXMgYSBMYXp5IHZhbHVlIHRvIGJlIGFibGUgdG8gYWNjZXNzIHRoZSBjdXJyZW50IFRlcnJhZm9ybVN0YWNrIGFuZCBwYXNzIGl0IHRvIHJlZigpXG4gICAgcmV0dXJuIExhenkuYW55VmFsdWUoXG4gICAgICB7XG4gICAgICAgIHByb2R1Y2U6IChjb250ZXh0KSA9PiB7XG4gICAgICAgICAgc3dpdGNoIChjb250ZXh0Lml0ZXJhdG9yQ29udGV4dCkge1xuICAgICAgICAgICAgY2FzZSBcIkRZTkFNSUNfQkxPQ0tcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIHJlZihcImVhY2gudmFsdWVcIik7XG4gICAgICAgICAgICBjYXNlIFwiRk9SX0VYUFJFU1NJT05cIjpcbiAgICAgICAgICAgICAgcmV0dXJuIEZPUl9FWFBSRVNTSU9OX1ZBTFVFO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgLy8gc2FtZSBhcyBkeW5hbWljIGJsb2NrLCBhcyB0aGlzIGlzIHRoZSBjYXNlIHdoZW4gYSBpdGVyYXRvciBpcyBwYXNzZWQgdG8gdGhlIHJvb3QgbGV2ZWwgb2YgZS5nLiBhIHJlc291cmNlXG4gICAgICAgICAgICAgIHJldHVybiByZWYoXCJlYWNoLnZhbHVlXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICB7IGRpc3BsYXlIaW50OiBcIjxpdGVyYXRvciB2YWx1ZT5cIiB9XG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByb3RlY3RlZCBfZ2V0S2V5KCk6IGFueSB7XG4gICAgLy8gdXNlcyBhIExhenkgdmFsdWUgdG8gYmUgYWJsZSB0byBhY2Nlc3MgdGhlIGN1cnJlbnQgVGVycmFmb3JtU3RhY2sgYW5kIHBhc3MgaXQgdG8gcmVmKClcbiAgICByZXR1cm4gTGF6eS5hbnlWYWx1ZShcbiAgICAgIHtcbiAgICAgICAgcHJvZHVjZTogKGNvbnRleHQpID0+IHtcbiAgICAgICAgICBzd2l0Y2ggKGNvbnRleHQuaXRlcmF0b3JDb250ZXh0KSB7XG4gICAgICAgICAgICBjYXNlIFwiRFlOQU1JQ19CTE9DS1wiOlxuICAgICAgICAgICAgICByZXR1cm4gcmVmKFwiZWFjaC5rZXlcIik7XG4gICAgICAgICAgICBjYXNlIFwiRk9SX0VYUFJFU1NJT05cIjpcbiAgICAgICAgICAgICAgcmV0dXJuIEZPUl9FWFBSRVNTSU9OX0tFWTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIHNhbWUgYXMgZHluYW1pYyBibG9jaywgYXMgdGhpcyBpcyB0aGUgY2FzZSB3aGVuIGEgaXRlcmF0b3IgaXMgcGFzc2VkIHRvIHRoZSByb290IGxldmVsIG9mIGUuZy4gYSByZXNvdXJjZVxuICAgICAgICAgICAgICByZXR1cm4gcmVmKFwiZWFjaC5rZXlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIHsgZGlzcGxheUhpbnQ6IFwiPGl0ZXJhdG9yIGtleT5cIiB9XG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZHluYW1pYyBleHByZXNzaW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gbG9vcCBvdmVyIHRoaXMgaXRlcmF0b3JcbiAgICogaW4gYSBkeW5hbWljIGJsb2NrLlxuICAgKiBBcyB0aGlzIHJldHVybnMgYW4gSVJlc29sdmFibGUgeW91IG1pZ2h0IG5lZWQgdG8gd3JhcCB0aGUgb3V0cHV0IGluXG4gICAqIGEgVG9rZW4sIGUuZy4gYFRva2VuLmFzU3RyaW5nYC5cbiAgICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmhhc2hpY29ycC5jb20vdGVycmFmb3JtL2Nka3RmL2NvbmNlcHRzL2l0ZXJhdG9ycyN1c2luZy1pdGVyYXRvcnMtZm9yLWxpc3QtYXR0cmlidXRlc1xuICAgKi9cbiAgcHVibGljIGR5bmFtaWMoYXR0cmlidXRlczogeyBba2V5OiBzdHJpbmddOiBhbnkgfSk6IElSZXNvbHZhYmxlIHtcbiAgICByZXR1cm4gVG9rZW4uYXNBbnkoXG4gICAgICBuZXcgVGVycmFmb3JtRHluYW1pY0V4cHJlc3Npb24oe1xuICAgICAgICBpdGVyYXRvcjogdGhpcyxcbiAgICAgICAgY29udGVudDogYXR0cmlidXRlcyxcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZm9yIGV4cHJlc3Npb24gdGhhdCBtYXBzIHRoZSBpdGVyYXRvcnMgdG8gaXRzIGtleXMuXG4gICAqIEZvciBsaXN0cyB0aGVzZSB3b3VsZCBiZSB0aGUgaW5kaWNlcywgZm9yIG1hcHMgdGhlIGtleXMuXG4gICAqIEFzIHRoaXMgcmV0dXJucyBhbiBJUmVzb2x2YWJsZSB5b3UgbWlnaHQgbmVlZCB0byB3cmFwIHRoZSBvdXRwdXQgaW5cbiAgICogYSBUb2tlbiwgZS5nLiBgVG9rZW4uYXNTdHJpbmdgLlxuICAgKi9cbiAgcHVibGljIGtleXMoKTogSVJlc29sdmFibGUge1xuICAgIHJldHVybiBUb2tlbi5hc0FueShcbiAgICAgIGZvckV4cHJlc3Npb24odGhpcy5fZ2V0Rm9yRWFjaEV4cHJlc3Npb24oKSwgRk9SX0VYUFJFU1NJT05fS0VZKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZvciBleHByZXNzaW9uIHRoYXQgbWFwcyB0aGUgaXRlcmF0b3JzIHRvIGl0cyB2YWx1ZSBpbiBjYXNlIGl0IGlzIGEgbWFwLlxuICAgKiBGb3IgbGlzdHMgdGhlc2Ugd291bGQgc3RheSB0aGUgc2FtZS5cbiAgICogQXMgdGhpcyByZXR1cm5zIGFuIElSZXNvbHZhYmxlIHlvdSBtaWdodCBuZWVkIHRvIHdyYXAgdGhlIG91dHB1dCBpblxuICAgKiBhIFRva2VuLCBlLmcuIGBUb2tlbi5hc1N0cmluZ2AuXG4gICAqL1xuICBwdWJsaWMgdmFsdWVzKCk6IElSZXNvbHZhYmxlIHtcbiAgICByZXR1cm4gVG9rZW4uYXNBbnkoXG4gICAgICBmb3JFeHByZXNzaW9uKHRoaXMuX2dldEZvckVhY2hFeHByZXNzaW9uKCksIEZPUl9FWFBSRVNTSU9OX1ZBTFVFKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZvciBleHByZXNzaW9uIHRoYXQgYWNjZXNzZXMgdGhlIGtleSBvbiBlYWNoIGVsZW1lbnQgb2YgdGhlIGl0ZXJhdG9yLlxuICAgKiBBcyB0aGlzIHJldHVybnMgYW4gSVJlc29sdmFibGUgeW91IG1pZ2h0IG5lZWQgdG8gd3JhcCB0aGUgb3V0cHV0IGluXG4gICAqIGEgVG9rZW4sIGUuZy4gYFRva2VuLmFzU3RyaW5nYC5cbiAgICogQHBhcmFtIHByb3BlcnR5IFRoZSBwcm9wZXJ0eSBvZiB0aGUgaXRlcmF0b3JzIHZhbHVlcyB0byBtYXAgdG9cbiAgICovXG4gIHB1YmxpYyBwbHVja1Byb3BlcnR5KHByb3BlcnR5OiBzdHJpbmcpOiBJUmVzb2x2YWJsZSB7XG4gICAgcmV0dXJuIFRva2VuLmFzQW55KFxuICAgICAgZm9yRXhwcmVzc2lvbihcbiAgICAgICAgdGhpcy5fZ2V0Rm9yRWFjaEV4cHJlc3Npb24oKSxcbiAgICAgICAgcHJvcGVydHlBY2Nlc3MoRk9SX0VYUFJFU1NJT05fVkFMVUUsIFtwcm9wZXJ0eV0pXG4gICAgICApXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZm9yIGV4cHJlc3Npb24gdGhhdCByZXN1bHRzIGluIGEgbGlzdC5cbiAgICogVGhpcyBtZXRob2QgYWxsb3dzIHlvdSB0byBjcmVhdGUgZXZlcnkgcG9zc2libGUgZm9yIGV4cHJlc3Npb24sIGJ1dCByZXF1aXJlcyBtb3JlIGtub3dsZWRnZSBhYm91dFxuICAgKiBUZXJyYWZvcm0ncyBmb3IgZXhwcmVzc2lvbiBzeW50YXguXG4gICAqIEZvciB0aGUgbW9zdCBjb21tb24gdXNlIGNhc2VzIHlvdSBjYW4gdXNlIGtleXMoKSwgdmFsdWVzKCksIGFuZCBwbHVja1Byb3BlcnR5KCkgaW5zdGVhZC5cbiAgICpcbiAgICogWW91IG1heSB3cml0ZSBhbnkgdmFsaWQgVGVycmFmb3JtIGZvciBlYWNoIGV4cHJlc3Npb24sIGUuZy5cbiAgICogYFRlcnJhZm9ybUl0ZXJhdG9yLmZyb21MaXN0KG15SXRlcmF0b3JTb3VyY2VWYXIpLmZvckV4cHJlc3Npb25Gb3JMaXN0KFwidmFsLmZvbyBpZiB2YWwuYmFyID09IHRydWVcIilgXG4gICAqIHdpbGwgcmVzdWx0IGluIGBbIGZvciBrZXksIHZhbCBpbiB2YXIubXlJdGVyYXRvclNvdXJjZTogdmFsLmZvbyBpZiB2YWwuYmFyID09IHRydWUgXWAuXG4gICAqXG4gICAqIEFzIHRoaXMgcmV0dXJucyBhbiBJUmVzb2x2YWJsZSB5b3UgbWlnaHQgbmVlZCB0byB3cmFwIHRoZSBvdXRwdXQgaW5cbiAgICogYSBUb2tlbiwgZS5nLiBgVG9rZW4uYXNTdHJpbmdgLlxuICAgKiBAcGFyYW0gZXhwcmVzc2lvbiBUaGUgZXhwcmVzc2lvbiB0byB1c2UgaW4gdGhlIGZvciBtYXBwaW5nXG4gICAqL1xuICBwdWJsaWMgZm9yRXhwcmVzc2lvbkZvckxpc3QoZXhwcmVzc2lvbjogc3RyaW5nIHwgSVJlc29sdmFibGUpIHtcbiAgICByZXR1cm4gVG9rZW4uYXNBbnkoZm9yRXhwcmVzc2lvbih0aGlzLl9nZXRGb3JFYWNoRXhwcmVzc2lvbigpLCBleHByZXNzaW9uKSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZvciBleHByZXNzaW9uIHRoYXQgcmVzdWx0cyBpbiBhIG1hcC5cbiAgICogVGhpcyBtZXRob2QgYWxsb3dzIHlvdSB0byBjcmVhdGUgZXZlcnkgcG9zc2libGUgZm9yIGV4cHJlc3Npb24sIGJ1dCByZXF1aXJlcyBtb3JlIGtub3dsZWRnZSBhYm91dFxuICAgKiBUZXJyYWZvcm1zIGZvciBleHByZXNzaW9uIHN5bnRheC5cbiAgICogRm9yIHRoZSBtb3N0IGNvbW1vbiB1c2UgY2FzZXMgeW91IGNhbiB1c2Uga2V5cygpLCB2YWx1ZXMoKSwgYW5kIHBsdWNrUHJvcGVydHkgaW5zdGVhZC5cbiAgICpcbiAgICogWW91IG1heSB3cml0ZSBhbnkgdmFsaWQgVGVycmFmb3JtIGZvciBlYWNoIGV4cHJlc3Npb24sIGUuZy5cbiAgICogYFRlcnJhZm9ybUl0ZXJhdG9yLmZyb21NYXAobXlJdGVyYXRvclNvdXJjZVZhcikuZm9yRXhwcmVzc2lvbkZvck1hcChcImtleVwiLCBcInZhbC5mb28gaWYgdmFsLmJhciA9PSB0cnVlXCIpYFxuICAgKiB3aWxsIHJlc3VsdCBpbiBgeyBmb3Iga2V5LCB2YWwgaW4gdmFyLm15SXRlcmF0b3JTb3VyY2U6IGtleSA9PiB2YWwuZm9vIGlmIHZhbC5iYXIgPT0gdHJ1ZSB9YC5cbiAgICpcbiAgICogQXMgdGhpcyByZXR1cm5zIGFuIElSZXNvbHZhYmxlIHlvdSBtaWdodCBuZWVkIHRvIHdyYXAgdGhlIG91dHB1dCBpblxuICAgKiBhIFRva2VuLCBlLmcuIGBUb2tlbi5hc1N0cmluZ2AuXG4gICAqIEBwYXJhbSBrZXlFeHByZXNzaW9uIFRoZSBleHByZXNzaW9uIHRvIHVzZSBhcyBrZXkgaW4gdGhlIGZvciBtYXBwaW5nXG4gICAqIEBwYXJhbSB2YWx1ZUV4cHJlc3Npb24gVGhlIGV4cHJlc3Npb24gdG8gdXNlIGFzIHZhbHVlIGluIHRoZSBmb3IgbWFwcGluZ1xuICAgKi9cbiAgcHVibGljIGZvckV4cHJlc3Npb25Gb3JNYXAoXG4gICAga2V5RXhwcmVzc2lvbjogc3RyaW5nIHwgSVJlc29sdmFibGUsXG4gICAgdmFsdWVFeHByZXNzaW9uOiBzdHJpbmcgfCBJUmVzb2x2YWJsZVxuICApIHtcbiAgICByZXR1cm4gVG9rZW4uYXNBbnkoXG4gICAgICBmb3JFeHByZXNzaW9uKFxuICAgICAgICB0aGlzLl9nZXRGb3JFYWNoRXhwcmVzc2lvbigpLFxuICAgICAgICB2YWx1ZUV4cHJlc3Npb24sXG4gICAgICAgIGtleUV4cHJlc3Npb25cbiAgICAgIClcbiAgICApO1xuICB9XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc2RvYy9yZXF1aXJlLWpzZG9jXG5leHBvcnQgY2xhc3MgTGlzdFRlcnJhZm9ybUl0ZXJhdG9yIGV4dGVuZHMgVGVycmFmb3JtSXRlcmF0b3Ige1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IGxpc3Q6IExpc3RUeXBlKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50bHkgZW50cnkgaW4gdGhlIGxpc3Qgb3Igc2V0IHRoYXQgaXMgYmVpbmcgaXRlcmF0ZWQgb3Zlci5cbiAgICogRm9yIGxpc3RzIHRoaXMgaXMgdGhlIHNhbWUgYXMgYGl0ZXJhdG9yLnZhbHVlYC4gSWYgeW91IG5lZWQgdGhlIGluZGV4LFxuICAgKiB1c2UgY291bnQgdmlhIGBUZXJyYWZvcm1Db3VudGA6XG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLmhhc2hpY29ycC5jb20vdGVycmFmb3JtL2Nka3RmL2NvbmNlcHRzL2l0ZXJhdG9ycyN1c2luZy1jb3VudFxuICAgKi9cbiAgcHVibGljIGdldCBrZXkoKTogYW55IHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0S2V5KCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGN1cnJlbnQgaXRlbSBpdGVyYXRlZCBvdmVyLlxuICAgKi9cbiAgcHVibGljIGdldCB2YWx1ZSgpOiBhbnkge1xuICAgIHJldHVybiB0aGlzLl9nZXRWYWx1ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbCB1c2VkIGJ5IFRlcnJhZm9ybVJlc291cmNlIHRvIHNldCB0aGUgZm9yX2VhY2ggZXhwcmVzc2lvblxuICAgKi9cbiAgcHVibGljIF9nZXRGb3JFYWNoRXhwcmVzc2lvbigpOiBhbnkge1xuICAgIC8vIG5lZWRzIHRvIGJlIHdyYXBwZWQgaW4gYSBzZXQgYXMgVGVycmFmb3JtIG9ubHkgYWxsb3dzIHNldHMgaW4gZm9yX2VhY2hcbiAgICByZXR1cm4gRm4udG9zZXQodGhpcy5saXN0KTtcbiAgfVxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvY1xuZXhwb3J0IGNsYXNzIE1hcFRlcnJhZm9ybUl0ZXJhdG9yIGV4dGVuZHMgVGVycmFmb3JtSXRlcmF0b3Ige1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IG1hcDogTWFwVHlwZSkge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsIHVzZWQgYnkgVGVycmFmb3JtUmVzb3VyY2UgdG8gc2V0IHRoZSBmb3JfZWFjaCBleHByZXNzaW9uXG4gICAqL1xuICBwdWJsaWMgX2dldEZvckVhY2hFeHByZXNzaW9uKCk6IGFueSB7XG4gICAgLy8gZXhwbGljaXQgd3JhcHBpbmcgdG8gY2lyY3VtdmVudCBcIkZvdW5kIGFuIGVuY29kZWQgbWFwIHRva2VuIGluIGEgc2NhbGFyIHN0cmluZyBjb250ZXh0LlwiIGVycm9yXG4gICAgcmV0dXJuIFRva2VuLmFzU3RyaW5nKHRoaXMubWFwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBrZXkgb2YgdGhlIGN1cnJlbnQgZW50cnkgaW4gdGhlIG1hcCB0aGF0IGlzIGJlaW5nIGl0ZXJhdGVkIG92ZXIuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGtleSgpOiBzdHJpbmcge1xuICAgIHJldHVybiBUb2tlbi5hc1N0cmluZyh0aGlzLl9nZXRLZXkoKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGN1cnJlbnQgaXRlbSBpdGVyYXRlZCBvdmVyLlxuICAgKi9cbiAgcHVibGljIGdldCB2YWx1ZSgpOiBhbnkge1xuICAgIHJldHVybiB0aGlzLl9nZXRWYWx1ZSgpO1xuICB9XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc2RvYy9yZXF1aXJlLWpzZG9jXG5leHBvcnQgY2xhc3MgUmVzb3VyY2VUZXJyYWZvcm1JdGVyYXRvciBleHRlbmRzIFRlcnJhZm9ybUl0ZXJhdG9yIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBlbGVtZW50OiBJVGVycmFmb3JtUmVzb3VyY2UpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgaWYgKGVsZW1lbnQuY291bnQpIHtcbiAgICAgIHRocm93IGl0ZXJhdG9yT25SZXNvdXJjZVdpdGhDb3VudCgpO1xuICAgIH1cblxuICAgIGlmICghZWxlbWVudC5mb3JFYWNoKSB7XG4gICAgICB0aHJvdyBpdGVyYXRvck9uUmVzb3VyY2VXaXRob3V0Rm9yRWFjaCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGVudHJ5IGluIHRoZSBsaXN0IG9yIHNldCB0aGF0IGlzIGJlaW5nIGl0ZXJhdGVkIG92ZXIuXG4gICAqIEZvciBsaXN0cyB0aGlzIGlzIHRoZSBzYW1lIGFzIGBpdGVyYXRvci52YWx1ZWAuIElmIHlvdSBuZWVkIHRoZSBpbmRleCxcbiAgICogdXNlIGNvdW50IHZpYSBgVGVycmFmb3JtQ291bnRgOlxuICAgKiBodHRwczovL2RldmVsb3Blci5oYXNoaWNvcnAuY29tL3RlcnJhZm9ybS9jZGt0Zi9jb25jZXB0cy9pdGVyYXRvcnMjdXNpbmctY291bnRcbiAgICovXG4gIHB1YmxpYyBnZXQga2V5KCk6IGFueSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldEtleSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBjdXJyZW50IGl0ZW0gaXRlcmF0ZWQgb3Zlci5cbiAgICovXG4gIHB1YmxpYyBnZXQgdmFsdWUoKTogYW55IHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0VmFsdWUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWwgdXNlZCBieSBUZXJyYWZvcm1SZXNvdXJjZSB0byBzZXQgdGhlIGZvcl9lYWNoIGV4cHJlc3Npb25cbiAgICovXG4gIHB1YmxpYyBfZ2V0Rm9yRWFjaEV4cHJlc3Npb24oKTogYW55IHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50LmZxbjsgLy8gbm8gd3JhcHBpbmcgbmVjZXNzYXJ5IGZvciByZXNvdXJjZXNcbiAgfVxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvY1xuZXhwb3J0IGNsYXNzIER5bmFtaWNMaXN0VGVycmFmb3JtSXRlcmF0b3IgZXh0ZW5kcyBNYXBUZXJyYWZvcm1JdGVyYXRvciB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgbGlzdDogTGlzdFR5cGUsXG4gICAgcHJpdmF0ZSByZWFkb25seSBtYXBLZXlBdHRyaWJ1dGVOYW1lOiBzdHJpbmdcbiAgKSB7XG4gICAgc3VwZXIobGlzdCk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsIHVzZWQgYnkgVGVycmFmb3JtUmVzb3VyY2UgdG8gc2V0IHRoZSBmb3JfZWFjaCBleHByZXNzaW9uXG4gICAqL1xuICBwdWJsaWMgX2dldEZvckVhY2hFeHByZXNzaW9uKCk6IGFueSB7XG4gICAgLy8gdXNlcyBhIExhenkgdmFsdWUgdG8gYmUgYWJsZSB0byByZW5kZXIgYSBjb252ZXJzaW9uIGludG8gYSBtYXAgaW4gdGhlIGNvbnRleHQgb2YgYSBUZXJyYWZvcm1SZXNvdXJjZVxuICAgIHJldHVybiBMYXp5LmFueVZhbHVlKFxuICAgICAge1xuICAgICAgICBwcm9kdWNlOiAoY29udGV4dCkgPT4ge1xuICAgICAgICAgIHN3aXRjaCAoY29udGV4dC5pdGVyYXRvckNvbnRleHQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJGT1JfRVhQUkVTU0lPTlwiOlxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0O1xuICAgICAgICAgICAgY2FzZSBcIkRZTkFNSUNfQkxPQ0tcIjogLy8gZmFsbHRocm91Z2hcbiAgICAgICAgICAgIGRlZmF1bHQ6IC8vIHNhbWUgYXMgZHluYW1pYyBibG9jaywgYXMgdGhpcyBpcyB0aGUgY2FzZSB3aGVuIGEgaXRlcmF0b3IgaXMgcGFzc2VkIHRvIHRoZSByb290IGxldmVsIG9mIGUuZy4gYSByZXNvdXJjZVxuICAgICAgICAgICAgICAvLyBUdXJuIGxpc3QgaW50byBhIG1hcFxuICAgICAgICAgICAgICAvLyB7IGZvciBrLHYgaW4gPGlucHV0PiA6IDxrZXlFeHByZXNzaW9uPiA9PiA8dmFsdWVFeHByZXNzaW9uPn1cbiAgICAgICAgICAgICAgcmV0dXJuIGZvckV4cHJlc3Npb24oXG4gICAgICAgICAgICAgICAgdGhpcy5saXN0LCAvLyBpbnB1dFxuICAgICAgICAgICAgICAgIEZPUl9FWFBSRVNTSU9OX1ZBTFVFLCAvLyB2YWx1ZUV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICBGbi5sb29rdXBOZXN0ZWQoRk9SX0VYUFJFU1NJT05fVkFMVUUsIFtcbiAgICAgICAgICAgICAgICAgIHRoaXMubWFwS2V5QXR0cmlidXRlTmFtZSxcbiAgICAgICAgICAgICAgICBdKSAvLyBrZXlFeHByZXNzaW9uXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIHsgZGlzcGxheUhpbnQ6IFwiPGl0ZXJhdG9yIHZhbHVlPlwiIH1cbiAgICApO1xuICB9XG59XG4iXX0=