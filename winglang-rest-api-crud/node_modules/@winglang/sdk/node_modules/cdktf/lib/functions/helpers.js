"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.terraformFunction = exports.asAny = exports.asBoolean = exports.asStringMap = exports.asList = exports.asNumber = exports.asString = exports.variadic = exports.listOf = exports.numericValue = exports.stringValue = exports.mapValue = exports.anyValue = void 0;
// Copyright (c) HashiCorp, Inc
// SPDX-License-Identifier: MPL-2.0
const token_1 = require("../tokens/token");
const tfExpression_1 = require("../tfExpression");
const encoding_1 = require("../tokens/private/encoding");
const errors_1 = require("../errors");
/**
 * Determines if given str has unescaped double quotes
 * @param str String to test
 * @returns Boolean
 */
function hasUnescapedDoubleQuotes(str) {
    return /(^|[^\\])([\\]{2})*"/.test(str);
}
// Validators
// eslint-disable-next-line jsdoc/require-jsdoc
function anyValue(value) {
    return { value };
}
exports.anyValue = anyValue;
// eslint-disable-next-line jsdoc/require-jsdoc
function mapValue(value) {
    return { value };
}
exports.mapValue = mapValue;
// eslint-disable-next-line jsdoc/require-jsdoc
function stringValue(value) {
    if (typeof value !== "string" && !token_1.Tokenization.isResolvable(value)) {
        throw (0, errors_1.valueIsInvalidStringOrToken)(value);
    }
    if (typeof value === "string" && hasUnescapedDoubleQuotes(value)) {
        throw (0, errors_1.valueContainsUnescapedQuotes)(value);
    }
    return { value };
}
exports.stringValue = stringValue;
// eslint-disable-next-line jsdoc/require-jsdoc
function numericValue(value) {
    if (typeof value !== "number" && !token_1.Tokenization.isResolvable(value)) {
        throw (0, errors_1.valueIsInvalidNumberOrToken)(value);
    }
    return { value };
}
exports.numericValue = numericValue;
// eslint-disable-next-line jsdoc/require-jsdoc
function listOf(type) {
    return (value) => {
        if (token_1.Tokenization.isResolvable(value)) {
            return { value };
        }
        if (!Array.isArray(value)) {
            //   throw new Error(`${value} is not a valid list`);
            return { value };
        }
        return {
            value: value
                .filter((item) => item !== undefined && item !== null)
                .map((item, i) => {
                if (token_1.Tokenization.isResolvable(item)) {
                    return item;
                }
                if (encoding_1.TokenString.forListToken(item).test()) {
                    return item;
                }
                if ((0, encoding_1.extractTokenDouble)(item, true) !== undefined) {
                    return item;
                }
                if (encoding_1.TokenString.forMapToken(item).test()) {
                    return item;
                }
                if (typeof item === "string") {
                    const tokenList = token_1.Tokenization.reverseString(item);
                    const numberOfTokens = tokenList.tokens.length + tokenList.intrinsic.length;
                    if (numberOfTokens === 1 && tokenList.literals.length === 0) {
                        return item;
                    }
                }
                try {
                    type(item);
                    return typeof item === "string" ? `"${item}"` : item;
                }
                catch (error) {
                    throw (0, errors_1.listElementIsOfWrongType)(value, i, error);
                }
            }),
        };
    };
}
exports.listOf = listOf;
// eslint-disable-next-line jsdoc/require-jsdoc
function variadic(type) {
    return (value) => {
        // we use the list validator and set variadic to true in order to have it expanded in the args passed to the TF function
        return { value: listOf(type)(value).value, variadic: true };
    };
}
exports.variadic = variadic;
// Tokenization
// eslint-disable-next-line jsdoc/require-jsdoc
function asString(value) {
    return token_1.Token.asString(value);
}
exports.asString = asString;
// eslint-disable-next-line jsdoc/require-jsdoc
function asNumber(value) {
    return token_1.Token.asNumber(value);
}
exports.asNumber = asNumber;
// eslint-disable-next-line jsdoc/require-jsdoc
function asList(value) {
    return token_1.Token.asList(value);
}
exports.asList = asList;
// eslint-disable-next-line jsdoc/require-jsdoc
function asStringMap(value) {
    return token_1.Token.asStringMap(value);
}
exports.asStringMap = asStringMap;
// eslint-disable-next-line jsdoc/require-jsdoc
function asBoolean(value) {
    return value; // Booleans can not be represented as a token
}
exports.asBoolean = asBoolean;
// eslint-disable-next-line jsdoc/require-jsdoc
function asAny(value) {
    // Ordinarily casting to any can cause issues, but
    // in this case it makes using functions a bit easier in TS
    // and doesn't really harm other languages.
    // Jsii has issues when returning the value directly,
    // so wrap as a string.
    return asString(value);
}
exports.asAny = asAny;
// eslint-disable-next-line jsdoc/require-jsdoc
function terraformFunction(name, argValidators) {
    return function (...args) {
        if (args.length !== argValidators.length) {
            throw (0, errors_1.functionReceivedWrongNumberOfArgs)(name, argValidators.length, args.length);
        }
        return (0, tfExpression_1.call)(name, 
        // We use flatMap now, since listOf() wraps everything in an extra array but variadic() does not
        // This enables us to have variadic pass multiple args into the call() from a single array
        args.reduce((carry, arg, i) => {
            try {
                const val = argValidators[i](arg);
                if (val.variadic)
                    return [...carry, ...val.value];
                else
                    return [...carry, val.value];
            }
            catch (error) {
                throw (0, errors_1.functionArgumentValidationFailure)(i, name, error);
            }
        }, []));
    };
}
exports.terraformFunction = terraformFunction;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGVscGVycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImhlbHBlcnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsK0JBQStCO0FBQy9CLG1DQUFtQztBQUNuQywyQ0FBc0Q7QUFDdEQsa0RBQXVDO0FBRXZDLHlEQUE2RTtBQUM3RSxzQ0FPbUI7QUFPbkI7Ozs7R0FJRztBQUNILFNBQVMsd0JBQXdCLENBQUMsR0FBVztJQUMzQyxPQUFPLHNCQUFzQixDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUMxQyxDQUFDO0FBRUQsYUFBYTtBQUNiLCtDQUErQztBQUMvQyxTQUFnQixRQUFRLENBQUksS0FBUTtJQUNsQyxPQUFPLEVBQUUsS0FBSyxFQUFFLENBQUM7QUFDbkIsQ0FBQztBQUZELDRCQUVDO0FBRUQsK0NBQStDO0FBQy9DLFNBQWdCLFFBQVEsQ0FBSSxLQUFRO0lBQ2xDLE9BQU8sRUFBRSxLQUFLLEVBQUUsQ0FBQztBQUNuQixDQUFDO0FBRkQsNEJBRUM7QUFFRCwrQ0FBK0M7QUFDL0MsU0FBZ0IsV0FBVyxDQUFtQixLQUFRO0lBQ3BELElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxJQUFJLENBQUMsb0JBQVksQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQztRQUNuRSxNQUFNLElBQUEsb0NBQTJCLEVBQUMsS0FBSyxDQUFDLENBQUM7SUFDM0MsQ0FBQztJQUVELElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxJQUFJLHdCQUF3QixDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUM7UUFDakUsTUFBTSxJQUFBLHFDQUE0QixFQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzVDLENBQUM7SUFFRCxPQUFPLEVBQUUsS0FBSyxFQUFFLENBQUM7QUFDbkIsQ0FBQztBQVZELGtDQVVDO0FBRUQsK0NBQStDO0FBQy9DLFNBQWdCLFlBQVksQ0FBSSxLQUFRO0lBQ3RDLElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxJQUFJLENBQUMs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Q0FBQyxNQUFNLENBQ1osQ0FBQztRQUNKLENBQUM7UUFDRCxPQUFPLElBQUEsbUJBQUksRUFDVCxJQUFJO1FBQ0osZ0dBQWdHO1FBQ2hHLDBGQUEwRjtRQUMxRixJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsS0FBSyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUM1QixJQUFJLENBQUM7Z0JBQ0gsTUFBTSxHQUFHLEdBQUcsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2dCQUNsQyxJQUFJLEdBQUcsQ0FBQyxRQUFRO29CQUFFLE9BQU8sQ0FBQyxHQUFHLEtBQUssRUFBRSxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQzs7b0JBQzdDLE9BQU8sQ0FBQyxHQUFHLEtBQUssRUFBRSxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDcEMsQ0FBQztZQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7Z0JBQ2YsTUFBTSxJQUFBLDBDQUFpQyxFQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFDMUQsQ0FBQztRQUNILENBQUMsRUFBRSxFQUFFLENBQUMsQ0FDUCxDQUFDO0lBQ0osQ0FBQyxDQUFDO0FBQ0osQ0FBQztBQTNCRCw4Q0EyQkMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIEhhc2hpQ29ycCwgSW5jXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTVBMLTIuMFxuaW1wb3J0IHsgVG9rZW5pemF0aW9uLCBUb2tlbiB9IGZyb20gXCIuLi90b2tlbnMvdG9rZW5cIjtcbmltcG9ydCB7IGNhbGwgfSBmcm9tIFwiLi4vdGZFeHByZXNzaW9uXCI7XG5pbXBvcnQgeyBJUmVzb2x2YWJsZSB9IGZyb20gXCIuLi90b2tlbnMvcmVzb2x2YWJsZVwiO1xuaW1wb3J0IHsgVG9rZW5TdHJpbmcsIGV4dHJhY3RUb2tlbkRvdWJsZSB9IGZyb20gXCIuLi90b2tlbnMvcHJpdmF0ZS9lbmNvZGluZ1wiO1xuaW1wb3J0IHtcbiAgZnVuY3Rpb25Bcmd1bWVudFZhbGlkYXRpb25GYWlsdXJlLFxuICBmdW5jdGlvblJlY2VpdmVkV3JvbmdOdW1iZXJPZkFyZ3MsXG4gIGxpc3RFbGVtZW50SXNPZldyb25nVHlwZSxcbiAgdmFsdWVDb250YWluc1VuZXNjYXBlZFF1b3RlcyxcbiAgdmFsdWVJc0ludmFsaWROdW1iZXJPclRva2VuLFxuICB2YWx1ZUlzSW52YWxpZFN0cmluZ09yVG9rZW4sXG59IGZyb20gXCIuLi9lcnJvcnNcIjtcblxudHlwZSBURlZhbHVlPFQ+ID0geyB2YXJpYWRpYz86IGJvb2xlYW47IHZhbHVlOiBUIH07XG50eXBlIFRGVmFsdWVWYWxpZGF0b3I8VD4gPSAodmFsdWU6IFQpID0+IFRGVmFsdWU8VD47XG5cbnR5cGUgRXhlY3V0YWJsZVRmRnVuY3Rpb24gPSAoLi4uYXJnczogYW55W10pID0+IElSZXNvbHZhYmxlO1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgZ2l2ZW4gc3RyIGhhcyB1bmVzY2FwZWQgZG91YmxlIHF1b3Rlc1xuICogQHBhcmFtIHN0ciBTdHJpbmcgdG8gdGVzdFxuICogQHJldHVybnMgQm9vbGVhblxuICovXG5mdW5jdGlvbiBoYXNVbmVzY2FwZWREb3VibGVRdW90ZXMoc3RyOiBzdHJpbmcpIHtcbiAgcmV0dXJuIC8oXnxbXlxcXFxdKShbXFxcXF17Mn0pKlwiLy50ZXN0KHN0cik7XG59XG5cbi8vIFZhbGlkYXRvcnNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc2RvYy9yZXF1aXJlLWpzZG9jXG5leHBvcnQgZnVuY3Rpb24gYW55VmFsdWU8VD4odmFsdWU6IFQpOiBURlZhbHVlPFQ+IHtcbiAgcmV0dXJuIHsgdmFsdWUgfTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2NcbmV4cG9ydCBmdW5jdGlvbiBtYXBWYWx1ZTxUPih2YWx1ZTogVCk6IFRGVmFsdWU8VD4ge1xuICByZXR1cm4geyB2YWx1ZSB9O1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvY1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ1ZhbHVlPFQgZXh0ZW5kcyBzdHJpbmc+KHZhbHVlOiBUKTogVEZWYWx1ZTxUPiB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIgJiYgIVRva2VuaXphdGlvbi5pc1Jlc29sdmFibGUodmFsdWUpKSB7XG4gICAgdGhyb3cgdmFsdWVJc0ludmFsaWRTdHJpbmdPclRva2VuKHZhbHVlKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgaGFzVW5lc2NhcGVkRG91YmxlUXVvdGVzKHZhbHVlKSkge1xuICAgIHRocm93IHZhbHVlQ29udGFpbnNVbmVzY2FwZWRRdW90ZXModmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIHsgdmFsdWUgfTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2NcbmV4cG9ydCBmdW5jdGlvbiBudW1lcmljVmFsdWU8VD4odmFsdWU6IFQpOiBURlZhbHVlPFQ+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIiAmJiAhVG9rZW5pemF0aW9uLmlzUmVzb2x2YWJsZSh2YWx1ZSkpIHtcbiAgICB0aHJvdyB2YWx1ZUlzSW52YWxpZE51bWJlck9yVG9rZW4odmFsdWUgYXMgc3RyaW5nKTtcbiAgfVxuICByZXR1cm4geyB2YWx1ZSB9O1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvY1xuZXhwb3J0IGZ1bmN0aW9uIGxpc3RPZjxUPih0eXBlOiBURlZhbHVlVmFsaWRhdG9yPFQ+KTogVEZWYWx1ZVZhbGlkYXRvcjxUW10+IHtcbiAgcmV0dXJuICh2YWx1ZTogYW55KSA9PiB7XG4gICAgaWYgKFRva2VuaXphdGlvbi5pc1Jlc29sdmFibGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4geyB2YWx1ZSB9O1xuICAgIH1cblxuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIC8vICAgdGhyb3cgbmV3IEVycm9yKGAke3ZhbHVlfSBpcyBub3QgYSB2YWxpZCBsaXN0YCk7XG4gICAgICByZXR1cm4geyB2YWx1ZSB9O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgLmZpbHRlcigoaXRlbSkgPT4gaXRlbSAhPT0gdW5kZWZpbmVkICYmIGl0ZW0gIT09IG51bGwpXG4gICAgICAgIC5tYXAoKGl0ZW0sIGkpID0+IHtcbiAgICAgICAgICBpZiAoVG9rZW5pemF0aW9uLmlzUmVzb2x2YWJsZShpdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKFRva2VuU3RyaW5nLmZvckxpc3RUb2tlbihpdGVtKS50ZXN0KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChleHRyYWN0VG9rZW5Eb3VibGUoaXRlbSwgdHJ1ZSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKFRva2VuU3RyaW5nLmZvck1hcFRva2VuKGl0ZW0pLnRlc3QoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbkxpc3QgPSBUb2tlbml6YXRpb24ucmV2ZXJzZVN0cmluZyhpdGVtKTtcbiAgICAgICAgICAgIGNvbnN0IG51bWJlck9mVG9rZW5zID1cbiAgICAgICAgICAgICAgdG9rZW5MaXN0LnRva2Vucy5sZW5ndGggKyB0b2tlbkxpc3QuaW50cmluc2ljLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChudW1iZXJPZlRva2VucyA9PT0gMSAmJiB0b2tlbkxpc3QubGl0ZXJhbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0eXBlKGl0ZW0pO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiID8gYFwiJHtpdGVtfVwiYCA6IGl0ZW07XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGxpc3RFbGVtZW50SXNPZldyb25nVHlwZSh2YWx1ZSwgaSwgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgfTtcbiAgfTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2NcbmV4cG9ydCBmdW5jdGlvbiB2YXJpYWRpYzxUPih0eXBlOiBURlZhbHVlVmFsaWRhdG9yPFQ+KTogVEZWYWx1ZVZhbGlkYXRvcjxUW10+IHtcbiAgcmV0dXJuICh2YWx1ZTogYW55KSA9PiB7XG4gICAgLy8gd2UgdXNlIHRoZSBsaXN0IHZhbGlkYXRvciBhbmQgc2V0IHZhcmlhZGljIHRvIHRydWUgaW4gb3JkZXIgdG8gaGF2ZSBpdCBleHBhbmRlZCBpbiB0aGUgYXJncyBwYXNzZWQgdG8gdGhlIFRGIGZ1bmN0aW9uXG4gICAgcmV0dXJuIHsgdmFsdWU6IGxpc3RPZih0eXBlKSh2YWx1ZSkudmFsdWUsIHZhcmlhZGljOiB0cnVlIH07XG4gIH07XG59XG5cbi8vIFRva2VuaXphdGlvblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2NcbmV4cG9ydCBmdW5jdGlvbiBhc1N0cmluZyh2YWx1ZTogSVJlc29sdmFibGUpIHtcbiAgcmV0dXJuIFRva2VuLmFzU3RyaW5nKHZhbHVlKTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2NcbmV4cG9ydCBmdW5jdGlvbiBhc051bWJlcih2YWx1ZTogSVJlc29sdmFibGUpIHtcbiAgcmV0dXJuIFRva2VuLmFzTnVtYmVyKHZhbHVlKTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2NcbmV4cG9ydCBmdW5jdGlvbiBhc0xpc3QodmFsdWU6IElSZXNvbHZhYmxlKSB7XG4gIHJldHVybiBUb2tlbi5hc0xpc3QodmFsdWUpO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvY1xuZXhwb3J0IGZ1bmN0aW9uIGFzU3RyaW5nTWFwKHZhbHVlOiBJUmVzb2x2YWJsZSkge1xuICByZXR1cm4gVG9rZW4uYXNTdHJpbmdNYXAodmFsdWUpO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvY1xuZXhwb3J0IGZ1bmN0aW9uIGFzQm9vbGVhbih2YWx1ZTogSVJlc29sdmFibGUpIHtcbiAgcmV0dXJuIHZhbHVlOyAvLyBCb29sZWFucyBjYW4gbm90IGJlIHJlcHJlc2VudGVkIGFzIGEgdG9rZW5cbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2NcbmV4cG9ydCBmdW5jdGlvbiBhc0FueSh2YWx1ZTogSVJlc29sdmFibGUpIHtcbiAgLy8gT3JkaW5hcmlseSBjYXN0aW5nIHRvIGFueSBjYW4gY2F1c2UgaXNzdWVzLCBidXRcbiAgLy8gaW4gdGhpcyBjYXNlIGl0IG1ha2VzIHVzaW5nIGZ1bmN0aW9ucyBhIGJpdCBlYXNpZXIgaW4gVFNcbiAgLy8gYW5kIGRvZXNuJ3QgcmVhbGx5IGhhcm0gb3RoZXIgbGFuZ3VhZ2VzLlxuICAvLyBKc2lpIGhhcyBpc3N1ZXMgd2hlbiByZXR1cm5pbmcgdGhlIHZhbHVlIGRpcmVjdGx5LFxuICAvLyBzbyB3cmFwIGFzIGEgc3RyaW5nLlxuICByZXR1cm4gYXNTdHJpbmcodmFsdWUpIGFzIGFueTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2NcbmV4cG9ydCBmdW5jdGlvbiB0ZXJyYWZvcm1GdW5jdGlvbihcbiAgbmFtZTogc3RyaW5nLFxuICBhcmdWYWxpZGF0b3JzOiBURlZhbHVlVmFsaWRhdG9yPGFueT5bXVxuKTogRXhlY3V0YWJsZVRmRnVuY3Rpb24ge1xuICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3M6IGFueVtdKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoICE9PSBhcmdWYWxpZGF0b3JzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgZnVuY3Rpb25SZWNlaXZlZFdyb25nTnVtYmVyT2ZBcmdzKFxuICAgICAgICBuYW1lLFxuICAgICAgICBhcmdWYWxpZGF0b3JzLmxlbmd0aCxcbiAgICAgICAgYXJncy5sZW5ndGhcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBjYWxsKFxuICAgICAgbmFtZSxcbiAgICAgIC8vIFdlIHVzZSBmbGF0TWFwIG5vdywgc2luY2UgbGlzdE9mKCkgd3JhcHMgZXZlcnl0aGluZyBpbiBhbiBleHRyYSBhcnJheSBidXQgdmFyaWFkaWMoKSBkb2VzIG5vdFxuICAgICAgLy8gVGhpcyBlbmFibGVzIHVzIHRvIGhhdmUgdmFyaWFkaWMgcGFzcyBtdWx0aXBsZSBhcmdzIGludG8gdGhlIGNhbGwoKSBmcm9tIGEgc2luZ2xlIGFycmF5XG4gICAgICBhcmdzLnJlZHVjZSgoY2FycnksIGFyZywgaSkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHZhbCA9IGFyZ1ZhbGlkYXRvcnNbaV0oYXJnKTtcbiAgICAgICAgICBpZiAodmFsLnZhcmlhZGljKSByZXR1cm4gWy4uLmNhcnJ5LCAuLi52YWwudmFsdWVdO1xuICAgICAgICAgIGVsc2UgcmV0dXJuIFsuLi5jYXJyeSwgdmFsLnZhbHVlXTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBmdW5jdGlvbkFyZ3VtZW50VmFsaWRhdGlvbkZhaWx1cmUoaSwgbmFtZSwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9LCBbXSlcbiAgICApO1xuICB9O1xufVxuIl19