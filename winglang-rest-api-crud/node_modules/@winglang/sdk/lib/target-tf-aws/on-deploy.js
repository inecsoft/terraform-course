"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OnDeploy = void 0;
const data_aws_lambda_invocation_1 = require("../.gen/providers/aws/data-aws-lambda-invocation");
const cloud = __importStar(require("../cloud"));
const core = __importStar(require("../core"));
/**
 * AWS implementation of `cloud.OnDeploy`.
 *
 * @inflight `@winglang/sdk.cloud.IOnDeployClient`
 */
class OnDeploy extends cloud.OnDeploy {
    constructor(scope, id, handler, props = {}) {
        super(scope, id, handler, props);
        let fn = new cloud.Function(this, "Function", handler, props);
        const awsFn = fn;
        // add all of the children of the construct to the dependencies
        const dependsOn = [];
        for (const c of props.executeAfter ?? []) {
            for (const child of c.node.findAll()) {
                if (isTerraformDependable(child)) {
                    dependsOn.push(child);
                }
            }
            this.node.addDependency(c);
        }
        // currently using the aws_lambda_invocation *data source* since it runs on every terraform apply.
        // if we want OnDeploy to only run code conditionally,
        // we can use the aws_lambda_invocation *resource* instead.
        const lambdaInvocation = new data_aws_lambda_invocation_1.DataAwsLambdaInvocation(this, "Invocation", {
            functionName: awsFn.functionName,
            input: JSON.stringify({}), // call the function with an empty object
            dependsOn,
        });
        for (const c of props.executeBefore ?? []) {
            // add the invocation as a dependency on all of the children of the construct
            for (const child of c.node.findAll()) {
                if (isTerraformResource(child)) {
                    if (child.dependsOn === undefined) {
                        child.dependsOn = [];
                    }
                    child.dependsOn.push(lambdaInvocation.fqn);
                }
            }
            c.node.addDependency(this);
        }
    }
    /** @internal */
    _toInflight() {
        return core.InflightClient.for(__dirname.replace("target-tf-aws", "shared-aws"), __filename, "OnDeployClient", []);
    }
}
exports.OnDeploy = OnDeploy;
function isTerraformDependable(x) {
    return "fqn" in x;
}
function isTerraformResource(x) {
    return "terraformResourceType" in x;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib24tZGVwbG95LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3RhcmdldC10Zi1hd3Mvb24tZGVwbG95LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBR0EsaUdBQTJGO0FBQzNGLGdEQUFrQztBQUNsQyw4Q0FBZ0M7QUFHaEM7Ozs7R0FJRztBQUNILE1BQWEsUUFBUyxTQUFRLEtBQUssQ0FBQyxRQUFRO0lBQzFDLFlBQ0UsS0FBZ0IsRUFDaEIsRUFBVSxFQUNWLE9BQStCLEVBQy9CLFFBQTZCLEVBQUU7UUFFL0IsS0FBSyxDQUFDLEtBQUssRUFBRSxFQUFFLEVBQUUsT0FBTyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBRWpDLElBQUksRUFBRSxHQUFHLElBQUksS0FBSyxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsVUFBVSxFQUFFLE9BQW9CLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDM0UsTUFBTSxLQUFLLEdBQUcsRUFBaUIsQ0FBQztRQUVoQywrREFBK0Q7UUFDL0QsTUFBTSxTQUFTLEdBQWdDLEVBQUUsQ0FBQztRQUNsRCxLQUFLLE1BQU0sQ0FBQyxJQUFJLEtBQUssQ0FBQyxZQUFZLElBQUksRUFBRSxFQUFFLENBQUM7WUFDekMsS0FBSyxNQUFNLEtBQUssSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUM7Z0JBQ3JDLElBQUkscUJBQXFCLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQztvQkFDakMsU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDeEIsQ0FBQztZQUNILENBQUM7WUFDRCxJQUFJLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUM3QixDQUFDO1FBRUQsa0dBQWtHO1FBQ2xHLHNEQUFzRDtRQUN0RCwyREFBMkQ7UUFDM0QsTUFBTSxnQkFBZ0IsR0FBRyxJQUFJLG9EQUF1QixDQUFDLElBQUksRUFBRSxZQUFZLEVBQUU7WUFDdkUsWUFBWSxFQUFFLEtBQUssQ0FBQyxZQUFZO1lBQ2hDLEtBQUssRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxFQUFFLHlDQUF5QztZQUNwRSxTQUFTO1NBQ1YsQ0FBQyxDQUFDO1FBRUgsS0FBSyxNQUFNLENBQUMsSUFBSSxLQUFLLENBQUMsYUFBYSxJQUFJLEVBQUUsRUFBRSxDQUFDO1lBQzFDLDZFQUE2RTtZQUM3RSxLQUFLLE1BQU0sS0FBSyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQztnQkFDckMsSUFBSSxtQkFBbUIsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDO29CQUMvQixJQUFJLEtBQUssQ0FBQyxTQUFTLEtBQUssU0FBUyxFQUFFLENBQUM7d0JBQ2xDLEtBQUssQ0FBQyxTQUFTLEdBQUcsRUFBRSxDQUFDO29CQUN2QixDQUFDO29CQUNELEtBQUssQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxDQUFDO2dCQUM3QyxDQUFDO1lBQ0gsQ0FBQztZQUNELENBQUMsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzdCLENBQUM7SUFDSCxDQUFDO0lBRUQsZ0JBQWdCO0lBQ1QsV0FBVztRQUNoQixPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUM1QixTQUFTLENBQUMsT0FBTyxDQUFDLGVBQWUsRUFBRSxZQUFZLENBQUMsRUFDaEQsVUFBVSxFQUNWLGdCQUFnQixFQUNoQixFQUFFLENBQ0gsQ0FBQztJQUNKLENBQUM7Q0FDRjtBQXZERCw0QkF1REM7QUFFRCxTQUFTLHFCQUFxQixDQUM1QixDQUFhO0lBRWIsT0FBTyxLQUFLLElBQUksQ0FBQyxDQUFDO0FBQ3BCLENBQUM7QUFFRCxTQUFTLG1CQUFtQixDQUMxQixDQUFhO0lBRWIsT0FBTyx1QkFBdUIsSUFBSSxDQUFDLENBQUM7QUFDdEMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IElUZXJyYWZvcm1EZXBlbmRhYmxlLCBJVGVycmFmb3JtUmVzb3VyY2UgfSBmcm9tIFwiY2RrdGZcIjtcbmltcG9ydCB7IENvbnN0cnVjdCwgSUNvbnN0cnVjdCB9IGZyb20gXCJjb25zdHJ1Y3RzXCI7XG5pbXBvcnQgeyBGdW5jdGlvbiBhcyBBd3NGdW5jdGlvbiB9IGZyb20gXCIuL2Z1bmN0aW9uXCI7XG5pbXBvcnQgeyBEYXRhQXdzTGFtYmRhSW52b2NhdGlvbiB9IGZyb20gXCIuLi8uZ2VuL3Byb3ZpZGVycy9hd3MvZGF0YS1hd3MtbGFtYmRhLWludm9jYXRpb25cIjtcbmltcG9ydCAqIGFzIGNsb3VkIGZyb20gXCIuLi9jbG91ZFwiO1xuaW1wb3J0ICogYXMgY29yZSBmcm9tIFwiLi4vY29yZVwiO1xuaW1wb3J0IHsgSUluZmxpZ2h0IH0gZnJvbSBcIi4uL3N0ZFwiO1xuXG4vKipcbiAqIEFXUyBpbXBsZW1lbnRhdGlvbiBvZiBgY2xvdWQuT25EZXBsb3lgLlxuICpcbiAqIEBpbmZsaWdodCBgQHdpbmdsYW5nL3Nkay5jbG91ZC5JT25EZXBsb3lDbGllbnRgXG4gKi9cbmV4cG9ydCBjbGFzcyBPbkRlcGxveSBleHRlbmRzIGNsb3VkLk9uRGVwbG95IHtcbiAgY29uc3RydWN0b3IoXG4gICAgc2NvcGU6IENvbnN0cnVjdCxcbiAgICBpZDogc3RyaW5nLFxuICAgIGhhbmRsZXI6IGNsb3VkLklPbkRlcGxveUhhbmRsZXIsXG4gICAgcHJvcHM6IGNsb3VkLk9uRGVwbG95UHJvcHMgPSB7fVxuICApIHtcbiAgICBzdXBlcihzY29wZSwgaWQsIGhhbmRsZXIsIHByb3BzKTtcblxuICAgIGxldCBmbiA9IG5ldyBjbG91ZC5GdW5jdGlvbih0aGlzLCBcIkZ1bmN0aW9uXCIsIGhhbmRsZXIgYXMgSUluZmxpZ2h0LCBwcm9wcyk7XG4gICAgY29uc3QgYXdzRm4gPSBmbiBhcyBBd3NGdW5jdGlvbjtcblxuICAgIC8vIGFkZCBhbGwgb2YgdGhlIGNoaWxkcmVuIG9mIHRoZSBjb25zdHJ1Y3QgdG8gdGhlIGRlcGVuZGVuY2llc1xuICAgIGNvbnN0IGRlcGVuZHNPbjogQXJyYXk8SVRlcnJhZm9ybURlcGVuZGFibGU+ID0gW107XG4gICAgZm9yIChjb25zdCBjIG9mIHByb3BzLmV4ZWN1dGVBZnRlciA/PyBbXSkge1xuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBjLm5vZGUuZmluZEFsbCgpKSB7XG4gICAgICAgIGlmIChpc1RlcnJhZm9ybURlcGVuZGFibGUoY2hpbGQpKSB7XG4gICAgICAgICAgZGVwZW5kc09uLnB1c2goY2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLm5vZGUuYWRkRGVwZW5kZW5jeShjKTtcbiAgICB9XG5cbiAgICAvLyBjdXJyZW50bHkgdXNpbmcgdGhlIGF3c19sYW1iZGFfaW52b2NhdGlvbiAqZGF0YSBzb3VyY2UqIHNpbmNlIGl0IHJ1bnMgb24gZXZlcnkgdGVycmFmb3JtIGFwcGx5LlxuICAgIC8vIGlmIHdlIHdhbnQgT25EZXBsb3kgdG8gb25seSBydW4gY29kZSBjb25kaXRpb25hbGx5LFxuICAgIC8vIHdlIGNhbiB1c2UgdGhlIGF3c19sYW1iZGFfaW52b2NhdGlvbiAqcmVzb3VyY2UqIGluc3RlYWQuXG4gICAgY29uc3QgbGFtYmRhSW52b2NhdGlvbiA9IG5ldyBEYXRhQXdzTGFtYmRhSW52b2NhdGlvbih0aGlzLCBcIkludm9jYXRpb25cIiwge1xuICAgICAgZnVuY3Rpb25OYW1lOiBhd3NGbi5mdW5jdGlvbk5hbWUsXG4gICAgICBpbnB1dDogSlNPTi5zdHJpbmdpZnkoe30pLCAvLyBjYWxsIHRoZSBmdW5jdGlvbiB3aXRoIGFuIGVtcHR5IG9iamVjdFxuICAgICAgZGVwZW5kc09uLFxuICAgIH0pO1xuXG4gICAgZm9yIChjb25zdCBjIG9mIHByb3BzLmV4ZWN1dGVCZWZvcmUgPz8gW10pIHtcbiAgICAgIC8vIGFkZCB0aGUgaW52b2NhdGlvbiBhcyBhIGRlcGVuZGVuY3kgb24gYWxsIG9mIHRoZSBjaGlsZHJlbiBvZiB0aGUgY29uc3RydWN0XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGMubm9kZS5maW5kQWxsKCkpIHtcbiAgICAgICAgaWYgKGlzVGVycmFmb3JtUmVzb3VyY2UoY2hpbGQpKSB7XG4gICAgICAgICAgaWYgKGNoaWxkLmRlcGVuZHNPbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjaGlsZC5kZXBlbmRzT24gPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2hpbGQuZGVwZW5kc09uLnB1c2gobGFtYmRhSW52b2NhdGlvbi5mcW4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjLm5vZGUuYWRkRGVwZW5kZW5jeSh0aGlzKTtcbiAgICB9XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHB1YmxpYyBfdG9JbmZsaWdodCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBjb3JlLkluZmxpZ2h0Q2xpZW50LmZvcihcbiAgICAgIF9fZGlybmFtZS5yZXBsYWNlKFwidGFyZ2V0LXRmLWF3c1wiLCBcInNoYXJlZC1hd3NcIiksXG4gICAgICBfX2ZpbGVuYW1lLFxuICAgICAgXCJPbkRlcGxveUNsaWVudFwiLFxuICAgICAgW11cbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVGVycmFmb3JtRGVwZW5kYWJsZShcbiAgeDogSUNvbnN0cnVjdFxuKTogeCBpcyBJVGVycmFmb3JtRGVwZW5kYWJsZSAmIElDb25zdHJ1Y3Qge1xuICByZXR1cm4gXCJmcW5cIiBpbiB4O1xufVxuXG5mdW5jdGlvbiBpc1RlcnJhZm9ybVJlc291cmNlKFxuICB4OiBJQ29uc3RydWN0XG4pOiB4IGlzIElUZXJyYWZvcm1SZXNvdXJjZSAmIElDb25zdHJ1Y3Qge1xuICByZXR1cm4gXCJ0ZXJyYWZvcm1SZXNvdXJjZVR5cGVcIiBpbiB4O1xufVxuIl19