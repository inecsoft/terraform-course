"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Node = exports.SDK_SOURCE_MODULE = exports.CONNECTIONS_FILE_PATH = exports.APP_SYMBOL = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const constructs_1 = require("constructs");
const connections_1 = require("../core/connections");
const NODE_SYMBOL = Symbol.for("@winglang/sdk.std.Node");
exports.APP_SYMBOL = Symbol.for("@winglang/sdk.std.Node/app");
const ROOT_SYMBOL = Symbol.for("@winglang/sdk.std.Node/root");
exports.CONNECTIONS_FILE_PATH = "connections.json";
exports.SDK_SOURCE_MODULE = "@winglang/sdk";
/**
 * The internal node of a construct.
 */
class Node {
    /**
     * Marks a type as the root of the tree.
     * @param rootConstructor
     * @internal
     */
    static _markRoot(rootConstructor) {
        rootConstructor[ROOT_SYMBOL] = true;
    }
    /**
     * Return the internal construct node.
     */
    static of(construct) {
        let node = construct[NODE_SYMBOL];
        if (!node) {
            node = new Node(construct);
            construct[NODE_SYMBOL] = node;
        }
        return node;
    }
    constructor(construct) {
        this.construct = construct;
        this._constructsNode = construct.node;
        this._connections = connections_1.Connections.of(construct); // tree-unique instance
    }
    /**
     * Adds a connection between two constructs. A connection is a piece of
     * metadata describing how one construct is related to another construct.
     */
    addConnection(props) {
        this._connections.add(props);
    }
    // ---- constructs 10.x APIs ----
    // https://github.com/aws/constructs/blob/10.x/src/construct.ts
    /**
     * Returns the scope in which this construct is defined.
     *
     * The value is `undefined` at the root of the construct scope tree.
     */
    get scope() {
        return this._constructsNode.scope;
    }
    /**
     * The id of this construct within the current scope.
     *
     * This is a a scope-unique id. To obtain an app-unique id for this construct, use `addr`.
     */
    get id() {
        return this._constructsNode.id;
    }
    /**
     * The full, absolute path of this construct in the tree.
     *
     * Components are separated by '/'.
     */
    get path() {
        return this._constructsNode.path;
    }
    /**
     * Returns an opaque tree-unique address for this construct.
     *
     * Addresses are 42 characters hexadecimal strings. They begin with "c8"
     * followed by 40 lowercase hexadecimal characters (0-9a-f).
     *
     * Addresses are calculated using a SHA-1 of the components of the construct
     * path.
     *
     * To enable refactorings of construct trees, constructs with the ID `Default`
     * will be excluded from the calculation. In those cases constructs in the
     * same tree may have the same addreess.
     *
     * @example c83a2846e506bcc5f10682b564084bca2d275709ee
     */
    get addr() {
        return this._constructsNode.addr;
    }
    /**
     * Return a direct child by id, or undefined
     *
     * @param id Identifier of direct child
     * @returns the child if found, or undefined
     */
    tryFindChild(id) {
        return this._constructsNode.tryFindChild(id);
    }
    /**
     * Return a direct child by id
     *
     * Throws an error if the child is not found.
     *
     * @param id Identifier of direct child
     * @returns Child with the given id.
     */
    findChild(id) {
        return this._constructsNode.findChild(id);
    }
    /**
     * Returns the child construct that has the id `Default` or `Resource"`.
     * This is usually the construct that provides the bulk of the underlying functionality.
     * Useful for modifications of the underlying construct that are not available at the higher levels.
     *
     * @throws if there is more than one child
     * @returns a construct or undefined if there is no default child
     */
    get defaultChild() {
        return this._constructsNode.defaultChild;
    }
    /**
     * Override the defaultChild property.
     *
     * This should only be used in the cases where the correct
     * default child is not named 'Resource' or 'Default' as it
     * should be.
     *
     * If you set this to undefined, the default behavior of finding
     * the child named 'Resource' or 'Default' will be used.
     */
    set defaultChild(value) {
        this._constructsNode.defaultChild = value;
    }
    /**
     * All direct children of this construct.
     */
    get children() {
        return this._constructsNode.children;
    }
    /**
     * Return this construct and all of its children in the given order
     */
    findAll(order = constructs_1.ConstructOrder.PREORDER) {
        return this._constructsNode.findAll(order);
    }
    /**
     * This can be used to set contextual values.
     * Context must be set before any children are added, since children may consult context info during construction.
     * If the key already exists, it will be overridden.
     * @param key The context key
     * @param value The context value
     */
    setContext(key, value) {
        this._constructsNode.setContext(key, value);
    }
    /**
     * Retrieves a value from tree context if present. Otherwise, would throw an error.
     *
     * Context is usually initialized at the root, but can be overridden at any point in the tree.
     *
     * @param key The context key
     * @returns The context value or throws error if there is no context value for this key
     */
    getContext(key) {
        return this._constructsNode.getContext(key);
    }
    /**
     * Retrieves a value from tree context.
     *
     * Context is usually initialized at the root, but can be overridden at any point in the tree.
     *
     * @param key The context key
     * @returns The context value or `undefined` if there is no context value for this key.
     */
    tryGetContext(key) {
        return this._constructsNode.tryGetContext(key);
    }
    /**
     * An immutable array of metadata objects associated with this construct.
     * This can be used, for example, to implement support for deprecation notices, source mapping, etc.
     */
    get metadata() {
        return this._constructsNode.metadata;
    }
    /**
     * Adds a metadata entry to this construct.
     * Entries are arbitrary values and will also include a stack trace to allow tracing back to
     * the code location for when the entry was added. It can be used, for example, to include source
     * mapping in CloudFormation templates to improve diagnostics.
     *
     * @param type a string denoting the type of metadata
     * @param data the value of the metadata (can be a Token). If null/undefined, metadata will not be added.
     * @param options options
     */
    addMetadata(type, data, options = {}) {
        this._constructsNode.addMetadata(type, data, options);
    }
    /**
     * All parent scopes of this construct.
     *
     * @returns a list of parent scopes. The last element in the list will always
     * be the current construct and the first element will be the root of the
     * tree.
     */
    get scopes() {
        return this._constructsNode.scopes;
    }
    /**
     * Returns the root of the construct tree (the `cloud.App` object).
     *
     * Similar to `app`.
     *
     * @returns The root of the construct tree.
     */
    get root() {
        if (!this._root) {
            this._root = this.findRoot(this.construct);
        }
        return this._root;
    }
    /**
     * Returns the root of the construct tree (the `cloud.App` object).
     *
     * Similar to `root`.
     *
     * @returns The root of the construct tree.
     */
    get app() {
        if (!this._app) {
            this._app = this.findApp(this.construct);
        }
        return this._app;
    }
    /**
     * Returns true if this construct or the scopes in which it is defined are
     * locked.
     */
    get locked() {
        return this._constructsNode.locked;
    }
    /**
     * Add an ordering dependency on another construct.
     *
     * An `IDependable`
     */
    addDependency(...deps) {
        this._constructsNode.addDependency(...deps);
    }
    /**
     * Return all dependencies registered on this node (non-recursive).
     */
    get dependencies() {
        return this._constructsNode.dependencies;
    }
    /**
     * Remove the child with the given name, if present.
     *
     * @returns Whether a child with the given name was deleted.
     * @experimental
     */
    tryRemoveChild(childName) {
        return this._constructsNode.tryRemoveChild(childName);
    }
    /**
     * Adds a validation to this construct.
     *
     * When `node.validate()` is called, the `validate()` method will be called on
     * all validations and all errors will be returned.
     *
     * @param validation The validation object
     */
    addValidation(validation) {
        this._constructsNode.addValidation(validation);
    }
    /**
     * Validates this construct.
     *
     * Invokes the `validate()` method on all validations added through
     * `addValidation()`.
     *
     * @returns an array of validation error messages associated with this
     * construct.
     */
    validate() {
        return this._constructsNode.validate();
    }
    /**
     * Locks this construct from allowing more children to be added. After this
     * call, no more children can be added to this construct or to any children.
     */
    lock() {
        this._constructsNode.lock();
    }
    /**
     * Returns the root app.
     */
    findApp(scope) {
        if (isApp(scope)) {
            return scope;
        }
        if (!scope.node.scope) {
            throw new Error("Cannot find root app");
        }
        return this.findApp(scope.node.scope);
    }
    findRoot(scope) {
        if (isRoot(scope)) {
            return scope;
        }
        if (!scope.node.scope) {
            throw new Error("Cannot find root construct");
        }
        return this.findRoot(scope.node.scope);
    }
}
exports.Node = Node;
_a = JSII_RTTI_SYMBOL_1;
Node[_a] = { fqn: "@winglang/sdk.std.Node", version: "0.0.0" };
function isApp(x) {
    return x && x[exports.APP_SYMBOL];
}
function isRoot(x) {
    return x && x.constructor && x.constructor[ROOT_SYMBOL];
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zdGQvbm9kZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLDJDQU9vQjtBQUNwQixxREFBa0Q7QUFHbEQsTUFBTSxXQUFXLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDO0FBQzVDLFFBQUEsVUFBVSxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsNEJBQTRCLENBQUMsQ0FBQztBQUNuRSxNQUFNLFdBQVcsR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLDZCQUE2QixDQUFDLENBQUM7QUFFakQsUUFBQSxxQkFBcUIsR0FBRyxrQkFBa0IsQ0FBQztBQUMzQyxRQUFBLGlCQUFpQixHQUFHLGVBQWUsQ0FBQztBQUVqRDs7R0FFRztBQUNILE1BQWEsSUFBSTtJQUNmOzs7O09BSUc7SUFDSSxNQUFNLENBQUMsU0FBUyxDQUFDLGVBQW9CO1FBQzFDLGVBQWUsQ0FBQyxXQUFXLENBQUMsR0FBRyxJQUFJLENBQUM7SUFDdEMsQ0FBQztJQUVEOztPQUVHO0lBQ0ksTUFBTSxDQUFDLEVBQUUsQ0FBQyxTQUFxQjtRQUNwQyxJQUFJLElBQUksR0FBSSxTQUFpQixDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBRTNDLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUNWLElBQUksR0FBRyxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUMxQixTQUFpQixDQUFDLFdBQVcsQ0FBQyxHQUFHLElBQUksQ0FBQztRQUN6QyxDQUFDO1FBRUQsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBcURELFlBQXFDLFNBQXFCO1FBQXJCLGNBQVMsR0FBVCxTQUFTLENBQVk7UUFDeEQsSUFBSSxDQUFDLGVBQWUsR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDO1FBQ3RDLElBQUksQ0FBQyxZQUFZLEdBQUcseUJBQVcsQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUMs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LE9BQU8sQ0FBQyxLQUFpQjtRQUMvQixJQUFJLEtBQUssQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDO1lBQ2pCLE9BQU8sS0FBYSxDQUFDO1FBQ3ZCLENBQUM7UUFFRCxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztZQUN0QixNQUFNLElBQUksS0FBSyxDQUFDLHNCQUFzQixDQUFDLENBQUM7UUFDMUMsQ0FBQztRQUVELE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3hDLENBQUM7SUFFTyxRQUFRLENBQUMsS0FBaUI7UUFDaEMsSUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQztZQUNsQixPQUFPLEtBQUssQ0FBQztRQUNmLENBQUM7UUFFRCxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztZQUN0QixNQUFNLElBQUksS0FBSyxDQUFDLDRCQUE0QixDQUFDLENBQUM7UUFDaEQsQ0FBQztRQUVELE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3pDLENBQUM7O0FBM1lILG9CQTRZQzs7O0FBNEVELFNBQVMsS0FBSyxDQUFDLENBQU07SUFDbkIsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLGtCQUFVLENBQUMsQ0FBQztBQUM1QixDQUFDO0FBRUQsU0FBUyxNQUFNLENBQUMsQ0FBTTtJQUNwQixPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsV0FBVyxJQUFJLENBQUMsQ0FBQyxXQUFXLENBQUMsV0FBVyxDQUFDLENBQUM7QUFDMUQsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIElDb25zdHJ1Y3QsXG4gIE5vZGUgYXMgQ29uc3RydWN0c05vZGUsXG4gIENvbnN0cnVjdE9yZGVyLFxuICBJRGVwZW5kYWJsZSxcbiAgTWV0YWRhdGFPcHRpb25zLFxuICBJVmFsaWRhdGlvbixcbn0gZnJvbSBcImNvbnN0cnVjdHNcIjtcbmltcG9ydCB7IENvbm5lY3Rpb25zIH0gZnJvbSBcIi4uL2NvcmUvY29ubmVjdGlvbnNcIjtcbmltcG9ydCB7IFBhcmFtZXRlclJlZ2lzdHJhciB9IGZyb20gXCIuLi9wbGF0Zm9ybVwiO1xuXG5jb25zdCBOT0RFX1NZTUJPTCA9IFN5bWJvbC5mb3IoXCJAd2luZ2xhbmcvc2RrLnN0ZC5Ob2RlXCIpO1xuZXhwb3J0IGNvbnN0IEFQUF9TWU1CT0wgPSBTeW1ib2wuZm9yKFwiQHdpbmdsYW5nL3Nkay5zdGQuTm9kZS9hcHBcIik7XG5jb25zdCBST09UX1NZTUJPTCA9IFN5bWJvbC5mb3IoXCJAd2luZ2xhbmcvc2RrLnN0ZC5Ob2RlL3Jvb3RcIik7XG5cbmV4cG9ydCBjb25zdCBDT05ORUNUSU9OU19GSUxFX1BBVEggPSBcImNvbm5lY3Rpb25zLmpzb25cIjtcbmV4cG9ydCBjb25zdCBTREtfU09VUkNFX01PRFVMRSA9IFwiQHdpbmdsYW5nL3Nka1wiO1xuXG4vKipcbiAqIFRoZSBpbnRlcm5hbCBub2RlIG9mIGEgY29uc3RydWN0LlxuICovXG5leHBvcnQgY2xhc3MgTm9kZSB7XG4gIC8qKlxuICAgKiBNYXJrcyBhIHR5cGUgYXMgdGhlIHJvb3Qgb2YgdGhlIHRyZWUuXG4gICAqIEBwYXJhbSByb290Q29uc3RydWN0b3JcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIF9tYXJrUm9vdChyb290Q29uc3RydWN0b3I6IGFueSkge1xuICAgIHJvb3RDb25zdHJ1Y3RvcltST09UX1NZTUJPTF0gPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgaW50ZXJuYWwgY29uc3RydWN0IG5vZGUuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG9mKGNvbnN0cnVjdDogSUNvbnN0cnVjdCk6IE5vZGUge1xuICAgIGxldCBub2RlID0gKGNvbnN0cnVjdCBhcyBhbnkpW05PREVfU1lNQk9MXTtcblxuICAgIGlmICghbm9kZSkge1xuICAgICAgbm9kZSA9IG5ldyBOb2RlKGNvbnN0cnVjdCk7XG4gICAgICAoY29uc3RydWN0IGFzIGFueSlbTk9ERV9TWU1CT0xdID0gbm9kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaXRsZSBvZiB0aGUgY29uc3RydWN0IGZvciBkaXNwbGF5IHB1cnBvc2VzLlxuICAgKi9cbiAgcHVibGljIHRpdGxlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBEZXNjcmlwdGlvbiBvZiB0aGUgY29uc3RydWN0IGZvciBkaXNwbGF5IHB1cnBvc2VzLlxuICAgKi9cbiAgcHVibGljIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgc291cmNlIGZpbGUgb3IgbGlicmFyeSB3aGVyZSB0aGUgY29uc3RydWN0IHdhcyBkZWZpbmVkLlxuICAgKi9cbiAgcHVibGljIHNvdXJjZU1vZHVsZT86IHN0cmluZztcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgY29uc3RydWN0IHNob3VsZCBiZSBoaWRkZW4gYnkgZGVmYXVsdCBpbiB0cmVlIHZpc3VhbGl6YXRpb25zLlxuICAgKi9cbiAgcHVibGljIGhpZGRlbj86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFRoZSBjb2xvciBvZiB0aGUgY29uc3RydWN0IGZvciBkaXNwbGF5IHB1cnBvc2VzLlxuICAgKiBTdXBwb3J0ZWQgY29sb3JzIGFyZTpcbiAgICogLSBvcmFuZ2VcbiAgICogLSBza3lcbiAgICogLSBlbWVyYWxkXG4gICAqIC0gbGltZVxuICAgKiAtIHBpbmtcbiAgICogLSBhbWJlclxuICAgKiAtIGN5YW5cbiAgICogLSBwdXJwbGVcbiAgICogLSByZWRcbiAgICogLSB2aW9sZXRcbiAgICogLSBzbGF0ZVxuICAgKi9cbiAgcHVibGljIGNvbG9yPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgaWNvbiBvZiB0aGUgY29uc3RydWN0IGZvciBkaXNwbGF5IHB1cnBvc2VzLlxuICAgKiBTdXBwb3J0ZWQgaWNvbnMgYXJlIGZyb20gSGVyb2ljb25zOlxuICAgKiAtIGh0dHBzOi8vaGVyb2ljb25zLmNvbS9cbiAgICogZS5nLlxuICAgKiAtIFwiYWNhZGVtaWMtY2FwXCJcbiAgICovXG4gIHB1YmxpYyBpY29uPzogc3RyaW5nO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgX2NvbnN0cnVjdHNOb2RlOiBDb25zdHJ1Y3RzTm9kZTtcbiAgcHJpdmF0ZSByZWFkb25seSBfY29ubmVjdGlvbnM6IENvbm5lY3Rpb25zO1xuICBwcml2YXRlIF9hcHA6IElBcHAgfCB1bmRlZmluZWQ7XG4gIHByaXZhdGUgX3Jvb3Q6IElDb25zdHJ1Y3QgfCB1bmRlZmluZWQ7XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IGNvbnN0cnVjdDogSUNvbnN0cnVjdCkge1xuICAgIHRoaXMuX2NvbnN0cnVjdHNOb2RlID0gY29uc3RydWN0Lm5vZGU7XG4gICAgdGhpcy5fY29ubmVjdGlvbnMgPSBDb25uZWN0aW9ucy5vZihjb25zdHJ1Y3QpOyAvLyB0cmVlLXVuaXF1ZSBpbnN0YW5jZVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBjb25uZWN0aW9uIGJldHdlZW4gdHdvIGNvbnN0cnVjdHMuIEEgY29ubmVjdGlvbiBpcyBhIHBpZWNlIG9mXG4gICAqIG1ldGFkYXRhIGRlc2NyaWJpbmcgaG93IG9uZSBjb25zdHJ1Y3QgaXMgcmVsYXRlZCB0byBhbm90aGVyIGNvbnN0cnVjdC5cbiAgICovXG4gIHB1YmxpYyBhZGRDb25uZWN0aW9uKHByb3BzOiBBZGRDb25uZWN0aW9uUHJvcHMpIHtcbiAgICB0aGlzLl9jb25uZWN0aW9ucy5hZGQocHJvcHMpO1xuICB9XG5cbiAgLy8gLS0tLSBjb25zdHJ1Y3RzIDEwLnggQVBJcyAtLS0tXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvY29uc3RydWN0cy9ibG9iLzEwLngvc3JjL2NvbnN0cnVjdC50c1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzY29wZSBpbiB3aGljaCB0aGlzIGNvbnN0cnVjdCBpcyBkZWZpbmVkLlxuICAgKlxuICAgKiBUaGUgdmFsdWUgaXMgYHVuZGVmaW5lZGAgYXQgdGhlIHJvb3Qgb2YgdGhlIGNvbnN0cnVjdCBzY29wZSB0cmVlLlxuICAgKi9cbiAgcHVibGljIGdldCBzY29wZSgpOiBJQ29uc3RydWN0IHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5fY29uc3RydWN0c05vZGUuc2NvcGU7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGlkIG9mIHRoaXMgY29uc3RydWN0IHdpdGhpbiB0aGUgY3VycmVudCBzY29wZS5cbiAgICpcbiAgICogVGhpcyBpcyBhIGEgc2NvcGUtdW5pcXVlIGlkLiBUbyBvYnRhaW4gYW4gYXBwLXVuaXF1ZSBpZCBmb3IgdGhpcyBjb25zdHJ1Y3QsIHVzZSBgYWRkcmAuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGlkKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnN0cnVjdHNOb2RlLmlkO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBmdWxsLCBhYnNvbHV0ZSBwYXRoIG9mIHRoaXMgY29uc3RydWN0IGluIHRoZSB0cmVlLlxuICAgKlxuICAgKiBDb21wb25lbnRzIGFyZSBzZXBhcmF0ZWQgYnkgJy8nLlxuICAgKi9cbiAgcHVibGljIGdldCBwYXRoKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnN0cnVjdHNOb2RlLnBhdGg7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBvcGFxdWUgdHJlZS11bmlxdWUgYWRkcmVzcyBmb3IgdGhpcyBjb25zdHJ1Y3QuXG4gICAqXG4gICAqIEFkZHJlc3NlcyBhcmUgNDIgY2hhcmFjdGVycyBoZXhhZGVjaW1hbCBzdHJpbmdzLiBUaGV5IGJlZ2luIHdpdGggXCJjOFwiXG4gICAqIGZvbGxvd2VkIGJ5IDQwIGxvd2VyY2FzZSBoZXhhZGVjaW1hbCBjaGFyYWN0ZXJzICgwLTlhLWYpLlxuICAgKlxuICAgKiBBZGRyZXNzZXMgYXJlIGNhbGN1bGF0ZWQgdXNpbmcgYSBTSEEtMSBvZiB0aGUgY29tcG9uZW50cyBvZiB0aGUgY29uc3RydWN0XG4gICAqIHBhdGguXG4gICAqXG4gICAqIFRvIGVuYWJsZSByZWZhY3RvcmluZ3Mgb2YgY29uc3RydWN0IHRyZWVzLCBjb25zdHJ1Y3RzIHdpdGggdGhlIElEIGBEZWZhdWx0YFxuICAgKiB3aWxsIGJlIGV4Y2x1ZGVkIGZyb20gdGhlIGNhbGN1bGF0aW9uLiBJbiB0aG9zZSBjYXNlcyBjb25zdHJ1Y3RzIGluIHRoZVxuICAgKiBzYW1lIHRyZWUgbWF5IGhhdmUgdGhlIHNhbWUgYWRkcmVlc3MuXG4gICAqXG4gICAqIEBleGFtcGxlIGM4M2EyODQ2ZTUwNmJjYzVmMTA2ODJiNTY0MDg0YmNhMmQyNzU3MDllZVxuICAgKi9cbiAgcHVibGljIGdldCBhZGRyKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnN0cnVjdHNOb2RlLmFkZHI7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgZGlyZWN0IGNoaWxkIGJ5IGlkLCBvciB1bmRlZmluZWRcbiAgICpcbiAgICogQHBhcmFtIGlkIElkZW50aWZpZXIgb2YgZGlyZWN0IGNoaWxkXG4gICAqIEByZXR1cm5zIHRoZSBjaGlsZCBpZiBmb3VuZCwgb3IgdW5kZWZpbmVkXG4gICAqL1xuICBwdWJsaWMgdHJ5RmluZENoaWxkKGlkOiBzdHJpbmcpOiBJQ29uc3RydWN0IHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5fY29uc3RydWN0c05vZGUudHJ5RmluZENoaWxkKGlkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBkaXJlY3QgY2hpbGQgYnkgaWRcbiAgICpcbiAgICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBjaGlsZCBpcyBub3QgZm91bmQuXG4gICAqXG4gICAqIEBwYXJhbSBpZCBJZGVudGlmaWVyIG9mIGRpcmVjdCBjaGlsZFxuICAgKiBAcmV0dXJucyBDaGlsZCB3aXRoIHRoZSBnaXZlbiBpZC5cbiAgICovXG4gIHB1YmxpYyBmaW5kQ2hpbGQoaWQ6IHN0cmluZyk6IElDb25zdHJ1Y3Qge1xuICAgIHJldHVybiB0aGlzLl9jb25zdHJ1Y3RzTm9kZS5maW5kQ2hpbGQoaWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNoaWxkIGNvbnN0cnVjdCB0aGF0IGhhcyB0aGUgaWQgYERlZmF1bHRgIG9yIGBSZXNvdXJjZVwiYC5cbiAgICogVGhpcyBpcyB1c3VhbGx5IHRoZSBjb25zdHJ1Y3QgdGhhdCBwcm92aWRlcyB0aGUgYnVsayBvZiB0aGUgdW5kZXJseWluZyBmdW5jdGlvbmFsaXR5LlxuICAgKiBVc2VmdWwgZm9yIG1vZGlmaWNhdGlvbnMgb2YgdGhlIHVuZGVybHlpbmcgY29uc3RydWN0IHRoYXQgYXJlIG5vdCBhdmFpbGFibGUgYXQgdGhlIGhpZ2hlciBsZXZlbHMuXG4gICAqXG4gICAqIEB0aHJvd3MgaWYgdGhlcmUgaXMgbW9yZSB0aGFuIG9uZSBjaGlsZFxuICAgKiBAcmV0dXJucyBhIGNvbnN0cnVjdCBvciB1bmRlZmluZWQgaWYgdGhlcmUgaXMgbm8gZGVmYXVsdCBjaGlsZFxuICAgKi9cbiAgcHVibGljIGdldCBkZWZhdWx0Q2hpbGQoKTogSUNvbnN0cnVjdCB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnN0cnVjdHNOb2RlLmRlZmF1bHRDaGlsZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSB0aGUgZGVmYXVsdENoaWxkIHByb3BlcnR5LlxuICAgKlxuICAgKiBUaGlzIHNob3VsZCBvbmx5IGJlIHVzZWQgaW4gdGhlIGNhc2VzIHdoZXJlIHRoZSBjb3JyZWN0XG4gICAqIGRlZmF1bHQgY2hpbGQgaXMgbm90IG5hbWVkICdSZXNvdXJjZScgb3IgJ0RlZmF1bHQnIGFzIGl0XG4gICAqIHNob3VsZCBiZS5cbiAgICpcbiAgICogSWYgeW91IHNldCB0aGlzIHRvIHVuZGVmaW5lZCwgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgZmluZGluZ1xuICAgKiB0aGUgY2hpbGQgbmFtZWQgJ1Jlc291cmNlJyBvciAnRGVmYXVsdCcgd2lsbCBiZSB1c2VkLlxuICAgKi9cbiAgcHVibGljIHNldCBkZWZhdWx0Q2hpbGQodmFsdWU6IElDb25zdHJ1Y3QgfCB1bmRlZmluZWQpIHtcbiAgICB0aGlzLl9jb25zdHJ1Y3RzTm9kZS5kZWZhdWx0Q2hpbGQgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGwgZGlyZWN0IGNoaWxkcmVuIG9mIHRoaXMgY29uc3RydWN0LlxuICAgKi9cbiAgcHVibGljIGdldCBjaGlsZHJlbigpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uc3RydWN0c05vZGUuY2hpbGRyZW47XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoaXMgY29uc3RydWN0IGFuZCBhbGwgb2YgaXRzIGNoaWxkcmVuIGluIHRoZSBnaXZlbiBvcmRlclxuICAgKi9cbiAgcHVibGljIGZpbmRBbGwoXG4gICAgb3JkZXI6IENvbnN0cnVjdE9yZGVyID0gQ29uc3RydWN0T3JkZXIuUFJFT1JERVJcbiAgKTogSUNvbnN0cnVjdFtdIHtcbiAgICByZXR1cm4gdGhpcy5fY29uc3RydWN0c05vZGUuZmluZEFsbChvcmRlcik7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBzZXQgY29udGV4dHVhbCB2YWx1ZXMuXG4gICAqIENvbnRleHQgbXVzdCBiZSBzZXQgYmVmb3JlIGFueSBjaGlsZHJlbiBhcmUgYWRkZWQsIHNpbmNlIGNoaWxkcmVuIG1heSBjb25zdWx0IGNvbnRleHQgaW5mbyBkdXJpbmcgY29uc3RydWN0aW9uLlxuICAgKiBJZiB0aGUga2V5IGFscmVhZHkgZXhpc3RzLCBpdCB3aWxsIGJlIG92ZXJyaWRkZW4uXG4gICAqIEBwYXJhbSBrZXkgVGhlIGNvbnRleHQga2V5XG4gICAqIEBwYXJhbSB2YWx1ZSBUaGUgY29udGV4dCB2YWx1ZVxuICAgKi9cbiAgcHVibGljIHNldENvbnRleHQoa2V5OiBzdHJpbmcsIHZhbHVlOiBhbnkpIHtcbiAgICB0aGlzLl9jb25zdHJ1Y3RzTm9kZS5zZXRDb250ZXh0KGtleSwgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhIHZhbHVlIGZyb20gdHJlZSBjb250ZXh0IGlmIHByZXNlbnQuIE90aGVyd2lzZSwgd291bGQgdGhyb3cgYW4gZXJyb3IuXG4gICAqXG4gICAqIENvbnRleHQgaXMgdXN1YWxseSBpbml0aWFsaXplZCBhdCB0aGUgcm9vdCwgYnV0IGNhbiBiZSBvdmVycmlkZGVuIGF0IGFueSBwb2ludCBpbiB0aGUgdHJlZS5cbiAgICpcbiAgICogQHBhcmFtIGtleSBUaGUgY29udGV4dCBrZXlcbiAgICogQHJldHVybnMgVGhlIGNvbnRleHQgdmFsdWUgb3IgdGhyb3dzIGVycm9yIGlmIHRoZXJlIGlzIG5vIGNvbnRleHQgdmFsdWUgZm9yIHRoaXMga2V5XG4gICAqL1xuICBwdWJsaWMgZ2V0Q29udGV4dChrZXk6IHN0cmluZyk6IGFueSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnN0cnVjdHNOb2RlLmdldENvbnRleHQoa2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYSB2YWx1ZSBmcm9tIHRyZWUgY29udGV4dC5cbiAgICpcbiAgICogQ29udGV4dCBpcyB1c3VhbGx5IGluaXRpYWxpemVkIGF0IHRoZSByb290LCBidXQgY2FuIGJlIG92ZXJyaWRkZW4gYXQgYW55IHBvaW50IGluIHRoZSB0cmVlLlxuICAgKlxuICAgKiBAcGFyYW0ga2V5IFRoZSBjb250ZXh0IGtleVxuICAgKiBAcmV0dXJucyBUaGUgY29udGV4dCB2YWx1ZSBvciBgdW5kZWZpbmVkYCBpZiB0aGVyZSBpcyBubyBjb250ZXh0IHZhbHVlIGZvciB0aGlzIGtleS5cbiAgICovXG4gIHB1YmxpYyB0cnlHZXRDb250ZXh0KGtleTogc3RyaW5nKTogYW55IHtcbiAgICByZXR1cm4gdGhpcy5fY29uc3RydWN0c05vZGUudHJ5R2V0Q29udGV4dChrZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFuIGltbXV0YWJsZSBhcnJheSBvZiBtZXRhZGF0YSBvYmplY3RzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNvbnN0cnVjdC5cbiAgICogVGhpcyBjYW4gYmUgdXNlZCwgZm9yIGV4YW1wbGUsIHRvIGltcGxlbWVudCBzdXBwb3J0IGZvciBkZXByZWNhdGlvbiBub3RpY2VzLCBzb3VyY2UgbWFwcGluZywgZXRjLlxuICAgKi9cbiAgcHVibGljIGdldCBtZXRhZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uc3RydWN0c05vZGUubWV0YWRhdGE7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIG1ldGFkYXRhIGVudHJ5IHRvIHRoaXMgY29uc3RydWN0LlxuICAgKiBFbnRyaWVzIGFyZSBhcmJpdHJhcnkgdmFsdWVzIGFuZCB3aWxsIGFsc28gaW5jbHVkZSBhIHN0YWNrIHRyYWNlIHRvIGFsbG93IHRyYWNpbmcgYmFjayB0b1xuICAgKiB0aGUgY29kZSBsb2NhdGlvbiBmb3Igd2hlbiB0aGUgZW50cnkgd2FzIGFkZGVkLiBJdCBjYW4gYmUgdXNlZCwgZm9yIGV4YW1wbGUsIHRvIGluY2x1ZGUgc291cmNlXG4gICAqIG1hcHBpbmcgaW4gQ2xvdWRGb3JtYXRpb24gdGVtcGxhdGVzIHRvIGltcHJvdmUgZGlhZ25vc3RpY3MuXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlIGEgc3RyaW5nIGRlbm90aW5nIHRoZSB0eXBlIG9mIG1ldGFkYXRhXG4gICAqIEBwYXJhbSBkYXRhIHRoZSB2YWx1ZSBvZiB0aGUgbWV0YWRhdGEgKGNhbiBiZSBhIFRva2VuKS4gSWYgbnVsbC91bmRlZmluZWQsIG1ldGFkYXRhIHdpbGwgbm90IGJlIGFkZGVkLlxuICAgKiBAcGFyYW0gb3B0aW9ucyBvcHRpb25zXG4gICAqL1xuICBwdWJsaWMgYWRkTWV0YWRhdGEoXG4gICAgdHlwZTogc3RyaW5nLFxuICAgIGRhdGE6IGFueSxcbiAgICBvcHRpb25zOiBNZXRhZGF0YU9wdGlvbnMgPSB7fVxuICApOiB2b2lkIHtcbiAgICB0aGlzLl9jb25zdHJ1Y3RzTm9kZS5hZGRNZXRhZGF0YSh0eXBlLCBkYXRhLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGwgcGFyZW50IHNjb3BlcyBvZiB0aGlzIGNvbnN0cnVjdC5cbiAgICpcbiAgICogQHJldHVybnMgYSBsaXN0IG9mIHBhcmVudCBzY29wZXMuIFRoZSBsYXN0IGVsZW1lbnQgaW4gdGhlIGxpc3Qgd2lsbCBhbHdheXNcbiAgICogYmUgdGhlIGN1cnJlbnQgY29uc3RydWN0IGFuZCB0aGUgZmlyc3QgZWxlbWVudCB3aWxsIGJlIHRoZSByb290IG9mIHRoZVxuICAgKiB0cmVlLlxuICAgKi9cbiAgcHVibGljIGdldCBzY29wZXMoKTogSUNvbnN0cnVjdFtdIHtcbiAgICByZXR1cm4gdGhpcy5fY29uc3RydWN0c05vZGUuc2NvcGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJvb3Qgb2YgdGhlIGNvbnN0cnVjdCB0cmVlICh0aGUgYGNsb3VkLkFwcGAgb2JqZWN0KS5cbiAgICpcbiAgICogU2ltaWxhciB0byBgYXBwYC5cbiAgICpcbiAgICogQHJldHVybnMgVGhlIHJvb3Qgb2YgdGhlIGNvbnN0cnVjdCB0cmVlLlxuICAgKi9cbiAgcHVibGljIGdldCByb290KCk6IElDb25zdHJ1Y3Qge1xuICAgIGlmICghdGhpcy5fcm9vdCkge1xuICAgICAgdGhpcy5fcm9vdCA9IHRoaXMuZmluZFJvb3QodGhpcy5jb25zdHJ1Y3QpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yb290O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJvb3Qgb2YgdGhlIGNvbnN0cnVjdCB0cmVlICh0aGUgYGNsb3VkLkFwcGAgb2JqZWN0KS5cbiAgICpcbiAgICogU2ltaWxhciB0byBgcm9vdGAuXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSByb290IG9mIHRoZSBjb25zdHJ1Y3QgdHJlZS5cbiAgICovXG4gIHB1YmxpYyBnZXQgYXBwKCk6IElBcHAge1xuICAgIGlmICghdGhpcy5fYXBwKSB7XG4gICAgICB0aGlzLl9hcHAgPSB0aGlzLmZpbmRBcHAodGhpcy5jb25zdHJ1Y3QpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9hcHA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgY29uc3RydWN0IG9yIHRoZSBzY29wZXMgaW4gd2hpY2ggaXQgaXMgZGVmaW5lZCBhcmVcbiAgICogbG9ja2VkLlxuICAgKi9cbiAgcHVibGljIGdldCBsb2NrZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnN0cnVjdHNOb2RlLmxvY2tlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYW4gb3JkZXJpbmcgZGVwZW5kZW5jeSBvbiBhbm90aGVyIGNvbnN0cnVjdC5cbiAgICpcbiAgICogQW4gYElEZXBlbmRhYmxlYFxuICAgKi9cbiAgcHVibGljIGFkZERlcGVuZGVuY3koLi4uZGVwczogSURlcGVuZGFibGVbXSkge1xuICAgIHRoaXMuX2NvbnN0cnVjdHNOb2RlLmFkZERlcGVuZGVuY3koLi4uZGVwcyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFsbCBkZXBlbmRlbmNpZXMgcmVnaXN0ZXJlZCBvbiB0aGlzIG5vZGUgKG5vbi1yZWN1cnNpdmUpLlxuICAgKi9cbiAgcHVibGljIGdldCBkZXBlbmRlbmNpZXMoKTogSUNvbnN0cnVjdFtdIHtcbiAgICByZXR1cm4gdGhpcy5fY29uc3RydWN0c05vZGUuZGVwZW5kZW5jaWVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgY2hpbGQgd2l0aCB0aGUgZ2l2ZW4gbmFtZSwgaWYgcHJlc2VudC5cbiAgICpcbiAgICogQHJldHVybnMgV2hldGhlciBhIGNoaWxkIHdpdGggdGhlIGdpdmVuIG5hbWUgd2FzIGRlbGV0ZWQuXG4gICAqIEBleHBlcmltZW50YWxcbiAgICovXG4gIHB1YmxpYyB0cnlSZW1vdmVDaGlsZChjaGlsZE5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9jb25zdHJ1Y3RzTm9kZS50cnlSZW1vdmVDaGlsZChjaGlsZE5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSB2YWxpZGF0aW9uIHRvIHRoaXMgY29uc3RydWN0LlxuICAgKlxuICAgKiBXaGVuIGBub2RlLnZhbGlkYXRlKClgIGlzIGNhbGxlZCwgdGhlIGB2YWxpZGF0ZSgpYCBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgb25cbiAgICogYWxsIHZhbGlkYXRpb25zIGFuZCBhbGwgZXJyb3JzIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqXG4gICAqIEBwYXJhbSB2YWxpZGF0aW9uIFRoZSB2YWxpZGF0aW9uIG9iamVjdFxuICAgKi9cbiAgcHVibGljIGFkZFZhbGlkYXRpb24odmFsaWRhdGlvbjogSVZhbGlkYXRpb24pIHtcbiAgICB0aGlzLl9jb25zdHJ1Y3RzTm9kZS5hZGRWYWxpZGF0aW9uKHZhbGlkYXRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB0aGlzIGNvbnN0cnVjdC5cbiAgICpcbiAgICogSW52b2tlcyB0aGUgYHZhbGlkYXRlKClgIG1ldGhvZCBvbiBhbGwgdmFsaWRhdGlvbnMgYWRkZWQgdGhyb3VnaFxuICAgKiBgYWRkVmFsaWRhdGlvbigpYC5cbiAgICpcbiAgICogQHJldHVybnMgYW4gYXJyYXkgb2YgdmFsaWRhdGlvbiBlcnJvciBtZXNzYWdlcyBhc3NvY2lhdGVkIHdpdGggdGhpc1xuICAgKiBjb25zdHJ1Y3QuXG4gICAqL1xuICBwdWJsaWMgdmFsaWRhdGUoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiB0aGlzLl9jb25zdHJ1Y3RzTm9kZS52YWxpZGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIExvY2tzIHRoaXMgY29uc3RydWN0IGZyb20gYWxsb3dpbmcgbW9yZSBjaGlsZHJlbiB0byBiZSBhZGRlZC4gQWZ0ZXIgdGhpc1xuICAgKiBjYWxsLCBubyBtb3JlIGNoaWxkcmVuIGNhbiBiZSBhZGRlZCB0byB0aGlzIGNvbnN0cnVjdCBvciB0byBhbnkgY2hpbGRyZW4uXG4gICAqL1xuICBwdWJsaWMgbG9jaygpIHtcbiAgICB0aGlzLl9jb25zdHJ1Y3RzTm9kZS5sb2NrKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcm9vdCBhcHAuXG4gICAqL1xuICBwcml2YXRlIGZpbmRBcHAoc2NvcGU6IElDb25zdHJ1Y3QpOiBJQXBwIHtcbiAgICBpZiAoaXNBcHAoc2NvcGUpKSB7XG4gICAgICByZXR1cm4gc2NvcGUgYXMgSUFwcDtcbiAgICB9XG5cbiAgICBpZiAoIXNjb3BlLm5vZGUuc2NvcGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIHJvb3QgYXBwXCIpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZpbmRBcHAoc2NvcGUubm9kZS5zY29wZSk7XG4gIH1cblxuICBwcml2YXRlIGZpbmRSb290KHNjb3BlOiBJQ29uc3RydWN0KTogSUNvbnN0cnVjdCB7XG4gICAgaWYgKGlzUm9vdChzY29wZSkpIHtcbiAgICAgIHJldHVybiBzY29wZTtcbiAgICB9XG5cbiAgICBpZiAoIXNjb3BlLm5vZGUuc2NvcGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIHJvb3QgY29uc3RydWN0XCIpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZpbmRSb290KHNjb3BlLm5vZGUuc2NvcGUpO1xuICB9XG59XG5cbi8qKlxuICogUHJvcHMgZm9yIGBOb2RlLmFkZENvbm5lY3Rpb25gLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEFkZENvbm5lY3Rpb25Qcm9wcyB7XG4gIC8qKlxuICAgKiBUaGUgc291cmNlIG9mIHRoZSBjb25uZWN0aW9uLlxuICAgKi9cbiAgcmVhZG9ubHkgc291cmNlOiBJQ29uc3RydWN0O1xuXG4gIC8qKlxuICAgKiBBbiBvcGVyYXRpb24gdGhhdCB0aGUgc291cmNlIGNvbnN0cnVjdCBzdXBwb3J0cy5cbiAgICogQGRlZmF1bHQgLSBubyBvcGVyYXRpb25cbiAgICovXG4gIHJlYWRvbmx5IHNvdXJjZU9wPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgdGFyZ2V0IG9mIHRoZSBjb25uZWN0aW9uLlxuICAgKi9cbiAgcmVhZG9ubHkgdGFyZ2V0OiBJQ29uc3RydWN0O1xuXG4gIC8qKlxuICAgKiBBbiBvcGVyYXRpb24gdGhhdCB0aGUgdGFyZ2V0IGNvbnN0cnVjdCBzdXBwb3J0cy5cbiAgICogQGRlZmF1bHQgLSBubyBvcGVyYXRpb25cbiAgICovXG4gIHJlYWRvbmx5IHRhcmdldE9wPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBIG5hbWUgZm9yIHRoZSBjb25uZWN0aW9uLlxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBXaW5nIGFwcGxpY2F0aW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIElBcHAgZXh0ZW5kcyBJQ29uc3RydWN0IHtcbiAgLyoqXG4gICAqIFR5cGUgbWFya2VyLlxuICAgKiBAaW50ZXJuYWxcbiAgICoqL1xuICByZWFkb25seSBbQVBQX1NZTUJPTF06IHRydWU7XG5cbiAgLyoqXG4gICAqIFRoZSBgLndpbmdgIGRpcmVjdG9yeSBpbnRvIHdoaWNoIHlvdSBjYW4gZW1pdCBhcnRpZmFjdHMgZHVyaW5nIHByZWZsaWdodC5cbiAgICovXG4gIHJlYWRvbmx5IHdvcmtkaXI6IHN0cmluZztcblxuICAvKipcbiAgICogYHRydWVgIGlmIHRoaXMgaXMgYSB0ZXN0aW5nIGVudmlyb25tZW50XG4gICAqL1xuICByZWFkb25seSBpc1Rlc3RFbnZpcm9ubWVudDogYm9vbGVhbjtcblxuICAvKipcbiAgICogVGhlIGRpcmVjdG9yeSBvZiB0aGUgZW50cnlwb2ludCBvZiB0aGUgY3VycmVudCBwcm9ncmFtLlxuICAgKi9cbiAgcmVhZG9ubHkgZW50cnlwb2ludERpcjogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgYXBwbGljYXRpb24ncyBwYXJhbWV0ZXIgcmVnaXN0cmFyXG4gICAqL1xuICByZWFkb25seSBwYXJhbWV0ZXJzOiBQYXJhbWV0ZXJSZWdpc3RyYXI7XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdW5pcXVlIElEIGZvciB0aGUgZ2l2ZW4gc2NvcGUgYW5kIHByZWZpeC4gVGhlIG5ld2x5IGdlbmVyYXRlZCBJRCBpc1xuICAgKiBndWFyYW50ZWVkIHRvIGJlIHVuaXF1ZSB3aXRoaW4gdGhlIGdpdmVuIHNjb3BlLlxuICAgKiBJdCB3aWxsIGhhdmUgdGhlIGZvcm0gJ3twcmVmaXh9e259Jywgd2hlcmUgJ3twcmVmaXh9JyBpcyB0aGUgZ2l2ZW4gcHJlZml4IGFuZCAne259JyBpcyBhblxuICAgKiBhc2NlbmRpbmcgc2VxdWVuY2Ugb2YgaW50ZWdlcnMgc3RhcnRpbmcgZnJvbSAnMCcuXG4gICAqXG4gICAqIEBwYXJhbSBzY29wZSB0byBndWFyYW50ZWUgdW5pcXVlbmVzcyBpblxuICAgKiBAcGFyYW0gcHJlZml4IHByZXBlbmRlZCB0byB0aGUgdW5pcXVlIGlkZW50aWZpZXJcbiAgICovXG4gIG1ha2VJZChzY29wZTogSUNvbnN0cnVjdCwgcHJlZml4Pzogc3RyaW5nKTogc3RyaW5nO1xufVxuXG5mdW5jdGlvbiBpc0FwcCh4OiBhbnkpOiB4IGlzIElBcHAge1xuICByZXR1cm4geCAmJiB4W0FQUF9TWU1CT0xdO1xufVxuXG5mdW5jdGlvbiBpc1Jvb3QoeDogYW55KTogYm9vbGVhbiB7XG4gIHJldHVybiB4ICYmIHguY29uc3RydWN0b3IgJiYgeC5jb25zdHJ1Y3RvcltST09UX1NZTUJPTF07XG59XG4iXX0=