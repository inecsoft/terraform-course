"use strict";
var _a, _b;
Object.defineProperty(exports, "__esModule", { value: true });
exports.MutArray = exports.Array = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const core_1 = require("../core");
/**
 * Immutable Array
 *
 * @typeparam T1
 */
class Array {
    /**
     * @internal
     */
    static _toInflightType() {
        return core_1.InflightClient.forType(__filename, this.name);
    }
    constructor() { }
    /**
     * The length of the array
     * @returns the length of the array
     */
    get length() {
        throw new Error("Abstract");
    }
    /**
     * Get the value at the given index
     * @macro ((arr, index) => { if (index < 0 || index >= arr.length) throw new Error("Index out of bounds"); return arr[index]; })($self$, $args$)
     * @param index index of the value to get
     * @returns the value at the given index
     */
    at(index) {
        index;
        throw new Error("Macro");
    }
    /**
     * Get the value at the given index, returning nil if the index is out of bounds.
     *
     * @macro $self$.at($args$)
     *
     * @param index index of the value to get
     * @returns the value at the given index, or undefined if the index is out of bounds
     */
    tryAt(index) {
        index;
        throw new Error("Macro");
    }
    /**
     * Merge arr to the end of this array
     * @param arr array to merge
     *
     * @returns a new ImmutableArray with the values of this array followed by the values of arr
     */
    concat(arr) {
        arr;
        throw new Error("Abstract");
    }
    /**
     * Checks if this array includes searchElement.
     *
     * @macro $self$.includes($args$)
     *
     * @param searchElement to search for.
     * @returns true if this array includes searchElement.
     */
    contains(searchElement) {
        searchElement;
        throw new Error("Macro");
    }
    /**
     * Create a mutable shallow copy of this array
     *
     * @macro [...($self$)]
     *
     * @returns a MutableArray with the same values as this array
     */
    copyMut() {
        throw new Error("Macro");
    }
    /**
     * Returns the index of the first occurrence of searchElement found.
     *
     * @macro $self$.indexOf($args$)
     *
     * @param searchElement to search for.
     * @returns the index of the first occurrence of searchElement found, or -1 if not found.
     */
    indexOf(searchElement) {
        searchElement;
        throw new Error("Macro");
    }
    /**
     * Returns a new string containing the concatenated values in this array,
     * separated by commas or a specified separator string. If the array has only
     * one item, then that item will be returned without using the separator.
     *
     * @returns a string containing the concatenated values in this array,
     * separated by commas or a specified separator string.
     */
    join(separator) {
        separator;
        throw new Error("Abstract");
    }
    /**
     * Returns the index of the last occurrence of searchElement found.
     *
     * @macro $self$.lastIndexOf($args$)
     *
     * @param searchElement to search for.
     * @returns the index of the last occurrence of searchElement found, or -1 if not found.
     */
    lastIndexOf(searchElement) {
        searchElement;
        throw new Error("Macro");
    }
    /**
     * Returns a shallow copy of a portion of the array.
     *
     * @macro $self$.slice($args$)
     *
     * @param start the beginning index of the slice, inclusive.
     * @param end the ending index of the slice, exclusive.
     * @returns a new array containing the sliced elements.
     */
    slice(start, end) {
        start;
        end;
        throw new Error("Macro");
    }
}
exports.Array = Array;
_a = JSII_RTTI_SYMBOL_1;
Array[_a] = { fqn: "@winglang/sdk.std.Array", version: "0.0.0" };
/**
 * Mutable Array
 *
 * @typeparam T1
 */
class MutArray {
    /**
     * @internal
     */
    static _toInflightType() {
        return core_1.InflightClient.forType(__filename, this.name);
    }
    constructor() { }
    /**
     * The length of the array
     * @returns the length of the array
     */
    get length() {
        throw new Error("Abstract");
    }
    /**
     * Get the value at the given index
     * @macro ((arr, index) => { if (index < 0 || index >= arr.length) throw new Error("Index out of bounds"); return arr[index]; })($self$, $args$)
     * @param index index of the value to get
     * @returns the value at the given index
     */
    at(index) {
        index;
        throw new Error("Macro");
    }
    /**
     * Merge arr to the end of this array
     * @param arr array to merge
     *
     * @returns a new MutableArray with the values of this array followed by the values of arr
     */
    concat(arr) {
        arr;
        throw new Error("Abstract");
    }
    /**
     * Checks if this array includes searchElement.
     *
     * @macro $self$.includes($args$)
     *
     * @param searchElement to search for.
     * @returns true if this array includes searchElement.
     */
    contains(searchElement) {
        searchElement;
        throw new Error("Macro");
    }
    /**
     * Create an immutable shallow copy of this array
     *
     * @macro [...($self$)]
     *
     * @returns an ImmutableArray with the same values as this array
     */
    copy() {
        throw new Error("Macro");
    }
    /**
     * Returns the index of the first occurrence of searchElement found.
     *
     * @macro $self$.indexOf($args$)
     *
     * @param searchElement to search for.
     * @returns the index of the first occurrence of searchElement found, or -1 if not found.
     */
    indexOf(searchElement) {
        searchElement;
        throw new Error("Macro");
    }
    /**
     * Returns a new string containing the concatenated values in this array,
     * separated by commas or a specified separator string. If the array has only
     * one item, then that item will be returned without using the separator.
     *
     * @returns a string containing the concatenated values in this array,
     * separated by commas or a specified separator string.
     */
    join(separator) {
        separator;
        throw new Error("Abstract");
    }
    /**
     * Returns the index of the last occurrence of searchElement found.
     *
     * @macro $self$.lastIndexOf($args$)
     *
     * @param searchElement to search for.
     * @returns the index of the last occurrence of searchElement found, or -1 if not found.
     */
    lastIndexOf(searchElement) {
        searchElement;
        throw new Error("Macro");
    }
    /**
     * Add values to end of array
     *
     * @macro $self$.push($args$)
     *
     * @param values values to add
     */
    push(...values) {
        values;
        throw new Error("Macro");
    }
    /**
     * Remove value from end of array
     * @returns the value removed
     */
    pop() {
        throw new Error("Abstract");
    }
    /**
     * Removes value from the given index of an array
     *
     * @macro ((obj, args) => { if (args[0] < 0 || args[0] >= $self$.length) throw new Error("Index out of bounds"); return obj.splice(args[0], 1)[0]; })($self$, [$args$])
     *
     * @param index the index to remove the value at
     * @returns the value removed
     * @throws index out of bounds error if the given index does not exist for the array
     */
    popAt(index) {
        index;
        throw new Error("Macro");
    }
    /**
     * Sets a new value at the given index of an array
     *
     * @macro ((obj, args) => { if (args[0] < 0 || args[0] >= $self$.length) throw new Error("Index out of bounds"); obj[args[0]] = args[1]; })($self$, [$args$])
     *
     * @param index the index to set the value at
     * @param value the value to set at the given index
     * @throws index out of bounds error if the given index does not exist for the array
     */
    set(index, value) {
        index;
        value;
        throw new Error("Macro");
    }
    /**
     * Inserts a new value at the given index of an array
     *
     * @macro ((obj, args) => { if (args[0] < 0 || args[0] > $self$.length) throw new Error("Index out of bounds"); obj.splice(args[0], 0, args[1]); })($self$, [$args$])
     *
     * @param index the index to insert the value at
     * @param value the value to insert at the given index
     * @throws index out of bounds error if the given index isn't valid
     */
    insert(index, value) {
        index;
        value;
        throw new Error("Macro");
    }
    /**
     * Removes first occurrence of a given value in an array
     *
     * @macro ((obj, args) => { if (obj.indexOf(args[0]) !== -1) { obj.splice(obj.indexOf(args[0]), 1); return true; } return false; })($self$, [$args$])
     *
     * @param value the value to remove
     * @returns true if value was removed
     */
    removeFirst(value) {
        value;
        throw new Error("Macro");
    }
    /**
     * Returns a shallow copy of a portion of the array.
     *
     * @macro $self$.slice($args$)
     *
     * @param start the beginning index of the slice, inclusive.
     * @param end the ending index of the slice, exclusive.
     * @returns a new array containing the sliced elements.
     */
    slice(start, end) {
        start;
        end;
        throw new Error("Macro");
    }
}
exports.MutArray = MutArray;
_b = JSII_RTTI_SYMBOL_1;
MutArray[_b] = { fqn: "@winglang/sdk.std.MutArray", version: "0.0.0" };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXJyYXkuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvc3RkL2FycmF5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBS0Esa0NBQXlDO0FBRXpDOzs7O0dBSUc7QUFDSCxNQUFhLEtBQUs7SUFDaEI7O09BRUc7SUFDSSxNQUFNLENBQUMsZUFBZTtRQUMzQixPQUFPLHFCQUFjLENBQUMsT0FBTyxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDdkQsQ0FBQztJQUVELGdCQUF1QixDQUFDO0lBRXhCOzs7T0FHRztJQUNILElBQVcsTUFBTTtRQUNmLE1BQU0sSUFBSSxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDOUIsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0ksRUFBRSxDQUFDLEtBQWE7UUFDckIsS0FBSyxDQUFDO1FBQ04sTUFBTSxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUMzQixDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNJLEtBQUssQ0FBQyxLQUFhO1FBQ3hCLEtBQUssQ0FBQztRQUNOLE1BQU0sSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDM0IsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0ksTUFBTSxDQUFDLEdBQVU7UUFDdEIsR0FBRyxDQUFDO1FBQ0osTUFBTSxJQUFJLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUM5QixDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNJLFFBQVEsQ0FBQyxhQUFpQjtRQUMvQixhQUFhLENBQUM7UUFDZCxNQUFNLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQzNCLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSSxPQUFPO1FBQ1osTUFBTSxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUMzQixDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNJLE9BQU8sQ0FBQyxhQUFpQjtRQUM5QixhQUFhLENBQUM7UUFD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Q0FBQztRQUNOLEtBQUssQ0FBQztRQUNOLE1BQU0sSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDM0IsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSSxXQUFXLENBQUMsS0FBUztRQUMxQixLQUFLLENBQUM7UUFDTixNQUFNLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQzNCLENBQUM7SUFFRDs7Ozs7Ozs7T0FRRztJQUNJLEtBQUssQ0FBQyxLQUFjLEVBQUUsR0FBWTtRQUN2QyxLQUFLLENBQUM7UUFDTixHQUFHLENBQUM7UUFDSixNQUFNLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQzNCLENBQUM7O0FBak1ILDRCQWtNQyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFRoZXNlIGNsYXNzZXMgYXJlIHVzZWQgYnkgV2luZyB0byBwcm92aWRlIEpTSUkgc3Vic2V0cyBvZiB0aGUgSlMgQXJyYXkgY2xhc3MuXG4vLyBUaGV5IHNob3VsZCBub3QgYmUgY29uc3VtZWQgZGlyZWN0bHkgYnkgdXNlcnMuXG4vLyBUT0RPOiBUaGVzZSBzaG91bGQgYmUgaW50ZXJmYWNlcywgY3VycmVudGx5IFdpbmcgZG9lcyBub3Qgc3VwcG9ydCBpbnRlcmZhY2UgSlNJSSBpbXBvcnRzXG5cbmltcG9ydCB7IFQxIH0gZnJvbSBcIi4vZ2VuZXJpY3NcIjtcbmltcG9ydCB7IEluZmxpZ2h0Q2xpZW50IH0gZnJvbSBcIi4uL2NvcmVcIjtcblxuLyoqXG4gKiBJbW11dGFibGUgQXJyYXlcbiAqXG4gKiBAdHlwZXBhcmFtIFQxXG4gKi9cbmV4cG9ydCBjbGFzcyBBcnJheSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgX3RvSW5mbGlnaHRUeXBlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIEluZmxpZ2h0Q2xpZW50LmZvclR5cGUoX19maWxlbmFtZSwgdGhpcy5uYW1lKTtcbiAgfVxuXG4gIHByaXZhdGUgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBUaGUgbGVuZ3RoIG9mIHRoZSBhcnJheVxuICAgKiBAcmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheVxuICAgKi9cbiAgcHVibGljIGdldCBsZW5ndGgoKTogbnVtYmVyIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBYnN0cmFjdFwiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhbHVlIGF0IHRoZSBnaXZlbiBpbmRleFxuICAgKiBAbWFjcm8gKChhcnIsIGluZGV4KSA9PiB7IGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gYXJyLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKFwiSW5kZXggb3V0IG9mIGJvdW5kc1wiKTsgcmV0dXJuIGFycltpbmRleF07IH0pKCRzZWxmJCwgJGFyZ3MkKVxuICAgKiBAcGFyYW0gaW5kZXggaW5kZXggb2YgdGhlIHZhbHVlIHRvIGdldFxuICAgKiBAcmV0dXJucyB0aGUgdmFsdWUgYXQgdGhlIGdpdmVuIGluZGV4XG4gICAqL1xuICBwdWJsaWMgYXQoaW5kZXg6IG51bWJlcik6IFQxIHtcbiAgICBpbmRleDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWNyb1wiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhbHVlIGF0IHRoZSBnaXZlbiBpbmRleCwgcmV0dXJuaW5nIG5pbCBpZiB0aGUgaW5kZXggaXMgb3V0IG9mIGJvdW5kcy5cbiAgICpcbiAgICogQG1hY3JvICRzZWxmJC5hdCgkYXJncyQpXG4gICAqXG4gICAqIEBwYXJhbSBpbmRleCBpbmRleCBvZiB0aGUgdmFsdWUgdG8gZ2V0XG4gICAqIEByZXR1cm5zIHRoZSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gaW5kZXgsIG9yIHVuZGVmaW5lZCBpZiB0aGUgaW5kZXggaXMgb3V0IG9mIGJvdW5kc1xuICAgKi9cbiAgcHVibGljIHRyeUF0KGluZGV4OiBudW1iZXIpOiBUMSB8IHVuZGVmaW5lZCB7XG4gICAgaW5kZXg7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWFjcm9cIik7XG4gIH1cblxuICAvKipcbiAgICogTWVyZ2UgYXJyIHRvIHRoZSBlbmQgb2YgdGhpcyBhcnJheVxuICAgKiBAcGFyYW0gYXJyIGFycmF5IHRvIG1lcmdlXG4gICAqXG4gICAqIEByZXR1cm5zIGEgbmV3IEltbXV0YWJsZUFycmF5IHdpdGggdGhlIHZhbHVlcyBvZiB0aGlzIGFycmF5IGZvbGxvd2VkIGJ5IHRoZSB2YWx1ZXMgb2YgYXJyXG4gICAqL1xuICBwdWJsaWMgY29uY2F0KGFycjogQXJyYXkpOiBBcnJheSB7XG4gICAgYXJyO1xuICAgIHRocm93IG5ldyBFcnJvcihcIkFic3RyYWN0XCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIGFycmF5IGluY2x1ZGVzIHNlYXJjaEVsZW1lbnQuXG4gICAqXG4gICAqIEBtYWNybyAkc2VsZiQuaW5jbHVkZXMoJGFyZ3MkKVxuICAgKlxuICAgKiBAcGFyYW0gc2VhcmNoRWxlbWVudCB0byBzZWFyY2ggZm9yLlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoaXMgYXJyYXkgaW5jbHVkZXMgc2VhcmNoRWxlbWVudC5cbiAgICovXG4gIHB1YmxpYyBjb250YWlucyhzZWFyY2hFbGVtZW50OiBUMSk6IGJvb2xlYW4ge1xuICAgIHNlYXJjaEVsZW1lbnQ7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWFjcm9cIik7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbXV0YWJsZSBzaGFsbG93IGNvcHkgb2YgdGhpcyBhcnJheVxuICAgKlxuICAgKiBAbWFjcm8gWy4uLigkc2VsZiQpXVxuICAgKlxuICAgKiBAcmV0dXJucyBhIE11dGFibGVBcnJheSB3aXRoIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGlzIGFycmF5XG4gICAqL1xuICBwdWJsaWMgY29weU11dCgpOiBNdXRBcnJheSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWFjcm9cIik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2Ygc2VhcmNoRWxlbWVudCBmb3VuZC5cbiAgICpcbiAgICogQG1hY3JvICRzZWxmJC5pbmRleE9mKCRhcmdzJClcbiAgICpcbiAgICogQHBhcmFtIHNlYXJjaEVsZW1lbnQgdG8gc2VhcmNoIGZvci5cbiAgICogQHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIHNlYXJjaEVsZW1lbnQgZm91bmQsIG9yIC0xIGlmIG5vdCBmb3VuZC5cbiAgICovXG4gIHB1YmxpYyBpbmRleE9mKHNlYXJjaEVsZW1lbnQ6IFQxKTogbnVtYmVyIHtcbiAgICBzZWFyY2hFbGVtZW50O1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1hY3JvXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIGNvbmNhdGVuYXRlZCB2YWx1ZXMgaW4gdGhpcyBhcnJheSxcbiAgICogc2VwYXJhdGVkIGJ5IGNvbW1hcyBvciBhIHNwZWNpZmllZCBzZXBhcmF0b3Igc3RyaW5nLiBJZiB0aGUgYXJyYXkgaGFzIG9ubHlcbiAgICogb25lIGl0ZW0sIHRoZW4gdGhhdCBpdGVtIHdpbGwgYmUgcmV0dXJuZWQgd2l0aG91dCB1c2luZyB0aGUgc2VwYXJhdG9yLlxuICAgKlxuICAgKiBAcmV0dXJucyBhIHN0cmluZyBjb250YWluaW5nIHRoZSBjb25jYXRlbmF0ZWQgdmFsdWVzIGluIHRoaXMgYXJyYXksXG4gICAqIHNlcGFyYXRlZCBieSBjb21tYXMgb3IgYSBzcGVjaWZpZWQgc2VwYXJhdG9yIHN0cmluZy5cbiAgICovXG4gIHB1YmxpYyBqb2luKHNlcGFyYXRvcj86IHN0cmluZyk6IHN0cmluZyB7XG4gICAgc2VwYXJhdG9yO1xuICAgIHRocm93IG5ldyBFcnJvcihcIkFic3RyYWN0XCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IG9jY3VycmVuY2Ugb2Ygc2VhcmNoRWxlbWVudCBmb3VuZC5cbiAgICpcbiAgICogQG1hY3JvICRzZWxmJC5sYXN0SW5kZXhPZigkYXJncyQpXG4gICAqXG4gICAqIEBwYXJhbSBzZWFyY2hFbGVtZW50IHRvIHNlYXJjaCBmb3IuXG4gICAqIEByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBvY2N1cnJlbmNlIG9mIHNlYXJjaEVsZW1lbnQgZm91bmQsIG9yIC0xIGlmIG5vdCBmb3VuZC5cbiAgICovXG4gIHB1YmxpYyBsYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50OiBUMSk6IG51bWJlciB7XG4gICAgc2VhcmNoRWxlbWVudDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWNyb1wiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc2hhbGxvdyBjb3B5IG9mIGEgcG9ydGlvbiBvZiB0aGUgYXJyYXkuXG4gICAqXG4gICAqIEBtYWNybyAkc2VsZiQuc2xpY2UoJGFyZ3MkKVxuICAgKlxuICAgKiBAcGFyYW0gc3RhcnQgdGhlIGJlZ2lubmluZyBpbmRleCBvZiB0aGUgc2xpY2UsIGluY2x1c2l2ZS5cbiAgICogQHBhcmFtIGVuZCB0aGUgZW5kaW5nIGluZGV4IG9mIHRoZSBzbGljZSwgZXhjbHVzaXZlLlxuICAgKiBAcmV0dXJucyBhIG5ldyBhcnJheSBjb250YWluaW5nIHRoZSBzbGljZWQgZWxlbWVudHMuXG4gICAqL1xuICBwdWJsaWMgc2xpY2Uoc3RhcnQ/OiBudW1iZXIsIGVuZD86IG51bWJlcik6IEFycmF5IHtcbiAgICBzdGFydDtcbiAgICBlbmQ7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWFjcm9cIik7XG4gIH1cbn1cblxuLyoqXG4gKiBNdXRhYmxlIEFycmF5XG4gKlxuICogQHR5cGVwYXJhbSBUMVxuICovXG5leHBvcnQgY2xhc3MgTXV0QXJyYXkge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIF90b0luZmxpZ2h0VHlwZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiBJbmZsaWdodENsaWVudC5mb3JUeXBlKF9fZmlsZW5hbWUsIHRoaXMubmFtZSk7XG4gIH1cblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogVGhlIGxlbmd0aCBvZiB0aGUgYXJyYXlcbiAgICogQHJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXlcbiAgICovXG4gIHB1YmxpYyBnZXQgbGVuZ3RoKCk6IG51bWJlciB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQWJzdHJhY3RcIik7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gaW5kZXhcbiAgICogQG1hY3JvICgoYXJyLCBpbmRleCkgPT4geyBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IGFyci5sZW5ndGgpIHRocm93IG5ldyBFcnJvcihcIkluZGV4IG91dCBvZiBib3VuZHNcIik7IHJldHVybiBhcnJbaW5kZXhdOyB9KSgkc2VsZiQsICRhcmdzJClcbiAgICogQHBhcmFtIGluZGV4IGluZGV4IG9mIHRoZSB2YWx1ZSB0byBnZXRcbiAgICogQHJldHVybnMgdGhlIHZhbHVlIGF0IHRoZSBnaXZlbiBpbmRleFxuICAgKi9cbiAgcHVibGljIGF0KGluZGV4OiBudW1iZXIpOiBUMSB7XG4gICAgaW5kZXg7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWFjcm9cIik7XG4gIH1cblxuICAvKipcbiAgICogTWVyZ2UgYXJyIHRvIHRoZSBlbmQgb2YgdGhpcyBhcnJheVxuICAgKiBAcGFyYW0gYXJyIGFycmF5IHRvIG1lcmdlXG4gICAqXG4gICAqIEByZXR1cm5zIGEgbmV3IE11dGFibGVBcnJheSB3aXRoIHRoZSB2YWx1ZXMgb2YgdGhpcyBhcnJheSBmb2xsb3dlZCBieSB0aGUgdmFsdWVzIG9mIGFyclxuICAgKi9cbiAgcHVibGljIGNvbmNhdChhcnI6IE11dEFycmF5KTogTXV0QXJyYXkge1xuICAgIGFycjtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBYnN0cmFjdFwiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyBhcnJheSBpbmNsdWRlcyBzZWFyY2hFbGVtZW50LlxuICAgKlxuICAgKiBAbWFjcm8gJHNlbGYkLmluY2x1ZGVzKCRhcmdzJClcbiAgICpcbiAgICogQHBhcmFtIHNlYXJjaEVsZW1lbnQgdG8gc2VhcmNoIGZvci5cbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGlzIGFycmF5IGluY2x1ZGVzIHNlYXJjaEVsZW1lbnQuXG4gICAqL1xuICBwdWJsaWMgY29udGFpbnMoc2VhcmNoRWxlbWVudDogVDEpOiBib29sZWFuIHtcbiAgICBzZWFyY2hFbGVtZW50O1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1hY3JvXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbW11dGFibGUgc2hhbGxvdyBjb3B5IG9mIHRoaXMgYXJyYXlcbiAgICpcbiAgICogQG1hY3JvIFsuLi4oJHNlbGYkKV1cbiAgICpcbiAgICogQHJldHVybnMgYW4gSW1tdXRhYmxlQXJyYXkgd2l0aCB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhpcyBhcnJheVxuICAgKi9cbiAgcHVibGljIGNvcHkoKTogQXJyYXkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1hY3JvXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIHNlYXJjaEVsZW1lbnQgZm91bmQuXG4gICAqXG4gICAqIEBtYWNybyAkc2VsZiQuaW5kZXhPZigkYXJncyQpXG4gICAqXG4gICAqIEBwYXJhbSBzZWFyY2hFbGVtZW50IHRvIHNlYXJjaCBmb3IuXG4gICAqIEByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBzZWFyY2hFbGVtZW50IGZvdW5kLCBvciAtMSBpZiBub3QgZm91bmQuXG4gICAqL1xuICBwdWJsaWMgaW5kZXhPZihzZWFyY2hFbGVtZW50OiBUMSk6IG51bWJlciB7XG4gICAgc2VhcmNoRWxlbWVudDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWNyb1wiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IHN0cmluZyBjb250YWluaW5nIHRoZSBjb25jYXRlbmF0ZWQgdmFsdWVzIGluIHRoaXMgYXJyYXksXG4gICAqIHNlcGFyYXRlZCBieSBjb21tYXMgb3IgYSBzcGVjaWZpZWQgc2VwYXJhdG9yIHN0cmluZy4gSWYgdGhlIGFycmF5IGhhcyBvbmx5XG4gICAqIG9uZSBpdGVtLCB0aGVuIHRoYXQgaXRlbSB3aWxsIGJlIHJldHVybmVkIHdpdGhvdXQgdXNpbmcgdGhlIHNlcGFyYXRvci5cbiAgICpcbiAgICogQHJldHVybnMgYSBzdHJpbmcgY29udGFpbmluZyB0aGUgY29uY2F0ZW5hdGVkIHZhbHVlcyBpbiB0aGlzIGFycmF5LFxuICAgKiBzZXBhcmF0ZWQgYnkgY29tbWFzIG9yIGEgc3BlY2lmaWVkIHNlcGFyYXRvciBzdHJpbmcuXG4gICAqL1xuICBwdWJsaWMgam9pbihzZXBhcmF0b3I/OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHNlcGFyYXRvcjtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBYnN0cmFjdFwiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBvY2N1cnJlbmNlIG9mIHNlYXJjaEVsZW1lbnQgZm91bmQuXG4gICAqXG4gICAqIEBtYWNybyAkc2VsZiQubGFzdEluZGV4T2YoJGFyZ3MkKVxuICAgKlxuICAgKiBAcGFyYW0gc2VhcmNoRWxlbWVudCB0byBzZWFyY2ggZm9yLlxuICAgKiBAcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgb2NjdXJyZW5jZSBvZiBzZWFyY2hFbGVtZW50IGZvdW5kLCBvciAtMSBpZiBub3QgZm91bmQuXG4gICAqL1xuICBwdWJsaWMgbGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudDogVDEpOiBudW1iZXIge1xuICAgIHNlYXJjaEVsZW1lbnQ7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWFjcm9cIik7XG4gIH1cblxuICAvKipcbiAgICogQWRkIHZhbHVlcyB0byBlbmQgb2YgYXJyYXlcbiAgICpcbiAgICogQG1hY3JvICRzZWxmJC5wdXNoKCRhcmdzJClcbiAgICpcbiAgICogQHBhcmFtIHZhbHVlcyB2YWx1ZXMgdG8gYWRkXG4gICAqL1xuICBwdWJsaWMgcHVzaCguLi52YWx1ZXM6IFQxW10pOiB2b2lkIHtcbiAgICB2YWx1ZXM7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWFjcm9cIik7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHZhbHVlIGZyb20gZW5kIG9mIGFycmF5XG4gICAqIEByZXR1cm5zIHRoZSB2YWx1ZSByZW1vdmVkXG4gICAqL1xuICBwdWJsaWMgcG9wKCk6IFQxIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBYnN0cmFjdFwiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHZhbHVlIGZyb20gdGhlIGdpdmVuIGluZGV4IG9mIGFuIGFycmF5XG4gICAqXG4gICAqIEBtYWNybyAoKG9iaiwgYXJncykgPT4geyBpZiAoYXJnc1swXSA8IDAgfHwgYXJnc1swXSA+PSAkc2VsZiQubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoXCJJbmRleCBvdXQgb2YgYm91bmRzXCIpOyByZXR1cm4gb2JqLnNwbGljZShhcmdzWzBdLCAxKVswXTsgfSkoJHNlbGYkLCBbJGFyZ3MkXSlcbiAgICpcbiAgICogQHBhcmFtIGluZGV4IHRoZSBpbmRleCB0byByZW1vdmUgdGhlIHZhbHVlIGF0XG4gICAqIEByZXR1cm5zIHRoZSB2YWx1ZSByZW1vdmVkXG4gICAqIEB0aHJvd3MgaW5kZXggb3V0IG9mIGJvdW5kcyBlcnJvciBpZiB0aGUgZ2l2ZW4gaW5kZXggZG9lcyBub3QgZXhpc3QgZm9yIHRoZSBhcnJheVxuICAgKi9cbiAgcHVibGljIHBvcEF0KGluZGV4OiBudW1iZXIpOiBUMSB7XG4gICAgaW5kZXg7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWFjcm9cIik7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhIG5ldyB2YWx1ZSBhdCB0aGUgZ2l2ZW4gaW5kZXggb2YgYW4gYXJyYXlcbiAgICpcbiAgICogQG1hY3JvICgob2JqLCBhcmdzKSA9PiB7IGlmIChhcmdzWzBdIDwgMCB8fCBhcmdzWzBdID49ICRzZWxmJC5sZW5ndGgpIHRocm93IG5ldyBFcnJvcihcIkluZGV4IG91dCBvZiBib3VuZHNcIik7IG9ialthcmdzWzBdXSA9IGFyZ3NbMV07IH0pKCRzZWxmJCwgWyRhcmdzJF0pXG4gICAqXG4gICAqIEBwYXJhbSBpbmRleCB0aGUgaW5kZXggdG8gc2V0IHRoZSB2YWx1ZSBhdFxuICAgKiBAcGFyYW0gdmFsdWUgdGhlIHZhbHVlIHRvIHNldCBhdCB0aGUgZ2l2ZW4gaW5kZXhcbiAgICogQHRocm93cyBpbmRleCBvdXQgb2YgYm91bmRzIGVycm9yIGlmIHRoZSBnaXZlbiBpbmRleCBkb2VzIG5vdCBleGlzdCBmb3IgdGhlIGFycmF5XG4gICAqL1xuICBwdWJsaWMgc2V0KGluZGV4OiBudW1iZXIsIHZhbHVlOiBUMSk6IHZvaWQge1xuICAgIGluZGV4O1xuICAgIHZhbHVlO1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1hY3JvXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydHMgYSBuZXcgdmFsdWUgYXQgdGhlIGdpdmVuIGluZGV4IG9mIGFuIGFycmF5XG4gICAqXG4gICAqIEBtYWNybyAoKG9iaiwgYXJncykgPT4geyBpZiAoYXJnc1swXSA8IDAgfHwgYXJnc1swXSA+ICRzZWxmJC5sZW5ndGgpIHRocm93IG5ldyBFcnJvcihcIkluZGV4IG91dCBvZiBib3VuZHNcIik7IG9iai5zcGxpY2UoYXJnc1swXSwgMCwgYXJnc1sxXSk7IH0pKCRzZWxmJCwgWyRhcmdzJF0pXG4gICAqXG4gICAqIEBwYXJhbSBpbmRleCB0aGUgaW5kZXggdG8gaW5zZXJ0IHRoZSB2YWx1ZSBhdFxuICAgKiBAcGFyYW0gdmFsdWUgdGhlIHZhbHVlIHRvIGluc2VydCBhdCB0aGUgZ2l2ZW4gaW5kZXhcbiAgICogQHRocm93cyBpbmRleCBvdXQgb2YgYm91bmRzIGVycm9yIGlmIHRoZSBnaXZlbiBpbmRleCBpc24ndCB2YWxpZFxuICAgKi9cbiAgcHVibGljIGluc2VydChpbmRleDogbnVtYmVyLCB2YWx1ZTogVDEpOiB2b2lkIHtcbiAgICBpbmRleDtcbiAgICB2YWx1ZTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWNyb1wiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGZpcnN0IG9jY3VycmVuY2Ugb2YgYSBnaXZlbiB2YWx1ZSBpbiBhbiBhcnJheVxuICAgKlxuICAgKiBAbWFjcm8gKChvYmosIGFyZ3MpID0+IHsgaWYgKG9iai5pbmRleE9mKGFyZ3NbMF0pICE9PSAtMSkgeyBvYmouc3BsaWNlKG9iai5pbmRleE9mKGFyZ3NbMF0pLCAxKTsgcmV0dXJuIHRydWU7IH0gcmV0dXJuIGZhbHNlOyB9KSgkc2VsZiQsIFskYXJncyRdKVxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWUgdGhlIHZhbHVlIHRvIHJlbW92ZVxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHZhbHVlIHdhcyByZW1vdmVkXG4gICAqL1xuICBwdWJsaWMgcmVtb3ZlRmlyc3QodmFsdWU6IFQxKTogYm9vbGVhbiB7XG4gICAgdmFsdWU7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWFjcm9cIik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHNoYWxsb3cgY29weSBvZiBhIHBvcnRpb24gb2YgdGhlIGFycmF5LlxuICAgKlxuICAgKiBAbWFjcm8gJHNlbGYkLnNsaWNlKCRhcmdzJClcbiAgICpcbiAgICogQHBhcmFtIHN0YXJ0IHRoZSBiZWdpbm5pbmcgaW5kZXggb2YgdGhlIHNsaWNlLCBpbmNsdXNpdmUuXG4gICAqIEBwYXJhbSBlbmQgdGhlIGVuZGluZyBpbmRleCBvZiB0aGUgc2xpY2UsIGV4Y2x1c2l2ZS5cbiAgICogQHJldHVybnMgYSBuZXcgYXJyYXkgY29udGFpbmluZyB0aGUgc2xpY2VkIGVsZW1lbnRzLlxuICAgKi9cbiAgcHVibGljIHNsaWNlKHN0YXJ0PzogbnVtYmVyLCBlbmQ/OiBudW1iZXIpOiBNdXRBcnJheSB7XG4gICAgc3RhcnQ7XG4gICAgZW5kO1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1hY3JvXCIpO1xuICB9XG59XG4iXX0=