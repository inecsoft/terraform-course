"use strict";
var _a, _b;
Object.defineProperty(exports, "__esModule", { value: true });
exports.MutSet = exports.Set = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const core_1 = require("../core");
/**
 * Immutable Set
 *
 * @typeparam T1
 */
class Set {
    /**
     * @internal
     */
    static _toInflightType() {
        return core_1.InflightClient.forType(__filename, this.name);
    }
    constructor() { }
    /**
     * The length of the set
     * @returns the length of the set
     */
    get size() {
        throw new Error("Abstract");
    }
    /**
     * Returns a boolean indicating whether an element with the specified value exists in the set.
     * @param value The value to test for presence in the Set object.
     * @returns `true` if an element with the specified value exists in the set; otherwise `false`.
     */
    has(value) {
        value;
        throw new Error("Abstract");
    }
    /**
     * Create a mutable shallow copy of this set
     *
     * @macro new Set($self$)
     *
     * @returns a MutableSet with the same values as this set
     */
    copyMut() {
        throw new Error("Macro");
    }
    /**
     * Create an immutable array shallow copy of this set
     *
     * @macro [...($self$)]
     *
     * @returns an ImmutableArray with the same values as this set
     */
    toArray() {
        throw new Error("Macro");
    }
}
exports.Set = Set;
_a = JSII_RTTI_SYMBOL_1;
Set[_a] = { fqn: "@winglang/sdk.std.Set", version: "0.0.0" };
/**
 * Mutable Set
 *
 * @typeparam T1
 */
class MutSet {
    /**
     * @internal
     */
    static _toInflightType() {
        return core_1.InflightClient.forType(__filename, this.name);
    }
    constructor() { }
    /**
     * The length of the set
     * @returns the length of the set
     */
    get size() {
        throw new Error("Abstract");
    }
    /**
     * Add value to set
     * @param value value to add
     * @returns true if the value was added, false if it was already in the set
     */
    add(value) {
        value;
        throw new Error("Abstract");
    }
    /**
     * The clear() method removes all elements from a set.
     */
    clear() {
        throw new Error("Abstract");
    }
    /**
     * Create an immutable shallow copy of this set
     *
     * @macro new Set($self$)
     *
     * @returns an ImmutableSet with the same values as this set
     */
    copy() {
        throw new Error("Macro");
    }
    /**
     * Removes a specified value from a set, if it is in the set.
     * @param value The value to remove from the set.
     * @returns Returns `true` if `value` was already in the set; otherwise `false`.
     */
    delete(value) {
        value;
        throw new Error("Abstract");
    }
    /**
     * Returns a boolean indicating whether an element with the specified value exists in the set.
     * @param value The value to test for presence in the Set object.
     * @returns `true` if an element with the specified value exists in the set; otherwise `false`.
     */
    has(value) {
        value;
        throw new Error("Abstract");
    }
    /**
     * Create an immutable array shallow copy of this set
     *
     * @macro [...($self$)]
     *
     * @returns an ImmutableArray with the same values as this set
     */
    toArray() {
        throw new Error("Macro");
    }
}
exports.MutSet = MutSet;
_b = JSII_RTTI_SYMBOL_1;
MutSet[_b] = { fqn: "@winglang/sdk.std.MutSet", version: "0.0.0" };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2V0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3N0ZC9zZXQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFNQSxrQ0FBeUM7QUFFekM7Ozs7R0FJRztBQUNILE1BQWEsR0FBRztJQUNkOztPQUVHO0lBQ0ksTUFBTSxDQUFDLGVBQWU7UUFDM0IsT0FBTyxxQkFBYyxDQUFDLE9BQU8sQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3ZELENBQUM7SUFFRCxnQkFBdUIsQ0FBQztJQUV4Qjs7O09BR0c7SUFDSCxJQUFXLElBQUk7UUFDYixNQUFNLElBQUksS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQzlCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksR0FBRyxDQUFDLEtBQVM7UUFDbEIsS0FBSyxDQUFDO1FBQ04sTUFBTSxJQUFJLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUM5QixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ksT0FBTztRQUNaLE1BQU0sSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDM0IsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNJLE9BQU87UUFDWixNQUFNLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQzNCLENBQUM7O0FBaERILGtCQWlEQzs7O0FBRUQ7Ozs7R0FJRztBQUNILE1BQWEsTUFBTTtJQUNqQjs7T0FFRztJQUNJLE1BQU0sQ0FBQyxlQUFlO1FBQzNCLE9BQU8scUJBQWMsQ0FBQyxPQUFPLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN2RCxDQUFDO0lBRUQsZ0JBQXVCLENBQUM7SUFFeEI7OztPQUdHO0lBQ0gsSUFBVyxJQUFJO1FBQ2IsTUFBTSxJQUFJLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUM5QixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLEdBQUcsQ0FBQyxLQUFTO1FBQ2xCLEtBQUssQ0FBQztRQUNOLE1BQU0sSUFBSSxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDOUIsQ0FBQztJQUVEOztPQUVHO0lBQ0ksS0FBSztRQUNWLE1BQU0sSUFBSSxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDOUIsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNJLElBQUk7UUFDVCxNQUFNLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQzNCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksTUFBTSxDQUFDLEtBQVM7UUFDckIsS0FBSyxDQUFDO1FBQ04sTUFBTSxJQUFJLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUM5QixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLEdBQUcsQ0FBQyxLQUFTO1FBQ2xCLEtBQUssQ0FBQztRQUNOLE1BQU0sSUFBSSxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDOUIsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNJLE9BQU87UUFDWixNQUFNLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQzNCLENBQUM7O0FBM0VILHdCQTRFQyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFRoZXNlIGNsYXNzZXMgYXJlIHVzZWQgYnkgV2luZyB0byBwcm92aWRlIEpTSUkgc3Vic2V0cyBvZiB0aGUgSlMgU2V0IGNsYXNzLlxuLy8gVGhleSBzaG91bGQgbm90IGJlIGNvbnN1bWVkIGRpcmVjdGx5IGJ5IHVzZXJzLlxuLy8gVE9ETzogVGhlc2Ugc2hvdWxkIGJlIGludGVyZmFjZXMsIGN1cnJlbnRseSBXaW5nIGRvZXMgbm90IHN1cHBvcnQgaW50ZXJmYWNlIEpTSUkgaW1wb3J0c1xuXG5pbXBvcnQgeyBBcnJheSB9IGZyb20gXCIuL2FycmF5XCI7XG5pbXBvcnQgeyBUMSB9IGZyb20gXCIuL2dlbmVyaWNzXCI7XG5pbXBvcnQgeyBJbmZsaWdodENsaWVudCB9IGZyb20gXCIuLi9jb3JlXCI7XG5cbi8qKlxuICogSW1tdXRhYmxlIFNldFxuICpcbiAqIEB0eXBlcGFyYW0gVDFcbiAqL1xuZXhwb3J0IGNsYXNzIFNldCB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgX3RvSW5mbGlnaHRUeXBlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIEluZmxpZ2h0Q2xpZW50LmZvclR5cGUoX19maWxlbmFtZSwgdGhpcy5uYW1lKTtcbiAgfVxuXG4gIHByaXZhdGUgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBUaGUgbGVuZ3RoIG9mIHRoZSBzZXRcbiAgICogQHJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgc2V0XG4gICAqL1xuICBwdWJsaWMgZ2V0IHNpemUoKTogbnVtYmVyIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBYnN0cmFjdFwiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgYW4gZWxlbWVudCB3aXRoIHRoZSBzcGVjaWZpZWQgdmFsdWUgZXhpc3RzIGluIHRoZSBzZXQuXG4gICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gdGVzdCBmb3IgcHJlc2VuY2UgaW4gdGhlIFNldCBvYmplY3QuXG4gICAqIEByZXR1cm5zIGB0cnVlYCBpZiBhbiBlbGVtZW50IHdpdGggdGhlIHNwZWNpZmllZCB2YWx1ZSBleGlzdHMgaW4gdGhlIHNldDsgb3RoZXJ3aXNlIGBmYWxzZWAuXG4gICAqL1xuICBwdWJsaWMgaGFzKHZhbHVlOiBUMSk6IGJvb2xlYW4ge1xuICAgIHZhbHVlO1xuICAgIHRocm93IG5ldyBFcnJvcihcIkFic3RyYWN0XCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG11dGFibGUgc2hhbGxvdyBjb3B5IG9mIHRoaXMgc2V0XG4gICAqXG4gICAqIEBtYWNybyBuZXcgU2V0KCRzZWxmJClcbiAgICpcbiAgICogQHJldHVybnMgYSBNdXRhYmxlU2V0IHdpdGggdGhlIHNhbWUgdmFsdWVzIGFzIHRoaXMgc2V0XG4gICAqL1xuICBwdWJsaWMgY29weU11dCgpOiBNdXRTZXQge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1hY3JvXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbW11dGFibGUgYXJyYXkgc2hhbGxvdyBjb3B5IG9mIHRoaXMgc2V0XG4gICAqXG4gICAqIEBtYWNybyBbLi4uKCRzZWxmJCldXG4gICAqXG4gICAqIEByZXR1cm5zIGFuIEltbXV0YWJsZUFycmF5IHdpdGggdGhlIHNhbWUgdmFsdWVzIGFzIHRoaXMgc2V0XG4gICAqL1xuICBwdWJsaWMgdG9BcnJheSgpOiBBcnJheSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWFjcm9cIik7XG4gIH1cbn1cblxuLyoqXG4gKiBNdXRhYmxlIFNldFxuICpcbiAqIEB0eXBlcGFyYW0gVDFcbiAqL1xuZXhwb3J0IGNsYXNzIE11dFNldCB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgX3RvSW5mbGlnaHRUeXBlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIEluZmxpZ2h0Q2xpZW50LmZvclR5cGUoX19maWxlbmFtZSwgdGhpcy5uYW1lKTtcbiAgfVxuXG4gIHByaXZhdGUgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBUaGUgbGVuZ3RoIG9mIHRoZSBzZXRcbiAgICogQHJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgc2V0XG4gICAqL1xuICBwdWJsaWMgZ2V0IHNpemUoKTogbnVtYmVyIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBYnN0cmFjdFwiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgdmFsdWUgdG8gc2V0XG4gICAqIEBwYXJhbSB2YWx1ZSB2YWx1ZSB0byBhZGRcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWUgd2FzIGFkZGVkLCBmYWxzZSBpZiBpdCB3YXMgYWxyZWFkeSBpbiB0aGUgc2V0XG4gICAqL1xuICBwdWJsaWMgYWRkKHZhbHVlOiBUMSk6IE11dFNldCB7XG4gICAgdmFsdWU7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQWJzdHJhY3RcIik7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGNsZWFyKCkgbWV0aG9kIHJlbW92ZXMgYWxsIGVsZW1lbnRzIGZyb20gYSBzZXQuXG4gICAqL1xuICBwdWJsaWMgY2xlYXIoKTogdm9pZCB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQWJzdHJhY3RcIik7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGltbXV0YWJsZSBzaGFsbG93IGNvcHkgb2YgdGhpcyBzZXRcbiAgICpcbiAgICogQG1hY3JvIG5ldyBTZXQoJHNlbGYkKVxuICAgKlxuICAgKiBAcmV0dXJucyBhbiBJbW11dGFibGVTZXQgd2l0aCB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhpcyBzZXRcbiAgICovXG4gIHB1YmxpYyBjb3B5KCk6IFNldCB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWFjcm9cIik7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIHNwZWNpZmllZCB2YWx1ZSBmcm9tIGEgc2V0LCBpZiBpdCBpcyBpbiB0aGUgc2V0LlxuICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIHJlbW92ZSBmcm9tIHRoZSBzZXQuXG4gICAqIEByZXR1cm5zIFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgd2FzIGFscmVhZHkgaW4gdGhlIHNldDsgb3RoZXJ3aXNlIGBmYWxzZWAuXG4gICAqL1xuICBwdWJsaWMgZGVsZXRlKHZhbHVlOiBUMSk6IGJvb2xlYW4ge1xuICAgIHZhbHVlO1xuICAgIHRocm93IG5ldyBFcnJvcihcIkFic3RyYWN0XCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBhbiBlbGVtZW50IHdpdGggdGhlIHNwZWNpZmllZCB2YWx1ZSBleGlzdHMgaW4gdGhlIHNldC5cbiAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byB0ZXN0IGZvciBwcmVzZW5jZSBpbiB0aGUgU2V0IG9iamVjdC5cbiAgICogQHJldHVybnMgYHRydWVgIGlmIGFuIGVsZW1lbnQgd2l0aCB0aGUgc3BlY2lmaWVkIHZhbHVlIGV4aXN0cyBpbiB0aGUgc2V0OyBvdGhlcndpc2UgYGZhbHNlYC5cbiAgICovXG4gIHB1YmxpYyBoYXModmFsdWU6IFQxKTogYm9vbGVhbiB7XG4gICAgdmFsdWU7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQWJzdHJhY3RcIik7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGltbXV0YWJsZSBhcnJheSBzaGFsbG93IGNvcHkgb2YgdGhpcyBzZXRcbiAgICpcbiAgICogQG1hY3JvIFsuLi4oJHNlbGYkKV1cbiAgICpcbiAgICogQHJldHVybnMgYW4gSW1tdXRhYmxlQXJyYXkgd2l0aCB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhpcyBzZXRcbiAgICovXG4gIHB1YmxpYyB0b0FycmF5KCk6IEFycmF5IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWNyb1wiKTtcbiAgfVxufVxuIl19