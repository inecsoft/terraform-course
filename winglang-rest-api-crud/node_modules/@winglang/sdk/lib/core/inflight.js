"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.importInflight = exports.inflight = exports.lift = exports.InflightClient = exports.closureId = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const path_1 = require("path");
const lifting_1 = require("./lifting");
const types_1 = require("./types");
const misc_1 = require("../shared/misc");
let closureCount = 0;
function closureId() {
    return closureCount++;
}
exports.closureId = closureId;
/**
 * Utility class with functions about inflight clients.
 */
class InflightClient {
    /**
     * Returns code for creating an inflight client.
     */
    static for(dirname, filename, clientClass, args) {
        const inflightDir = dirname;
        const inflightFile = (0, path_1.basename)(filename).split(".")[0] + ".inflight";
        return `new (require("${(0, misc_1.normalPath)(`${inflightDir}/${inflightFile}`)}")).${clientClass}(${args.join(", ")})`;
    }
    /**
     * Returns code for implementing `_toInflightType()`.
     */
    static forType(filename, clientClass) {
        return `require("${(0, misc_1.normalPath)(filename)}").${clientClass}`;
    }
    constructor() { }
}
exports.InflightClient = InflightClient;
_a = JSII_RTTI_SYMBOL_1;
InflightClient[_a] = { fqn: "@winglang/sdk.core.InflightClient", version: "0.0.0" };
/**
 * Prepares preflight objects for use in inflight functions.
 *
 * Conventionally, this is used by passing in a `const` object to bind it with the same name
 *
 * ```ts
 * const bucket = new cloud.Bucket(app, "Bucket");
 * const number = 5;
 *
 * lift({ bucket, number })
 *   .inflight(({ bucket, number }) => { ... }))
 * ```
 *
 * However, the name is not required to match the variable in the current scope.
 *
 * This is especially useful/necessary when lifting data via a reference or some other expression
 *
 * ```ts
 * const bucket = new cloud.Bucket(app, "Bucket");
 *
 * lift({ bkt: bucket, sum: 2 + 2, field: bucket.field })
 *   .inflight(({ bkt, sum, field }) => { ... }))
 * ```
 */
function lift(captures) {
    return new Lifter().lift(captures);
}
exports.lift = lift;
/**
 * Creates a inflight function.
 *
 * This function must not reference any variables outside of its scope.
 * If needed, use `lift` to bind variables to the scope of the function.
 *
 * Built-in NodeJS globals are available, such as `console` and `process`.
 * @wing inflight
 */
function inflight(fn) {
    return new Lifter().inflight(fn);
}
exports.inflight = inflight;
/**
 * Create an inflight function from a string.
 */
function importInflight(
/**
 * Raw JavaScript to use as the inflight function.
 */
inflightText, 
/**
 * The lifts the JS needs to be able to access.
 */
lifts) {
    const newLifts = {};
    const newGrants = {};
    // convert the lifts to the correct format for the Lifter
    for (const liftAnnotation of lifts ?? []) {
        if (liftAnnotation.alias === undefined) {
            throw new Error("The alias field is required for all lifts");
        }
        newLifts[liftAnnotation.alias] = liftAnnotation.obj;
        if (liftAnnotation.ops) {
            newGrants[liftAnnotation.alias] = liftAnnotation.ops;
        }
    }
    return (lift(newLifts)
        .grant(newGrants)
        // cast as any because the inflight has already been pre-serialized
        .inflight(inflightText));
}
exports.importInflight = importInflight;
/**
 * Manages the liftable objects and operations for an inflight function.
 */
class Lifter {
    constructor(lifts = {}, grants = {}) {
        this.lifts = lifts;
        this.grants = grants;
    }
    /**
     * Add additional liftable objects to the scope of the inflight function.
     * Any existing liftable objects with the same name will be overwritten.
     *
     * Conventionally, this is used by passing in a `const` object to bind it with the same name
     *
     * ```ts
     * const bucket = new cloud.Bucket(app, "Bucket");
     * const number = 5;
     *
     * lift({ bucket, number })
     *   .inflight(({ bucket, number }) => { ... }))
     * ```
     *
     * However, the name is not required to match the variable in the current scope.
     *
     * This is especially useful/necessary when lifting data via a reference or some other expression
     *
     * ```ts
     * const bucket = new cloud.Bucket(app, "Bucket");
     *
     * lift({ bkt: bucket, sum: 2 + 2, field: bucket.field })
     *   .inflight(({ bkt, sum, field }) => { ... }))
     * ```
     */
    lift(captures) {
        return new Lifter({
            ...this.lifts,
            ...captures,
        }, this.grants);
    }
    /**
     * Grant permissions for lifted resources.
     *
     * By default, all all possible methods are granted to lifted resources.
     * This function restricts those:
     *
     * ```ts
     * const bucket = new cloud.Bucket(app, "Bucket");
     *
     * lift({ bucket })
     *   .grant({ bucket: ["get"] })
     *   .inflight(({ bucket }) => {
     *     await bucket.get("key");
     *     await bucket.set("key", "value"); // Error: set is not granted
     *   });
     * ```
     *
     * fields are always accessible, even if not granted.
     */
    grant(grants) {
        return new Lifter(this.lifts, {
            ...this.grants,
            ...grants,
        });
    }
    /**
     * Create an inflight function with the available lifted data.
     *
     * This function must not reference any variables outside of its scope.
     * If needed, use `lift` again to bind variables to the scope of the function.
     * Bound variables will be available as properties on the `ctx` object passed as the first argument to the function.
     *
     * Built-in NodeJS globals are available, such as `console` and `process`.
     * @wing inflight
     */
    inflight(fn) {
        // This is a simplified version of the Wing compiler's _liftMap generation
        // It specifies what transitive permissions need to be added based on what
        // inflight methods are called on an object
        // The SDK models inflight functions as objects with a "handle" property,
        // so here we annotate that "handle" needs all of the required permissions
        const _liftMap = { handle: [] };
        for (const [key, obj] of Object.entries(this.lifts)) {
            const knownOps = this.grants[key] ??
                Object.keys(obj._liftMap ?? {}).filter((x) => x !== lifting_1.INFLIGHT_INIT_METHOD_NAME // filter "$inflight_init"
                );
            _liftMap.handle.push([obj, knownOps]);
        }
        return {
            _id: closureId(),
            _toInflight: () => {
                // Extremely advanced function serialization
                const serializedFunction = fn.toString();
                return `\
(await (async () => {
  const $func = ${serializedFunction}
  const $ctx = {
  ${Object.entries(this.lifts)
                    .map(([name, liftable]) => `${name}: ${(0, lifting_1.liftObject)(liftable)}`)
                    .join(",\n")}
  };
  let newFunction = async (...args) => {
    return $func($ctx, ...args);
  };
  newFunction.handle = newFunction;
  return newFunction;
}
)())`;
            },
            _liftMap,
            // @ts-expect-error This function's type doesn't actually match, but it will just throw anyways
            [types_1.INFLIGHT_SYMBOL]: () => {
                throw new Error("This is a inflight function and can only be invoked while inflight");
            },
        };
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5mbGlnaHQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvY29yZS9pbmZsaWdodC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLCtCQUFnQztBQUNoQyx1Q0FBMkU7QUFDM0UsbUNBS2lCO0FBRWpCLHlDQUE0QztBQUc1QyxJQUFJLFlBQVksR0FBRyxDQUFDLENBQUM7QUFFckIsU0FBZ0IsU0FBUztJQUN2QixPQUFPLFlBQVksRUFBRSxDQUFDO0FBQ3hCLENBQUM7QUFGRCw4QkFFQztBQW1CRDs7R0FFRztBQUNILE1BQWEsY0FBYztJQUN6Qjs7T0FFRztJQUNJLE1BQU0sQ0FBQyxHQUFHLENBQ2YsT0FBZSxFQUNmLFFBQWdCLEVBQ2hCLFdBQW1CLEVBQ25CLElBQWM7UUFFZCxNQUFNLFdBQVcsR0FBRyxPQUFPLENBQUM7UUFDNUIsTUFBTSxZQUFZLEdBQUcsSUFBQSxlQUFRLEVBQUMsUUFBUSxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLFdBQVcsQ0FBQztRQUNwRSxPQUFPLGlCQUFpQixJQUFBLGlCQUFVLEVBQ2hDLEdBQUcsV0FBVyxJQUFJLFlBQVksRUFBRSxDQUNqQyxPQUFPLFdBQVcsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUM7SUFDNUMsQ0FBQztJQUVEOztPQUVHO0lBQ0ksTUFBTSxDQUFDLE9BQU8sQ0FBQyxRQUFnQixFQUFFLFdBQW1CO1FBQ3pELE9BQU8sWUFBWSxJQUFBLGlCQUFVLEVBQUMsUUFBUSxDQUFDLE1BQU0sV0FBVyxFQUFFLENBQUM7SUFDN0QsQ0FBQztJQUVELGdCQUF1QixDQUFDOztBQXhCMUIsd0NBeUJDOzs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0F1Qkc7QUFDSCxTQUFnQixJQUFJLENBQ2xCLFFBQWlCO0lBRWpCLE9BQU8sSUFBSSxNQUFNLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxD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RUFBRTtnQkFDaEIsNENBQTRDO2dCQUM1QyxNQUFNLGtCQUFrQixHQUFHLEVBQUUsQ0FBQyxRQUFRLEVBQUUsQ0FBQztnQkFFekMsT0FBTzs7a0JBRUcsa0JBQWtCOztJQUVoQyxNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUM7cUJBQ3pCLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxHQUFHLElBQUksS0FBSyxJQUFBLG9CQUFVLEVBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQztxQkFDN0QsSUFBSSxDQUFDLEtBQUssQ0FBQzs7Ozs7Ozs7S0FRWCxDQUFDO1lBQ0EsQ0FBQztZQUNELFFBQVE7WUFDUiwrRkFBK0Y7WUFDL0YsQ0FBQyx1QkFBZSxDQUFDLEVBQUUsR0FBRyxFQUFFO2dCQUN0QixNQUFNLElBQUksS0FBSyxDQUNiLG9FQUFvRSxDQUNyRSxDQUFDO1lBQ0osQ0FBQztTQUNGLENBQUM7SUFDSixDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBiYXNlbmFtZSB9IGZyb20gXCJwYXRoXCI7XG5pbXBvcnQgeyBsaWZ0T2JqZWN0LCBMaWZ0TWFwLCBJTkZMSUdIVF9JTklUX01FVEhPRF9OQU1FIH0gZnJvbSBcIi4vbGlmdGluZ1wiO1xuaW1wb3J0IHtcbiAgQXN5bmNGdW5jdGlvbixcbiAgSU5GTElHSFRfU1lNQk9MLFxuICBJbmZsaWdodCxcbiAgT3BlcmF0aW9uc09mLFxufSBmcm9tIFwiLi90eXBlc1wiO1xuaW1wb3J0IHsgTGlmdGFibGVSZWNvcmQsIExpZnRlZE1hcCwgUGlja05vbkZ1bmN0aW9ucyB9IGZyb20gXCIuL3V0aWxpdHktdHlwZXNcIjtcbmltcG9ydCB7IG5vcm1hbFBhdGggfSBmcm9tIFwiLi4vc2hhcmVkL21pc2NcIjtcbmltcG9ydCB0eXBlIHsgSUhvc3RlZExpZnRhYmxlLCBJbXBvcnRJbmZsaWdodE9wdGlvbnMgfSBmcm9tIFwiLi4vc3RkL3Jlc291cmNlXCI7XG5cbmxldCBjbG9zdXJlQ291bnQgPSAwO1xuXG5leHBvcnQgZnVuY3Rpb24gY2xvc3VyZUlkKCk6IG51bWJlciB7XG4gIHJldHVybiBjbG9zdXJlQ291bnQrKztcbn1cblxuZXhwb3J0IHR5cGUgSW5mbGlnaHRCaW5kaW5ncyA9IFJlY29yZDxzdHJpbmcsIEluZmxpZ2h0QmluZGluZz47XG5cbi8qKlxuICogQW4gaW5mbGlnaHQgYmluZGluZy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbmZsaWdodEJpbmRpbmcge1xuICAvKipcbiAgICogVGhlIHJlc291cmNlIG9yIGNhcHR1cmFibGUgdmFsdWUuXG4gICAqL1xuICByZWFkb25seSBvYmo6IGFueTtcblxuICAvKipcbiAgICogVGhlIGxpc3Qgb2Ygb3BlcmF0aW9ucyB1c2VkIG9uIHRoZSByZXNvdXJjZS5cbiAgICovXG4gIHJlYWRvbmx5IG9wcz86IHN0cmluZ1tdO1xufVxuXG4vKipcbiAqIFV0aWxpdHkgY2xhc3Mgd2l0aCBmdW5jdGlvbnMgYWJvdXQgaW5mbGlnaHQgY2xpZW50cy5cbiAqL1xuZXhwb3J0IGNsYXNzIEluZmxpZ2h0Q2xpZW50IHtcbiAgLyoqXG4gICAqIFJldHVybnMgY29kZSBmb3IgY3JlYXRpbmcgYW4gaW5mbGlnaHQgY2xpZW50LlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBmb3IoXG4gICAgZGlybmFtZTogc3RyaW5nLFxuICAgIGZpbGVuYW1lOiBzdHJpbmcsXG4gICAgY2xpZW50Q2xhc3M6IHN0cmluZyxcbiAgICBhcmdzOiBzdHJpbmdbXVxuICApOiBzdHJpbmcge1xuICAgIGNvbnN0IGluZmxpZ2h0RGlyID0gZGlybmFtZTtcbiAgICBjb25zdCBpbmZsaWdodEZpbGUgPSBiYXNlbmFtZShmaWxlbmFtZSkuc3BsaXQoXCIuXCIpWzBdICsgXCIuaW5mbGlnaHRcIjtcbiAgICByZXR1cm4gYG5ldyAocmVxdWlyZShcIiR7bm9ybWFsUGF0aChcbiAgICAgIGAke2luZmxpZ2h0RGlyfS8ke2luZmxpZ2h0RmlsZX1gXG4gICAgKX1cIikpLiR7Y2xpZW50Q2xhc3N9KCR7YXJncy5qb2luKFwiLCBcIil9KWA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBjb2RlIGZvciBpbXBsZW1lbnRpbmcgYF90b0luZmxpZ2h0VHlwZSgpYC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZm9yVHlwZShmaWxlbmFtZTogc3RyaW5nLCBjbGllbnRDbGFzczogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYHJlcXVpcmUoXCIke25vcm1hbFBhdGgoZmlsZW5hbWUpfVwiKS4ke2NsaWVudENsYXNzfWA7XG4gIH1cblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge31cbn1cblxuLyoqXG4gKiBQcmVwYXJlcyBwcmVmbGlnaHQgb2JqZWN0cyBmb3IgdXNlIGluIGluZmxpZ2h0IGZ1bmN0aW9ucy5cbiAqXG4gKiBDb252ZW50aW9uYWxseSwgdGhpcyBpcyB1c2VkIGJ5IHBhc3NpbmcgaW4gYSBgY29uc3RgIG9iamVjdCB0byBiaW5kIGl0IHdpdGggdGhlIHNhbWUgbmFtZVxuICpcbiAqIGBgYHRzXG4gKiBjb25zdCBidWNrZXQgPSBuZXcgY2xvdWQuQnVja2V0KGFwcCwgXCJCdWNrZXRcIik7XG4gKiBjb25zdCBudW1iZXIgPSA1O1xuICpcbiAqIGxpZnQoeyBidWNrZXQsIG51bWJlciB9KVxuICogICAuaW5mbGlnaHQoKHsgYnVja2V0LCBudW1iZXIgfSkgPT4geyAuLi4gfSkpXG4gKiBgYGBcbiAqXG4gKiBIb3dldmVyLCB0aGUgbmFtZSBpcyBub3QgcmVxdWlyZWQgdG8gbWF0Y2ggdGhlIHZhcmlhYmxlIGluIHRoZSBjdXJyZW50IHNjb3BlLlxuICpcbiAqIFRoaXMgaXMgZXNwZWNpYWxseSB1c2VmdWwvbmVjZXNzYXJ5IHdoZW4gbGlmdGluZyBkYXRhIHZpYSBhIHJlZmVyZW5jZSBvciBzb21lIG90aGVyIGV4cHJlc3Npb25cbiAqXG4gKiBgYGB0c1xuICogY29uc3QgYnVja2V0ID0gbmV3IGNsb3VkLkJ1Y2tldChhcHAsIFwiQnVja2V0XCIpO1xuICpcbiAqIGxpZnQoeyBia3Q6IGJ1Y2tldCwgc3VtOiAyICsgMiwgZmllbGQ6IGJ1Y2tldC5maWVsZCB9KVxuICogICAuaW5mbGlnaHQoKHsgYmt0LCBzdW0sIGZpZWxkIH0pID0+IHsgLi4uIH0pKVxuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaWZ0PFRUb0xpZnQgZXh0ZW5kcyBMaWZ0YWJsZVJlY29yZD4oXG4gIGNhcHR1cmVzOiBUVG9MaWZ0XG4pOiBMaWZ0ZXI8TGlmdGVkTWFwPFRUb0xpZnQ+LCB7fT4ge1xuICByZXR1cm4gbmV3IExpZnRlcigpLmxpZnQoY2FwdHVyZXMpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBpbmZsaWdodCBmdW5jdGlvbi5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIG11c3Qgbm90IHJlZmVyZW5jZSBhbnkgdmFyaWFibGVzIG91dHNpZGUgb2YgaXRzIHNjb3BlLlxuICogSWYgbmVlZGVkLCB1c2UgYGxpZnRgIHRvIGJpbmQgdmFyaWFibGVzIHRvIHRoZSBzY29wZSBvZiB0aGUgZnVuY3Rpb24uXG4gKlxuICogQnVpbHQtaW4gTm9kZUpTIGdsb2JhbHMgYXJlIGF2YWlsYWJsZSwgc3VjaCBhcyBgY29uc29sZWAgYW5kIGBwcm9jZXNzYC5cbiAqIEB3aW5nIGluZmxpZ2h0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmZsaWdodDxURnVuY3Rpb24gZXh0ZW5kcyBBc3luY0Z1bmN0aW9uPihcbiAgZm46IChjdHg6IHt9LCAuLi5hcmdzOiBQYXJhbWV0ZXJzPFRGdW5jdGlvbj4pID0+IFJldHVyblR5cGU8VEZ1bmN0aW9uPlxuKSB7XG4gIHJldHVybiBuZXcgTGlmdGVyKCkuaW5mbGlnaHQoZm4pO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBpbmZsaWdodCBmdW5jdGlvbiBmcm9tIGEgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW1wb3J0SW5mbGlnaHQoXG4gIC8qKlxuICAgKiBSYXcgSmF2YVNjcmlwdCB0byB1c2UgYXMgdGhlIGluZmxpZ2h0IGZ1bmN0aW9uLlxuICAgKi9cbiAgaW5mbGlnaHRUZXh0OiBzdHJpbmcsXG5cbiAgLyoqXG4gICAqIFRoZSBsaWZ0cyB0aGUgSlMgbmVlZHMgdG8gYmUgYWJsZSB0byBhY2Nlc3MuXG4gICAqL1xuICBsaWZ0cz86IEltcG9ydEluZmxpZ2h0T3B0aW9uc1tcImxpZnRzXCJdXG4pIHtcbiAgY29uc3QgbmV3TGlmdHM6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fTtcbiAgY29uc3QgbmV3R3JhbnRzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXT4gPSB7fTtcblxuICAvLyBjb252ZXJ0IHRoZSBsaWZ0cyB0byB0aGUgY29ycmVjdCBmb3JtYXQgZm9yIHRoZSBMaWZ0ZXJcbiAgZm9yIChjb25zdCBsaWZ0QW5ub3RhdGlvbiBvZiBsaWZ0cyA/PyBbXSkge1xuICAgIGlmIChsaWZ0QW5ub3RhdGlvbi5hbGlhcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYWxpYXMgZmllbGQgaXMgcmVxdWlyZWQgZm9yIGFsbCBsaWZ0c1wiKTtcbiAgICB9XG5cbiAgICBuZXdMaWZ0c1tsaWZ0QW5ub3RhdGlvbi5hbGlhc10gPSBsaWZ0QW5ub3RhdGlvbi5vYmo7XG4gICAgaWYgKGxpZnRBbm5vdGF0aW9uLm9wcykge1xuICAgICAgbmV3R3JhbnRzW2xpZnRBbm5vdGF0aW9uLmFsaWFzXSA9IGxpZnRBbm5vdGF0aW9uLm9wcztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gKFxuICAgIGxpZnQobmV3TGlmdHMpXG4gICAgICAuZ3JhbnQobmV3R3JhbnRzKVxuICAgICAgLy8gY2FzdCBhcyBhbnkgYmVjYXVzZSB0aGUgaW5mbGlnaHQgaGFzIGFscmVhZHkgYmVlbiBwcmUtc2VyaWFsaXplZFxuICAgICAgLmluZmxpZ2h0KGluZmxpZ2h0VGV4dCBhcyBhbnkpXG4gICk7XG59XG5cbi8qKlxuICogTWFuYWdlcyB0aGUgbGlmdGFibGUgb2JqZWN0cyBhbmQgb3BlcmF0aW9ucyBmb3IgYW4gaW5mbGlnaHQgZnVuY3Rpb24uXG4gKi9cbmNsYXNzIExpZnRlcjxcbiAgVExpZnRlZCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIGFueT4sXG4gIFRPcGVyYXRpb25zIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgc3RyaW5nW10+XG4+IHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBsaWZ0czogTGlmdGFibGVSZWNvcmQgPSB7fSxcbiAgICBwcml2YXRlIGdyYW50czogUmVjb3JkPHN0cmluZywgc3RyaW5nW10+ID0ge31cbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBBZGQgYWRkaXRpb25hbCBsaWZ0YWJsZSBvYmplY3RzIHRvIHRoZSBzY29wZSBvZiB0aGUgaW5mbGlnaHQgZnVuY3Rpb24uXG4gICAqIEFueSBleGlzdGluZyBsaWZ0YWJsZSBvYmplY3RzIHdpdGggdGhlIHNhbWUgbmFtZSB3aWxsIGJlIG92ZXJ3cml0dGVuLlxuICAgKlxuICAgKiBDb252ZW50aW9uYWxseSwgdGhpcyBpcyB1c2VkIGJ5IHBhc3NpbmcgaW4gYSBgY29uc3RgIG9iamVjdCB0byBiaW5kIGl0IHdpdGggdGhlIHNhbWUgbmFtZVxuICAgKlxuICAgKiBgYGB0c1xuICAgKiBjb25zdCBidWNrZXQgPSBuZXcgY2xvdWQuQnVja2V0KGFwcCwgXCJCdWNrZXRcIik7XG4gICAqIGNvbnN0IG51bWJlciA9IDU7XG4gICAqXG4gICAqIGxpZnQoeyBidWNrZXQsIG51bWJlciB9KVxuICAgKiAgIC5pbmZsaWdodCgoeyBidWNrZXQsIG51bWJlciB9KSA9PiB7IC4uLiB9KSlcbiAgICogYGBgXG4gICAqXG4gICAqIEhvd2V2ZXIsIHRoZSBuYW1lIGlzIG5vdCByZXF1aXJlZCB0byBtYXRjaCB0aGUgdmFyaWFibGUgaW4gdGhlIGN1cnJlbnQgc2NvcGUuXG4gICAqXG4gICAqIFRoaXMgaXMgZXNwZWNpYWxseSB1c2VmdWwvbmVjZXNzYXJ5IHdoZW4gbGlmdGluZyBkYXRhIHZpYSBhIHJlZmVyZW5jZSBvciBzb21lIG90aGVyIGV4cHJlc3Npb25cbiAgICpcbiAgICogYGBgdHNcbiAgICogY29uc3QgYnVja2V0ID0gbmV3IGNsb3VkLkJ1Y2tldChhcHAsIFwiQnVja2V0XCIpO1xuICAgKlxuICAgKiBsaWZ0KHsgYmt0OiBidWNrZXQsIHN1bTogMiArIDIsIGZpZWxkOiBidWNrZXQuZmllbGQgfSlcbiAgICogICAuaW5mbGlnaHQoKHsgYmt0LCBzdW0sIGZpZWxkIH0pID0+IHsgLi4uIH0pKVxuICAgKiBgYGBcbiAgICovXG4gIHB1YmxpYyBsaWZ0PFRXaWxsTGlmdCBleHRlbmRzIExpZnRhYmxlUmVjb3JkPihjYXB0dXJlczogVFdpbGxMaWZ0KSB7XG4gICAgcmV0dXJuIG5ldyBMaWZ0ZXI8XG4gICAgICBPbWl0PFRMaWZ0ZWQsIGtleW9mIFRXaWxsTGlmdD4gJiBMaWZ0ZWRNYXA8VFdpbGxMaWZ0PixcbiAgICAgIFRPcGVyYXRpb25zXG4gICAgPihcbiAgICAgIHtcbiAgICAgICAgLi4udGhpcy5saWZ0cyxcbiAgICAgICAgLi4uY2FwdHVyZXMsXG4gICAgICB9LFxuICAgICAgdGhpcy5ncmFudHNcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdyYW50IHBlcm1pc3Npb25zIGZvciBsaWZ0ZWQgcmVzb3VyY2VzLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBhbGwgYWxsIHBvc3NpYmxlIG1ldGhvZHMgYXJlIGdyYW50ZWQgdG8gbGlmdGVkIHJlc291cmNlcy5cbiAgICogVGhpcyBmdW5jdGlvbiByZXN0cmljdHMgdGhvc2U6XG4gICAqXG4gICAqIGBgYHRzXG4gICAqIGNvbnN0IGJ1Y2tldCA9IG5ldyBjbG91ZC5CdWNrZXQoYXBwLCBcIkJ1Y2tldFwiKTtcbiAgICpcbiAgICogbGlmdCh7IGJ1Y2tldCB9KVxuICAgKiAgIC5ncmFudCh7IGJ1Y2tldDogW1wiZ2V0XCJdIH0pXG4gICAqICAgLmluZmxpZ2h0KCh7IGJ1Y2tldCB9KSA9PiB7XG4gICAqICAgICBhd2FpdCBidWNrZXQuZ2V0KFwia2V5XCIpO1xuICAgKiAgICAgYXdhaXQgYnVja2V0LnNldChcImtleVwiLCBcInZhbHVlXCIpOyAvLyBFcnJvcjogc2V0IGlzIG5vdCBncmFudGVkXG4gICAqICAgfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBmaWVsZHMgYXJlIGFsd2F5cyBhY2Nlc3NpYmxlLCBldmVuIGlmIG5vdCBncmFudGVkLlxuICAgKi9cbiAgcHVibGljIGdyYW50PFxuICAgIFROZXdPcHMgZXh0ZW5kcyBQYXJ0aWFsPHtcbiAgICAgIFtLIGluIGtleW9mIFRMaWZ0ZWRdOiBPcGVyYXRpb25zT2Y8VExpZnRlZFtLXT47XG4gICAgfT5cbiAgPihncmFudHM6IFROZXdPcHMpIHtcbiAgICByZXR1cm4gbmV3IExpZnRlcjxUTGlmdGVkLCBPbWl0PFRPcGVyYXRpb25zLCBrZXlvZiBUTmV3T3BzPiAmIFROZXdPcHM+KFxuICAgICAgdGhpcy5saWZ0cyxcbiAgICAgIHtcbiAgICAgICAgLi4udGhpcy5ncmFudHMsXG4gICAgICAgIC4uLmdyYW50cyxcbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbmZsaWdodCBmdW5jdGlvbiB3aXRoIHRoZSBhdmFpbGFibGUgbGlmdGVkIGRhdGEuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gbXVzdCBub3QgcmVmZXJlbmNlIGFueSB2YXJpYWJsZXMgb3V0c2lkZSBvZiBpdHMgc2NvcGUuXG4gICAqIElmIG5lZWRlZCwgdXNlIGBsaWZ0YCBhZ2FpbiB0byBiaW5kIHZhcmlhYmxlcyB0byB0aGUgc2NvcGUgb2YgdGhlIGZ1bmN0aW9uLlxuICAgKiBCb3VuZCB2YXJpYWJsZXMgd2lsbCBiZSBhdmFpbGFibGUgYXMgcHJvcGVydGllcyBvbiB0aGUgYGN0eGAgb2JqZWN0IHBhc3NlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBCdWlsdC1pbiBOb2RlSlMgZ2xvYmFscyBhcmUgYXZhaWxhYmxlLCBzdWNoIGFzIGBjb25zb2xlYCBhbmQgYHByb2Nlc3NgLlxuICAgKiBAd2luZyBpbmZsaWdodFxuICAgKi9cbiAgcHVibGljIGluZmxpZ2h0PFRGdW5jdGlvbiBleHRlbmRzIEFzeW5jRnVuY3Rpb24+KFxuICAgIGZuOiAoXG4gICAgICAvKiogQWxsIGxpZnRlZCBkYXRhIGF2YWlsYWJsZSBpbiB0aGlzIGluZmxpZ2h0ICovXG4gICAgICBjdHg6IC8vIEdldCBhbGwgdGhlIGxpZnRlZCB0eXBlcyB3aGljaCB3ZXJlIG5vdCBleHBsaWNpdGx5IGdyYW50ZWRcbiAgICAgIE9taXQ8VExpZnRlZCwga2V5b2YgVE9wZXJhdGlvbnM+ICYge1xuICAgICAgICAvLyBGb3IgZWFjaCBvZiB0aGUgZ3JhbnRlZCB0eXBlcywgZ2V0IHRoZSBsaWZ0ZWQgdHlwZSB3aXRoIG9ubHkgdGhlIGdyYW50ZWQgb3BlcmF0aW9ucyBhdmFpbGFibGUgKGFuZCBhbnkgZmllbGRzIGFzIHdlbGwpXG4gICAgICAgIFtLIGluIGtleW9mIFRPcGVyYXRpb25zICZcbiAgICAgICAgICBrZXlvZiBUTGlmdGVkXTogVE9wZXJhdGlvbnNbS10gZXh0ZW5kcyAoaW5mZXIgVEdyYW50ZWRPcHMgZXh0ZW5kcyBrZXlvZiBUTGlmdGVkW0tdKVtdXG4gICAgICAgICAgPyBQaWNrTm9uRnVuY3Rpb25zPFRMaWZ0ZWRbS10+ICYgUGljazxUTGlmdGVkW0tdLCBUR3JhbnRlZE9wcz5cbiAgICAgICAgICA6IFRMaWZ0ZWRbS107XG4gICAgICB9LFxuICAgICAgLi4uYXJnczogUGFyYW1ldGVyczxURnVuY3Rpb24+XG4gICAgKSA9PiBSZXR1cm5UeXBlPFRGdW5jdGlvbj5cbiAgKTogSW5mbGlnaHQ8VEZ1bmN0aW9uPiB7XG4gICAgLy8gVGhpcyBpcyBhIHNpbXBsaWZpZWQgdmVyc2lvbiBvZiB0aGUgV2luZyBjb21waWxlcidzIF9saWZ0TWFwIGdlbmVyYXRpb25cbiAgICAvLyBJdCBzcGVjaWZpZXMgd2hhdCB0cmFuc2l0aXZlIHBlcm1pc3Npb25zIG5lZWQgdG8gYmUgYWRkZWQgYmFzZWQgb24gd2hhdFxuICAgIC8vIGluZmxpZ2h0IG1ldGhvZHMgYXJlIGNhbGxlZCBvbiBhbiBvYmplY3RcbiAgICAvLyBUaGUgU0RLIG1vZGVscyBpbmZsaWdodCBmdW5jdGlvbnMgYXMgb2JqZWN0cyB3aXRoIGEgXCJoYW5kbGVcIiBwcm9wZXJ0eSxcbiAgICAvLyBzbyBoZXJlIHdlIGFubm90YXRlIHRoYXQgXCJoYW5kbGVcIiBuZWVkcyBhbGwgb2YgdGhlIHJlcXVpcmVkIHBlcm1pc3Npb25zXG4gICAgY29uc3QgX2xpZnRNYXA6IExpZnRNYXAgPSB7IGhhbmRsZTogW10gfTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIG9ial0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5saWZ0cykpIHtcbiAgICAgIGNvbnN0IGtub3duT3BzID1cbiAgICAgICAgdGhpcy5ncmFudHNba2V5XSA/P1xuICAgICAgICBPYmplY3Qua2V5cygob2JqIGFzIElIb3N0ZWRMaWZ0YWJsZSkuX2xpZnRNYXAgPz8ge30pLmZpbHRlcihcbiAgICAgICAgICAoeCkgPT4geCAhPT0gSU5GTElHSFRfSU5JVF9NRVRIT0RfTkFNRSAvLyBmaWx0ZXIgXCIkaW5mbGlnaHRfaW5pdFwiXG4gICAgICAgICk7XG5cbiAgICAgIF9saWZ0TWFwLmhhbmRsZS5wdXNoKFtvYmosIGtub3duT3BzXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIF9pZDogY2xvc3VyZUlkKCksXG4gICAgICBfdG9JbmZsaWdodDogKCkgPT4ge1xuICAgICAgICAvLyBFeHRyZW1lbHkgYWR2YW5jZWQgZnVuY3Rpb24gc2VyaWFsaXphdGlvblxuICAgICAgICBjb25zdCBzZXJpYWxpemVkRnVuY3Rpb24gPSBmbi50b1N0cmluZygpO1xuXG4gICAgICAgIHJldHVybiBgXFxcbihhd2FpdCAoYXN5bmMgKCkgPT4ge1xuICBjb25zdCAkZnVuYyA9ICR7c2VyaWFsaXplZEZ1bmN0aW9ufVxuICBjb25zdCAkY3R4ID0ge1xuICAke09iamVjdC5lbnRyaWVzKHRoaXMubGlmdHMpXG4gICAgLm1hcCgoW25hbWUsIGxpZnRhYmxlXSkgPT4gYCR7bmFtZX06ICR7bGlmdE9iamVjdChsaWZ0YWJsZSl9YClcbiAgICAuam9pbihcIixcXG5cIil9XG4gIH07XG4gIGxldCBuZXdGdW5jdGlvbiA9IGFzeW5jICguLi5hcmdzKSA9PiB7XG4gICAgcmV0dXJuICRmdW5jKCRjdHgsIC4uLmFyZ3MpO1xuICB9O1xuICBuZXdGdW5jdGlvbi5oYW5kbGUgPSBuZXdGdW5jdGlvbjtcbiAgcmV0dXJuIG5ld0Z1bmN0aW9uO1xufVxuKSgpKWA7XG4gICAgICB9LFxuICAgICAgX2xpZnRNYXAsXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRoaXMgZnVuY3Rpb24ncyB0eXBlIGRvZXNuJ3QgYWN0dWFsbHkgbWF0Y2gsIGJ1dCBpdCB3aWxsIGp1c3QgdGhyb3cgYW55d2F5c1xuICAgICAgW0lORkxJR0hUX1NZTUJPTF06ICgpID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiVGhpcyBpcyBhIGluZmxpZ2h0IGZ1bmN0aW9uIGFuZCBjYW4gb25seSBiZSBpbnZva2VkIHdoaWxlIGluZmxpZ2h0XCJcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxufVxuIl19