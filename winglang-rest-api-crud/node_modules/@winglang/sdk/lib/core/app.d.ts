import { Construct, IConstruct } from "constructs";
import { ParameterRegistrar } from "../platform";
import { APP_SYMBOL, IApp } from "../std/node";
import { TestRunner } from "../std/test-runner";
/**
 * Props for all `App` classes.
 */
export interface AppProps {
    /**
     * Directory where artifacts are synthesized to.
     * @default - current working directory
     */
    readonly outdir?: string;
    /**
     * The name of the app.
     * @default "app"
     */
    readonly name?: string;
    /**
     * The root construct class that should be instantiated with a scope and id.
     * If provided, then it will be instantiated on the user's behalf.
     * When the app is synthesized with `isTestEnvironment` set to `true`, then
     * one instance of the root construct will be created per test; otherwise,
     * it will be created exactly once.
     * @default - no root construct
     */
    readonly rootConstruct?: any;
    /**
     * Whether or not this app is being synthesized into a test environment.
     * @default false
     */
    readonly isTestEnvironment?: boolean;
    /**
     *  The absolute directory location for the wing entry point file
     */
    readonly entrypointDir: string;
    /**
     *  The App root id
     * @default Default
     */
    readonly rootId?: string;
    /**
     * Hooks to be called at various stages of the synthesis process.
     * @default - no hooks
     */
    readonly synthHooks?: SynthHooks;
    /**
     * Hooks for overriding newInstance calls
     * @default - []
     */
    readonly newInstanceOverrides?: any[];
    /**
     * ParameterRegistrar of composed platforms
     * @default - undefined
     */
    readonly platformParameterRegistrar?: ParameterRegistrar;
}
/**
 * Hooks for the synthesis process.
 */
export interface SynthHooks {
    /**
     * Hooks to be called before synthesizing the app.
     */
    readonly preSynthesize?: any[];
    /**
     * Hooks to be called after synthesizing the app.
     */
    readonly postSynthesize?: any[];
    /**
     * Hooks to be called for validating the synthesized configuration.
     */
    readonly validate?: any[];
}
/**
 * A Wing application.
 */
export declare abstract class App extends Construct implements IApp {
    /**
     * Returns the root app.
     */
    static of(scope: Construct): App;
    /** @internal */
    readonly [APP_SYMBOL] = true;
    /**
     * The name of the compilation target.
     * @internal
     */
    abstract readonly _target: "sim" | "tf-aws" | "tf-azure" | "tf-gcp" | "awscdk";
    /**
     * Wing source files directory absolute path
     */
    readonly entrypointDir: string;
    /**
     * Used in `makeId` to keep track of known IDs
     */
    private readonly _idCounters;
    /**
     * The output directory.
     */
    abstract readonly outdir: string;
    /**
     * Whether or not this app is being synthesized into a test environment.
     */
    readonly isTestEnvironment: boolean;
    /**
     * NewInstance hooks for defining resource implementations.
     * @internal
     */
    readonly _newInstanceOverrides: any[];
    /**
     * The test runner for this app. Only created if `isTestEnvironment` is true.
     * @internal
     */
    _testRunner: TestRunner | undefined;
    /**
     * SynthHooks hooks of dependent platforms
     * @internal
     */
    protected _synthHooks?: SynthHooks;
    /**
     * Parameter registrar of composed platforms
     * @internal
     */
    protected _parameters?: ParameterRegistrar;
    constructor(scope: Construct, id: string, props: AppProps);
    /**
     * The ".wing" directory, which is where the compiler emits its output. We are taking an implicit
     * assumption here that it is always set to be `$outdir/.wing` which is currently hard coded into
     * the `cli/compile.ts` file.
     */
    get workdir(): string;
    /**
     * The parameter registrar for the app, can be used to find and register
     * parameter values that were provided to the wing application.
     */
    get parameters(): ParameterRegistrar;
    /**
     * Synthesize the app into an artifact.
     */
    abstract synth(): string;
    /**
     * Creates a new object of the given FQN.
     * @param fqn the fqn of the class to instantiate
     * @param ctor the constructor of the class to instantiate (undefined for abstract classes)
     * @param scope the scope of the resource
     * @param id the id of the resource
     * @param args the arguments to pass to the resource
     * @returns the new instance
     * @throws if the FQN is not supported
     */
    new(fqn: string, ctor: any, scope: Construct, id: string, ...args: any[]): any;
    /**
     * Creates a new object of the given abstract class FQN.
     */
    newAbstract(fqn: string, scope: Construct, id: string, ...args: any[]): any;
    makeId(scope: IConstruct, prefix?: string): string;
    /**
     * Can be overridden by derived classes to inject dependencies.
     *
     * @param fqn The fully qualified name of the class we want the type for (jsii).
     *
     * @returns The dependency injected specific target type for the given FQN, or undefined if not found.
     */
    protected typeForFqn(fqn: string): any;
    /**
     * Can be overridden by derived classes to inject dependencies.
     *
     * @param fqn The fully qualified name of the class to instantiate (jsii).
     * @param scope The construct scope.
     * @param id The construct id.
     * @param args The arguments to pass to the constructor.
     */
    private tryNew;
}
export declare function preSynthesizeAllConstructs(app: App): void;
