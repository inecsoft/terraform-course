import { AsyncFunction, Inflight, OperationsOf } from "./types";
import { LiftableRecord, LiftedMap, PickNonFunctions } from "./utility-types";
import type { ImportInflightOptions } from "../std/resource";
export declare function closureId(): number;
export type InflightBindings = Record<string, InflightBinding>;
/**
 * An inflight binding.
 */
export interface InflightBinding {
    /**
     * The resource or capturable value.
     */
    readonly obj: any;
    /**
     * The list of operations used on the resource.
     */
    readonly ops?: string[];
}
/**
 * Utility class with functions about inflight clients.
 */
export declare class InflightClient {
    /**
     * Returns code for creating an inflight client.
     */
    static for(dirname: string, filename: string, clientClass: string, args: string[]): string;
    /**
     * Returns code for implementing `_toInflightType()`.
     */
    static forType(filename: string, clientClass: string): string;
    private constructor();
}
/**
 * Prepares preflight objects for use in inflight functions.
 *
 * Conventionally, this is used by passing in a `const` object to bind it with the same name
 *
 * ```ts
 * const bucket = new cloud.Bucket(app, "Bucket");
 * const number = 5;
 *
 * lift({ bucket, number })
 *   .inflight(({ bucket, number }) => { ... }))
 * ```
 *
 * However, the name is not required to match the variable in the current scope.
 *
 * This is especially useful/necessary when lifting data via a reference or some other expression
 *
 * ```ts
 * const bucket = new cloud.Bucket(app, "Bucket");
 *
 * lift({ bkt: bucket, sum: 2 + 2, field: bucket.field })
 *   .inflight(({ bkt, sum, field }) => { ... }))
 * ```
 */
export declare function lift<TToLift extends LiftableRecord>(captures: TToLift): Lifter<LiftedMap<TToLift>, {}>;
/**
 * Creates a inflight function.
 *
 * This function must not reference any variables outside of its scope.
 * If needed, use `lift` to bind variables to the scope of the function.
 *
 * Built-in NodeJS globals are available, such as `console` and `process`.
 * @wing inflight
 */
export declare function inflight<TFunction extends AsyncFunction>(fn: (ctx: {}, ...args: Parameters<TFunction>) => ReturnType<TFunction>): Inflight<TFunction>;
/**
 * Create an inflight function from a string.
 */
export declare function importInflight(
/**
 * Raw JavaScript to use as the inflight function.
 */
inflightText: string, 
/**
 * The lifts the JS needs to be able to access.
 */
lifts?: ImportInflightOptions["lifts"]): Inflight<AsyncFunction>;
/**
 * Manages the liftable objects and operations for an inflight function.
 */
declare class Lifter<TLifted extends Record<string, any>, TOperations extends Record<string, string[]>> {
    private lifts;
    private grants;
    constructor(lifts?: LiftableRecord, grants?: Record<string, string[]>);
    /**
     * Add additional liftable objects to the scope of the inflight function.
     * Any existing liftable objects with the same name will be overwritten.
     *
     * Conventionally, this is used by passing in a `const` object to bind it with the same name
     *
     * ```ts
     * const bucket = new cloud.Bucket(app, "Bucket");
     * const number = 5;
     *
     * lift({ bucket, number })
     *   .inflight(({ bucket, number }) => { ... }))
     * ```
     *
     * However, the name is not required to match the variable in the current scope.
     *
     * This is especially useful/necessary when lifting data via a reference or some other expression
     *
     * ```ts
     * const bucket = new cloud.Bucket(app, "Bucket");
     *
     * lift({ bkt: bucket, sum: 2 + 2, field: bucket.field })
     *   .inflight(({ bkt, sum, field }) => { ... }))
     * ```
     */
    lift<TWillLift extends LiftableRecord>(captures: TWillLift): Lifter<Omit<TLifted, keyof TWillLift> & LiftedMap<TWillLift>, TOperations>;
    /**
     * Grant permissions for lifted resources.
     *
     * By default, all all possible methods are granted to lifted resources.
     * This function restricts those:
     *
     * ```ts
     * const bucket = new cloud.Bucket(app, "Bucket");
     *
     * lift({ bucket })
     *   .grant({ bucket: ["get"] })
     *   .inflight(({ bucket }) => {
     *     await bucket.get("key");
     *     await bucket.set("key", "value"); // Error: set is not granted
     *   });
     * ```
     *
     * fields are always accessible, even if not granted.
     */
    grant<TNewOps extends Partial<{
        [K in keyof TLifted]: OperationsOf<TLifted[K]>;
    }>>(grants: TNewOps): Lifter<TLifted, Omit<TOperations, keyof TNewOps> & TNewOps>;
    /**
     * Create an inflight function with the available lifted data.
     *
     * This function must not reference any variables outside of its scope.
     * If needed, use `lift` again to bind variables to the scope of the function.
     * Bound variables will be available as properties on the `ctx` object passed as the first argument to the function.
     *
     * Built-in NodeJS globals are available, such as `console` and `process`.
     * @wing inflight
     */
    inflight<TFunction extends AsyncFunction>(fn: (
    /** All lifted data available in this inflight */
    ctx: // Get all the lifted types which were not explicitly granted
    Omit<TLifted, keyof TOperations> & {
        [K in keyof TOperations & keyof TLifted]: TOperations[K] extends (infer TGrantedOps extends keyof TLifted[K])[] ? PickNonFunctions<TLifted[K]> & Pick<TLifted[K], TGrantedOps> : TLifted[K];
    }, ...args: Parameters<TFunction>) => ReturnType<TFunction>): Inflight<TFunction>;
}
export {};
