"use strict";
var _a, _b;
Object.defineProperty(exports, "__esModule", { value: true });
exports.DependencyVertex = exports.DependencyGraph = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
// This file is copied from
// https://github.com/cdk8s-team/cdk8s-core/blob/2.x/src/dependency.ts
const constructs_1 = require("constructs");
/**
 * Represents the dependency graph for a given Node.
 *
 * This graph includes the dependency relationships between all nodes in the
 * node (construct) sub-tree who's root is this Node.
 *
 * Note that this means that lonely nodes (no dependencies and no dependants) are also included in this graph as
 * childless children of the root node of the graph.
 *
 * The graph does not include cross-scope dependencies. That is, if a child on the current scope depends on a node
 * from a different scope, that relationship is not represented in this graph.
 *
 */
class DependencyGraph {
    constructor(node) {
        this._fosterParent = new DependencyVertex();
        const nodes = {};
        function putVertex(construct) {
            nodes[constructs_1.Node.of(construct).path] = new DependencyVertex(construct);
        }
        function getVertex(construct) {
            return nodes[constructs_1.Node.of(construct).path];
        }
        // create all vertices of the graph.
        for (const n of node.findAll()) {
            putVertex(n);
        }
        const deps = [];
        for (const child of node.findAll()) {
            for (const dep of child.node.dependencies) {
                deps.push({ source: child, target: dep });
            }
        }
        // create all the edges of the graph.
        for (const dep of deps) {
            if (!getVertex(dep.target)) {
                // dont cross scope boundaries.
                // since charts only renders its own children, this is ok and
                // has the benefit of simplifying the graph. we should reconsider this behavior when moving
                // to a more general purpose use-case.
                continue;
            }
            const sourceDepNode = getVertex(dep.source);
            const targetDepNode = getVertex(dep.target);
            sourceDepNode.addChild(targetDepNode);
        }
        // create the root.
        for (const n of Object.values(nodes)) {
            if (n.inbound.length === 0) {
                // orphans are dependency roots. lets adopt them!
                this._fosterParent.addChild(n);
            }
        }
    }
    /**
     * Returns the root of the graph.
     *
     * Note that this vertex will always have `null` as its `.value` since it is an artifical root
     * that binds all the connected spaces of the graph.
     */
    get root() {
        return this._fosterParent;
    }
    /**
     * Returns a topologically sorted array of the constructs in the sub-graph.
     */
    topology() {
        return this._fosterParent.topology();
    }
}
exports.DependencyGraph = DependencyGraph;
_a = JSII_RTTI_SYMBOL_1;
DependencyGraph[_a] = { fqn: "@winglang/sdk.core.DependencyGraph", version: "0.0.0" };
/**
 * Represents a vertex in the graph.
 *
 * The value of each vertex is an `IConstruct` that is accessible via the `.value` getter.
 */
class DependencyVertex {
    constructor(value = undefined) {
        this._children = new Set();
        this._parents = new Set();
        this._value = value;
    }
    /**
     * Returns the IConstruct this graph vertex represents.
     *
     * `null` in case this is the root of the graph.
     */
    get value() {
        return this._value;
    }
    /**
     * Returns the children of the vertex (i.e dependencies)
     */
    get outbound() {
        return Array.from(this._children);
    }
    /**
     * Returns the parents of the vertex (i.e dependants)
     */
    get inbound() {
        return Array.from(this._parents);
    }
    /**
     * Returns a topologically sorted array of the constructs in the sub-graph.
     */
    topology() {
        const found = new Set();
        const topology = [];
        function visit(n) {
            for (const c of n.outbound) {
                visit(c);
            }
            if (!found.has(n)) {
                topology.push(n);
                found.add(n);
            }
        }
        visit(this);
        return topology.filter((d) => d.value).map((d) => d.value);
    }
    /**
     * Adds a vertex as a dependency of the current node.
     * Also updates the parents of `dep`, so that it contains this node as a parent.
     *
     * This operation will fail in case it creates a cycle in the graph.
     *
     * @param dep The dependency
     */
    addChild(dep) {
        const cycle = dep.findRoute(this);
        if (cycle.length !== 0) {
            cycle.push(dep);
            throw new Error(`Dependency cycle detected: ${cycle
                .filter((d) => d.value)
                .map((d) => constructs_1.Node.of(d.value).path)
                .join(" => ")}`);
        }
        this._children.add(dep);
        dep.addParent(this);
    }
    addParent(dep) {
        this._parents.add(dep);
    }
    findRoute(dst) {
        const route = [];
        visit(this);
        return route;
        function visit(n) {
            route.push(n);
            let found = false;
            for (const c of n.outbound) {
                if (c === dst) {
                    route.push(c);
                    return true;
                }
                found = visit(c);
            }
            if (!found) {
                route.pop();
            }
            return found;
        }
    }
}
exports.DependencyVertex = DependencyVertex;
_b = JSII_RTTI_SYMBOL_1;
DependencyVertex[_b] = { fqn: "@winglang/sdk.core.DependencyVertex", version: "0.0.0" };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVwZW5kZW5jeS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb3JlL2RlcGVuZGVuY3kudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSwyQkFBMkI7QUFDM0Isc0VBQXNFO0FBQ3RFLDJDQUE4QztBQUU5Qzs7Ozs7Ozs7Ozs7O0dBWUc7QUFDSCxNQUFhLGVBQWU7SUFHMUIsWUFBWSxJQUFVO1FBQ3BCLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxnQkFBZ0IsRUFBRSxDQUFDO1FBRTVDLE1BQU0sS0FBSyxHQUFxQyxFQUFFLENBQUM7UUFFbkQsU0FBUyxTQUFTLENBQUMsU0FBcUI7WUFDdEMsS0FBSyxDQUFDLGlCQUFJLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksZ0JBQWdCLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDbkUsQ0FBQztRQUVELFNBQVMsU0FBUyxDQUFDLFNBQXFCO1lBQ3RDLE9BQU8sS0FBSyxDQUFDLGlCQUFJLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3hDLENBQUM7UUFFRCxvQ0FBb0M7UUFDcEMsS0FBSyxNQUFNLENBQUMsSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQztZQUMvQixTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDZixDQUFDO1FBRUQsTUFBTSxJQUFJLEdBQUcsRUFBRSxDQUFDO1FBQ2hCLEtBQUssTUFBTSxLQUFLLElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUM7WUFDbkMsS0FBSyxNQUFNLEdBQUcsSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO2dCQUMxQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQztZQUM1QyxDQUFDO1FBQ0gsQ0FBQztR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Q0FBQztnQkFDRCxLQUFLLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ25CLENBQUM7WUFDRCxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7Z0JBQ1gsS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBQ2QsQ0FBQztZQUNELE9BQU8sS0FBSyxDQUFDO1FBQ2YsQ0FBQztJQUNILENBQUM7O0FBeEdILDRDQXlHQyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFRoaXMgZmlsZSBpcyBjb3BpZWQgZnJvbVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2NkazhzLXRlYW0vY2RrOHMtY29yZS9ibG9iLzIueC9zcmMvZGVwZW5kZW5jeS50c1xuaW1wb3J0IHsgTm9kZSwgSUNvbnN0cnVjdCB9IGZyb20gXCJjb25zdHJ1Y3RzXCI7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgZGVwZW5kZW5jeSBncmFwaCBmb3IgYSBnaXZlbiBOb2RlLlxuICpcbiAqIFRoaXMgZ3JhcGggaW5jbHVkZXMgdGhlIGRlcGVuZGVuY3kgcmVsYXRpb25zaGlwcyBiZXR3ZWVuIGFsbCBub2RlcyBpbiB0aGVcbiAqIG5vZGUgKGNvbnN0cnVjdCkgc3ViLXRyZWUgd2hvJ3Mgcm9vdCBpcyB0aGlzIE5vZGUuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgbWVhbnMgdGhhdCBsb25lbHkgbm9kZXMgKG5vIGRlcGVuZGVuY2llcyBhbmQgbm8gZGVwZW5kYW50cykgYXJlIGFsc28gaW5jbHVkZWQgaW4gdGhpcyBncmFwaCBhc1xuICogY2hpbGRsZXNzIGNoaWxkcmVuIG9mIHRoZSByb290IG5vZGUgb2YgdGhlIGdyYXBoLlxuICpcbiAqIFRoZSBncmFwaCBkb2VzIG5vdCBpbmNsdWRlIGNyb3NzLXNjb3BlIGRlcGVuZGVuY2llcy4gVGhhdCBpcywgaWYgYSBjaGlsZCBvbiB0aGUgY3VycmVudCBzY29wZSBkZXBlbmRzIG9uIGEgbm9kZVxuICogZnJvbSBhIGRpZmZlcmVudCBzY29wZSwgdGhhdCByZWxhdGlvbnNoaXAgaXMgbm90IHJlcHJlc2VudGVkIGluIHRoaXMgZ3JhcGguXG4gKlxuICovXG5leHBvcnQgY2xhc3MgRGVwZW5kZW5jeUdyYXBoIHtcbiAgcHJpdmF0ZSByZWFkb25seSBfZm9zdGVyUGFyZW50OiBEZXBlbmRlbmN5VmVydGV4O1xuXG4gIGNvbnN0cnVjdG9yKG5vZGU6IE5vZGUpIHtcbiAgICB0aGlzLl9mb3N0ZXJQYXJlbnQgPSBuZXcgRGVwZW5kZW5jeVZlcnRleCgpO1xuXG4gICAgY29uc3Qgbm9kZXM6IFJlY29yZDxzdHJpbmcsIERlcGVuZGVuY3lWZXJ0ZXg+ID0ge307XG5cbiAgICBmdW5jdGlvbiBwdXRWZXJ0ZXgoY29uc3RydWN0OiBJQ29uc3RydWN0KSB7XG4gICAgICBub2Rlc1tOb2RlLm9mKGNvbnN0cnVjdCkucGF0aF0gPSBuZXcgRGVwZW5kZW5jeVZlcnRleChjb25zdHJ1Y3QpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFZlcnRleChjb25zdHJ1Y3Q6IElDb25zdHJ1Y3QpOiBEZXBlbmRlbmN5VmVydGV4IHtcbiAgICAgIHJldHVybiBub2Rlc1tOb2RlLm9mKGNvbnN0cnVjdCkucGF0aF07XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIGFsbCB2ZXJ0aWNlcyBvZiB0aGUgZ3JhcGguXG4gICAgZm9yIChjb25zdCBuIG9mIG5vZGUuZmluZEFsbCgpKSB7XG4gICAgICBwdXRWZXJ0ZXgobik7XG4gICAgfVxuXG4gICAgY29uc3QgZGVwcyA9IFtdO1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2Ygbm9kZS5maW5kQWxsKCkpIHtcbiAgICAgIGZvciAoY29uc3QgZGVwIG9mIGNoaWxkLm5vZGUuZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgIGRlcHMucHVzaCh7IHNvdXJjZTogY2hpbGQsIHRhcmdldDogZGVwIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBhbGwgdGhlIGVkZ2VzIG9mIHRoZSBncmFwaC5cbiAgICBmb3IgKGNvbnN0IGRlcCBvZiBkZXBzKSB7XG4gICAgICBpZiAoIWdldFZlcnRleChkZXAudGFyZ2V0KSkge1xuICAgICAgICAvLyBkb250IGNyb3NzIHNjb3BlIGJvdW5kYXJpZXMuXG4gICAgICAgIC8vIHNpbmNlIGNoYXJ0cyBvbmx5IHJlbmRlcnMgaXRzIG93biBjaGlsZHJlbiwgdGhpcyBpcyBvayBhbmRcbiAgICAgICAgLy8gaGFzIHRoZSBiZW5lZml0IG9mIHNpbXBsaWZ5aW5nIHRoZSBncmFwaC4gd2Ugc2hvdWxkIHJlY29uc2lkZXIgdGhpcyBiZWhhdmlvciB3aGVuIG1vdmluZ1xuICAgICAgICAvLyB0byBhIG1vcmUgZ2VuZXJhbCBwdXJwb3NlIHVzZS1jYXNlLlxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc291cmNlRGVwTm9kZSA9IGdldFZlcnRleChkZXAuc291cmNlKTtcbiAgICAgIGNvbnN0IHRhcmdldERlcE5vZGUgPSBnZXRWZXJ0ZXgoZGVwLnRhcmdldCk7XG5cbiAgICAgIHNvdXJjZURlcE5vZGUuYWRkQ2hpbGQodGFyZ2V0RGVwTm9kZSk7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIHRoZSByb290LlxuICAgIGZvciAoY29uc3QgbiBvZiBPYmplY3QudmFsdWVzKG5vZGVzKSkge1xuICAgICAgaWYgKG4uaW5ib3VuZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gb3JwaGFucyBhcmUgZGVwZW5kZW5jeSByb290cy4gbGV0cyBhZG9wdCB0aGVtIVxuICAgICAgICB0aGlzLl9mb3N0ZXJQYXJlbnQuYWRkQ2hpbGQobik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJvb3Qgb2YgdGhlIGdyYXBoLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhpcyB2ZXJ0ZXggd2lsbCBhbHdheXMgaGF2ZSBgbnVsbGAgYXMgaXRzIGAudmFsdWVgIHNpbmNlIGl0IGlzIGFuIGFydGlmaWNhbCByb290XG4gICAqIHRoYXQgYmluZHMgYWxsIHRoZSBjb25uZWN0ZWQgc3BhY2VzIG9mIHRoZSBncmFwaC5cbiAgICovXG4gIHB1YmxpYyBnZXQgcm9vdCgpOiBEZXBlbmRlbmN5VmVydGV4IHtcbiAgICByZXR1cm4gdGhpcy5fZm9zdGVyUGFyZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB0b3BvbG9naWNhbGx5IHNvcnRlZCBhcnJheSBvZiB0aGUgY29uc3RydWN0cyBpbiB0aGUgc3ViLWdyYXBoLlxuICAgKi9cbiAgcHVibGljIHRvcG9sb2d5KCk6IElDb25zdHJ1Y3RbXSB7XG4gICAgcmV0dXJuIHRoaXMuX2Zvc3RlclBhcmVudC50b3BvbG9neSgpO1xuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHZlcnRleCBpbiB0aGUgZ3JhcGguXG4gKlxuICogVGhlIHZhbHVlIG9mIGVhY2ggdmVydGV4IGlzIGFuIGBJQ29uc3RydWN0YCB0aGF0IGlzIGFjY2Vzc2libGUgdmlhIHRoZSBgLnZhbHVlYCBnZXR0ZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBEZXBlbmRlbmN5VmVydGV4IHtcbiAgcHJpdmF0ZSByZWFkb25seSBfdmFsdWU6IElDb25zdHJ1Y3QgfCB1bmRlZmluZWQ7XG4gIHByaXZhdGUgcmVhZG9ubHkgX2NoaWxkcmVuOiBTZXQ8RGVwZW5kZW5jeVZlcnRleD4gPVxuICAgIG5ldyBTZXQ8RGVwZW5kZW5jeVZlcnRleD4oKTtcbiAgcHJpdmF0ZSByZWFkb25seSBfcGFyZW50czogU2V0PERlcGVuZGVuY3lWZXJ0ZXg+ID1cbiAgICBuZXcgU2V0PERlcGVuZGVuY3lWZXJ0ZXg+KCk7XG5cbiAgY29uc3RydWN0b3IodmFsdWU6IElDb25zdHJ1Y3QgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIElDb25zdHJ1Y3QgdGhpcyBncmFwaCB2ZXJ0ZXggcmVwcmVzZW50cy5cbiAgICpcbiAgICogYG51bGxgIGluIGNhc2UgdGhpcyBpcyB0aGUgcm9vdCBvZiB0aGUgZ3JhcGguXG4gICAqL1xuICBwdWJsaWMgZ2V0IHZhbHVlKCk6IElDb25zdHJ1Y3QgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjaGlsZHJlbiBvZiB0aGUgdmVydGV4IChpLmUgZGVwZW5kZW5jaWVzKVxuICAgKi9cbiAgcHVibGljIGdldCBvdXRib3VuZCgpOiBBcnJheTxEZXBlbmRlbmN5VmVydGV4PiB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5fY2hpbGRyZW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBhcmVudHMgb2YgdGhlIHZlcnRleCAoaS5lIGRlcGVuZGFudHMpXG4gICAqL1xuICBwdWJsaWMgZ2V0IGluYm91bmQoKTogQXJyYXk8RGVwZW5kZW5jeVZlcnRleD4ge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuX3BhcmVudHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB0b3BvbG9naWNhbGx5IHNvcnRlZCBhcnJheSBvZiB0aGUgY29uc3RydWN0cyBpbiB0aGUgc3ViLWdyYXBoLlxuICAgKi9cbiAgcHVibGljIHRvcG9sb2d5KCk6IElDb25zdHJ1Y3RbXSB7XG4gICAgY29uc3QgZm91bmQgPSBuZXcgU2V0PERlcGVuZGVuY3lWZXJ0ZXg+KCk7XG4gICAgY29uc3QgdG9wb2xvZ3k6IERlcGVuZGVuY3lWZXJ0ZXhbXSA9IFtdO1xuXG4gICAgZnVuY3Rpb24gdmlzaXQobjogRGVwZW5kZW5jeVZlcnRleCkge1xuICAgICAgZm9yIChjb25zdCBjIG9mIG4ub3V0Ym91bmQpIHtcbiAgICAgICAgdmlzaXQoYyk7XG4gICAgICB9XG4gICAgICBpZiAoIWZvdW5kLmhhcyhuKSkge1xuICAgICAgICB0b3BvbG9neS5wdXNoKG4pO1xuICAgICAgICBmb3VuZC5hZGQobik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmlzaXQodGhpcyk7XG5cbiAgICByZXR1cm4gdG9wb2xvZ3kuZmlsdGVyKChkKSA9PiBkLnZhbHVlKS5tYXAoKGQpID0+IGQudmFsdWUhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgdmVydGV4IGFzIGEgZGVwZW5kZW5jeSBvZiB0aGUgY3VycmVudCBub2RlLlxuICAgKiBBbHNvIHVwZGF0ZXMgdGhlIHBhcmVudHMgb2YgYGRlcGAsIHNvIHRoYXQgaXQgY29udGFpbnMgdGhpcyBub2RlIGFzIGEgcGFyZW50LlxuICAgKlxuICAgKiBUaGlzIG9wZXJhdGlvbiB3aWxsIGZhaWwgaW4gY2FzZSBpdCBjcmVhdGVzIGEgY3ljbGUgaW4gdGhlIGdyYXBoLlxuICAgKlxuICAgKiBAcGFyYW0gZGVwIFRoZSBkZXBlbmRlbmN5XG4gICAqL1xuICBwdWJsaWMgYWRkQ2hpbGQoZGVwOiBEZXBlbmRlbmN5VmVydGV4KSB7XG4gICAgY29uc3QgY3ljbGU6IERlcGVuZGVuY3lWZXJ0ZXhbXSA9IGRlcC5maW5kUm91dGUodGhpcyk7XG4gICAgaWYgKGN5Y2xlLmxlbmd0aCAhPT0gMCkge1xuICAgICAgY3ljbGUucHVzaChkZXApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRGVwZW5kZW5jeSBjeWNsZSBkZXRlY3RlZDogJHtjeWNsZVxuICAgICAgICAgIC5maWx0ZXIoKGQpID0+IGQudmFsdWUpXG4gICAgICAgICAgLm1hcCgoZCkgPT4gTm9kZS5vZihkLnZhbHVlISkucGF0aClcbiAgICAgICAgICAuam9pbihcIiA9PiBcIil9YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLl9jaGlsZHJlbi5hZGQoZGVwKTtcbiAgICBkZXAuYWRkUGFyZW50KHRoaXMpO1xuICB9XG5cbiAgcHJpdmF0ZSBhZGRQYXJlbnQoZGVwOiBEZXBlbmRlbmN5VmVydGV4KSB7XG4gICAgdGhpcy5fcGFyZW50cy5hZGQoZGVwKTtcbiAgfVxuXG4gIHByaXZhdGUgZmluZFJvdXRlKGRzdDogRGVwZW5kZW5jeVZlcnRleCk6IERlcGVuZGVuY3lWZXJ0ZXhbXSB7XG4gICAgY29uc3Qgcm91dGU6IERlcGVuZGVuY3lWZXJ0ZXhbXSA9IFtdO1xuICAgIHZpc2l0KHRoaXMpO1xuICAgIHJldHVybiByb3V0ZTtcblxuICAgIGZ1bmN0aW9uIHZpc2l0KG46IERlcGVuZGVuY3lWZXJ0ZXgpOiBib29sZWFuIHtcbiAgICAgIHJvdXRlLnB1c2gobik7XG4gICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgIGZvciAoY29uc3QgYyBvZiBuLm91dGJvdW5kKSB7XG4gICAgICAgIGlmIChjID09PSBkc3QpIHtcbiAgICAgICAgICByb3V0ZS5wdXNoKGMpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvdW5kID0gdmlzaXQoYyk7XG4gICAgICB9XG4gICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgIHJvdXRlLnBvcCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cbiAgfVxufVxuIl19