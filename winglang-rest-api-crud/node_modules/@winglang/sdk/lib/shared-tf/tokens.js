"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CdkTfTokens = void 0;
const cdktf_1 = require("cdktf");
const cloud_1 = require("../cloud");
const tokens_1 = require("../core/tokens");
/**
 * Represents values that can only be resolved after the app is synthesized.
 * Tokens values are captured as environment variable, and resolved through the compilation target token mechanism.
 */
class CdkTfTokens {
    constructor() {
        this._jsonEncodeCache = new Map();
    }
    /**
     * Returns true is the given value is a CDKTF token.
     */
    isToken(value) {
        return cdktf_1.Token.isUnresolved(value);
    }
    /**
     * CDKTF tokens are captured as Json values.
     * e.g. `JSON.parse(process.env["WING_TOKEN__TOKEN1"])`
     */
    lift(value) {
        return `JSON.parse(process.env[${JSON.stringify((0, tokens_1.tokenEnvName)(JSON.stringify(value)))}])`;
    }
    /**
     * CDKTF tokens are bounded as Json values.
     */
    onLiftValue(host, value) {
        if (!(host instanceof cloud_1.Function)) {
            throw new Error(`Tokens can only be bound by a Function for now`);
        }
        const envName = (0, tokens_1.tokenEnvName)(JSON.stringify(value));
        // Fn.jsonencode produces a fresh CDKTF token each time, so we cache the results
        let envValue = this._jsonEncodeCache.get(envName);
        if (!envValue) {
            envValue = cdktf_1.Fn.jsonencode(value);
            this._jsonEncodeCache.set(envName, envValue);
        }
        host.addEnvironment(envName, envValue);
    }
}
exports.CdkTfTokens = CdkTfTokens;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9rZW5zLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3NoYXJlZC10Zi90b2tlbnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsaUNBQWtDO0FBQ2xDLG9DQUFvQztBQUNwQywyQ0FBOEQ7QUFHOUQ7OztHQUdHO0FBQ0gsTUFBYSxXQUFXO0lBQXhCO1FBQ1UscUJBQWdCLEdBQUcsSUFBSSxHQUFHLEVBQWtCLENBQUM7SUFxQ3ZELENBQUM7SUFuQ0M7O09BRUc7SUFDSSxPQUFPLENBQUMsS0FBVTtRQUN2QixPQUFPLGFBQUssQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDbkMsQ0FBQztJQUVEOzs7T0FHRztJQUNJLElBQUksQ0FBQyxLQUFVO1FBQ3BCLE9BQU8sMEJBQTBCLElBQUksQ0FBQyxTQUFTLENBQzdDLElBQUEscUJBQVksRUFBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQ3BDLElBQUksQ0FBQztJQUNSLENBQUM7SUFFRDs7T0FFRztJQUNJLFdBQVcsQ0FBQyxJQUFtQixFQUFFLEtBQVU7UUFDaEQsSUFBSSxDQUFDLENBQUMsSUFBSSxZQUFZLGdCQUFRLENBQUMsRUFBRSxDQUFDO1lBQ2hDLE1BQU0sSUFBSSxLQUFLLENBQUMsZ0RBQWdELENBQUMsQ0FBQztRQUNwRSxDQUFDO1FBRUQsTUFBTSxPQUFPLEdBQUcsSUFBQSxxQkFBWSxFQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztRQUVwRCxnRkFBZ0Y7UUFDaEYsSUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUNsRCxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7WUFDZCxRQUFRLEdBQUcsVUFBRSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNoQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxRQUFRLENBQUMsQ0FBQztRQUMvQyxDQUFDO1FBQ0QsSUFBSSxDQUFDLGNBQWMsQ0FBQyxPQUFPLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDekMsQ0FBQztDQUNGO0FBdENELGtDQXNDQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEZuLCBUb2tlbiB9IGZyb20gXCJjZGt0ZlwiO1xuaW1wb3J0IHsgRnVuY3Rpb24gfSBmcm9tIFwiLi4vY2xvdWRcIjtcbmltcG9ydCB7IHRva2VuRW52TmFtZSwgSVRva2VuUmVzb2x2ZXIgfSBmcm9tIFwiLi4vY29yZS90b2tlbnNcIjtcbmltcG9ydCB7IElJbmZsaWdodEhvc3QgfSBmcm9tIFwiLi4vc3RkXCI7XG5cbi8qKlxuICogUmVwcmVzZW50cyB2YWx1ZXMgdGhhdCBjYW4gb25seSBiZSByZXNvbHZlZCBhZnRlciB0aGUgYXBwIGlzIHN5bnRoZXNpemVkLlxuICogVG9rZW5zIHZhbHVlcyBhcmUgY2FwdHVyZWQgYXMgZW52aXJvbm1lbnQgdmFyaWFibGUsIGFuZCByZXNvbHZlZCB0aHJvdWdoIHRoZSBjb21waWxhdGlvbiB0YXJnZXQgdG9rZW4gbWVjaGFuaXNtLlxuICovXG5leHBvcnQgY2xhc3MgQ2RrVGZUb2tlbnMgaW1wbGVtZW50cyBJVG9rZW5SZXNvbHZlciB7XG4gIHByaXZhdGUgX2pzb25FbmNvZGVDYWNoZSA9IG5ldyBNYXA8c3RyaW5nLCBzdHJpbmc+KCk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpcyB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBDREtURiB0b2tlbi5cbiAgICovXG4gIHB1YmxpYyBpc1Rva2VuKHZhbHVlOiBhbnkpOiBib29sZWFuIHtcbiAgICByZXR1cm4gVG9rZW4uaXNVbnJlc29sdmVkKHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDREtURiB0b2tlbnMgYXJlIGNhcHR1cmVkIGFzIEpzb24gdmFsdWVzLlxuICAgKiBlLmcuIGBKU09OLnBhcnNlKHByb2Nlc3MuZW52W1wiV0lOR19UT0tFTl9fVE9LRU4xXCJdKWBcbiAgICovXG4gIHB1YmxpYyBsaWZ0KHZhbHVlOiBhbnkpOiBzdHJpbmcge1xuICAgIHJldHVybiBgSlNPTi5wYXJzZShwcm9jZXNzLmVudlske0pTT04uc3RyaW5naWZ5KFxuICAgICAgdG9rZW5FbnZOYW1lKEpTT04uc3RyaW5naWZ5KHZhbHVlKSlcbiAgICApfV0pYDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDREtURiB0b2tlbnMgYXJlIGJvdW5kZWQgYXMgSnNvbiB2YWx1ZXMuXG4gICAqL1xuICBwdWJsaWMgb25MaWZ0VmFsdWUoaG9zdDogSUluZmxpZ2h0SG9zdCwgdmFsdWU6IGFueSkge1xuICAgIGlmICghKGhvc3QgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVG9rZW5zIGNhbiBvbmx5IGJlIGJvdW5kIGJ5IGEgRnVuY3Rpb24gZm9yIG5vd2ApO1xuICAgIH1cblxuICAgIGNvbnN0IGVudk5hbWUgPSB0b2tlbkVudk5hbWUoSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcblxuICAgIC8vIEZuLmpzb25lbmNvZGUgcHJvZHVjZXMgYSBmcmVzaCBDREtURiB0b2tlbiBlYWNoIHRpbWUsIHNvIHdlIGNhY2hlIHRoZSByZXN1bHRzXG4gICAgbGV0IGVudlZhbHVlID0gdGhpcy5fanNvbkVuY29kZUNhY2hlLmdldChlbnZOYW1lKTtcbiAgICBpZiAoIWVudlZhbHVlKSB7XG4gICAgICBlbnZWYWx1ZSA9IEZuLmpzb25lbmNvZGUodmFsdWUpO1xuICAgICAgdGhpcy5fanNvbkVuY29kZUNhY2hlLnNldChlbnZOYW1lLCBlbnZWYWx1ZSk7XG4gICAgfVxuICAgIGhvc3QuYWRkRW52aXJvbm1lbnQoZW52TmFtZSwgZW52VmFsdWUpO1xuICB9XG59XG4iXX0=