"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveDirname = exports.createExternRequire = exports.assign = exports.lookup = exports.unwrap = exports.normalPath = exports.nodeof = exports.range = exports.assert = exports.neq = exports.eq = void 0;
// Code in this file will be automatically included in all inflight code bundles,
// so avoid importing anything heavy here.
const node_assert_1 = require("node:assert");
const path = __importStar(require("node:path"));
function eq(a, b) {
    try {
        (0, node_assert_1.deepStrictEqual)(a, b);
        return true;
    }
    catch {
        return false;
    }
}
exports.eq = eq;
function neq(a, b) {
    try {
        (0, node_assert_1.notDeepStrictEqual)(a, b);
        return true;
    }
    catch {
        return false;
    }
}
exports.neq = neq;
function assert(condition, message) {
    if (!condition) {
        throw new Error("assertion failed: " + message);
    }
}
exports.assert = assert;
function range(start, end, inclusive) {
    function* iterator() {
        let i = start;
        let limit = inclusive ? (end < start ? end - 1 : end + 1) : end;
        while (i < limit)
            yield i++;
        while (i > limit)
            yield i--;
    }
    return iterator();
}
exports.range = range;
function nodeof(construct) {
    // Should only be used preflight, avoid bundling
    const Node = eval("require('./std/node').Node");
    return Node.of(construct);
}
exports.nodeof = nodeof;
function normalPath(p) {
    return p.replace(/\\+/g, "/");
}
exports.normalPath = normalPath;
function unwrap(value) {
    if (value != null) {
        return value;
    }
    throw new Error("Unexpected nil");
}
exports.unwrap = unwrap;
function lookup(obj, index) {
    checkIndex(index);
    if (typeof index === "number") {
        index = checkArrayAccess(obj, index);
        return obj[index];
    }
    if (typeof obj !== "object") {
        throw new TypeError(`Lookup failed, value is not an object (found "${typeof obj}")`);
    }
    if (!(index in obj)) {
        throw new RangeError(`Key "${index}" not found`);
    }
    return obj[index];
}
exports.lookup = lookup;
function assign(obj, index, kind, value) {
    checkIndex(index);
    if (typeof index === "number") {
        index = checkArrayAccess(obj, index);
    }
    if (typeof index === "string" && typeof obj !== "object") {
        throw new TypeError(`Assignment failed, value is not an object (found \"${typeof obj}\")`);
    }
    switch (kind) {
        case "=":
            obj[index] = value;
            break;
        case "+=":
            obj[index] += value;
            break;
        case "-=":
            obj[index] -= value;
            break;
        default:
            throw new Error(`Invalid assignment kind: ${kind}`);
    }
}
exports.assign = assign;
function checkIndex(index) {
    if (typeof index !== "string" && typeof index !== "number") {
        throw new TypeError(`Index must be a string or number (found "${typeof index}")`);
    }
}
function checkArrayAccess(obj, index) {
    if (!Array.isArray(obj) && !Buffer.isBuffer(obj) && typeof obj !== "string") {
        throw new TypeError("Index is a number but collection is not an array or string");
    }
    if (index < 0 && index >= -obj.length) {
        index = obj.length + index;
    }
    if (index < 0 || index >= obj.length) {
        throw new RangeError(`Index ${index} out of bounds for array of length ${obj.length}`);
    }
    return index;
}
function createExternRequire(dirname) {
    return (externPath) => {
        // using eval to always avoid bundling
        const jiti = eval("require('jiti')");
        const esbuild = eval("require('esbuild')");
        const newRequire = jiti(dirname, {
            sourceMaps: true,
            interopDefault: true,
            transform(opts) {
                return esbuild.transformSync(opts.source, {
                    format: "cjs",
                    target: "node20",
                    sourcemap: "inline",
                    loader: opts.ts ? "ts" : "js",
                });
            },
        });
        return newRequire(externPath);
    };
}
exports.createExternRequire = createExternRequire;
function resolveDirname(outdir, relativeSourceDir) {
    return normalPath(path.resolve(outdir, relativeSourceDir));
}
exports.resolveDirname = resolveDirname;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGVscGVycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9oZWxwZXJzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsaUZBQWlGO0FBQ2pGLDBDQUEwQztBQUMxQyw2Q0FBa0U7QUFDbEUsZ0RBQWtDO0FBSWxDLFNBQWdCLEVBQUUsQ0FBQyxDQUFNLEVBQUUsQ0FBTTtJQUMvQixJQUFJLENBQUM7UUFDSCxJQUFBLDZCQUFlLEVBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ3RCLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUFDLE1BQU0sQ0FBQztRQUNQLE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztBQUNILENBQUM7QUFQRCxnQkFPQztBQUVELFNBQWdCLEdBQUcsQ0FBQyxDQUFNLEVBQUUsQ0FBTTtJQUNoQyxJQUFJLENBQUM7UUFDSCxJQUFBLGdDQUFrQixFQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUN6QixPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFBQyxNQUFNLENBQUM7UUFDUCxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7QUFDSCxDQUFDO0FBUEQsa0JBT0M7QUFFRCxTQUFnQixNQUFNLENBQUMsU0FBYyxFQUFFLE9BQWU7SUFDcEQsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQ2YsTUFBTSxJQUFJLEtBQUssQ0FBQyxvQkFBb0IsR0FBRyxPQUFPLENBQUMsQ0FBQztJQUNsRCxDQUFDO0FBQ0gsQ0FBQztBQUpELHdCQUlDO0FBRUQsU0FBZ0IsS0FBSyxDQUFDLEtBQWEsRUFBRSxHQUFXLEVBQUUsU0FBa0I7SUFDbEUsUUFBUSxDQUFDLENBQUMsUUFBUTtRQUNoQixJQUFJLENBQUMsR0FBRyxLQUFLLENBQUM7UUFDZCxJQUFJLEtBQUssR0FBRyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLEtBQUssQ0FBQyxDQUFDLENB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VUFBVSxFQUFFLElBQUk7WUFDaEIsY0FBYyxFQUFFLElBQUk7WUFDcEIsU0FBUyxDQUFDLElBQUk7Z0JBQ1osT0FBTyxPQUFPLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUU7b0JBQ3hDLE1BQU0sRUFBRSxLQUFLO29CQUNiLE1BQU0sRUFBRSxRQUFRO29CQUNoQixTQUFTLEVBQUUsUUFBUTtvQkFDbkIsTUFBTSxFQUFFLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSTtpQkFDOUIsQ0FBQyxDQUFDO1lBQ0wsQ0FBQztTQUNGLENBQUMsQ0FBQztRQUNILE9BQU8sVUFBVSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQ2hDLENBQUMsQ0FBQztBQUNKLENBQUM7QUFwQkQsa0RBb0JDO0FBRUQsU0FBZ0IsY0FBYyxDQUM1QixNQUFjLEVBQ2QsaUJBQXlCO0lBRXpCLE9BQU8sVUFBVSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLGlCQUFpQixDQUFDLENBQUMsQ0FBQztBQUM3RCxDQUFDO0FBTEQsd0NBS0MiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb2RlIGluIHRoaXMgZmlsZSB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgaW5jbHVkZWQgaW4gYWxsIGluZmxpZ2h0IGNvZGUgYnVuZGxlcyxcbi8vIHNvIGF2b2lkIGltcG9ydGluZyBhbnl0aGluZyBoZWF2eSBoZXJlLlxuaW1wb3J0IHsgZGVlcFN0cmljdEVxdWFsLCBub3REZWVwU3RyaWN0RXF1YWwgfSBmcm9tIFwibm9kZTphc3NlcnRcIjtcbmltcG9ydCAqIGFzIHBhdGggZnJvbSBcIm5vZGU6cGF0aFwiO1xuaW1wb3J0IHR5cGUgeyBDb25zdHJ1Y3QgfSBmcm9tIFwiY29uc3RydWN0c1wiO1xuaW1wb3J0IHR5cGUgeyBOb2RlIH0gZnJvbSBcIi4vc3RkL25vZGVcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGVxKGE6IGFueSwgYjogYW55KTogYm9vbGVhbiB7XG4gIHRyeSB7XG4gICAgZGVlcFN0cmljdEVxdWFsKGEsIGIpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5lcShhOiBhbnksIGI6IGFueSk6IGJvb2xlYW4ge1xuICB0cnkge1xuICAgIG5vdERlZXBTdHJpY3RFcXVhbChhLCBiKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uOiBhbnksIG1lc3NhZ2U6IHN0cmluZyk6IGFzc2VydHMgY29uZGl0aW9uIHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJhc3NlcnRpb24gZmFpbGVkOiBcIiArIG1lc3NhZ2UpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByYW5nZShzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlciwgaW5jbHVzaXZlOiBib29sZWFuKSB7XG4gIGZ1bmN0aW9uKiBpdGVyYXRvcigpIHtcbiAgICBsZXQgaSA9IHN0YXJ0O1xuICAgIGxldCBsaW1pdCA9IGluY2x1c2l2ZSA/IChlbmQgPCBzdGFydCA/IGVuZCAtIDEgOiBlbmQgKyAxKSA6IGVuZDtcbiAgICB3aGlsZSAoaSA8IGxpbWl0KSB5aWVsZCBpKys7XG4gICAgd2hpbGUgKGkgPiBsaW1pdCkgeWllbGQgaS0tO1xuICB9XG4gIHJldHVybiBpdGVyYXRvcigpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9kZW9mKGNvbnN0cnVjdDogQ29uc3RydWN0KTogTm9kZSB7XG4gIC8vIFNob3VsZCBvbmx5IGJlIHVzZWQgcHJlZmxpZ2h0LCBhdm9pZCBidW5kbGluZ1xuICBjb25zdCBOb2RlID0gZXZhbChcInJlcXVpcmUoJy4vc3RkL25vZGUnKS5Ob2RlXCIpO1xuICByZXR1cm4gTm9kZS5vZihjb25zdHJ1Y3QpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsUGF0aChwOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gcC5yZXBsYWNlKC9cXFxcKy9nLCBcIi9cIik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bndyYXA8VD4odmFsdWU6IFQpOiBUIHwgbmV2ZXIge1xuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIG5pbFwiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvb2t1cChvYmo6IGFueSwgaW5kZXg6IHN0cmluZyB8IG51bWJlcik6IGFueSB7XG4gIGNoZWNrSW5kZXgoaW5kZXgpO1xuXG4gIGlmICh0eXBlb2YgaW5kZXggPT09IFwibnVtYmVyXCIpIHtcbiAgICBpbmRleCA9IGNoZWNrQXJyYXlBY2Nlc3Mob2JqLCBpbmRleCk7XG4gICAgcmV0dXJuIG9ialtpbmRleF07XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICBgTG9va3VwIGZhaWxlZCwgdmFsdWUgaXMgbm90IGFuIG9iamVjdCAoZm91bmQgXCIke3R5cGVvZiBvYmp9XCIpYFxuICAgICk7XG4gIH1cblxuICBpZiAoIShpbmRleCBpbiBvYmopKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEtleSBcIiR7aW5kZXh9XCIgbm90IGZvdW5kYCk7XG4gIH1cblxuICByZXR1cm4gb2JqW2luZGV4XTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbihcbiAgb2JqOiBhbnksXG4gIGluZGV4OiBzdHJpbmcgfCBudW1iZXIsXG4gIGtpbmQ6IFwiPVwiIHwgXCIrPVwiIHwgXCItPVwiLFxuICB2YWx1ZTogYW55XG4pIHtcbiAgY2hlY2tJbmRleChpbmRleCk7XG5cbiAgaWYgKHR5cGVvZiBpbmRleCA9PT0gXCJudW1iZXJcIikge1xuICAgIGluZGV4ID0gY2hlY2tBcnJheUFjY2VzcyhvYmosIGluZGV4KTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaW5kZXggPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICBgQXNzaWdubWVudCBmYWlsZWQsIHZhbHVlIGlzIG5vdCBhbiBvYmplY3QgKGZvdW5kIFxcXCIke3R5cGVvZiBvYmp9XFxcIilgXG4gICAgKTtcbiAgfVxuXG4gIHN3aXRjaCAoa2luZCkge1xuICAgIGNhc2UgXCI9XCI6XG4gICAgICBvYmpbaW5kZXhdID0gdmFsdWU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiKz1cIjpcbiAgICAgIG9ialtpbmRleF0gKz0gdmFsdWU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiLT1cIjpcbiAgICAgIG9ialtpbmRleF0gLT0gdmFsdWU7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGFzc2lnbm1lbnQga2luZDogJHtraW5kfWApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrSW5kZXgoaW5kZXg6IHN0cmluZyB8IG51bWJlcikge1xuICBpZiAodHlwZW9mIGluZGV4ICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBpbmRleCAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICBgSW5kZXggbXVzdCBiZSBhIHN0cmluZyBvciBudW1iZXIgKGZvdW5kIFwiJHt0eXBlb2YgaW5kZXh9XCIpYFxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tBcnJheUFjY2VzcyhvYmo6IGFueSwgaW5kZXg6IG51bWJlcik6IG51bWJlciB7XG4gIGlmICghQXJyYXkuaXNBcnJheShvYmopICYmICFCdWZmZXIuaXNCdWZmZXIob2JqKSAmJiB0eXBlb2Ygb2JqICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgIFwiSW5kZXggaXMgYSBudW1iZXIgYnV0IGNvbGxlY3Rpb24gaXMgbm90IGFuIGFycmF5IG9yIHN0cmluZ1wiXG4gICAgKTtcbiAgfVxuICBpZiAoaW5kZXggPCAwICYmIGluZGV4ID49IC1vYmoubGVuZ3RoKSB7XG4gICAgaW5kZXggPSBvYmoubGVuZ3RoICsgaW5kZXg7XG4gIH1cbiAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSBvYmoubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXG4gICAgICBgSW5kZXggJHtpbmRleH0gb3V0IG9mIGJvdW5kcyBmb3IgYXJyYXkgb2YgbGVuZ3RoICR7b2JqLmxlbmd0aH1gXG4gICAgKTtcbiAgfVxuICByZXR1cm4gaW5kZXg7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFeHRlcm5SZXF1aXJlKGRpcm5hbWU6IHN0cmluZykge1xuICByZXR1cm4gKGV4dGVyblBhdGg6IHN0cmluZykgPT4ge1xuICAgIC8vIHVzaW5nIGV2YWwgdG8gYWx3YXlzIGF2b2lkIGJ1bmRsaW5nXG4gICAgY29uc3Qgaml0aTogdHlwZW9mIGltcG9ydChcImppdGlcIikuZGVmYXVsdCA9IGV2YWwoXCJyZXF1aXJlKCdqaXRpJylcIik7XG4gICAgY29uc3QgZXNidWlsZDogdHlwZW9mIGltcG9ydChcImVzYnVpbGRcIikgPSBldmFsKFwicmVxdWlyZSgnZXNidWlsZCcpXCIpO1xuXG4gICAgY29uc3QgbmV3UmVxdWlyZSA9IGppdGkoZGlybmFtZSwge1xuICAgICAgc291cmNlTWFwczogdHJ1ZSxcbiAgICAgIGludGVyb3BEZWZhdWx0OiB0cnVlLFxuICAgICAgdHJhbnNmb3JtKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIGVzYnVpbGQudHJhbnNmb3JtU3luYyhvcHRzLnNvdXJjZSwge1xuICAgICAgICAgIGZvcm1hdDogXCJjanNcIixcbiAgICAgICAgICB0YXJnZXQ6IFwibm9kZTIwXCIsXG4gICAgICAgICAgc291cmNlbWFwOiBcImlubGluZVwiLFxuICAgICAgICAgIGxvYWRlcjogb3B0cy50cyA/IFwidHNcIiA6IFwianNcIixcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiBuZXdSZXF1aXJlKGV4dGVyblBhdGgpO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZURpcm5hbWUoXG4gIG91dGRpcjogc3RyaW5nLFxuICByZWxhdGl2ZVNvdXJjZURpcjogc3RyaW5nXG4pOiBzdHJpbmcge1xuICByZXR1cm4gbm9ybWFsUGF0aChwYXRoLnJlc29sdmUob3V0ZGlyLCByZWxhdGl2ZVNvdXJjZURpcikpO1xufVxuIl19