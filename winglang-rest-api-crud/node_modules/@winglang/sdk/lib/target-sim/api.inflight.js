"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Api = void 0;
const fs = __importStar(require("fs"));
const net_1 = require("net");
const path_1 = require("path");
const express_1 = __importDefault(require("express"));
const util_1 = require("./util");
const cloud_1 = require("../cloud");
const simulator_1 = require("../simulator/simulator");
const std_1 = require("../std");
const LOCALHOST_ADDRESS = "127.0.0.1";
const STATE_FILENAME = "state.json";
class Api {
    constructor(props) {
        this.routes = [];
        const { corsHeaders } = props;
        // Set up an express server that handles the routes.
        this.app = (0, express_1.default)();
        // we parse all requests as text and leave the parsing to the inflight handler
        // matching the limit to aws api gateway's payload size limit:
        // https://docs.aws.amazon.com/apigateway/latest/developerguide/limits.html
        this.app.use(express_1.default.text({ limit: "10mb", type: "*/*" }));
        // Set up CORS headers for options requests.
        if (corsHeaders) {
            this.app.use((req, res, next) => {
                const method = req.method && req.method.toUpperCase && req.method.toUpperCase();
                if (method === "OPTIONS") {
                    for (const [key, value] of Object.entries(corsHeaders.optionsResponse)) {
                        res.setHeader(key, value);
                    }
                    res.status(204).send();
                }
                else {
                    for (const [key, value] of Object.entries(corsHeaders.defaultResponse)) {
                        res.setHeader(key, value);
                    }
                    next();
                }
            });
        }
    }
    get context() {
        if (!this._context) {
            throw new Error("Cannot access context during class construction");
        }
        return this._context;
    }
    async init(context) {
        this._context = context;
        // Check for a previous state file to see if there was a port that was previously being used
        // if so, try to use it out of convenience
        let lastPort;
        const state = await this.loadState();
        if (state.lastPort) {
            const portAvailable = await isPortAvailable(state.lastPort);
            if (portAvailable) {
                lastPort = state.lastPort;
            }
        }
        // `server.address()` returns `null` until the server is listening
        // on a port. We use a promise to wait for the server to start
        // listening before returning the URL.
        const addrInfo = await new Promise((resolve, reject) => {
            this.server = this.app.listen(lastPort ?? 0, LOCALHOST_ADDRESS, () => {
                const addr = this.server?.address();
                if (addr && typeof addr === "object" && addr.port) {
                    resolve(addr);
                }
                else {
                    reject(new Error("No address found"));
                }
            });
        });
        this.port = addrInfo.port;
        this.url = `http://${addrInfo.address}:${addrInfo.port}`;
        this.addTrace(`Server listening on ${this.url}`, std_1.LogLevel.VERBOSE);
        return {
            url: this.url,
        };
    }
    async cleanup() {
        this.addTrace(`Closing server on ${this.url}`, std_1.LogLevel.VERBOSE);
        return new Promise((resolve, reject) => {
            this.server?.close((err) => {
                if (err) {
                    return reject(err);
                }
                this.server?.closeAllConnections();
                return resolve();
            });
        });
    }
    async save() {
        await this.saveState({ lastPort: this.port });
    }
    async plan() {
        return simulator_1.UpdatePlan.AUTO;
    }
    async loadState() {
        const stateFileExists = await (0, util_1.exists)((0, path_1.join)(this.context.statedir, STATE_FILENAME));
        if (stateFileExists) {
            const stateFileContents = await fs.promises.readFile((0, path_1.join)(this.context.statedir, STATE_FILENAME), "utf-8");
            return JSON.parse(stateFileContents);
        }
        else {
            return {};
        }
    }
    async saveState(state) {
        fs.writeFileSync((0, path_1.join)(this.context.statedir, STATE_FILENAME), JSON.stringify(state));
    }
    async addEventSubscription(subscriber, subscriptionProps) {
        const routes = subscriptionProps.routes;
        for (const route of routes) {
            const s = {
                functionHandle: subscriber,
                method: route.method,
                pathPattern: route.pathPattern,
            };
            this.populateRoute(s, subscriber);
            // Keep track of the internal express function so we can remove it later
            // Each layer object in express looks something like this:
            //
            // Layer {
            //   handle: [Function: bound dispatch],
            //   name: 'bound dispatch',
            //   params: undefined,
            //   path: undefined,
            //   keys: [ [Object] ],
            //   regexp: /^\/foo\/(?:([^\/]+?))\/?$/i { fast_star: false, fast_slash: false },
            //   route: Route { path: '/foo/:bar', stack: [Array], methods: [Object] }
            // }
            const expressRouteHandle = this.app._router.stack[this.app._router.stack.length - 1];
            this.routes.push({
                ...s,
                expressLayer: expressRouteHandle,
            });
        }
    }
    async removeEventSubscription(subscriber) {
        const index = this.routes.findIndex((s) => s.functionHandle === subscriber);
        if (index === -1) {
            this.addTrace(`Internal error: No route found for subscriber ${subscriber}.`, std_1.LogLevel.WARNING);
            return;
        }
        const layer = this.routes[index].expressLayer;
        const layerIndex = this.app._router.stack.indexOf(layer);
        if (layerIndex === -1) {
            this.addTrace(`Internal error: No express layer found for route ${this.routes[index].pathPattern}.`, std_1.LogLevel.WARNING);
            return;
        }
        this.app._router.stack.splice(layerIndex, 1);
        this.routes.splice(index, 1);
    }
    populateRoute(route, functionHandle) {
        const method = route.method.toLowerCase();
        const fnClient = this.context.getClient(functionHandle);
        this.app[method](transformRoutePath(route.pathPattern), asyncMiddleware(async (req, res, next) => {
            this.addTrace(`Processing "${route.method} ${route.pathPattern}" params=${JSON.stringify(req.params)}).`, std_1.LogLevel.VERBOSE);
            const apiRequest = transformRequest(req);
            try {
                const responseString = await fnClient.invoke(JSON.stringify(apiRequest));
                const response = JSON.parse(responseString ?? "{}");
                const status = response.status ?? cloud_1.DEFAULT_RESPONSE_STATUS;
                res.status(status);
                for (const [key, value] of Object.entries(response?.headers ?? {})) {
                    res.set(key, value);
                }
                if (response?.body !== undefined) {
                    res.send(response.body);
                }
                else {
                    res.end();
                }
                this.addTrace(`${route.method} ${route.pathPattern} - ${status}.`, std_1.LogLevel.VERBOSE);
            }
            catch (err) {
                return next(err);
            }
        }));
    }
    addTrace(message, level) {
        this.context.addTrace({
            type: std_1.TraceType.RESOURCE,
            level,
            data: {
                message,
            },
            sourcePath: this.context.resourcePath,
            sourceType: cloud_1.API_FQN,
            timestamp: new Date().toISOString(),
        });
    }
}
exports.Api = Api;
function transformRequest(req) {
    return {
        headers: (0, cloud_1.sanitizeParamLikeObject)(req.headers),
        body: Object.keys(req.body).length > 0 ? req.body : "",
        method: (0, cloud_1.parseHttpMethod)(req.method),
        path: req.path,
        query: (0, cloud_1.sanitizeParamLikeObject)(req.query),
        vars: req.params,
    };
}
function transformRoutePath(route) {
    // route validation is done in the preflight file
    return route.replace(/{/g, ":").replace(/}/g, "");
}
// express v4 doesn't natively handle async request handlers, so we need to
// wrap them in a middleware function
function asyncMiddleware(fn) {
    return (req, res, next) => {
        Promise.resolve(fn(req, res, next)).catch(next);
    };
}
async function isPortAvailable(port) {
    return new Promise((resolve, _reject) => {
        const s = new net_1.Socket();
        s.once("error", (err) => {
            s.destroy();
            if (err.code !== "ECONNREFUSED") {
                resolve(false);
            }
            else {
                // connection refused means the port is not used
                resolve(true);
            }
        });
        s.once("connect", () => {
            s.destroy();
            // connection successful means the port is used
            resolve(false);
        });
        s.connect(port, LOCALHOST_ADDRESS);
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBpLmluZmxpZ2h0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3RhcmdldC1zaW0vYXBpLmluZmxpZ2h0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsdUNBQXlCO0FBRXpCLDZCQUEwQztBQUMxQywrQkFBNEI7QUFDNUIsc0RBQThCO0FBUTlCLGlDQUFnQztBQUNoQyxvQ0FTa0I7QUFDbEIsc0RBSWdDO0FBQ2hDLGdDQUE2QztBQUU3QyxNQUFNLGlCQUFpQixHQUFHLFdBQVcsQ0FBQztBQUV0QyxNQUFNLGNBQWMsR0FBRyxZQUFZLENBQUM7QUFpQnBDLE1BQWEsR0FBRztJQVVkLFlBQVksS0FBZ0I7UUFDMUIsSUFBSSxDQUFDLE1BQU0sR0FBRyxFQUFFLENBQUM7UUFDakIsTUFBTSxFQUFFLFdBQVcsRUFBRSxHQUFHLEtBQUssQ0FBQztRQUU5QixvREFBb0Q7UUFDcEQsSUFBSSxDQUFDLEdBQUcsR0FBRyxJQUFBLGlCQUFPLEdBQUUsQ0FBQztRQUVyQiw4RUFBOEU7UUFDOUUsOERBQThEO1FBQzlELDJFQUEyRTtRQUMzRSxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxpQkFBTyxDQUFDLElBQUksQ0FBQyxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQztRQUUzRCw0Q0FBNEM7UUFDNUMsSUFBSSxXQUFXLEVBQUUsQ0FBQztZQUNoQixJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLEVBQUU7Z0JBQzlCLE1BQU0sTUFBTSxHQUNWLEdBQUcsQ0FBQyxNQUFNLElBQUksR0FBRyxDQUFDLE1BQU0sQ0FBQyxXQUFXLElBQUksR0FBRyxDQUFDLE1BQU0sQ0FBQyxXQUFXLEVBQUUsQ0FBQztnQkFFbkUsSUFBSSxNQUFNLEtBQUssU0FBUyxF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QUMvQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDakIsQ0FBQyxDQUFDLENBQUM7UUFFSCxDQUFDLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxpQkFBaUIsQ0FBQyxDQUFDO0lBQ3JDLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGZzIGZyb20gXCJmc1wiO1xuaW1wb3J0IHsgU2VydmVyIH0gZnJvbSBcImh0dHBcIjtcbmltcG9ydCB7IEFkZHJlc3NJbmZvLCBTb2NrZXQgfSBmcm9tIFwibmV0XCI7XG5pbXBvcnQgeyBqb2luIH0gZnJvbSBcInBhdGhcIjtcbmltcG9ydCBleHByZXNzIGZyb20gXCJleHByZXNzXCI7XG5pbXBvcnQgeyBJRXZlbnRQdWJsaXNoZXIgfSBmcm9tIFwiLi9ldmVudC1tYXBwaW5nXCI7XG5pbXBvcnQge1xuICBBcGlBdHRyaWJ1dGVzLFxuICBBcGlTY2hlbWEsXG4gIEFwaVJvdXRlLFxuICBFdmVudFN1YnNjcmlwdGlvbixcbn0gZnJvbSBcIi4vc2NoZW1hLXJlc291cmNlc1wiO1xuaW1wb3J0IHsgZXhpc3RzIH0gZnJvbSBcIi4vdXRpbFwiO1xuaW1wb3J0IHtcbiAgQVBJX0ZRTixcbiAgQXBpUmVxdWVzdCxcbiAgQXBpUmVzcG9uc2UsXG4gIERFRkFVTFRfUkVTUE9OU0VfU1RBVFVTLFxuICBJQXBpQ2xpZW50LFxuICBJRnVuY3Rpb25DbGllbnQsXG4gIHBhcnNlSHR0cE1ldGhvZCxcbiAgc2FuaXRpemVQYXJhbUxpa2VPYmplY3QsXG59IGZyb20gXCIuLi9jbG91ZFwiO1xuaW1wb3J0IHtcbiAgSVNpbXVsYXRvckNvbnRleHQsXG4gIElTaW11bGF0b3JSZXNvdXJjZUluc3RhbmNlLFxuICBVcGRhdGVQbGFuLFxufSBmcm9tIFwiLi4vc2ltdWxhdG9yL3NpbXVsYXRvclwiO1xuaW1wb3J0IHsgTG9nTGV2ZWwsIFRyYWNlVHlwZSB9IGZyb20gXCIuLi9zdGRcIjtcblxuY29uc3QgTE9DQUxIT1NUX0FERFJFU1MgPSBcIjEyNy4wLjAuMVwiO1xuXG5jb25zdCBTVEFURV9GSUxFTkFNRSA9IFwic3RhdGUuanNvblwiO1xuXG4vKipcbiAqIENvbnRlbnRzIG9mIHRoZSBzdGF0ZSBmaWxlIGZvciB0aGlzIHJlc291cmNlLlxuICovXG5pbnRlcmZhY2UgU3RhdGVGaWxlQ29udGVudHMge1xuICAvKipcbiAgICogVGhlIGxhc3QgcG9ydCB1c2VkIGJ5IHRoZSBBUEkgc2VydmVyIG9uIGEgcHJldmlvdXMgc2ltdWxhdG9yIHJ1bi5cbiAgICovXG4gIHJlYWRvbmx5IGxhc3RQb3J0PzogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgQXBpUm91dGVXaXRoRnVuY3Rpb25IYW5kbGUgZXh0ZW5kcyBBcGlSb3V0ZSB7XG4gIGZ1bmN0aW9uSGFuZGxlOiBzdHJpbmc7XG4gIGV4cHJlc3NMYXllcjogYW55O1xufVxuXG5leHBvcnQgY2xhc3MgQXBpXG4gIGltcGxlbWVudHMgSUFwaUNsaWVudCwgSVNpbXVsYXRvclJlc291cmNlSW5zdGFuY2UsIElFdmVudFB1Ymxpc2hlclxue1xuICBwcml2YXRlIHJlYWRvbmx5IHJvdXRlczogQXBpUm91dGVXaXRoRnVuY3Rpb25IYW5kbGVbXTtcbiAgcHJpdmF0ZSBfY29udGV4dDogSVNpbXVsYXRvckNvbnRleHQgfCB1bmRlZmluZWQ7XG4gIHByaXZhdGUgcmVhZG9ubHkgYXBwOiBleHByZXNzLkFwcGxpY2F0aW9uO1xuICBwcml2YXRlIHNlcnZlcjogU2VydmVyIHwgdW5kZWZpbmVkO1xuICBwcml2YXRlIHVybDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICBwcml2YXRlIHBvcnQ6IG51bWJlciB8IHVuZGVmaW5lZDtcblxuICBjb25zdHJ1Y3Rvcihwcm9wczogQXBpU2NoZW1hKSB7XG4gICAgdGhpcy5yb3V0ZXMgPSBbXTtcbiAgICBjb25zdCB7IGNvcnNIZWFkZXJzIH0gPSBwcm9wcztcblxuICAgIC8vIFNldCB1cCBhbiBleHByZXNzIHNlcnZlciB0aGF0IGhhbmRsZXMgdGhlIHJvdXRlcy5cbiAgICB0aGlzLmFwcCA9IGV4cHJlc3MoKTtcblxuICAgIC8vIHdlIHBhcnNlIGFsbCByZXF1ZXN0cyBhcyB0ZXh0IGFuZCBsZWF2ZSB0aGUgcGFyc2luZyB0byB0aGUgaW5mbGlnaHQgaGFuZGxlclxuICAgIC8vIG1hdGNoaW5nIHRoZSBsaW1pdCB0byBhd3MgYXBpIGdhdGV3YXkncyBwYXlsb2FkIHNpemUgbGltaXQ6XG4gICAgLy8gaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL2FwaWdhdGV3YXkvbGF0ZXN0L2RldmVsb3Blcmd1aWRlL2xpbWl0cy5odG1sXG4gICAgdGhpcy5hcHAudXNlKGV4cHJlc3MudGV4dCh7IGxpbWl0OiBcIjEwbWJcIiwgdHlwZTogXCIqLypcIiB9KSk7XG5cbiAgICAvLyBTZXQgdXAgQ09SUyBoZWFkZXJzIGZvciBvcHRpb25zIHJlcXVlc3RzLlxuICAgIGlmIChjb3JzSGVhZGVycykge1xuICAgICAgdGhpcy5hcHAudXNlKChyZXEsIHJlcywgbmV4dCkgPT4ge1xuICAgICAgICBjb25zdCBtZXRob2QgPVxuICAgICAgICAgIHJlcS5tZXRob2QgJiYgcmVxLm1ldGhvZC50b1VwcGVyQ2FzZSAmJiByZXEubWV0aG9kLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJPUFRJT05TXCIpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhcbiAgICAgICAgICAgIGNvcnNIZWFkZXJzLm9wdGlvbnNSZXNwb25zZVxuICAgICAgICAgICkpIHtcbiAgICAgICAgICAgIHJlcy5zZXRIZWFkZXIoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlcy5zdGF0dXMoMjA0KS5zZW5kKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoXG4gICAgICAgICAgICBjb3JzSGVhZGVycy5kZWZhdWx0UmVzcG9uc2VcbiAgICAgICAgICApKSB7XG4gICAgICAgICAgICByZXMuc2V0SGVhZGVyKGtleSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZ2V0IGNvbnRleHQoKTogSVNpbXVsYXRvckNvbnRleHQge1xuICAgIGlmICghdGhpcy5fY29udGV4dCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFjY2VzcyBjb250ZXh0IGR1cmluZyBjbGFzcyBjb25zdHJ1Y3Rpb25cIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jb250ZXh0O1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGluaXQoY29udGV4dDogSVNpbXVsYXRvckNvbnRleHQpOiBQcm9taXNlPEFwaUF0dHJpYnV0ZXM+IHtcbiAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICAvLyBDaGVjayBmb3IgYSBwcmV2aW91cyBzdGF0ZSBmaWxlIHRvIHNlZSBpZiB0aGVyZSB3YXMgYSBwb3J0IHRoYXQgd2FzIHByZXZpb3VzbHkgYmVpbmcgdXNlZFxuICAgIC8vIGlmIHNvLCB0cnkgdG8gdXNlIGl0IG91dCBvZiBjb252ZW5pZW5jZVxuICAgIGxldCBsYXN0UG9ydDogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgIGNvbnN0IHN0YXRlOiBTdGF0ZUZpbGVDb250ZW50cyA9IGF3YWl0IHRoaXMubG9hZFN0YXRlKCk7XG4gICAgaWYgKHN0YXRlLmxhc3RQb3J0KSB7XG4gICAgICBjb25zdCBwb3J0QXZhaWxhYmxlID0gYXdhaXQgaXNQb3J0QXZhaWxhYmxlKHN0YXRlLmxhc3RQb3J0KTtcbiAgICAgIGlmIChwb3J0QXZhaWxhYmxlKSB7XG4gICAgICAgIGxhc3RQb3J0ID0gc3RhdGUubGFzdFBvcnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYHNlcnZlci5hZGRyZXNzKClgIHJldHVybnMgYG51bGxgIHVudGlsIHRoZSBzZXJ2ZXIgaXMgbGlzdGVuaW5nXG4gICAgLy8gb24gYSBwb3J0LiBXZSB1c2UgYSBwcm9taXNlIHRvIHdhaXQgZm9yIHRoZSBzZXJ2ZXIgdG8gc3RhcnRcbiAgICAvLyBsaXN0ZW5pbmcgYmVmb3JlIHJldHVybmluZyB0aGUgVVJMLlxuICAgIGNvbnN0IGFkZHJJbmZvOiBBZGRyZXNzSW5mbyA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuc2VydmVyID0gdGhpcy5hcHAubGlzdGVuKGxhc3RQb3J0ID8/IDAsIExPQ0FMSE9TVF9BRERSRVNTLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGFkZHIgPSB0aGlzLnNlcnZlcj8uYWRkcmVzcygpO1xuICAgICAgICBpZiAoYWRkciAmJiB0eXBlb2YgYWRkciA9PT0gXCJvYmplY3RcIiAmJiAoYWRkciBhcyBBZGRyZXNzSW5mbykucG9ydCkge1xuICAgICAgICAgIHJlc29sdmUoYWRkcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIk5vIGFkZHJlc3MgZm91bmRcIikpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLnBvcnQgPSBhZGRySW5mby5wb3J0O1xuICAgIHRoaXMudXJsID0gYGh0dHA6Ly8ke2FkZHJJbmZvLmFkZHJlc3N9OiR7YWRkckluZm8ucG9ydH1gO1xuXG4gICAgdGhpcy5hZGRUcmFjZShgU2VydmVyIGxpc3RlbmluZyBvbiAke3RoaXMudXJsfWAsIExvZ0xldmVsLlZFUkJPU0UpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHVybDogdGhpcy51cmwsXG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBjbGVhbnVwKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMuYWRkVHJhY2UoYENsb3Npbmcgc2VydmVyIG9uICR7dGhpcy51cmx9YCwgTG9nTGV2ZWwuVkVSQk9TRSk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5zZXJ2ZXI/LmNsb3NlKChlcnIpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2VydmVyPy5jbG9zZUFsbENvbm5lY3Rpb25zKCk7XG4gICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBzYXZlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMuc2F2ZVN0YXRlKHsgbGFzdFBvcnQ6IHRoaXMucG9ydCB9KTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBwbGFuKCkge1xuICAgIHJldHVybiBVcGRhdGVQbGFuLkFVVE87XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGxvYWRTdGF0ZSgpOiBQcm9taXNlPFN0YXRlRmlsZUNvbnRlbnRzPiB7XG4gICAgY29uc3Qgc3RhdGVGaWxlRXhpc3RzID0gYXdhaXQgZXhpc3RzKFxuICAgICAgam9pbih0aGlzLmNvbnRleHQuc3RhdGVkaXIsIFNUQVRFX0ZJTEVOQU1FKVxuICAgICk7XG4gICAgaWYgKHN0YXRlRmlsZUV4aXN0cykge1xuICAgICAgY29uc3Qgc3RhdGVGaWxlQ29udGVudHMgPSBhd2FpdCBmcy5wcm9taXNlcy5yZWFkRmlsZShcbiAgICAgICAgam9pbih0aGlzLmNvbnRleHQuc3RhdGVkaXIsIFNUQVRFX0ZJTEVOQU1FKSxcbiAgICAgICAgXCJ1dGYtOFwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RhdGVGaWxlQ29udGVudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBzYXZlU3RhdGUoc3RhdGU6IFN0YXRlRmlsZUNvbnRlbnRzKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgZnMud3JpdGVGaWxlU3luYyhcbiAgICAgIGpvaW4odGhpcy5jb250ZXh0LnN0YXRlZGlyLCBTVEFURV9GSUxFTkFNRSksXG4gICAgICBKU09OLnN0cmluZ2lmeShzdGF0ZSlcbiAgICApO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGFkZEV2ZW50U3Vic2NyaXB0aW9uKFxuICAgIHN1YnNjcmliZXI6IHN0cmluZyxcbiAgICBzdWJzY3JpcHRpb25Qcm9wczogRXZlbnRTdWJzY3JpcHRpb25cbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3Qgcm91dGVzID0gKHN1YnNjcmlwdGlvblByb3BzIGFzIGFueSkucm91dGVzIGFzIEFwaVJvdXRlW107XG4gICAgZm9yIChjb25zdCByb3V0ZSBvZiByb3V0ZXMpIHtcbiAgICAgIGNvbnN0IHMgPSB7XG4gICAgICAgIGZ1bmN0aW9uSGFuZGxlOiBzdWJzY3JpYmVyLFxuICAgICAgICBtZXRob2Q6IHJvdXRlLm1ldGhvZCxcbiAgICAgICAgcGF0aFBhdHRlcm46IHJvdXRlLnBhdGhQYXR0ZXJuLFxuICAgICAgfTtcbiAgICAgIHRoaXMucG9wdWxhdGVSb3V0ZShzLCBzdWJzY3JpYmVyKTtcblxuICAgICAgLy8gS2VlcCB0cmFjayBvZiB0aGUgaW50ZXJuYWwgZXhwcmVzcyBmdW5jdGlvbiBzbyB3ZSBjYW4gcmVtb3ZlIGl0IGxhdGVyXG4gICAgICAvLyBFYWNoIGxheWVyIG9iamVjdCBpbiBleHByZXNzIGxvb2tzIHNvbWV0aGluZyBsaWtlIHRoaXM6XG4gICAgICAvL1xuICAgICAgLy8gTGF5ZXIge1xuICAgICAgLy8gICBoYW5kbGU6IFtGdW5jdGlvbjogYm91bmQgZGlzcGF0Y2hdLFxuICAgICAgLy8gICBuYW1lOiAnYm91bmQgZGlzcGF0Y2gnLFxuICAgICAgLy8gICBwYXJhbXM6IHVuZGVmaW5lZCxcbiAgICAgIC8vICAgcGF0aDogdW5kZWZpbmVkLFxuICAgICAgLy8gICBrZXlzOiBbIFtPYmplY3RdIF0sXG4gICAgICAvLyAgIHJlZ2V4cDogL15cXC9mb29cXC8oPzooW15cXC9dKz8pKVxcLz8kL2kgeyBmYXN0X3N0YXI6IGZhbHNlLCBmYXN0X3NsYXNoOiBmYWxzZSB9LFxuICAgICAgLy8gICByb3V0ZTogUm91dGUgeyBwYXRoOiAnL2Zvby86YmFyJywgc3RhY2s6IFtBcnJheV0sIG1ldGhvZHM6IFtPYmplY3RdIH1cbiAgICAgIC8vIH1cbiAgICAgIGNvbnN0IGV4cHJlc3NSb3V0ZUhhbmRsZSA9XG4gICAgICAgIHRoaXMuYXBwLl9yb3V0ZXIuc3RhY2tbdGhpcy5hcHAuX3JvdXRlci5zdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIHRoaXMucm91dGVzLnB1c2goe1xuICAgICAgICAuLi5zLFxuICAgICAgICBleHByZXNzTGF5ZXI6IGV4cHJlc3NSb3V0ZUhhbmRsZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyByZW1vdmVFdmVudFN1YnNjcmlwdGlvbihzdWJzY3JpYmVyOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMucm91dGVzLmZpbmRJbmRleCgocykgPT4gcy5mdW5jdGlvbkhhbmRsZSA9PT0gc3Vic2NyaWJlcik7XG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgdGhpcy5hZGRUcmFjZShcbiAgICAgICAgYEludGVybmFsIGVycm9yOiBObyByb3V0ZSBmb3VuZCBmb3Igc3Vic2NyaWJlciAke3N1YnNjcmliZXJ9LmAsXG4gICAgICAgIExvZ0xldmVsLldBUk5JTkdcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5yb3V0ZXNbaW5kZXhdLmV4cHJlc3NMYXllcjtcbiAgICBjb25zdCBsYXllckluZGV4ID0gdGhpcy5hcHAuX3JvdXRlci5zdGFjay5pbmRleE9mKGxheWVyKTtcbiAgICBpZiAobGF5ZXJJbmRleCA9PT0gLTEpIHtcbiAgICAgIHRoaXMuYWRkVHJhY2UoXG4gICAgICAgIGBJbnRlcm5hbCBlcnJvcjogTm8gZXhwcmVzcyBsYXllciBmb3VuZCBmb3Igcm91dGUgJHt0aGlzLnJvdXRlc1tpbmRleF0ucGF0aFBhdHRlcm59LmAsXG4gICAgICAgIExvZ0xldmVsLldBUk5JTkdcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYXBwLl9yb3V0ZXIuc3RhY2suc3BsaWNlKGxheWVySW5kZXgsIDEpO1xuICAgIHRoaXMucm91dGVzLnNwbGljZShpbmRleCwgMSk7XG4gIH1cblxuICBwcml2YXRlIHBvcHVsYXRlUm91dGUocm91dGU6IEFwaVJvdXRlLCBmdW5jdGlvbkhhbmRsZTogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc3QgbWV0aG9kID0gcm91dGUubWV0aG9kLnRvTG93ZXJDYXNlKCkgYXNcbiAgICAgIHwgXCJnZXRcIlxuICAgICAgfCBcInBvc3RcIlxuICAgICAgfCBcInB1dFwiXG4gICAgICB8IFwiZGVsZXRlXCJcbiAgICAgIHwgXCJoZWFkXCJcbiAgICAgIHwgXCJvcHRpb25zXCJcbiAgICAgIHwgXCJwYXRjaFwiXG4gICAgICB8IFwiY29ubmVjdFwiO1xuXG4gICAgY29uc3QgZm5DbGllbnQgPSB0aGlzLmNvbnRleHQuZ2V0Q2xpZW50KGZ1bmN0aW9uSGFuZGxlKSBhcyBJRnVuY3Rpb25DbGllbnQ7XG4gICAgdGhpcy5hcHBbbWV0aG9kXShcbiAgICAgIHRyYW5zZm9ybVJvdXRlUGF0aChyb3V0ZS5wYXRoUGF0dGVybiksXG4gICAgICBhc3luY01pZGRsZXdhcmUoXG4gICAgICAgIGFzeW5jIChcbiAgICAgICAgICByZXE6IGV4cHJlc3MuUmVxdWVzdCxcbiAgICAgICAgICByZXM6IGV4cHJlc3MuUmVzcG9uc2UsXG4gICAgICAgICAgbmV4dDogZXhwcmVzcy5OZXh0RnVuY3Rpb25cbiAgICAgICAgKSA9PiB7XG4gICAgICAgICAgdGhpcy5hZGRUcmFjZShcbiAgICAgICAgICAgIGBQcm9jZXNzaW5nIFwiJHtyb3V0ZS5tZXRob2R9ICR7XG4gICAgICAgICAgICAgIHJvdXRlLnBhdGhQYXR0ZXJuXG4gICAgICAgICAgICB9XCIgcGFyYW1zPSR7SlNPTi5zdHJpbmdpZnkocmVxLnBhcmFtcyl9KS5gLFxuICAgICAgICAgICAgTG9nTGV2ZWwuVkVSQk9TRVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBjb25zdCBhcGlSZXF1ZXN0ID0gdHJhbnNmb3JtUmVxdWVzdChyZXEpO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlU3RyaW5nID0gYXdhaXQgZm5DbGllbnQuaW52b2tlKFxuICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShhcGlSZXF1ZXN0KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlOiBBcGlSZXNwb25zZSA9IEpTT04ucGFyc2UocmVzcG9uc2VTdHJpbmcgPz8gXCJ7fVwiKTtcblxuICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzID8/IERFRkFVTFRfUkVTUE9OU0VfU1RBVFVTO1xuICAgICAgICAgICAgcmVzLnN0YXR1cyhzdGF0dXMpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoXG4gICAgICAgICAgICAgIHJlc3BvbnNlPy5oZWFkZXJzID8/IHt9XG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgIHJlcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzcG9uc2U/LmJvZHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZXMuc2VuZChyZXNwb25zZS5ib2R5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWRkVHJhY2UoXG4gICAgICAgICAgICAgIGAke3JvdXRlLm1ldGhvZH0gJHtyb3V0ZS5wYXRoUGF0dGVybn0gLSAke3N0YXR1c30uYCxcbiAgICAgICAgICAgICAgTG9nTGV2ZWwuVkVSQk9TRVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgYWRkVHJhY2UobWVzc2FnZTogc3RyaW5nLCBsZXZlbDogTG9nTGV2ZWwpOiB2b2lkIHtcbiAgICB0aGlzLmNvbnRleHQuYWRkVHJhY2Uoe1xuICAgICAgdHlwZTogVHJhY2VUeXBlLlJFU09VUkNFLFxuICAgICAgbGV2ZWwsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICB9LFxuICAgICAgc291cmNlUGF0aDogdGhpcy5jb250ZXh0LnJlc291cmNlUGF0aCxcbiAgICAgIHNvdXJjZVR5cGU6IEFQSV9GUU4sXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1SZXF1ZXN0KHJlcTogZXhwcmVzcy5SZXF1ZXN0KTogQXBpUmVxdWVzdCB7XG4gIHJldHVybiB7XG4gICAgaGVhZGVyczogc2FuaXRpemVQYXJhbUxpa2VPYmplY3QocmVxLmhlYWRlcnMpLFxuICAgIGJvZHk6IE9iamVjdC5rZXlzKHJlcS5ib2R5KS5sZW5ndGggPiAwID8gcmVxLmJvZHkgOiBcIlwiLFxuICAgIG1ldGhvZDogcGFyc2VIdHRwTWV0aG9kKHJlcS5tZXRob2QpLFxuICAgIHBhdGg6IHJlcS5wYXRoLFxuICAgIHF1ZXJ5OiBzYW5pdGl6ZVBhcmFtTGlrZU9iamVjdChyZXEucXVlcnkgYXMgYW55KSxcbiAgICB2YXJzOiByZXEucGFyYW1zLFxuICB9O1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Sb3V0ZVBhdGgocm91dGU6IHN0cmluZyk6IHN0cmluZyB7XG4gIC8vIHJvdXRlIHZhbGlkYXRpb24gaXMgZG9uZSBpbiB0aGUgcHJlZmxpZ2h0IGZpbGVcbiAgcmV0dXJuIHJvdXRlLnJlcGxhY2UoL3svZywgXCI6XCIpLnJlcGxhY2UoL30vZywgXCJcIik7XG59XG5cbi8vIGV4cHJlc3MgdjQgZG9lc24ndCBuYXRpdmVseSBoYW5kbGUgYXN5bmMgcmVxdWVzdCBoYW5kbGVycywgc28gd2UgbmVlZCB0b1xuLy8gd3JhcCB0aGVtIGluIGEgbWlkZGxld2FyZSBmdW5jdGlvblxuZnVuY3Rpb24gYXN5bmNNaWRkbGV3YXJlKFxuICBmbjogKFxuICAgIHJlcTogZXhwcmVzcy5SZXF1ZXN0LFxuICAgIHJlczogZXhwcmVzcy5SZXNwb25zZSxcbiAgICBuZXh0OiBleHByZXNzLk5leHRGdW5jdGlvblxuICApID0+IFByb21pc2U8YW55PlxuKSB7XG4gIHJldHVybiAoXG4gICAgcmVxOiBleHByZXNzLlJlcXVlc3QsXG4gICAgcmVzOiBleHByZXNzLlJlc3BvbnNlLFxuICAgIG5leHQ6IGV4cHJlc3MuTmV4dEZ1bmN0aW9uXG4gICkgPT4ge1xuICAgIFByb21pc2UucmVzb2x2ZShmbihyZXEsIHJlcywgbmV4dCkpLmNhdGNoKG5leHQpO1xuICB9O1xufVxuXG5hc3luYyBmdW5jdGlvbiBpc1BvcnRBdmFpbGFibGUocG9ydDogbnVtYmVyKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgX3JlamVjdCkgPT4ge1xuICAgIGNvbnN0IHMgPSBuZXcgU29ja2V0KCk7XG4gICAgcy5vbmNlKFwiZXJyb3JcIiwgKGVycikgPT4ge1xuICAgICAgcy5kZXN0cm95KCk7XG4gICAgICBpZiAoKGVyciBhcyBhbnkpLmNvZGUgIT09IFwiRUNPTk5SRUZVU0VEXCIpIHtcbiAgICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjb25uZWN0aW9uIHJlZnVzZWQgbWVhbnMgdGhlIHBvcnQgaXMgbm90IHVzZWRcbiAgICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHMub25jZShcImNvbm5lY3RcIiwgKCkgPT4ge1xuICAgICAgcy5kZXN0cm95KCk7XG4gICAgICAvLyBjb25uZWN0aW9uIHN1Y2Nlc3NmdWwgbWVhbnMgdGhlIHBvcnQgaXMgdXNlZFxuICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgfSk7XG5cbiAgICBzLmNvbm5lY3QocG9ydCwgTE9DQUxIT1NUX0FERFJFU1MpO1xuICB9KTtcbn1cbiJdfQ==