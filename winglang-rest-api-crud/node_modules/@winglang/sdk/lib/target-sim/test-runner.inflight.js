"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestRunner = void 0;
const simulator_1 = require("../simulator");
const std_1 = require("../std");
class TestRunner {
    constructor(props) {
        this.tests = new Map(Object.entries(props.tests));
    }
    get context() {
        if (!this._context) {
            throw new Error("Cannot access context during class construction");
        }
        return this._context;
    }
    async init(context) {
        this._context = context;
        return {};
    }
    async cleanup() {
        return;
    }
    async save() { }
    async plan() {
        return simulator_1.UpdatePlan.AUTO;
    }
    async listTests() {
        return Array.from(this.tests.keys());
    }
    async runTest(path) {
        let functionHandle = this.tests.get(path);
        if (!functionHandle) {
            throw new Error(`No test found at path "${path}"`);
        }
        const fnClient = this.context.getClient(functionHandle, true);
        let pass = false;
        let error;
        const previousTraces = this.context.listTraces().length;
        try {
            await fnClient.invoke();
            pass = true;
        }
        catch (e) {
            error = e.stack;
        }
        // only return traces that were added after the test was run
        const newTraces = this.context.listTraces().slice(previousTraces);
        // as well as any log trace prior to that- https://github.com/winglang/wing/issues/4995
        const logTraces = this.context
            .listTraces()
            .slice(0, previousTraces)
            .filter((trace) => trace.type === std_1.TraceType.LOG);
        return {
            path,
            pass,
            error,
            traces: [...logTraces, ...newTraces],
        };
    }
}
exports.TestRunner = TestRunner;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVzdC1ydW5uZXIuaW5mbGlnaHQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvdGFyZ2V0LXNpbS90ZXN0LXJ1bm5lci5pbmZsaWdodC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFFQSw0Q0FJc0I7QUFDdEIsZ0NBQWtFO0FBRWxFLE1BQWEsVUFBVTtJQU9yQixZQUFZLEtBQXVCO1FBQ2pDLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxHQUFHLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztJQUNwRCxDQUFDO0lBRUQsSUFBWSxPQUFPO1FBQ2pCLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7WUFDbkIsTUFBTSxJQUFJLEtBQUssQ0FBQyxpREFBaUQsQ0FBQyxDQUFDO1FBQ3JFLENBQUM7UUFDRCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUM7SUFDdkIsQ0FBQztJQUVNLEtBQUssQ0FBQyxJQUFJLENBQUMsT0FBMEI7UUFDMUMsSUFBSSxDQUFDLFFBQVEsR0FBRyxPQUFPLENBQUM7UUFDeEIsT0FBTyxFQUFFLENBQUM7SUFDWixDQUFDO0lBRU0sS0FBSyxDQUFDLE9BQU87UUFDbEIsT0FBTztJQUNULENBQUM7SUFFTSxLQUFLLENBQUMsSUFBSSxLQUFtQixDQUFDO0lBRTlCLEtBQUssQ0FBQyxJQUFJO1FBQ2YsT0FBTyxzQkFBVSxDQUFDLElBQUksQ0FBQztJQUN6QixDQUFDO0lBRU0sS0FBSyxDQUFDLFNBQVM7UUFDcEIsT0FBTyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQztJQUN2QyxDQUFDO0lBRU0sS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFZO1FBQy9CLElBQUksY0FBYyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzFDLElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQztZQUNwQixNQUFNLElBQUksS0FBSyxDQUFDLDBCQUEwQixJQUFJLEdBQUcsQ0FBQyxDQUFDO1FBQ3JELENBQUM7UUFDRCxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FDckMsY0FBYyxFQUNkLElBQUksQ0FDYyxDQUFDO1FBQ3JCLElBQUksSUFBSSxHQUFHLEtBQUssQ0FBQztRQUNqQixJQUFJLEtBQXlCLENBQUM7UUFDOUIsTUFBTSxjQUFjLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxVQUFVLEVBQUUsQ0FBQyxNQUFNLENBQUM7UUFDeEQsSUFBSSxDQUFDO1lBQ0gsTUFBTSxRQUFRLENBQUMsTUFBTSxFQUFFLENBQUM7WUFDeEIsSUFBSSxHQUFHLElBQUksQ0FBQztRQUNkLENBQUM7UUFBQyxPQUFPLENBQU0sRUFBRSxDQUFDO1lBQ2hCLEtBQUssR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDO1FBQ2xCLENBQUM7UUFDRCw0REFBNEQ7UUFDNUQsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxVQUFVLEVBQUUsQ0FBQyxLQUFLLENBQUMsY0FBYyxDQUFDLENBQUM7UUFFbEUsdUZBQXVGO1FBQ3ZGLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxPQUFPO2FBQzNCLFVBQVUsRUFBRTthQUNaLEtBQUssQ0FBQyxDQUFDLEVBQUUsY0FBYyxDQUFDO2FBQ3hCLE1BQU0sQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksS0FBSyxlQUFTLENBQUMsR0FBRyxDQUFDLENBQUM7UUFFbkQsT0FBTztZQUNMLElBQUk7WUFDSixJQUFJO1lBQ0osS0FBSztZQUNMLE1BQU0sRUFBRSxDQUFDLEdBQUcsU0FBUyxFQUFFLEdBQUcsU0FBUyxDQUFDO1NBQ3JDLENBQUM7SUFDSixDQUFDO0NBQ0Y7QUF2RUQsZ0NBdUVDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVGVzdFJ1bm5lckF0dHJpYnV0ZXMsIFRlc3RSdW5uZXJTY2hlbWEgfSBmcm9tIFwiLi9zY2hlbWEtcmVzb3VyY2VzXCI7XG5pbXBvcnQgeyBJRnVuY3Rpb25DbGllbnQgfSBmcm9tIFwiLi4vY2xvdWRcIjtcbmltcG9ydCB7XG4gIElTaW11bGF0b3JDb250ZXh0LFxuICBJU2ltdWxhdG9yUmVzb3VyY2VJbnN0YW5jZSxcbiAgVXBkYXRlUGxhbixcbn0gZnJvbSBcIi4uL3NpbXVsYXRvclwiO1xuaW1wb3J0IHsgSVRlc3RSdW5uZXJDbGllbnQsIFRlc3RSZXN1bHQsIFRyYWNlVHlwZSB9IGZyb20gXCIuLi9zdGRcIjtcblxuZXhwb3J0IGNsYXNzIFRlc3RSdW5uZXJcbiAgaW1wbGVtZW50cyBJVGVzdFJ1bm5lckNsaWVudCwgSVNpbXVsYXRvclJlc291cmNlSW5zdGFuY2VcbntcbiAgLy8gQSBtYXAgZnJvbSB0ZXN0IHBhdGhzIHRvIHRoZWlyIGNvcnJlc3BvbmRpbmcgZnVuY3Rpb24gaGFuZGxlcy5cbiAgcHJpdmF0ZSByZWFkb25seSB0ZXN0czogTWFwPHN0cmluZywgc3RyaW5nPjtcbiAgcHJpdmF0ZSBfY29udGV4dDogSVNpbXVsYXRvckNvbnRleHQgfCB1bmRlZmluZWQ7XG5cbiAgY29uc3RydWN0b3IocHJvcHM6IFRlc3RSdW5uZXJTY2hlbWEpIHtcbiAgICB0aGlzLnRlc3RzID0gbmV3IE1hcChPYmplY3QuZW50cmllcyhwcm9wcy50ZXN0cykpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXQgY29udGV4dCgpOiBJU2ltdWxhdG9yQ29udGV4dCB7XG4gICAgaWYgKCF0aGlzLl9jb250ZXh0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYWNjZXNzIGNvbnRleHQgZHVyaW5nIGNsYXNzIGNvbnN0cnVjdGlvblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRleHQ7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgaW5pdChjb250ZXh0OiBJU2ltdWxhdG9yQ29udGV4dCk6IFByb21pc2U8VGVzdFJ1bm5lckF0dHJpYnV0ZXM+IHtcbiAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgY2xlYW51cCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm47XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgc2F2ZSgpOiBQcm9taXNlPHZvaWQ+IHt9XG5cbiAgcHVibGljIGFzeW5jIHBsYW4oKSB7XG4gICAgcmV0dXJuIFVwZGF0ZVBsYW4uQVVUTztcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBsaXN0VGVzdHMoKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMudGVzdHMua2V5cygpKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBydW5UZXN0KHBhdGg6IHN0cmluZyk6IFByb21pc2U8VGVzdFJlc3VsdD4ge1xuICAgIGxldCBmdW5jdGlvbkhhbmRsZSA9IHRoaXMudGVzdHMuZ2V0KHBhdGgpO1xuICAgIGlmICghZnVuY3Rpb25IYW5kbGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gdGVzdCBmb3VuZCBhdCBwYXRoIFwiJHtwYXRofVwiYCk7XG4gICAgfVxuICAgIGNvbnN0IGZuQ2xpZW50ID0gdGhpcy5jb250ZXh0LmdldENsaWVudChcbiAgICAgIGZ1bmN0aW9uSGFuZGxlLFxuICAgICAgdHJ1ZVxuICAgICkgYXMgSUZ1bmN0aW9uQ2xpZW50O1xuICAgIGxldCBwYXNzID0gZmFsc2U7XG4gICAgbGV0IGVycm9yOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgY29uc3QgcHJldmlvdXNUcmFjZXMgPSB0aGlzLmNvbnRleHQubGlzdFRyYWNlcygpLmxlbmd0aDtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgZm5DbGllbnQuaW52b2tlKCk7XG4gICAgICBwYXNzID0gdHJ1ZTtcbiAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgIGVycm9yID0gZS5zdGFjaztcbiAgICB9XG4gICAgLy8gb25seSByZXR1cm4gdHJhY2VzIHRoYXQgd2VyZSBhZGRlZCBhZnRlciB0aGUgdGVzdCB3YXMgcnVuXG4gICAgY29uc3QgbmV3VHJhY2VzID0gdGhpcy5jb250ZXh0Lmxpc3RUcmFjZXMoKS5zbGljZShwcmV2aW91c1RyYWNlcyk7XG5cbiAgICAvLyBhcyB3ZWxsIGFzIGFueSBsb2cgdHJhY2UgcHJpb3IgdG8gdGhhdC0gaHR0cHM6Ly9naXRodWIuY29tL3dpbmdsYW5nL3dpbmcvaXNzdWVzLzQ5OTVcbiAgICBjb25zdCBsb2dUcmFjZXMgPSB0aGlzLmNvbnRleHRcbiAgICAgIC5saXN0VHJhY2VzKClcbiAgICAgIC5zbGljZSgwLCBwcmV2aW91c1RyYWNlcylcbiAgICAgIC5maWx0ZXIoKHRyYWNlKSA9PiB0cmFjZS50eXBlID09PSBUcmFjZVR5cGUuTE9HKTtcblxuICAgIHJldHVybiB7XG4gICAgICBwYXRoLFxuICAgICAgcGFzcyxcbiAgICAgIGVycm9yLFxuICAgICAgdHJhY2VzOiBbLi4ubG9nVHJhY2VzLCAuLi5uZXdUcmFjZXNdLFxuICAgIH07XG4gIH1cbn1cbiJdfQ==