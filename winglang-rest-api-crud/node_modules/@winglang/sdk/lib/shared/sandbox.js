"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SandboxMultipleConcurrentCallsError = exports.SandboxTimeoutError = exports.Sandbox = void 0;
const cp = __importStar(require("child_process"));
const fs_1 = require("fs");
const promises_1 = require("fs/promises");
const inspector_1 = require("inspector");
const bundling_1 = require("./bundling");
const stream_processor_1 = require("./stream-processor");
const std_1 = require("../std");
class Sandbox {
    static async createBundle(entrypoint, log) {
        let contents = await (0, promises_1.readFile)(entrypoint, "utf-8");
        // log a warning if contents includes __dirname or __filename
        if (contents.includes("__dirname") || contents.includes("__filename")) {
            log?.(`Warning: __dirname and __filename cannot be used within bundled cloud functions. There may be unexpected behavior.`, std_1.LogLevel.WARNING);
        }
        let debugShim = "";
        if ((0, inspector_1.url)?.()) {
            // If we're debugging, we need to make sure the debugger has enough time to attach
            // to the child process. This gives enough time for the debugger load sourcemaps and set breakpoints.
            // See https://github.com/microsoft/vscode-js-debug/issues/1510
            debugShim =
                "\n  await new Promise((resolve) => setTimeout(resolve, 25));";
        }
        // wrap contents with a shim that handles the communication with the parent process
        // we insert this shim before bundling to ensure source maps are generated correctly
        contents += `
process.on("uncaughtException", (reason) => {
  process.send({ type: "error", reason });
});

process.on("message", async (message) => {${debugShim}
  const { fn, args } = message;
  const value = await exports[fn](...args);
  process.send({ type: "ok", value });
});
`;
        const wrappedPath = entrypoint.replace(/\.cjs$/, ".sandbox.cjs");
        (0, fs_1.writeFileSync)(wrappedPath, contents); // async fsPromises.writeFile "flush" option is not available in Node 20
        const bundle = (0, bundling_1.createBundle)(wrappedPath);
        if (process.env.DEBUG) {
            const fileStats = await (0, promises_1.stat)(entrypoint);
            log?.(`Bundled code (${fileStats.size} bytes).`, std_1.LogLevel.VERBOSE);
        }
        return bundle;
    }
    constructor(entrypoint, options = {}) {
        // Tracks whether the sandbox is available to process a new request
        // When call() is called, it sets this to false, and when it's returning
        // a response or error, it sets it back to true.
        this.available = true;
        this.cleaningUp = false;
        this.entrypoint = entrypoint;
        this.options = options;
    }
    async cleanup() {
        this.cleaningUp = true;
        if (this.timeout) {
            clearTimeout(this.timeout);
        }
        else {
        }
        if (this.child) {
            this.debugLog(`Terminating sandbox child process (PID ${this.childPid}).`);
            this.child.kill("SIGTERM");
            this.child = undefined;
            this.available = true;
        }
    }
    isAvailable() {
        return this.available;
    }
    async initialize() {
        const childEnv = this.options.env ?? {};
        if ((0, inspector_1.url)?.()) {
            // We're exposing a debugger, let's attempt to ensure the child process automatically attaches
            childEnv.NODE_OPTIONS =
                (childEnv.NODE_OPTIONS ?? "") + (process.env.NODE_OPTIONS ?? "");
            // If the child process is not already configured to attach a debugger, add a flag to do so
            if (!childEnv.NODE_OPTIONS.includes("--inspect") &&
                !process.execArgv.includes("--inspect")) {
                childEnv.NODE_OPTIONS += " --inspect=0";
            }
            // VSCode's debugger adds some environment variables that we want to pass to the child process
            for (const key in process.env) {
                if (key.startsWith("VSCODE_")) {
                    childEnv[key] = process.env[key];
                }
            }
        }
        // start a Node.js process that runs the inflight code
        // note: unlike the fork(2) POSIX system call, child_process.fork()
        // does not clone the current process
        this.child = cp.fork(this.entrypoint, {
            env: childEnv,
            stdio: "pipe",
            // keep the process detached so in the case of cloud.Service, if the parent process is killed
            // (e.g. someone presses Ctrl+C while using Wing Console),
            // we can gracefully call any cleanup code in the child process
            detached: true,
            // this option allows complex objects like Error to be sent from the child process to the parent
            serialization: "advanced",
        });
        this.childPid = this.child.pid;
        this.debugLog(`Initialized sandbox (PID ${this.childPid}).`);
        const log = (message) => {
            let level = std_1.LogLevel.INFO;
            if (message.startsWith("info:")) {
                message = message.slice(5);
            }
            else if (message.startsWith("error:")) {
                message = message.slice(6);
                level = std_1.LogLevel.ERROR;
            }
            else if (message.startsWith("warning:")) {
                message = message.slice(8);
                level = std_1.LogLevel.WARNING;
            }
            else if (message.startsWith("verbose:")) {
                message = message.slice(8);
                level = std_1.LogLevel.VERBOSE;
            }
            this.options.log?.(false, level, message);
        };
        const logError = (message) => this.options.log?.(false, std_1.LogLevel.ERROR, message);
        // pipe stdout and stderr from the child process
        if (this.child.stdout) {
            (0, stream_processor_1.processStream)(this.child.stdout, log);
        }
        if (this.child.stderr) {
            (0, stream_processor_1.processStream)(this.child.stderr, logError);
        }
        this.child.on("message", (message) => {
            this.onChildMessage?.(message);
        });
        this.child.on("error", (error) => {
            this.onChildError?.(error);
        });
        this.child.on("exit", (code, signal) => {
            this.onChildExit?.(code, signal);
        });
    }
    async call(fn, ...args) {
        if (!this.available) {
            throw new SandboxMultipleConcurrentCallsError();
        }
        // Prevent multiple calls to the same sandbox running concurrently.
        this.available = false;
        // If this sandbox doesn't have a child process running (because it
        // just got created, OR because the previous child process was killed due
        // to timeout or an unexpected error), initialize one.
        if (!this.child) {
            await this.initialize();
        }
        // Send the function name and arguments to the child process.
        // When a message is received, resolve or reject the promise.
        return new Promise((resolve, reject) => {
            this.child.send({ fn, args });
            this.debugLog(`Sent a message to the sandbox (PID ${this.childPid}): ${JSON.stringify({
                fn,
                args,
            })}`);
            this.onChildMessage = (message) => {
                this.debugLog(`Received a message from the sandbox (PID ${this.childPid}): ${JSON.stringify(message)}`);
                this.available = true;
                if (this.timeout) {
                    clearTimeout(this.timeout);
                }
                if (message.type === "ok") {
                    resolve(message.value);
                }
                else if (message.type === "error") {
                    reject(message.reason);
                }
                else {
                    reject(new Error(`Unexpected message from the sandbox (PID ${this.childPid}): ${message}`));
                }
            };
            // "error" could be emitted for any number of reasons
            // (e.g. the process couldn't be spawned or killed, or a message couldn't be sent).
            // Since this is unexpected, we kill the process with SIGKILL to ensure it's dead, and reject the promise.
            this.onChildError = (error) => {
                this.debugLog(`Unexpected error from the sandbox (PID ${this.childPid}).`);
                this.child?.kill("SIGKILL");
                this.child = undefined;
                this.available = true;
                if (this.timeout) {
                    clearTimeout(this.timeout);
                }
                if (this.cleaningUp) {
                    resolve(undefined);
                }
                else {
                    reject(error);
                }
            };
            // "exit" could be emitted if the user code called process.exit(), or if we killed the process
            // due to a timeout or unexpected error. In any case, we reject the promise.
            this.onChildExit = (code, signal) => {
                this.debugLog(`Sandbox (PID ${this.childPid}) stopped.`);
                this.child = undefined;
                this.available = true;
                if (this.timeout) {
                    clearTimeout(this.timeout);
                }
                if (this.cleaningUp) {
                    resolve(undefined);
                }
                else {
                    reject(new Error(`Process exited with code ${code}, signal ${signal}`));
                }
            };
            if (this.options.timeout && !(0, inspector_1.url)?.()) {
                this.timeout = setTimeout(() => {
                    this.debugLog(`Killing sandbox (PID ${this.childPid}) after timeout.`);
                    this.child?.kill("SIGTERM");
                    this.child = undefined;
                    this.available = true;
                    if (this.cleaningUp) {
                        resolve(undefined);
                    }
                    else {
                        reject(new SandboxTimeoutError(this.options.timeout ?? 0));
                    }
                }, this.options.timeout);
            }
        });
    }
    debugLog(message) {
        if (process.env.DEBUG) {
            this.options.log?.(true, std_1.LogLevel.VERBOSE, message);
        }
    }
}
exports.Sandbox = Sandbox;
class SandboxTimeoutError extends Error {
    constructor(timeout) {
        super("Timed out after " + timeout + "ms.");
        this.timeout = timeout;
    }
}
exports.SandboxTimeoutError = SandboxTimeoutError;
class SandboxMultipleConcurrentCallsError extends Error {
    constructor() {
        super("Cannot process multiple requests in parallel.");
    }
}
exports.SandboxMultipleConcurrentCallsError = SandboxMultipleConcurrentCallsError;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2FuZGJveC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zaGFyZWQvc2FuZGJveC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGtEQUFvQztBQUNwQywyQkFBbUM7QUFDbkMsMENBQTZDO0FBQzdDLHlDQUFnRDtBQUNoRCx5Q0FBa0Q7QUFDbEQseURBQW1EO0FBQ25ELGdDQUFrQztBQXFDbEMsTUFBYSxPQUFPO0lBQ1gsTUFBTSxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQzlCLFVBQWtCLEVBQ2xCLEdBQWdEO1FBRWhELElBQUksUUFBUSxHQUFHLE1BQU0sSUFBQSxtQkFBUSxFQUFDLFVBQVUsRUFBRSxPQUFPLENBQUMsQ0FBQztRQUVuRCw2REFBNkQ7UUFDN0QsSUFBSSxRQUFRLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQztZQUN0RSxHQUFHLEVBQUUsQ0FDSCxvSEFBb0gsRUFDcEgsY0FBUSxDQUFDLE9BQU8sQ0FDakIsQ0FBQztRQUNKLENBQUM7UUFFRCxJQUFJLFNBQVMsR0FBRyxFQUFFLENBQUM7UUFDbkIsSUFBSSxJQUFBLGVBQVksQ0FBQSxFQUFFLEVBQUUsRUFBRSxDQUFDO1lBQ3JCLGtGQUFrRjtZQUNsRixxR0FBcUc7WUFDckcsK0RBQStEO1lBQy9ELFNBQVM7Z0JBQ1AsOERBQThELENBQUM7UUFDbkUsQ0FBQztRQUVELG1GQUFtRjtRQUNuRixvRkFBb0Y7UUFDcEYsUUFBUSxJQUFJOzs7Ozs0Q0FLNEIsU0FBUzs7Ozs7Q0FLcEQsQ0FBQztRQUVFLE1BQU0sV0FBVyxHQUFHLFVBQVUsQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLGNBQWMsQ0FBQyxDQUFDO1FBQ2pFLElBQUEsa0JBQWEsRUFBQyxXQUFXLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQyx3RUFBd0U7UUFDOUcsTUFBTSxN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QyxPQUFlO1FBQzlCLElBQUksT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsQ0FBQztZQUN0QixJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksRUFBRSxjQUFRLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQ3RELENBQUM7SUFDSCxDQUFDO0NBQ0Y7QUE3UkQsMEJBNlJDO0FBRUQsTUFBYSxtQkFBb0IsU0FBUSxLQUFLO0lBQzVDLFlBQTRCLE9BQWU7UUFDekMsS0FBSyxDQUFDLGtCQUFrQixHQUFHLE9BQU8sR0FBRyxLQUFLLENBQUMsQ0FBQztRQURsQixZQUFPLEdBQVAsT0FBTyxDQUFRO0lBRTNDLENBQUM7Q0FDRjtBQUpELGtEQUlDO0FBRUQsTUFBYSxtQ0FBb0MsU0FBUSxLQUFLO0lBQzVEO1FBQ0UsS0FBSyxDQUFDLCtDQUErQyxDQUFDLENBQUM7SUFDekQsQ0FBQztDQUNGO0FBSkQsa0ZBSUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBjcCBmcm9tIFwiY2hpbGRfcHJvY2Vzc1wiO1xuaW1wb3J0IHsgd3JpdGVGaWxlU3luYyB9IGZyb20gXCJmc1wiO1xuaW1wb3J0IHsgcmVhZEZpbGUsIHN0YXQgfSBmcm9tIFwiZnMvcHJvbWlzZXNcIjtcbmltcG9ydCB7IHVybCBhcyBpbnNwZWN0b3JVcmwgfSBmcm9tIFwiaW5zcGVjdG9yXCI7XG5pbXBvcnQgeyBCdW5kbGUsIGNyZWF0ZUJ1bmRsZSB9IGZyb20gXCIuL2J1bmRsaW5nXCI7XG5pbXBvcnQgeyBwcm9jZXNzU3RyZWFtIH0gZnJvbSBcIi4vc3RyZWFtLXByb2Nlc3NvclwiO1xuaW1wb3J0IHsgTG9nTGV2ZWwgfSBmcm9tIFwiLi4vc3RkXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2FuZGJveE9wdGlvbnMge1xuICByZWFkb25seSBlbnY/OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xuICByZWFkb25seSBjb250ZXh0PzogeyBba2V5OiBzdHJpbmddOiBhbnkgfTtcbiAgLyoqXG4gICAqIEhvdyBsb25nIHRoZSBzYW5kYm94IGlzIGFsbG93ZWQgdG8gcnVuIGNvZGUgd2hlbiBgc2FuZGJveC5jYWxsKClgIGlzIGNhbGxlZFxuICAgKiBiZWZvcmUgdGhlIGNoaWxkIHByb2Nlc3Mgc2hvdWxkIGJlIHN0b3BwZWQgKGtpbGxlZCksIGluIG1pbGxpc2Vjb25kcy5cbiAgICpcbiAgICogSWYgYW4gaW52b2NhdGlvbiByZXR1cm5zIHN1Y2Nlc3NmdWxseSwgdGhlIGNoaWxkIHByb2Nlc3MgY29udGludWVzIHJ1bm5pbmdcbiAgICogYW5kIGNhbiBiZSByZXVzZWQgZm9yIHN1YnNlcXVlbnQgaW52b2NhdGlvbnMuXG4gICAqL1xuICByZWFkb25seSB0aW1lb3V0PzogbnVtYmVyO1xuICByZWFkb25seSBsb2c/OiAoaW50ZXJuYWw6IGJvb2xlYW4sIGxldmVsOiBMb2dMZXZlbCwgbWVzc2FnZTogc3RyaW5nKSA9PiB2b2lkO1xufVxuXG4vKipcbiAqIFNoYXBlIG9mIHRoZSBtZXNzYWdlcyBzZW50IHRvIHRoZSBjaGlsZCBwcm9jZXNzLlxuICovXG50eXBlIFByb2Nlc3NSZXF1ZXN0ID0ge1xuICBmbjogc3RyaW5nO1xuICBhcmdzOiBhbnlbXTtcbn07XG5cbi8qKlxuICogU2hhcGUgb2YgdGhlIG1lc3NhZ2VzIHJldHVybmVkIGJ5IHRoZSBjaGlsZCBwcm9jZXNzLlxuICovXG50eXBlIFByb2Nlc3NSZXNwb25zZSA9XG4gIHwge1xuICAgICAgdHlwZTogXCJva1wiO1xuICAgICAgdmFsdWU6IGFueTtcbiAgICB9XG4gIHwge1xuICAgICAgdHlwZTogXCJlcnJvclwiO1xuICAgICAgcmVhc29uOiBFcnJvcjtcbiAgICB9O1xuXG5leHBvcnQgY2xhc3MgU2FuZGJveCB7XG4gIHB1YmxpYyBzdGF0aWMgYXN5bmMgY3JlYXRlQnVuZGxlKFxuICAgIGVudHJ5cG9pbnQ6IHN0cmluZyxcbiAgICBsb2c/OiAobWVzc2FnZTogc3RyaW5nLCBsZXZlbDogTG9nTGV2ZWwpID0+IHZvaWRcbiAgKTogUHJvbWlzZTxCdW5kbGU+IHtcbiAgICBsZXQgY29udGVudHMgPSBhd2FpdCByZWFkRmlsZShlbnRyeXBvaW50LCBcInV0Zi04XCIpO1xuXG4gICAgLy8gbG9nIGEgd2FybmluZyBpZiBjb250ZW50cyBpbmNsdWRlcyBfX2Rpcm5hbWUgb3IgX19maWxlbmFtZVxuICAgIGlmIChjb250ZW50cy5pbmNsdWRlcyhcIl9fZGlybmFtZVwiKSB8fCBjb250ZW50cy5pbmNsdWRlcyhcIl9fZmlsZW5hbWVcIikpIHtcbiAgICAgIGxvZz8uKFxuICAgICAgICBgV2FybmluZzogX19kaXJuYW1lIGFuZCBfX2ZpbGVuYW1lIGNhbm5vdCBiZSB1c2VkIHdpdGhpbiBidW5kbGVkIGNsb3VkIGZ1bmN0aW9ucy4gVGhlcmUgbWF5IGJlIHVuZXhwZWN0ZWQgYmVoYXZpb3IuYCxcbiAgICAgICAgTG9nTGV2ZWwuV0FSTklOR1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgZGVidWdTaGltID0gXCJcIjtcbiAgICBpZiAoaW5zcGVjdG9yVXJsPy4oKSkge1xuICAgICAgLy8gSWYgd2UncmUgZGVidWdnaW5nLCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGUgZGVidWdnZXIgaGFzIGVub3VnaCB0aW1lIHRvIGF0dGFjaFxuICAgICAgLy8gdG8gdGhlIGNoaWxkIHByb2Nlc3MuIFRoaXMgZ2l2ZXMgZW5vdWdoIHRpbWUgZm9yIHRoZSBkZWJ1Z2dlciBsb2FkIHNvdXJjZW1hcHMgYW5kIHNldCBicmVha3BvaW50cy5cbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L3ZzY29kZS1qcy1kZWJ1Zy9pc3N1ZXMvMTUxMFxuICAgICAgZGVidWdTaGltID1cbiAgICAgICAgXCJcXG4gIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDI1KSk7XCI7XG4gICAgfVxuXG4gICAgLy8gd3JhcCBjb250ZW50cyB3aXRoIGEgc2hpbSB0aGF0IGhhbmRsZXMgdGhlIGNvbW11bmljYXRpb24gd2l0aCB0aGUgcGFyZW50IHByb2Nlc3NcbiAgICAvLyB3ZSBpbnNlcnQgdGhpcyBzaGltIGJlZm9yZSBidW5kbGluZyB0byBlbnN1cmUgc291cmNlIG1hcHMgYXJlIGdlbmVyYXRlZCBjb3JyZWN0bHlcbiAgICBjb250ZW50cyArPSBgXG5wcm9jZXNzLm9uKFwidW5jYXVnaHRFeGNlcHRpb25cIiwgKHJlYXNvbikgPT4ge1xuICBwcm9jZXNzLnNlbmQoeyB0eXBlOiBcImVycm9yXCIsIHJlYXNvbiB9KTtcbn0pO1xuXG5wcm9jZXNzLm9uKFwibWVzc2FnZVwiLCBhc3luYyAobWVzc2FnZSkgPT4geyR7ZGVidWdTaGltfVxuICBjb25zdCB7IGZuLCBhcmdzIH0gPSBtZXNzYWdlO1xuICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4cG9ydHNbZm5dKC4uLmFyZ3MpO1xuICBwcm9jZXNzLnNlbmQoeyB0eXBlOiBcIm9rXCIsIHZhbHVlIH0pO1xufSk7XG5gO1xuXG4gICAgY29uc3Qgd3JhcHBlZFBhdGggPSBlbnRyeXBvaW50LnJlcGxhY2UoL1xcLmNqcyQvLCBcIi5zYW5kYm94LmNqc1wiKTtcbiAgICB3cml0ZUZpbGVTeW5jKHdyYXBwZWRQYXRoLCBjb250ZW50cyk7IC8vIGFzeW5jIGZzUHJvbWlzZXMud3JpdGVGaWxlIFwiZmx1c2hcIiBvcHRpb24gaXMgbm90IGF2YWlsYWJsZSBpbiBOb2RlIDIwXG4gICAgY29uc3QgYnVuZGxlID0gY3JlYXRlQnVuZGxlKHdyYXBwZWRQYXRoKTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5ERUJVRykge1xuICAgICAgY29uc3QgZmlsZVN0YXRzID0gYXdhaXQgc3RhdChlbnRyeXBvaW50KTtcbiAgICAgIGxvZz8uKGBCdW5kbGVkIGNvZGUgKCR7ZmlsZVN0YXRzLnNpemV9IGJ5dGVzKS5gLCBMb2dMZXZlbC5WRVJCT1NFKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVuZGxlO1xuICB9XG5cbiAgcHJpdmF0ZSByZWFkb25seSBlbnRyeXBvaW50OiBzdHJpbmc7XG4gIHByaXZhdGUgcmVhZG9ubHkgb3B0aW9uczogU2FuZGJveE9wdGlvbnM7XG5cbiAgcHJpdmF0ZSBjaGlsZDogY3AuQ2hpbGRQcm9jZXNzIHwgdW5kZWZpbmVkO1xuICBwcml2YXRlIGNoaWxkUGlkOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gIHByaXZhdGUgb25DaGlsZE1lc3NhZ2U6ICgobWVzc2FnZTogUHJvY2Vzc1Jlc3BvbnNlKSA9PiB2b2lkKSB8IHVuZGVmaW5lZDtcbiAgcHJpdmF0ZSBvbkNoaWxkRXJyb3I6ICgoZXJyb3I6IEVycm9yKSA9PiB2b2lkKSB8IHVuZGVmaW5lZDtcbiAgcHJpdmF0ZSBvbkNoaWxkRXhpdDpcbiAgICB8ICgoY29kZTogbnVtYmVyIHwgbnVsbCwgc2lnbmFsOiBOb2RlSlMuU2lnbmFscyB8IG51bGwpID0+IHZvaWQpXG4gICAgfCB1bmRlZmluZWQ7XG5cbiAgcHJpdmF0ZSB0aW1lb3V0OiBOb2RlSlMuVGltZW91dCB8IHVuZGVmaW5lZDtcblxuICAvLyBUcmFja3Mgd2hldGhlciB0aGUgc2FuZGJveCBpcyBhdmFpbGFibGUgdG8gcHJvY2VzcyBhIG5ldyByZXF1ZXN0XG4gIC8vIFdoZW4gY2FsbCgpIGlzIGNhbGxlZCwgaXQgc2V0cyB0aGlzIHRvIGZhbHNlLCBhbmQgd2hlbiBpdCdzIHJldHVybmluZ1xuICAvLyBhIHJlc3BvbnNlIG9yIGVycm9yLCBpdCBzZXRzIGl0IGJhY2sgdG8gdHJ1ZS5cbiAgcHJpdmF0ZSBhdmFpbGFibGUgPSB0cnVlO1xuICBwcml2YXRlIGNsZWFuaW5nVXAgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihlbnRyeXBvaW50OiBzdHJpbmcsIG9wdGlvbnM6IFNhbmRib3hPcHRpb25zID0ge30pIHtcbiAgICB0aGlzLmVudHJ5cG9pbnQgPSBlbnRyeXBvaW50O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgY2xlYW51cCgpIHtcbiAgICB0aGlzLmNsZWFuaW5nVXAgPSB0cnVlO1xuICAgIGlmICh0aGlzLnRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY2hpbGQpIHtcbiAgICAgIHRoaXMuZGVidWdMb2coXG4gICAgICAgIGBUZXJtaW5hdGluZyBzYW5kYm94IGNoaWxkIHByb2Nlc3MgKFBJRCAke3RoaXMuY2hpbGRQaWR9KS5gXG4gICAgICApO1xuICAgICAgdGhpcy5jaGlsZC5raWxsKFwiU0lHVEVSTVwiKTtcbiAgICAgIHRoaXMuY2hpbGQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmF2YWlsYWJsZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGlzQXZhaWxhYmxlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmF2YWlsYWJsZTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBpbml0aWFsaXplKCkge1xuICAgIGNvbnN0IGNoaWxkRW52ID0gdGhpcy5vcHRpb25zLmVudiA/PyB7fTtcbiAgICBpZiAoaW5zcGVjdG9yVXJsPy4oKSkge1xuICAgICAgLy8gV2UncmUgZXhwb3NpbmcgYSBkZWJ1Z2dlciwgbGV0J3MgYXR0ZW1wdCB0byBlbnN1cmUgdGhlIGNoaWxkIHByb2Nlc3MgYXV0b21hdGljYWxseSBhdHRhY2hlc1xuICAgICAgY2hpbGRFbnYuTk9ERV9PUFRJT05TID1cbiAgICAgICAgKGNoaWxkRW52Lk5PREVfT1BUSU9OUyA/PyBcIlwiKSArIChwcm9jZXNzLmVudi5OT0RFX09QVElPTlMgPz8gXCJcIik7XG5cbiAgICAgIC8vIElmIHRoZSBjaGlsZCBwcm9jZXNzIGlzIG5vdCBhbHJlYWR5IGNvbmZpZ3VyZWQgdG8gYXR0YWNoIGEgZGVidWdnZXIsIGFkZCBhIGZsYWcgdG8gZG8gc29cbiAgICAgIGlmIChcbiAgICAgICAgIWNoaWxkRW52Lk5PREVfT1BUSU9OUy5pbmNsdWRlcyhcIi0taW5zcGVjdFwiKSAmJlxuICAgICAgICAhcHJvY2Vzcy5leGVjQXJndi5pbmNsdWRlcyhcIi0taW5zcGVjdFwiKVxuICAgICAgKSB7XG4gICAgICAgIGNoaWxkRW52Lk5PREVfT1BUSU9OUyArPSBcIiAtLWluc3BlY3Q9MFwiO1xuICAgICAgfVxuXG4gICAgICAvLyBWU0NvZGUncyBkZWJ1Z2dlciBhZGRzIHNvbWUgZW52aXJvbm1lbnQgdmFyaWFibGVzIHRoYXQgd2Ugd2FudCB0byBwYXNzIHRvIHRoZSBjaGlsZCBwcm9jZXNzXG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9jZXNzLmVudikge1xuICAgICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoXCJWU0NPREVfXCIpKSB7XG4gICAgICAgICAgY2hpbGRFbnZba2V5XSA9IHByb2Nlc3MuZW52W2tleV0hO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc3RhcnQgYSBOb2RlLmpzIHByb2Nlc3MgdGhhdCBydW5zIHRoZSBpbmZsaWdodCBjb2RlXG4gICAgLy8gbm90ZTogdW5saWtlIHRoZSBmb3JrKDIpIFBPU0lYIHN5c3RlbSBjYWxsLCBjaGlsZF9wcm9jZXNzLmZvcmsoKVxuICAgIC8vIGRvZXMgbm90IGNsb25lIHRoZSBjdXJyZW50IHByb2Nlc3NcbiAgICB0aGlzLmNoaWxkID0gY3AuZm9yayh0aGlzLmVudHJ5cG9pbnQsIHtcbiAgICAgIGVudjogY2hpbGRFbnYsXG4gICAgICBzdGRpbzogXCJwaXBlXCIsXG4gICAgICAvLyBrZWVwIHRoZSBwcm9jZXNzIGRldGFjaGVkIHNvIGluIHRoZSBjYXNlIG9mIGNsb3VkLlNlcnZpY2UsIGlmIHRoZSBwYXJlbnQgcHJvY2VzcyBpcyBraWxsZWRcbiAgICAgIC8vIChlLmcuIHNvbWVvbmUgcHJlc3NlcyBDdHJsK0Mgd2hpbGUgdXNpbmcgV2luZyBDb25zb2xlKSxcbiAgICAgIC8vIHdlIGNhbiBncmFjZWZ1bGx5IGNhbGwgYW55IGNsZWFudXAgY29kZSBpbiB0aGUgY2hpbGQgcHJvY2Vzc1xuICAgICAgZGV0YWNoZWQ6IHRydWUsXG4gICAgICAvLyB0aGlzIG9wdGlvbiBhbGxvd3MgY29tcGxleCBvYmplY3RzIGxpa2UgRXJyb3IgdG8gYmUgc2VudCBmcm9tIHRoZSBjaGlsZCBwcm9jZXNzIHRvIHRoZSBwYXJlbnRcbiAgICAgIHNlcmlhbGl6YXRpb246IFwiYWR2YW5jZWRcIixcbiAgICB9KTtcbiAgICB0aGlzLmNoaWxkUGlkID0gdGhpcy5jaGlsZC5waWQ7XG5cbiAgICB0aGlzLmRlYnVnTG9nKGBJbml0aWFsaXplZCBzYW5kYm94IChQSUQgJHt0aGlzLmNoaWxkUGlkfSkuYCk7XG5cbiAgICBjb25zdCBsb2cgPSAobWVzc2FnZTogc3RyaW5nKSA9PiB7XG4gICAgICBsZXQgbGV2ZWwgPSBMb2dMZXZlbC5JTkZPO1xuICAgICAgaWYgKG1lc3NhZ2Uuc3RhcnRzV2l0aChcImluZm86XCIpKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlLnNsaWNlKDUpO1xuICAgICAgfSBlbHNlIGlmIChtZXNzYWdlLnN0YXJ0c1dpdGgoXCJlcnJvcjpcIikpIHtcbiAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2Uuc2xpY2UoNik7XG4gICAgICAgIGxldmVsID0gTG9nTGV2ZWwuRVJST1I7XG4gICAgICB9IGVsc2UgaWYgKG1lc3NhZ2Uuc3RhcnRzV2l0aChcIndhcm5pbmc6XCIpKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlLnNsaWNlKDgpO1xuICAgICAgICBsZXZlbCA9IExvZ0xldmVsLldBUk5JTkc7XG4gICAgICB9IGVsc2UgaWYgKG1lc3NhZ2Uuc3RhcnRzV2l0aChcInZlcmJvc2U6XCIpKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlLnNsaWNlKDgpO1xuICAgICAgICBsZXZlbCA9IExvZ0xldmVsLlZFUkJPU0U7XG4gICAgICB9XG4gICAgICB0aGlzLm9wdGlvbnMubG9nPy4oZmFsc2UsIGxldmVsLCBtZXNzYWdlKTtcbiAgICB9O1xuICAgIGNvbnN0IGxvZ0Vycm9yID0gKG1lc3NhZ2U6IHN0cmluZykgPT5cbiAgICAgIHRoaXMub3B0aW9ucy5sb2c/LihmYWxzZSwgTG9nTGV2ZWwuRVJST1IsIG1lc3NhZ2UpO1xuXG4gICAgLy8gcGlwZSBzdGRvdXQgYW5kIHN0ZGVyciBmcm9tIHRoZSBjaGlsZCBwcm9jZXNzXG4gICAgaWYgKHRoaXMuY2hpbGQuc3Rkb3V0KSB7XG4gICAgICBwcm9jZXNzU3RyZWFtKHRoaXMuY2hpbGQuc3Rkb3V0LCBsb2cpO1xuICAgIH1cbiAgICBpZiAodGhpcy5jaGlsZC5zdGRlcnIpIHtcbiAgICAgIHByb2Nlc3NTdHJlYW0odGhpcy5jaGlsZC5zdGRlcnIsIGxvZ0Vycm9yKTtcbiAgICB9XG5cbiAgICB0aGlzLmNoaWxkLm9uKFwibWVzc2FnZVwiLCAobWVzc2FnZTogUHJvY2Vzc1Jlc3BvbnNlKSA9PiB7XG4gICAgICB0aGlzLm9uQ2hpbGRNZXNzYWdlPy4obWVzc2FnZSk7XG4gICAgfSk7XG4gICAgdGhpcy5jaGlsZCEub24oXCJlcnJvclwiLCAoZXJyb3IpID0+IHtcbiAgICAgIHRoaXMub25DaGlsZEVycm9yPy4oZXJyb3IpO1xuICAgIH0pO1xuICAgIHRoaXMuY2hpbGQhLm9uKFwiZXhpdFwiLCAoY29kZSwgc2lnbmFsKSA9PiB7XG4gICAgICB0aGlzLm9uQ2hpbGRFeGl0Py4oY29kZSwgc2lnbmFsKTtcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBjYWxsKGZuOiBzdHJpbmcsIC4uLmFyZ3M6IGFueVtdKTogUHJvbWlzZTxhbnk+IHtcbiAgICBpZiAoIXRoaXMuYXZhaWxhYmxlKSB7XG4gICAgICB0aHJvdyBuZXcgU2FuZGJveE11bHRpcGxlQ29uY3VycmVudENhbGxzRXJyb3IoKTtcbiAgICB9XG5cbiAgICAvLyBQcmV2ZW50IG11bHRpcGxlIGNhbGxzIHRvIHRoZSBzYW1lIHNhbmRib3ggcnVubmluZyBjb25jdXJyZW50bHkuXG4gICAgdGhpcy5hdmFpbGFibGUgPSBmYWxzZTtcblxuICAgIC8vIElmIHRoaXMgc2FuZGJveCBkb2Vzbid0IGhhdmUgYSBjaGlsZCBwcm9jZXNzIHJ1bm5pbmcgKGJlY2F1c2UgaXRcbiAgICAvLyBqdXN0IGdvdCBjcmVhdGVkLCBPUiBiZWNhdXNlIHRoZSBwcmV2aW91cyBjaGlsZCBwcm9jZXNzIHdhcyBraWxsZWQgZHVlXG4gICAgLy8gdG8gdGltZW91dCBvciBhbiB1bmV4cGVjdGVkIGVycm9yKSwgaW5pdGlhbGl6ZSBvbmUuXG4gICAgaWYgKCF0aGlzLmNoaWxkKSB7XG4gICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemUoKTtcbiAgICB9XG5cbiAgICAvLyBTZW5kIHRoZSBmdW5jdGlvbiBuYW1lIGFuZCBhcmd1bWVudHMgdG8gdGhlIGNoaWxkIHByb2Nlc3MuXG4gICAgLy8gV2hlbiBhIG1lc3NhZ2UgaXMgcmVjZWl2ZWQsIHJlc29sdmUgb3IgcmVqZWN0IHRoZSBwcm9taXNlLlxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLmNoaWxkIS5zZW5kKHsgZm4sIGFyZ3MgfSBhcyBQcm9jZXNzUmVxdWVzdCk7XG4gICAgICB0aGlzLmRlYnVnTG9nKFxuICAgICAgICBgU2VudCBhIG1lc3NhZ2UgdG8gdGhlIHNhbmRib3ggKFBJRCAke3RoaXMuY2hpbGRQaWR9KTogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICB7XG4gICAgICAgICAgICBmbixcbiAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgfVxuICAgICAgICApfWBcbiAgICAgICk7XG5cbiAgICAgIHRoaXMub25DaGlsZE1lc3NhZ2UgPSAobWVzc2FnZTogUHJvY2Vzc1Jlc3BvbnNlKSA9PiB7XG4gICAgICAgIHRoaXMuZGVidWdMb2coXG4gICAgICAgICAgYFJlY2VpdmVkIGEgbWVzc2FnZSBmcm9tIHRoZSBzYW5kYm94IChQSUQgJHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRQaWRcbiAgICAgICAgICB9KTogJHtKU09OLnN0cmluZ2lmeShtZXNzYWdlKX1gXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuYXZhaWxhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnR5cGUgPT09IFwib2tcIikge1xuICAgICAgICAgIHJlc29sdmUobWVzc2FnZS52YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgICByZWplY3QobWVzc2FnZS5yZWFzb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYFVuZXhwZWN0ZWQgbWVzc2FnZSBmcm9tIHRoZSBzYW5kYm94IChQSUQgJHt0aGlzLmNoaWxkUGlkfSk6ICR7bWVzc2FnZX1gXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gXCJlcnJvclwiIGNvdWxkIGJlIGVtaXR0ZWQgZm9yIGFueSBudW1iZXIgb2YgcmVhc29uc1xuICAgICAgLy8gKGUuZy4gdGhlIHByb2Nlc3MgY291bGRuJ3QgYmUgc3Bhd25lZCBvciBraWxsZWQsIG9yIGEgbWVzc2FnZSBjb3VsZG4ndCBiZSBzZW50KS5cbiAgICAgIC8vIFNpbmNlIHRoaXMgaXMgdW5leHBlY3RlZCwgd2Uga2lsbCB0aGUgcHJvY2VzcyB3aXRoIFNJR0tJTEwgdG8gZW5zdXJlIGl0J3MgZGVhZCwgYW5kIHJlamVjdCB0aGUgcHJvbWlzZS5cbiAgICAgIHRoaXMub25DaGlsZEVycm9yID0gKGVycm9yOiBFcnJvcikgPT4ge1xuICAgICAgICB0aGlzLmRlYnVnTG9nKFxuICAgICAgICAgIGBVbmV4cGVjdGVkIGVycm9yIGZyb20gdGhlIHNhbmRib3ggKFBJRCAke3RoaXMuY2hpbGRQaWR9KS5gXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuY2hpbGQ/LmtpbGwoXCJTSUdLSUxMXCIpO1xuICAgICAgICB0aGlzLmNoaWxkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmF2YWlsYWJsZSA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLnRpbWVvdXQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jbGVhbmluZ1VwKSB7XG4gICAgICAgICAgcmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIFwiZXhpdFwiIGNvdWxkIGJlIGVtaXR0ZWQgaWYgdGhlIHVzZXIgY29kZSBjYWxsZWQgcHJvY2Vzcy5leGl0KCksIG9yIGlmIHdlIGtpbGxlZCB0aGUgcHJvY2Vzc1xuICAgICAgLy8gZHVlIHRvIGEgdGltZW91dCBvciB1bmV4cGVjdGVkIGVycm9yLiBJbiBhbnkgY2FzZSwgd2UgcmVqZWN0IHRoZSBwcm9taXNlLlxuICAgICAgdGhpcy5vbkNoaWxkRXhpdCA9IChjb2RlOiBudW1iZXIgfCBudWxsLCBzaWduYWw6IHVua25vd24pID0+IHtcbiAgICAgICAgdGhpcy5kZWJ1Z0xvZyhgU2FuZGJveCAoUElEICR7dGhpcy5jaGlsZFBpZH0pIHN0b3BwZWQuYCk7XG4gICAgICAgIHRoaXMuY2hpbGQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuYXZhaWxhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNsZWFuaW5nVXApIHtcbiAgICAgICAgICByZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgbmV3IEVycm9yKGBQcm9jZXNzIGV4aXRlZCB3aXRoIGNvZGUgJHtjb2RlfSwgc2lnbmFsICR7c2lnbmFsfWApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy50aW1lb3V0ICYmICFpbnNwZWN0b3JVcmw/LigpKSB7XG4gICAgICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuZGVidWdMb2coXG4gICAgICAgICAgICBgS2lsbGluZyBzYW5kYm94IChQSUQgJHt0aGlzLmNoaWxkUGlkfSkgYWZ0ZXIgdGltZW91dC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLmNoaWxkPy5raWxsKFwiU0lHVEVSTVwiKTtcbiAgICAgICAgICB0aGlzLmNoaWxkID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHRoaXMuYXZhaWxhYmxlID0gdHJ1ZTtcbiAgICAgICAgICBpZiAodGhpcy5jbGVhbmluZ1VwKSB7XG4gICAgICAgICAgICByZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgU2FuZGJveFRpbWVvdXRFcnJvcih0aGlzLm9wdGlvbnMudGltZW91dCA/PyAwKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzLm9wdGlvbnMudGltZW91dCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGRlYnVnTG9nKG1lc3NhZ2U6IHN0cmluZykge1xuICAgIGlmIChwcm9jZXNzLmVudi5ERUJVRykge1xuICAgICAgdGhpcy5vcHRpb25zLmxvZz8uKHRydWUsIExvZ0xldmVsLlZFUkJPU0UsIG1lc3NhZ2UpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgU2FuZGJveFRpbWVvdXRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IHRpbWVvdXQ6IG51bWJlcikge1xuICAgIHN1cGVyKFwiVGltZWQgb3V0IGFmdGVyIFwiICsgdGltZW91dCArIFwibXMuXCIpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTYW5kYm94TXVsdGlwbGVDb25jdXJyZW50Q2FsbHNFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJDYW5ub3QgcHJvY2VzcyBtdWx0aXBsZSByZXF1ZXN0cyBpbiBwYXJhbGxlbC5cIik7XG4gIH1cbn1cbiJdfQ==