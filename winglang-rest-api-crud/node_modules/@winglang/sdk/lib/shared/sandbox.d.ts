import { Bundle } from "./bundling";
import { LogLevel } from "../std";
export interface SandboxOptions {
    readonly env?: {
        [key: string]: string;
    };
    readonly context?: {
        [key: string]: any;
    };
    /**
     * How long the sandbox is allowed to run code when `sandbox.call()` is called
     * before the child process should be stopped (killed), in milliseconds.
     *
     * If an invocation returns successfully, the child process continues running
     * and can be reused for subsequent invocations.
     */
    readonly timeout?: number;
    readonly log?: (internal: boolean, level: LogLevel, message: string) => void;
}
export declare class Sandbox {
    static createBundle(entrypoint: string, log?: (message: string, level: LogLevel) => void): Promise<Bundle>;
    private readonly entrypoint;
    private readonly options;
    private child;
    private childPid;
    private onChildMessage;
    private onChildError;
    private onChildExit;
    private timeout;
    private available;
    private cleaningUp;
    constructor(entrypoint: string, options?: SandboxOptions);
    cleanup(): Promise<void>;
    isAvailable(): boolean;
    initialize(): Promise<void>;
    call(fn: string, ...args: any[]): Promise<any>;
    private debugLog;
}
export declare class SandboxTimeoutError extends Error {
    readonly timeout: number;
    constructor(timeout: number);
}
export declare class SandboxMultipleConcurrentCallsError extends Error {
    constructor();
}
