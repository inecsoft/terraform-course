"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BucketClient = void 0;
const consumers = __importStar(require("stream/consumers"));
const client_s3_1 = require("@aws-sdk/client-s3");
const s3_request_presigner_1 = require("@aws-sdk/s3-request-presigner");
const mime_types_1 = __importDefault(require("mime-types"));
const cloud_1 = require("../cloud");
const std_1 = require("../std");
class BucketClient {
    constructor(bucketName, s3Client = new client_s3_1.S3Client({})) {
        this.bucketName = bucketName;
        this.s3Client = s3Client;
    }
    async bucketRegion() {
        const res = await this.s3Client.send(new client_s3_1.HeadBucketCommand({
            Bucket: this.bucketName,
        }));
        if (!res.BucketRegion) {
            throw new Error(`Failed to get region of the bucket (bucket=${this.bucketName}).`);
        }
        return res.BucketRegion;
    }
    /**
     * Check if an object exists in the bucket
     *
     * @param key Key of the object
     */
    async exists(key) {
        const command = new client_s3_1.HeadObjectCommand({
            Bucket: this.bucketName,
            Key: key,
        });
        try {
            await this.s3Client.send(command);
            return true;
        }
        catch (error) {
            if (error instanceof client_s3_1.NotFound) {
                return false;
            }
            throw error;
        }
    }
    /**
     * Put object into bucket with given body contents
     *
     * @param key Key of the object
     * @param body string contents of the object
     */
    async put(key, body, opts) {
        const command = new client_s3_1.PutObjectCommand({
            Bucket: this.bucketName,
            Key: key,
            Body: body,
            ContentType: (opts?.contentType ?? mime_types_1.default.lookup(key)) || "application/octet-stream",
        });
        await this.s3Client.send(command);
    }
    /**
     * Put Json object into bucket with given body contents
     *
     * @param key Key of the object
     * @param body Json object
     */
    async putJson(key, body) {
        await this.put(key, JSON.stringify(body, null, 2), {
            contentType: "application/json",
        });
    }
    /**
     * See https://github.com/aws/aws-sdk-js-v3/issues/1877
     */
    async getObjectContent(key, options) {
        const getObjectParams = {
            Bucket: this.bucketName,
            Key: key,
        };
        // Conditionally add the `Range` parameter
        if (options?.startByte !== undefined || options?.endByte !== undefined) {
            const startByte = options?.startByte ?? 0;
            const endByte = options?.endByte ?? "";
            getObjectParams.Range = `bytes=${startByte}-${endByte}`;
        }
        const command = new client_s3_1.GetObjectCommand(getObjectParams);
        try {
            const resp = await this.s3Client.send(command);
            const objectContent = resp.Body;
            try {
                return new TextDecoder("utf8", { fatal: true }).decode(await consumers.buffer(objectContent));
            }
            catch (e) {
                throw new Error(`Object content could not be read as text (key=${key}): ${e.stack})}`);
            }
        }
        catch (e) {
            if (e instanceof client_s3_1.NoSuchKey) {
                return undefined;
            }
            throw new Error(e.stack);
        }
    }
    /**
     * Get an object from the bucket
     *
     * @param key Key of the object
     * @returns content of the object
     */
    async get(key, options) {
        const objectContent = await this.getObjectContent(key, options);
        if (objectContent !== undefined) {
            return objectContent;
        }
        throw new Error(`Object does not exist (key=${key}).`);
    }
    /**
     * Get an object from the bucket if it exists
     *
     * @param key Key of the object
     * @returns content of the object
     */
    async tryGet(key, options) {
        return this.getObjectContent(key, options);
    }
    /**
     * Get a Json object from the bucket
     *
     * @param key Key of the object
     * @returns Json content of the object
     */
    async getJson(key) {
        return JSON.parse(await this.get(key));
    }
    /**
     * Get a Json object from the bucket if it exists
     *
     * @param key Key of the object
     * @returns Json content of the object
     */
    async tryGetJson(key) {
        const objectContent = await this.tryGet(key);
        if (objectContent !== undefined) {
            return JSON.parse(objectContent);
        }
        else {
            return undefined;
        }
    }
    /**
     * Delete an object from the bucket
     *
     * @param key Key of the object
     * @param opts Option object supporting additional strategies to delete item from a bucket
     */
    async delete(key, opts) {
        const mustExist = opts?.mustExist ?? false;
        if (mustExist && !(await this.exists(key))) {
            throw new Error(`Object does not exist (key=${key}).`);
        }
        const command = new client_s3_1.DeleteObjectCommand({
            Key: key,
            Bucket: this.bucketName,
        });
        try {
            await this.s3Client.send(command);
        }
        catch (error) {
            if (!mustExist && error instanceof client_s3_1.NoSuchKey) {
                return;
            }
            throw new Error(`Failed to delete object (key=${key}).`);
        }
    }
    /**
     * Delete an object from the bucket if it exists
     *
     * @param key Key of the object
     * @param opts Option object supporting additional strategies to delete item from a bucket
     */
    async tryDelete(key) {
        if (await this.exists(key)) {
            await this.delete(key);
            return true;
        }
        return false;
    }
    /**
     * List all keys in the bucket.
     * @param prefix Limits the response to keys that begin with the specified prefix
     * TODO - add pagination support, currently returns all existing keys in the bucket
     * https://github.com/winglang/wing/issues/315
     */
    async list(prefix) {
        const list = [];
        let fetchMore = true;
        let marker = undefined;
        while (fetchMore) {
            const command = new client_s3_1.ListObjectsV2Command({
                Bucket: this.bucketName,
                Prefix: prefix,
                StartAfter: marker,
            });
            const resp = await this.s3Client.send(command);
            for (const content of resp.Contents ?? []) {
                if (content.Key === undefined) {
                    continue;
                }
                list.push(content.Key);
            }
            fetchMore = resp?.IsTruncated ?? false;
            marker = list.length > 0 ? list.at(-1) : undefined;
        }
        return list;
    }
    /**
     * Copy an object to a new location in the bucket. If the destination object
     * already exists, it will be overwritten.
     * @param srcKey The key of the source object you wish to copy.
     * @param dstKey The key of the destination object after copying.
     */
    async copy(srcKey, dstKey) {
        try {
            // Get properties of the source object
            const headResult = await this.s3Client.send(new client_s3_1.HeadObjectCommand({
                Bucket: this.bucketName,
                Key: srcKey,
            }));
            // Equivalent to `aws s3 cp --copy-props` in AWS CLI v2
            const command = new client_s3_1.CopyObjectCommand({
                Bucket: this.bucketName,
                CopySource: `${this.bucketName}/${srcKey}`,
                Key: dstKey,
                MetadataDirective: "REPLACE",
                // Properties carried over from the source object
                ContentType: headResult?.ContentType,
                ContentLanguage: headResult?.ContentLanguage,
                ContentEncoding: headResult?.ContentEncoding,
                ContentDisposition: headResult?.ContentDisposition,
                CacheControl: headResult?.CacheControl,
                Expires: headResult?.Expires,
                Metadata: headResult?.Metadata,
            });
            await this.s3Client.send(command);
        }
        catch (error) {
            if (error instanceof client_s3_1.NotFound) {
                throw new Error(`Source object does not exist (srcKey=${srcKey}).`);
            }
            throw error;
        }
    }
    /**
     * Move an object to a new location in the bucket. If the destination object
     * already exists, it will be overwritten. Returns once the renaming is finished.
     * @param srcKey The key of the source object you wish to rename.
     * @param dstKey The key of the destination object after renaming.
     * @throws if `srcKey` object doesn't exist or if it matches `dstKey`.
     * @inflight
     */
    async rename(srcKey, dstKey) {
        if (srcKey === dstKey) {
            throw new Error(`Renaming an object to its current name is not a valid operation (srcKey=${srcKey}, dstKey=${dstKey}).`);
        }
        await this.copy(srcKey, dstKey);
        await this.delete(srcKey);
    }
    /**
     * Checks if the bucket is public
     * @returns true if the bucket is public and false otherwise
     */
    async checkIfPublic() {
        const command = new client_s3_1.GetPublicAccessBlockCommand({
            Bucket: this.bucketName,
        });
        const resp = await this.s3Client.send(command);
        return (!resp.PublicAccessBlockConfiguration?.BlockPublicAcls &&
            !resp.PublicAccessBlockConfiguration?.BlockPublicPolicy &&
            !resp.PublicAccessBlockConfiguration?.RestrictPublicBuckets &&
            !resp.PublicAccessBlockConfiguration?.IgnorePublicAcls);
    }
    /**
     * Returns a url to the given file.
     * @Throws if the file is not public or if object does not exist.
     */
    async publicUrl(key) {
        if (!(await this.checkIfPublic())) {
            throw new Error("Cannot provide public url for a non-public bucket");
        }
        if (!(await this.exists(key))) {
            throw new Error(`Cannot provide public url for a non-existent key (key=${key})`);
        }
        const region = await this.getLocation();
        return encodeURI(`https://${this.bucketName}.s3.${region}.amazonaws.com/${key}`);
    }
    /**
     * Returns a presigned URL for the specified key in the bucket.
     * @param key The key of the object in the bucket.
     * @param opts The options including the action and the duration for the signed URL.
     * @returns The presigned URL string.
     * @inflight
     */
    async signedUrl(key, opts) {
        let s3Command;
        // Set default action to DOWNLOAD if not provided
        const action = opts?.action ?? cloud_1.BucketSignedUrlAction.DOWNLOAD;
        // Set the S3 command
        switch (action) {
            case cloud_1.BucketSignedUrlAction.DOWNLOAD:
                if (!(await this.exists(key))) {
                    throw new Error(`Cannot provide signed url for a non-existent key (key=${key})`);
                }
                s3Command = new client_s3_1.GetObjectCommand({
                    Bucket: this.bucketName,
                    Key: key,
                });
                break;
            case cloud_1.BucketSignedUrlAction.UPLOAD:
                s3Command = new client_s3_1.PutObjectCommand({
                    Bucket: this.bucketName,
                    Key: key,
                });
                break;
            default:
                throw new Error(`Invalid action: ${opts?.action}`);
        }
        // Generate the presigned URL
        const signedUrl = await (0, s3_request_presigner_1.getSignedUrl)(this.s3Client, s3Command, {
            expiresIn: opts?.duration?.seconds ?? 900,
        });
        return signedUrl;
    }
    /**
     * Get the metadata of an object in the bucket.
     * @param key Key of the object.
     */
    async metadata(key) {
        const command = new client_s3_1.HeadObjectCommand({
            Bucket: this.bucketName,
            Key: key,
        });
        try {
            const resp = await this.s3Client.send(command);
            return {
                contentType: resp.ContentType,
                lastModified: std_1.Datetime.fromDate(resp.LastModified),
                size: resp.ContentLength,
            };
        }
        catch (error) {
            // 403 is thrown if s3:ListObject is not granted.
            if (error instanceof client_s3_1.NotFound || error.name === "403") {
                throw new Error(`Object does not exist (key=${key}).`);
            }
            throw error;
        }
    }
    async getLocation() {
        const command = new client_s3_1.GetBucketLocationCommand({
            Bucket: this.bucketName,
        });
        //Buckets in Region us-east-1 have a LocationConstraint of null.
        //https://docs.aws.amazon.com/AmazonS3/latest/API/API_GetBucketLocation.html#API_GetBucketLocation_ResponseSyntax
        const { LocationConstraint: region = "us-east-1" } = await this.s3Client.send(command);
        return region;
    }
}
exports.BucketClient = BucketClient;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVja2V0LmluZmxpZ2h0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3NoYXJlZC1hd3MvYnVja2V0LmluZmxpZ2h0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0EsNERBQThDO0FBQzlDLGtEQWtCNEI7QUFDNUIsd0VBQTZEO0FBQzdELDREQUE4QjtBQUU5QixvQ0FRa0I7QUFDbEIsZ0NBQXdDO0FBRXhDLE1BQWEsWUFBWTtJQUN2QixZQUNtQixVQUFrQixFQUNsQixXQUFxQixJQUFJLG9CQUFRLENBQUMsRUFBRSxDQUFDO1FBRHJDLGVBQVUsR0FBVixVQUFVLENBQVE7UUFDbEIsYUFBUSxHQUFSLFFBQVEsQ0FBNkI7SUFDckQsQ0FBQztJQUVHLEtBQUssQ0FBQyxZQUFZO1FBQ3ZCLE1BQU0sR0FBRyxHQUFHLE1BQU0sSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQ2xDLElBQUksNkJBQWlCLENBQUM7WUFDcEIsTUFBTSxFQUFFLElBQUksQ0FBQyxVQUFVO1NBQ3hCLENBQUMsQ0FDSCxDQUFDO1FBRUYsSUFBSSxDQUFDLEdBQUcsQ0FBQyxZQUFZLEVBQUUsQ0FBQztZQUN0QixNQUFNLElBQUksS0FBSyxDQUNiLDhDQUE4QyxJQUFJLENBQUMsVUFBVSxJQUFJLENBQ2xFLENBQUM7UUFDSixDQUFDO1FBRUQsT0FBTyxHQUFHLENBQUMsWUFBWSxDQUFDO0lBQzFCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksS0FBSyxDQUFDLE1BQU0sQ0FBQyxHQUFXO1FBQzdCLE1BQU0sT0FBTyxHQUFHLElBQUksNkJBQWlCLENBQUM7WUFDcEMsTUFBTSxFQUFFLElBQUksQ0FBQyxVQUFVO1lBQ3ZCLEdBQUcsRUFBRSxHQUFHO1NBQ1QsQ0FBQyxDQUFDO1FBRUgsSUFBSSxDQUFDO1lBQ0gsTUFBTSxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUNs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WSxFQUFFLGNBQVEsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFlBQWEsQ0FBQztnQkFDbkQsSUFBSSxFQUFFLElBQUksQ0FBQyxhQUFjO2FBQzFCLENBQUM7UUFDSixDQUFDO1FBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQztZQUNmLGlEQUFpRDtZQUNqRCxJQUFJLEtBQUssWUFBWSxvQkFBUSxJQUFLLEtBQWUsQ0FBQyxJQUFJLEtBQUssS0FBSyxFQUFFLENBQUM7Z0JBQ2pFLE1BQU0sSUFBSSxLQUFLLENBQUMsOEJBQThCLEdBQUcsSUFBSSxDQUFDLENBQUM7WUFDekQsQ0FBQztZQUNELE1BQU0sS0FBSyxDQUFDO1FBQ2QsQ0FBQztJQUNILENBQUM7SUFFTyxLQUFLLENBQUMsV0FBVztRQUN2QixNQUFNLE9BQU8sR0FBRyxJQUFJLG9DQUF3QixDQUFDO1lBQzNDLE1BQU0sRUFBRSxJQUFJLENBQUMsVUFBVTtTQUN4QixDQUFDLENBQUM7UUFDSCxnRUFBZ0U7UUFDaEUsaUhBQWlIO1FBQ2pILE1BQU0sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLEdBQUcsV0FBVyxFQUFFLEdBQ2hELE1BQU0sSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDcEMsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQztDQUNGO0FBN2FELG9DQTZhQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJlYWRhYmxlIH0gZnJvbSBcInN0cmVhbVwiO1xuaW1wb3J0ICogYXMgY29uc3VtZXJzIGZyb20gXCJzdHJlYW0vY29uc3VtZXJzXCI7XG5pbXBvcnQge1xuICBfX0NsaWVudCxcbiAgQ29weU9iamVjdENvbW1hbmQsXG4gIERlbGV0ZU9iamVjdENvbW1hbmQsXG4gIEdldEJ1Y2tldExvY2F0aW9uQ29tbWFuZCxcbiAgR2V0T2JqZWN0Q29tbWFuZCxcbiAgR2V0T2JqZWN0Q29tbWFuZElucHV0LFxuICBHZXRPYmplY3RPdXRwdXQsXG4gIEdldFB1YmxpY0FjY2Vzc0Jsb2NrQ29tbWFuZCxcbiAgR2V0UHVibGljQWNjZXNzQmxvY2tDb21tYW5kT3V0cHV0LFxuICBIZWFkT2JqZWN0Q29tbWFuZCxcbiAgTGlzdE9iamVjdHNWMkNvbW1hbmQsXG4gIExpc3RPYmplY3RzVjJDb21tYW5kT3V0cHV0LFxuICBOb3RGb3VuZCxcbiAgTm9TdWNoS2V5LFxuICBQdXRPYmplY3RDb21tYW5kLFxuICBTM0NsaWVudCxcbiAgSGVhZEJ1Y2tldENvbW1hbmQsXG59IGZyb20gXCJAYXdzLXNkay9jbGllbnQtczNcIjtcbmltcG9ydCB7IGdldFNpZ25lZFVybCB9IGZyb20gXCJAYXdzLXNkay9zMy1yZXF1ZXN0LXByZXNpZ25lclwiO1xuaW1wb3J0IG1pbWUgZnJvbSBcIm1pbWUtdHlwZXNcIjtcbmltcG9ydCB7IElBd3NCdWNrZXRDbGllbnQgfSBmcm9tIFwiLi9idWNrZXRcIjtcbmltcG9ydCB7XG4gIE9iamVjdE1ldGFkYXRhLFxuICBCdWNrZXRQdXRPcHRpb25zLFxuICBCdWNrZXREZWxldGVPcHRpb25zLFxuICBCdWNrZXRTaWduZWRVcmxPcHRpb25zLFxuICBCdWNrZXRTaWduZWRVcmxBY3Rpb24sXG4gIEJ1Y2tldEdldE9wdGlvbnMsXG4gIEJ1Y2tldFRyeUdldE9wdGlvbnMsXG59IGZyb20gXCIuLi9jbG91ZFwiO1xuaW1wb3J0IHsgRGF0ZXRpbWUsIEpzb24gfSBmcm9tIFwiLi4vc3RkXCI7XG5cbmV4cG9ydCBjbGFzcyBCdWNrZXRDbGllbnQgaW1wbGVtZW50cyBJQXdzQnVja2V0Q2xpZW50IHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBidWNrZXROYW1lOiBzdHJpbmcsXG4gICAgcHJpdmF0ZSByZWFkb25seSBzM0NsaWVudDogUzNDbGllbnQgPSBuZXcgUzNDbGllbnQoe30pXG4gICkge31cblxuICBwdWJsaWMgYXN5bmMgYnVja2V0UmVnaW9uKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5zM0NsaWVudC5zZW5kKFxuICAgICAgbmV3IEhlYWRCdWNrZXRDb21tYW5kKHtcbiAgICAgICAgQnVja2V0OiB0aGlzLmJ1Y2tldE5hbWUsXG4gICAgICB9KVxuICAgICk7XG5cbiAgICBpZiAoIXJlcy5CdWNrZXRSZWdpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEZhaWxlZCB0byBnZXQgcmVnaW9uIG9mIHRoZSBidWNrZXQgKGJ1Y2tldD0ke3RoaXMuYnVja2V0TmFtZX0pLmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcy5CdWNrZXRSZWdpb247XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gb2JqZWN0IGV4aXN0cyBpbiB0aGUgYnVja2V0XG4gICAqXG4gICAqIEBwYXJhbSBrZXkgS2V5IG9mIHRoZSBvYmplY3RcbiAgICovXG4gIHB1YmxpYyBhc3luYyBleGlzdHMoa2V5OiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCBjb21tYW5kID0gbmV3IEhlYWRPYmplY3RDb21tYW5kKHtcbiAgICAgIEJ1Y2tldDogdGhpcy5idWNrZXROYW1lLFxuICAgICAgS2V5OiBrZXksXG4gICAgfSk7XG5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5zM0NsaWVudC5zZW5kKGNvbW1hbmQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIE5vdEZvdW5kKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQdXQgb2JqZWN0IGludG8gYnVja2V0IHdpdGggZ2l2ZW4gYm9keSBjb250ZW50c1xuICAgKlxuICAgKiBAcGFyYW0ga2V5IEtleSBvZiB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSBib2R5IHN0cmluZyBjb250ZW50cyBvZiB0aGUgb2JqZWN0XG4gICAqL1xuICBwdWJsaWMgYXN5bmMgcHV0KFxuICAgIGtleTogc3RyaW5nLFxuICAgIGJvZHk6IHN0cmluZyxcbiAgICBvcHRzPzogQnVja2V0UHV0T3B0aW9uc1xuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBjb21tYW5kID0gbmV3IFB1dE9iamVjdENvbW1hbmQoe1xuICAgICAgQnVja2V0OiB0aGlzLmJ1Y2tldE5hbWUsXG4gICAgICBLZXk6IGtleSxcbiAgICAgIEJvZHk6IGJvZHksXG4gICAgICBDb250ZW50VHlwZTpcbiAgICAgICAgKG9wdHM/LmNvbnRlbnRUeXBlID8/IG1pbWUubG9va3VwKGtleSkpIHx8IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIsXG4gICAgfSk7XG4gICAgYXdhaXQgdGhpcy5zM0NsaWVudC5zZW5kKGNvbW1hbmQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1dCBKc29uIG9iamVjdCBpbnRvIGJ1Y2tldCB3aXRoIGdpdmVuIGJvZHkgY29udGVudHNcbiAgICpcbiAgICogQHBhcmFtIGtleSBLZXkgb2YgdGhlIG9iamVjdFxuICAgKiBAcGFyYW0gYm9keSBKc29uIG9iamVjdFxuICAgKi9cbiAgcHVibGljIGFzeW5jIHB1dEpzb24oa2V5OiBzdHJpbmcsIGJvZHk6IEpzb24pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCB0aGlzLnB1dChrZXksIEpTT04uc3RyaW5naWZ5KGJvZHksIG51bGwsIDIpLCB7XG4gICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvYXdzLXNkay1qcy12My9pc3N1ZXMvMTg3N1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBnZXRPYmplY3RDb250ZW50KFxuICAgIGtleTogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBCdWNrZXRHZXRPcHRpb25zXG4gICk6IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiB7XG4gICAgY29uc3QgZ2V0T2JqZWN0UGFyYW1zOiBHZXRPYmplY3RDb21tYW5kSW5wdXQgPSB7XG4gICAgICBCdWNrZXQ6IHRoaXMuYnVja2V0TmFtZSxcbiAgICAgIEtleToga2V5LFxuICAgIH07XG5cbiAgICAvLyBDb25kaXRpb25hbGx5IGFkZCB0aGUgYFJhbmdlYCBwYXJhbWV0ZXJcbiAgICBpZiAob3B0aW9ucz8uc3RhcnRCeXRlICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucz8uZW5kQnl0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBzdGFydEJ5dGUgPSBvcHRpb25zPy5zdGFydEJ5dGUgPz8gMDtcbiAgICAgIGNvbnN0IGVuZEJ5dGUgPSBvcHRpb25zPy5lbmRCeXRlID8/IFwiXCI7XG4gICAgICBnZXRPYmplY3RQYXJhbXMuUmFuZ2UgPSBgYnl0ZXM9JHtzdGFydEJ5dGV9LSR7ZW5kQnl0ZX1gO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbW1hbmQgPSBuZXcgR2V0T2JqZWN0Q29tbWFuZChnZXRPYmplY3RQYXJhbXMpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3A6IEdldE9iamVjdE91dHB1dCA9IGF3YWl0IHRoaXMuczNDbGllbnQuc2VuZChjb21tYW5kKTtcbiAgICAgIGNvbnN0IG9iamVjdENvbnRlbnQgPSByZXNwLkJvZHkgYXMgUmVhZGFibGU7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKFwidXRmOFwiLCB7IGZhdGFsOiB0cnVlIH0pLmRlY29kZShcbiAgICAgICAgICBhd2FpdCBjb25zdW1lcnMuYnVmZmVyKG9iamVjdENvbnRlbnQpXG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgT2JqZWN0IGNvbnRlbnQgY291bGQgbm90IGJlIHJlYWQgYXMgdGV4dCAoa2V5PSR7a2V5fSk6ICR7XG4gICAgICAgICAgICAoZSBhcyBFcnJvcikuc3RhY2tcbiAgICAgICAgICB9KX1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBOb1N1Y2hLZXkpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcigoZSBhcyBFcnJvcikuc3RhY2spO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYW4gb2JqZWN0IGZyb20gdGhlIGJ1Y2tldFxuICAgKlxuICAgKiBAcGFyYW0ga2V5IEtleSBvZiB0aGUgb2JqZWN0XG4gICAqIEByZXR1cm5zIGNvbnRlbnQgb2YgdGhlIG9iamVjdFxuICAgKi9cbiAgcHVibGljIGFzeW5jIGdldChrZXk6IHN0cmluZywgb3B0aW9ucz86IEJ1Y2tldEdldE9wdGlvbnMpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IG9iamVjdENvbnRlbnQgPSBhd2FpdCB0aGlzLmdldE9iamVjdENvbnRlbnQoa2V5LCBvcHRpb25zKTtcbiAgICBpZiAob2JqZWN0Q29udGVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gb2JqZWN0Q29udGVudDtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBPYmplY3QgZG9lcyBub3QgZXhpc3QgKGtleT0ke2tleX0pLmApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBvYmplY3QgZnJvbSB0aGUgYnVja2V0IGlmIGl0IGV4aXN0c1xuICAgKlxuICAgKiBAcGFyYW0ga2V5IEtleSBvZiB0aGUgb2JqZWN0XG4gICAqIEByZXR1cm5zIGNvbnRlbnQgb2YgdGhlIG9iamVjdFxuICAgKi9cbiAgcHVibGljIGFzeW5jIHRyeUdldChcbiAgICBrZXk6IHN0cmluZyxcbiAgICBvcHRpb25zPzogQnVja2V0VHJ5R2V0T3B0aW9uc1xuICApOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICAgIHJldHVybiB0aGlzLmdldE9iamVjdENvbnRlbnQoa2V5LCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBKc29uIG9iamVjdCBmcm9tIHRoZSBidWNrZXRcbiAgICpcbiAgICogQHBhcmFtIGtleSBLZXkgb2YgdGhlIG9iamVjdFxuICAgKiBAcmV0dXJucyBKc29uIGNvbnRlbnQgb2YgdGhlIG9iamVjdFxuICAgKi9cbiAgcHVibGljIGFzeW5jIGdldEpzb24oa2V5OiBzdHJpbmcpOiBQcm9taXNlPEpzb24+IHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShhd2FpdCB0aGlzLmdldChrZXkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBKc29uIG9iamVjdCBmcm9tIHRoZSBidWNrZXQgaWYgaXQgZXhpc3RzXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgS2V5IG9mIHRoZSBvYmplY3RcbiAgICogQHJldHVybnMgSnNvbiBjb250ZW50IG9mIHRoZSBvYmplY3RcbiAgICovXG4gIHB1YmxpYyBhc3luYyB0cnlHZXRKc29uKGtleTogc3RyaW5nKTogUHJvbWlzZTxKc29uIHwgdW5kZWZpbmVkPiB7XG4gICAgY29uc3Qgb2JqZWN0Q29udGVudCA9IGF3YWl0IHRoaXMudHJ5R2V0KGtleSk7XG4gICAgaWYgKG9iamVjdENvbnRlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2Uob2JqZWN0Q29udGVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhbiBvYmplY3QgZnJvbSB0aGUgYnVja2V0XG4gICAqXG4gICAqIEBwYXJhbSBrZXkgS2V5IG9mIHRoZSBvYmplY3RcbiAgICogQHBhcmFtIG9wdHMgT3B0aW9uIG9iamVjdCBzdXBwb3J0aW5nIGFkZGl0aW9uYWwgc3RyYXRlZ2llcyB0byBkZWxldGUgaXRlbSBmcm9tIGEgYnVja2V0XG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZGVsZXRlKGtleTogc3RyaW5nLCBvcHRzPzogQnVja2V0RGVsZXRlT3B0aW9ucyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IG11c3RFeGlzdCA9IG9wdHM/Lm11c3RFeGlzdCA/PyBmYWxzZTtcblxuICAgIGlmIChtdXN0RXhpc3QgJiYgIShhd2FpdCB0aGlzLmV4aXN0cyhrZXkpKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBPYmplY3QgZG9lcyBub3QgZXhpc3QgKGtleT0ke2tleX0pLmApO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbW1hbmQgPSBuZXcgRGVsZXRlT2JqZWN0Q29tbWFuZCh7XG4gICAgICBLZXk6IGtleSxcbiAgICAgIEJ1Y2tldDogdGhpcy5idWNrZXROYW1lLFxuICAgIH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuczNDbGllbnQuc2VuZChjb21tYW5kKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKCFtdXN0RXhpc3QgJiYgZXJyb3IgaW5zdGFuY2VvZiBOb1N1Y2hLZXkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZGVsZXRlIG9iamVjdCAoa2V5PSR7a2V5fSkuYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhbiBvYmplY3QgZnJvbSB0aGUgYnVja2V0IGlmIGl0IGV4aXN0c1xuICAgKlxuICAgKiBAcGFyYW0ga2V5IEtleSBvZiB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSBvcHRzIE9wdGlvbiBvYmplY3Qgc3VwcG9ydGluZyBhZGRpdGlvbmFsIHN0cmF0ZWdpZXMgdG8gZGVsZXRlIGl0ZW0gZnJvbSBhIGJ1Y2tldFxuICAgKi9cbiAgcHVibGljIGFzeW5jIHRyeURlbGV0ZShrZXk6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGlmIChhd2FpdCB0aGlzLmV4aXN0cyhrZXkpKSB7XG4gICAgICBhd2FpdCB0aGlzLmRlbGV0ZShrZXkpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3QgYWxsIGtleXMgaW4gdGhlIGJ1Y2tldC5cbiAgICogQHBhcmFtIHByZWZpeCBMaW1pdHMgdGhlIHJlc3BvbnNlIHRvIGtleXMgdGhhdCBiZWdpbiB3aXRoIHRoZSBzcGVjaWZpZWQgcHJlZml4XG4gICAqIFRPRE8gLSBhZGQgcGFnaW5hdGlvbiBzdXBwb3J0LCBjdXJyZW50bHkgcmV0dXJucyBhbGwgZXhpc3Rpbmcga2V5cyBpbiB0aGUgYnVja2V0XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS93aW5nbGFuZy93aW5nL2lzc3Vlcy8zMTVcbiAgICovXG4gIHB1YmxpYyBhc3luYyBsaXN0KHByZWZpeD86IHN0cmluZyk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICBjb25zdCBsaXN0OiBzdHJpbmdbXSA9IFtdO1xuICAgIGxldCBmZXRjaE1vcmUgPSB0cnVlO1xuICAgIGxldCBtYXJrZXI6IHN0cmluZyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICB3aGlsZSAoZmV0Y2hNb3JlKSB7XG4gICAgICBjb25zdCBjb21tYW5kID0gbmV3IExpc3RPYmplY3RzVjJDb21tYW5kKHtcbiAgICAgICAgQnVja2V0OiB0aGlzLmJ1Y2tldE5hbWUsXG4gICAgICAgIFByZWZpeDogcHJlZml4LFxuICAgICAgICBTdGFydEFmdGVyOiBtYXJrZXIsXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHJlc3A6IExpc3RPYmplY3RzVjJDb21tYW5kT3V0cHV0ID0gYXdhaXQgdGhpcy5zM0NsaWVudC5zZW5kKFxuICAgICAgICBjb21tYW5kXG4gICAgICApO1xuICAgICAgZm9yIChjb25zdCBjb250ZW50IG9mIHJlc3AuQ29udGVudHMgPz8gW10pIHtcbiAgICAgICAgaWYgKGNvbnRlbnQuS2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsaXN0LnB1c2goY29udGVudC5LZXkpO1xuICAgICAgfVxuICAgICAgZmV0Y2hNb3JlID0gcmVzcD8uSXNUcnVuY2F0ZWQgPz8gZmFsc2U7XG4gICAgICBtYXJrZXIgPSBsaXN0Lmxlbmd0aCA+IDAgPyBsaXN0LmF0KC0xKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3Q7XG4gIH1cblxuICAvKipcbiAgICogQ29weSBhbiBvYmplY3QgdG8gYSBuZXcgbG9jYXRpb24gaW4gdGhlIGJ1Y2tldC4gSWYgdGhlIGRlc3RpbmF0aW9uIG9iamVjdFxuICAgKiBhbHJlYWR5IGV4aXN0cywgaXQgd2lsbCBiZSBvdmVyd3JpdHRlbi5cbiAgICogQHBhcmFtIHNyY0tleSBUaGUga2V5IG9mIHRoZSBzb3VyY2Ugb2JqZWN0IHlvdSB3aXNoIHRvIGNvcHkuXG4gICAqIEBwYXJhbSBkc3RLZXkgVGhlIGtleSBvZiB0aGUgZGVzdGluYXRpb24gb2JqZWN0IGFmdGVyIGNvcHlpbmcuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgY29weShzcmNLZXk6IHN0cmluZywgZHN0S2V5OiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgLy8gR2V0IHByb3BlcnRpZXMgb2YgdGhlIHNvdXJjZSBvYmplY3RcbiAgICAgIGNvbnN0IGhlYWRSZXN1bHQgPSBhd2FpdCB0aGlzLnMzQ2xpZW50LnNlbmQoXG4gICAgICAgIG5ldyBIZWFkT2JqZWN0Q29tbWFuZCh7XG4gICAgICAgICAgQnVja2V0OiB0aGlzLmJ1Y2tldE5hbWUsXG4gICAgICAgICAgS2V5OiBzcmNLZXksXG4gICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgICAvLyBFcXVpdmFsZW50IHRvIGBhd3MgczMgY3AgLS1jb3B5LXByb3BzYCBpbiBBV1MgQ0xJIHYyXG4gICAgICBjb25zdCBjb21tYW5kID0gbmV3IENvcHlPYmplY3RDb21tYW5kKHtcbiAgICAgICAgQnVja2V0OiB0aGlzLmJ1Y2tldE5hbWUsXG4gICAgICAgIENvcHlTb3VyY2U6IGAke3RoaXMuYnVja2V0TmFtZX0vJHtzcmNLZXl9YCxcbiAgICAgICAgS2V5OiBkc3RLZXksXG4gICAgICAgIE1ldGFkYXRhRGlyZWN0aXZlOiBcIlJFUExBQ0VcIixcbiAgICAgICAgLy8gUHJvcGVydGllcyBjYXJyaWVkIG92ZXIgZnJvbSB0aGUgc291cmNlIG9iamVjdFxuICAgICAgICBDb250ZW50VHlwZTogaGVhZFJlc3VsdD8uQ29udGVudFR5cGUsXG4gICAgICAgIENvbnRlbnRMYW5ndWFnZTogaGVhZFJlc3VsdD8uQ29udGVudExhbmd1YWdlLFxuICAgICAgICBDb250ZW50RW5jb2Rpbmc6IGhlYWRSZXN1bHQ/LkNvbnRlbnRFbmNvZGluZyxcbiAgICAgICAgQ29udGVudERpc3Bvc2l0aW9uOiBoZWFkUmVzdWx0Py5Db250ZW50RGlzcG9zaXRpb24sXG4gICAgICAgIENhY2hlQ29udHJvbDogaGVhZFJlc3VsdD8uQ2FjaGVDb250cm9sLFxuICAgICAgICBFeHBpcmVzOiBoZWFkUmVzdWx0Py5FeHBpcmVzLFxuICAgICAgICBNZXRhZGF0YTogaGVhZFJlc3VsdD8uTWV0YWRhdGEsXG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgdGhpcy5zM0NsaWVudC5zZW5kKGNvbW1hbmQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBOb3RGb3VuZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNvdXJjZSBvYmplY3QgZG9lcyBub3QgZXhpc3QgKHNyY0tleT0ke3NyY0tleX0pLmApO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1vdmUgYW4gb2JqZWN0IHRvIGEgbmV3IGxvY2F0aW9uIGluIHRoZSBidWNrZXQuIElmIHRoZSBkZXN0aW5hdGlvbiBvYmplY3RcbiAgICogYWxyZWFkeSBleGlzdHMsIGl0IHdpbGwgYmUgb3ZlcndyaXR0ZW4uIFJldHVybnMgb25jZSB0aGUgcmVuYW1pbmcgaXMgZmluaXNoZWQuXG4gICAqIEBwYXJhbSBzcmNLZXkgVGhlIGtleSBvZiB0aGUgc291cmNlIG9iamVjdCB5b3Ugd2lzaCB0byByZW5hbWUuXG4gICAqIEBwYXJhbSBkc3RLZXkgVGhlIGtleSBvZiB0aGUgZGVzdGluYXRpb24gb2JqZWN0IGFmdGVyIHJlbmFtaW5nLlxuICAgKiBAdGhyb3dzIGlmIGBzcmNLZXlgIG9iamVjdCBkb2Vzbid0IGV4aXN0IG9yIGlmIGl0IG1hdGNoZXMgYGRzdEtleWAuXG4gICAqIEBpbmZsaWdodFxuICAgKi9cbiAgcHVibGljIGFzeW5jIHJlbmFtZShzcmNLZXk6IHN0cmluZywgZHN0S2V5OiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoc3JjS2V5ID09PSBkc3RLZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFJlbmFtaW5nIGFuIG9iamVjdCB0byBpdHMgY3VycmVudCBuYW1lIGlzIG5vdCBhIHZhbGlkIG9wZXJhdGlvbiAoc3JjS2V5PSR7c3JjS2V5fSwgZHN0S2V5PSR7ZHN0S2V5fSkuYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBhd2FpdCB0aGlzLmNvcHkoc3JjS2V5LCBkc3RLZXkpO1xuICAgIGF3YWl0IHRoaXMuZGVsZXRlKHNyY0tleSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBidWNrZXQgaXMgcHVibGljXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGJ1Y2tldCBpcyBwdWJsaWMgYW5kIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBjaGVja0lmUHVibGljKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IGNvbW1hbmQgPSBuZXcgR2V0UHVibGljQWNjZXNzQmxvY2tDb21tYW5kKHtcbiAgICAgIEJ1Y2tldDogdGhpcy5idWNrZXROYW1lLFxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3A6IEdldFB1YmxpY0FjY2Vzc0Jsb2NrQ29tbWFuZE91dHB1dCA9IGF3YWl0IHRoaXMuczNDbGllbnQuc2VuZChcbiAgICAgIGNvbW1hbmRcbiAgICApO1xuICAgIHJldHVybiAoXG4gICAgICAhcmVzcC5QdWJsaWNBY2Nlc3NCbG9ja0NvbmZpZ3VyYXRpb24/LkJsb2NrUHVibGljQWNscyAmJlxuICAgICAgIXJlc3AuUHVibGljQWNjZXNzQmxvY2tDb25maWd1cmF0aW9uPy5CbG9ja1B1YmxpY1BvbGljeSAmJlxuICAgICAgIXJlc3AuUHVibGljQWNjZXNzQmxvY2tDb25maWd1cmF0aW9uPy5SZXN0cmljdFB1YmxpY0J1Y2tldHMgJiZcbiAgICAgICFyZXNwLlB1YmxpY0FjY2Vzc0Jsb2NrQ29uZmlndXJhdGlvbj8uSWdub3JlUHVibGljQWNsc1xuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHVybCB0byB0aGUgZ2l2ZW4gZmlsZS5cbiAgICogQFRocm93cyBpZiB0aGUgZmlsZSBpcyBub3QgcHVibGljIG9yIGlmIG9iamVjdCBkb2VzIG5vdCBleGlzdC5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBwdWJsaWNVcmwoa2V5OiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGlmICghKGF3YWl0IHRoaXMuY2hlY2tJZlB1YmxpYygpKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHByb3ZpZGUgcHVibGljIHVybCBmb3IgYSBub24tcHVibGljIGJ1Y2tldFwiKTtcbiAgICB9XG5cbiAgICBpZiAoIShhd2FpdCB0aGlzLmV4aXN0cyhrZXkpKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IHByb3ZpZGUgcHVibGljIHVybCBmb3IgYSBub24tZXhpc3RlbnQga2V5IChrZXk9JHtrZXl9KWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVnaW9uID0gYXdhaXQgdGhpcy5nZXRMb2NhdGlvbigpO1xuXG4gICAgcmV0dXJuIGVuY29kZVVSSShcbiAgICAgIGBodHRwczovLyR7dGhpcy5idWNrZXROYW1lfS5zMy4ke3JlZ2lvbn0uYW1hem9uYXdzLmNvbS8ke2tleX1gXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgcHJlc2lnbmVkIFVSTCBmb3IgdGhlIHNwZWNpZmllZCBrZXkgaW4gdGhlIGJ1Y2tldC5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBvYmplY3QgaW4gdGhlIGJ1Y2tldC5cbiAgICogQHBhcmFtIG9wdHMgVGhlIG9wdGlvbnMgaW5jbHVkaW5nIHRoZSBhY3Rpb24gYW5kIHRoZSBkdXJhdGlvbiBmb3IgdGhlIHNpZ25lZCBVUkwuXG4gICAqIEByZXR1cm5zIFRoZSBwcmVzaWduZWQgVVJMIHN0cmluZy5cbiAgICogQGluZmxpZ2h0XG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc2lnbmVkVXJsKFxuICAgIGtleTogc3RyaW5nLFxuICAgIG9wdHM/OiBCdWNrZXRTaWduZWRVcmxPcHRpb25zXG4gICk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgbGV0IHMzQ29tbWFuZDogR2V0T2JqZWN0Q29tbWFuZCB8IFB1dE9iamVjdENvbW1hbmQ7XG5cbiAgICAvLyBTZXQgZGVmYXVsdCBhY3Rpb24gdG8gRE9XTkxPQUQgaWYgbm90IHByb3ZpZGVkXG4gICAgY29uc3QgYWN0aW9uID0gb3B0cz8uYWN0aW9uID8/IEJ1Y2tldFNpZ25lZFVybEFjdGlvbi5ET1dOTE9BRDtcblxuICAgIC8vIFNldCB0aGUgUzMgY29tbWFuZFxuICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICBjYXNlIEJ1Y2tldFNpZ25lZFVybEFjdGlvbi5ET1dOTE9BRDpcbiAgICAgICAgaWYgKCEoYXdhaXQgdGhpcy5leGlzdHMoa2V5KSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgQ2Fubm90IHByb3ZpZGUgc2lnbmVkIHVybCBmb3IgYSBub24tZXhpc3RlbnQga2V5IChrZXk9JHtrZXl9KWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHMzQ29tbWFuZCA9IG5ldyBHZXRPYmplY3RDb21tYW5kKHtcbiAgICAgICAgICBCdWNrZXQ6IHRoaXMuYnVja2V0TmFtZSxcbiAgICAgICAgICBLZXk6IGtleSxcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBCdWNrZXRTaWduZWRVcmxBY3Rpb24uVVBMT0FEOlxuICAgICAgICBzM0NvbW1hbmQgPSBuZXcgUHV0T2JqZWN0Q29tbWFuZCh7XG4gICAgICAgICAgQnVja2V0OiB0aGlzLmJ1Y2tldE5hbWUsXG4gICAgICAgICAgS2V5OiBrZXksXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBhY3Rpb246ICR7b3B0cz8uYWN0aW9ufWApO1xuICAgIH1cblxuICAgIC8vIEdlbmVyYXRlIHRoZSBwcmVzaWduZWQgVVJMXG4gICAgY29uc3Qgc2lnbmVkVXJsID0gYXdhaXQgZ2V0U2lnbmVkVXJsKHRoaXMuczNDbGllbnQsIHMzQ29tbWFuZCwge1xuICAgICAgZXhwaXJlc0luOiBvcHRzPy5kdXJhdGlvbj8uc2Vjb25kcyA/PyA5MDAsXG4gICAgfSk7XG5cbiAgICByZXR1cm4gc2lnbmVkVXJsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWV0YWRhdGEgb2YgYW4gb2JqZWN0IGluIHRoZSBidWNrZXQuXG4gICAqIEBwYXJhbSBrZXkgS2V5IG9mIHRoZSBvYmplY3QuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgbWV0YWRhdGEoa2V5OiBzdHJpbmcpOiBQcm9taXNlPE9iamVjdE1ldGFkYXRhPiB7XG4gICAgY29uc3QgY29tbWFuZCA9IG5ldyBIZWFkT2JqZWN0Q29tbWFuZCh7XG4gICAgICBCdWNrZXQ6IHRoaXMuYnVja2V0TmFtZSxcbiAgICAgIEtleToga2V5LFxuICAgIH0pO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwID0gYXdhaXQgdGhpcy5zM0NsaWVudC5zZW5kKGNvbW1hbmQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29udGVudFR5cGU6IHJlc3AuQ29udGVudFR5cGUsXG4gICAgICAgIGxhc3RNb2RpZmllZDogRGF0ZXRpbWUuZnJvbURhdGUocmVzcC5MYXN0TW9kaWZpZWQhKSxcbiAgICAgICAgc2l6ZTogcmVzcC5Db250ZW50TGVuZ3RoISxcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIDQwMyBpcyB0aHJvd24gaWYgczM6TGlzdE9iamVjdCBpcyBub3QgZ3JhbnRlZC5cbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIE5vdEZvdW5kIHx8IChlcnJvciBhcyBFcnJvcikubmFtZSA9PT0gXCI0MDNcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9iamVjdCBkb2VzIG5vdCBleGlzdCAoa2V5PSR7a2V5fSkuYCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGdldExvY2F0aW9uKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3QgY29tbWFuZCA9IG5ldyBHZXRCdWNrZXRMb2NhdGlvbkNvbW1hbmQoe1xuICAgICAgQnVja2V0OiB0aGlzLmJ1Y2tldE5hbWUsXG4gICAgfSk7XG4gICAgLy9CdWNrZXRzIGluIFJlZ2lvbiB1cy1lYXN0LTEgaGF2ZSBhIExvY2F0aW9uQ29uc3RyYWludCBvZiBudWxsLlxuICAgIC8vaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FtYXpvblMzL2xhdGVzdC9BUEkvQVBJX0dldEJ1Y2tldExvY2F0aW9uLmh0bWwjQVBJX0dldEJ1Y2tldExvY2F0aW9uX1Jlc3BvbnNlU3ludGF4XG4gICAgY29uc3QgeyBMb2NhdGlvbkNvbnN0cmFpbnQ6IHJlZ2lvbiA9IFwidXMtZWFzdC0xXCIgfSA9XG4gICAgICBhd2FpdCB0aGlzLnMzQ2xpZW50LnNlbmQoY29tbWFuZCk7XG4gICAgcmV0dXJuIHJlZ2lvbjtcbiAgfVxufVxuIl19