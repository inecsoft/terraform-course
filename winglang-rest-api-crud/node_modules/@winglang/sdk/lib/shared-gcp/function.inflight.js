"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FunctionClient = void 0;
const google_auth_library_1 = require("google-auth-library");
const http_1 = require("../http");
class FunctionClient {
    constructor(functionName, projectId, region) {
        this.functionName = functionName;
        this.projectId = projectId;
        this.region = region;
    }
    get functionURL() {
        return `https://${this.region}-${this.projectId}.cloudfunctions.net/${this.functionName}`;
    }
    async _invokeLocally(payload, token) {
        try {
            const res = await http_1.Util.post(this.functionURL, {
                headers: {
                    body: payload,
                    "Content-Type": "text/plain",
                    authorization: `bearer ${token}`,
                },
                redirect: http_1.RequestRedirect.FOLLOW,
            });
            if (!res.ok) {
                throw new Error(res.body);
            }
            return res.body ?? "";
        }
        catch (error) {
            throw new Error(`Error while invoking the function ${this.functionName}:\n${error.message}`);
        }
    }
    /**
     * Invoke the function, passing the given payload as an argument.
     *  @returns the function returned payload only
     */
    async invoke(payload) {
        try {
            const auth = new google_auth_library_1.GoogleAuth();
            const client = await auth.getIdTokenClient(this.functionURL);
            const res = await client.request({
                url: this.functionURL,
                method: "POST",
                body: payload,
                headers: {
                    "Content-Type": "text/plain",
                },
                retryConfig: {
                    retry: 8,
                    retryDelay: 15 * 1000,
                    shouldRetry: ({ code }) => {
                        // unauthorized - means that the permissions for the invocation are not yet established
                        return code === "403";
                    },
                },
            });
            return res.data;
        }
        catch (error) {
            throw new Error(`Error while invoking the function ${this.functionName}:\n${error.message}`);
        }
    }
    async invokeAsync(_payload) {
        throw new Error("invokeAsync not implemented");
    }
    /**
     * Invoke the function, passing the given payload as an argument.
     *
     * @returns the function returned payload and logs
     */
    async invokeWithLogs(payload, token) {
        console.error("Test invocation on tf-gcp doesn't include logs yet");
        //TODO: add traces to tf-gcp tests- https://github.com/winglang/wing/issues/4904
        return [await this._invokeLocally(payload, token), []];
    }
}
exports.FunctionClient = FunctionClient;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZnVuY3Rpb24uaW5mbGlnaHQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvc2hhcmVkLWdjcC9mdW5jdGlvbi5pbmZsaWdodC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSw2REFBaUQ7QUFFakQsa0NBQXdEO0FBR3hELE1BQWEsY0FBYztJQUN6QixZQUNtQixZQUFvQixFQUNwQixTQUFpQixFQUNqQixNQUFjO1FBRmQsaUJBQVksR0FBWixZQUFZLENBQVE7UUFDcEIsY0FBUyxHQUFULFNBQVMsQ0FBUTtRQUNqQixXQUFNLEdBQU4sTUFBTSxDQUFRO0lBQzlCLENBQUM7SUFFSixJQUFZLFdBQVc7UUFDckIsT0FBTyxXQUFXLElBQUksQ0FBQyxNQUFNLElBQUksSUFBSSxDQUFDLFNBQVMsdUJBQXVCLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUM1RixDQUFDO0lBRU8sS0FBSyxDQUFDLGNBQWMsQ0FDMUIsT0FBZSxFQUNmLEtBQWE7UUFFYixJQUFJLENBQUM7WUFDSCxNQUFNLEdBQUcsR0FBRyxNQUFNLFdBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRTtnQkFDNUMsT0FBTyxFQUFFO29CQUNQLElBQUksRUFBRSxPQUFPO29CQUNiLGNBQWMsRUFBRSxZQUFZO29CQUM1QixhQUFhLEVBQUUsVUFBVSxLQUFLLEVBQUU7aUJBQ2pDO2dCQUNELFFBQVEsRUFBRSxzQkFBZSxDQUFDLE1BQU07YUFDakMsQ0FBQyxDQUFDO1lBQ0gsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQztnQkFDWixNQUFNLElBQUksS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUM1QixDQUFDO1lBQ0QsT0FBTyxHQUFHLENBQUMsSUFBSSxJQUFJLEVBQUUsQ0FBQztRQUN4QixDQUFDO1FBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQztZQUNmLE1BQU0sSUFBSSxLQUFLLENBQ2IscUNBQXFDLElBQUksQ0FBQyxZQUFZLE1BQ25ELEtBQWUsQ0FBQyxPQUNuQixFQUFFLENBQ0gsQ0FBQztRQUNKLENBQUM7SUFDSCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksS0FBSyxDQUFDLE1BQU0sQ0FBQyxPQUFnQjtRQUNsQyxJQUFJLENBQUM7WUFDSCxNQUFNLElBQUksR0FBRyxJQUFJLGdDQUFVLEVBQUUsQ0FBQztZQUM5QixNQUFNLE1BQU0sR0FBRyxNQUFNLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7WUFFN0QsTUFBTSxHQUFHLEdBQUcsTUFBTSxNQUFNLENBQUMsT0FBTyxDQUFDO2dCQUMvQixHQUFHLEVBQUUsSUFBSSxDQUFDLFdBQVc7Z0JBQ3JCLE1BQU0sRUFBRSxNQUFNO2dCQUNkLElBQUksRUFBRSxPQUFPO2dCQUNiLE9BQU8sRUFBRTtvQkFDUCxjQUFjLEVBQUUsWUFBWTtpQkFDN0I7Z0JBQ0QsV0FBVyxFQUFFO29CQUNYLEtBQUssRUFBRSxDQUFDO29CQUNSLFVBQVUsRUFBRSxFQUFFLEdBQUcsSUFBSTtvQkFDckIsV0FBVyxFQUFFLENBQUMsRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFO3dCQUN4Qix1RkFBdUY7d0JBQ3ZGLE9BQU8sSUFBSSxLQUFLLEtBQUssQ0FBQztvQkFDeEIsQ0FBQztpQkFDRjthQUNGLENBQUMsQ0FBQztZQUNILE9BQU8sR0FBRyxDQUFDLElBQTBCLENBQUM7UUFDeEMsQ0FBQztRQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7WUFDZixNQUFNLElBQUksS0FBSyxDQUNiLHFDQUFxQyxJQUFJLENBQUMsWUFBWSxNQUNuRCxLQUFlLENBQUMsT0FDbkIsRUFBRSxDQUNILENBQUM7UUFDSixDQUFDO0lBQ0gsQ0FBQztJQUVNLEtBQUssQ0FBQyxXQUFXLENBQUMsUUFBaUI7UUFDeEMsTUFBTSxJQUFJLEtBQUssQ0FBQyw2QkFBNkIsQ0FBQyxDQUFDO0lBQ2pELENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksS0FBSyxDQUFDLGNBQWMsQ0FDekIsT0FBZSxFQUNmLEtBQWE7UUFFYixPQUFPLENBQUMsS0FBSyxDQUFDLG9EQUFvRCxDQUFDLENBQUM7UUFDcEUsZ0ZBQWdGO1FBQ2hGLE9BQU8sQ0FBQyxNQUFNLElBQUksQ0FBQyxjQUFjLENBQUMsT0FBTyxFQUFFLEtBQUssQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQ3pELENBQUM7Q0FDRjtBQXpGRCx3Q0F5RkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBHb29nbGVBdXRoIH0gZnJvbSBcImdvb2dsZS1hdXRoLWxpYnJhcnlcIjtcbmltcG9ydCB7IElGdW5jdGlvbkNsaWVudCB9IGZyb20gXCIuLi9jbG91ZFwiO1xuaW1wb3J0IHsgUmVxdWVzdFJlZGlyZWN0LCBVdGlsIGFzIGh0dHAgfSBmcm9tIFwiLi4vaHR0cFwiO1xuaW1wb3J0IHsgVHJhY2UgfSBmcm9tIFwiLi4vc3RkXCI7XG5cbmV4cG9ydCBjbGFzcyBGdW5jdGlvbkNsaWVudCBpbXBsZW1lbnRzIElGdW5jdGlvbkNsaWVudCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZnVuY3Rpb25OYW1lOiBzdHJpbmcsXG4gICAgcHJpdmF0ZSByZWFkb25seSBwcm9qZWN0SWQ6IHN0cmluZyxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHJlZ2lvbjogc3RyaW5nXG4gICkge31cblxuICBwcml2YXRlIGdldCBmdW5jdGlvblVSTCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBgaHR0cHM6Ly8ke3RoaXMucmVnaW9ufS0ke3RoaXMucHJvamVjdElkfS5jbG91ZGZ1bmN0aW9ucy5uZXQvJHt0aGlzLmZ1bmN0aW9uTmFtZX1gO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfaW52b2tlTG9jYWxseShcbiAgICBwYXlsb2FkOiBzdHJpbmcsXG4gICAgdG9rZW46IHN0cmluZ1xuICApOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBodHRwLnBvc3QodGhpcy5mdW5jdGlvblVSTCwge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgYm9keTogcGF5bG9hZCxcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcInRleHQvcGxhaW5cIixcbiAgICAgICAgICBhdXRob3JpemF0aW9uOiBgYmVhcmVyICR7dG9rZW59YCxcbiAgICAgICAgfSxcbiAgICAgICAgcmVkaXJlY3Q6IFJlcXVlc3RSZWRpcmVjdC5GT0xMT1csXG4gICAgICB9KTtcbiAgICAgIGlmICghcmVzLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyZXMuYm9keSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzLmJvZHkgPz8gXCJcIjtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRXJyb3Igd2hpbGUgaW52b2tpbmcgdGhlIGZ1bmN0aW9uICR7dGhpcy5mdW5jdGlvbk5hbWV9OlxcbiR7XG4gICAgICAgICAgKGVycm9yIGFzIEVycm9yKS5tZXNzYWdlXG4gICAgICAgIH1gXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2UgdGhlIGZ1bmN0aW9uLCBwYXNzaW5nIHRoZSBnaXZlbiBwYXlsb2FkIGFzIGFuIGFyZ3VtZW50LlxuICAgKiAgQHJldHVybnMgdGhlIGZ1bmN0aW9uIHJldHVybmVkIHBheWxvYWQgb25seVxuICAgKi9cbiAgcHVibGljIGFzeW5jIGludm9rZShwYXlsb2FkPzogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYXV0aCA9IG5ldyBHb29nbGVBdXRoKCk7XG4gICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBhdXRoLmdldElkVG9rZW5DbGllbnQodGhpcy5mdW5jdGlvblVSTCk7XG5cbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGNsaWVudC5yZXF1ZXN0KHtcbiAgICAgICAgdXJsOiB0aGlzLmZ1bmN0aW9uVVJMLFxuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBib2R5OiBwYXlsb2FkLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJ0ZXh0L3BsYWluXCIsXG4gICAgICAgIH0sXG4gICAgICAgIHJldHJ5Q29uZmlnOiB7XG4gICAgICAgICAgcmV0cnk6IDgsXG4gICAgICAgICAgcmV0cnlEZWxheTogMTUgKiAxMDAwLFxuICAgICAgICAgIHNob3VsZFJldHJ5OiAoeyBjb2RlIH0pID0+IHtcbiAgICAgICAgICAgIC8vIHVuYXV0aG9yaXplZCAtIG1lYW5zIHRoYXQgdGhlIHBlcm1pc3Npb25zIGZvciB0aGUgaW52b2NhdGlvbiBhcmUgbm90IHlldCBlc3RhYmxpc2hlZFxuICAgICAgICAgICAgcmV0dXJuIGNvZGUgPT09IFwiNDAzXCI7XG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlcy5kYXRhIGFzIHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRXJyb3Igd2hpbGUgaW52b2tpbmcgdGhlIGZ1bmN0aW9uICR7dGhpcy5mdW5jdGlvbk5hbWV9OlxcbiR7XG4gICAgICAgICAgKGVycm9yIGFzIEVycm9yKS5tZXNzYWdlXG4gICAgICAgIH1gXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBpbnZva2VBc3luYyhfcGF5bG9hZD86IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludm9rZUFzeW5jIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2UgdGhlIGZ1bmN0aW9uLCBwYXNzaW5nIHRoZSBnaXZlbiBwYXlsb2FkIGFzIGFuIGFyZ3VtZW50LlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGUgZnVuY3Rpb24gcmV0dXJuZWQgcGF5bG9hZCBhbmQgbG9nc1xuICAgKi9cbiAgcHVibGljIGFzeW5jIGludm9rZVdpdGhMb2dzKFxuICAgIHBheWxvYWQ6IHN0cmluZyxcbiAgICB0b2tlbjogc3RyaW5nXG4gICk6IFByb21pc2U8W3N0cmluZywgVHJhY2VbXV0+IHtcbiAgICBjb25zb2xlLmVycm9yKFwiVGVzdCBpbnZvY2F0aW9uIG9uIHRmLWdjcCBkb2Vzbid0IGluY2x1ZGUgbG9ncyB5ZXRcIik7XG4gICAgLy9UT0RPOiBhZGQgdHJhY2VzIHRvIHRmLWdjcCB0ZXN0cy0gaHR0cHM6Ly9naXRodWIuY29tL3dpbmdsYW5nL3dpbmcvaXNzdWVzLzQ5MDRcbiAgICByZXR1cm4gW2F3YWl0IHRoaXMuX2ludm9rZUxvY2FsbHkocGF5bG9hZCwgdG9rZW4pLCBbXV07XG4gIH1cbn1cbiJdfQ==