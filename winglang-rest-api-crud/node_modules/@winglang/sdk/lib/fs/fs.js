"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Util = exports.SymlinkType = exports.FileType = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const crypto = __importStar(require("crypto"));
const fs = __importStar(require("fs"));
const os = __importStar(require("os"));
const nodePath = __importStar(require("path"));
const glob = __importStar(require("glob"));
const yaml = __importStar(require("yaml"));
const core_1 = require("../core");
const misc_1 = require("../shared/misc");
const std_1 = require("../std");
/**
 * Represents the type of a file system object.
 */
var FileType;
(function (FileType) {
    /** Represents a regular file. */
    FileType["FILE"] = "File";
    /** Represents a directory. */
    FileType["DIRECTORY"] = "Directory";
    /** Represents a symbolic link. */
    FileType["SYMLINK"] = "Symlink";
    /**
     * Represents any type of file system object that is not `FILE`, `DIRECTORY` or `SYMLINK`.
     * This includes sockets, FIFOs (named pipes), block devices, and character devices.
     */
    FileType["OTHER"] = "Other";
})(FileType || (exports.FileType = FileType = {}));
/**
 * Represents the type of the target for creating symbolic links.
 */
var SymlinkType;
(function (SymlinkType) {
    /** Symbolic link that points to a file. */
    SymlinkType["FILE"] = "file";
    /** Symbolic link that points to a directory. */
    SymlinkType["DIRECTORY"] = "dir";
    /** Windows-specific: Symbolic link that points to a directory junction. */
    SymlinkType["JUNCTION"] = "junction";
})(SymlinkType || (exports.SymlinkType = SymlinkType = {}));
/**
 * The fs class is used for interacting with the file system.
 * All file paths must be POSIX file paths (/ instead of \),
 * and will be normalized to the target platform if running on Windows.
 */
class Util {
    /**
     * Join all arguments together and normalize the resulting path.
     * @param paths The array of path need to join.
     * @returns The resulting path after joining all the paths.
     */
    static join(...paths) {
        return (0, misc_1.normalPath)(nodePath.join(...paths));
    }
    /**
     * Retrieve the name of the directory from a given file path.
     * @param path The path to evaluate.
     * @returns The directory name of the path.
     */
    static dirname(path) {
        return (0, misc_1.normalPath)(nodePath.dirname(path));
    }
    /**
     * Retrieve the final segment of a given file path.
     * @param path The path to evaluate.
     * @returns The last portion of a path.
     */
    static basename(path) {
        return nodePath.basename(path);
    }
    /**
     * Solve the relative path from {from} to {to} based on the current working directory.
     * At times we have two absolute paths, and we need to derive the relative path from one to the other.
     * @returns The relative path from {from} to {to}.
     */
    static relative(from, to) {
        return (0, misc_1.normalPath)(nodePath.relative(from, to));
    }
    /**
     * The right-most parameter is considered {to}. Other parameters are considered an array of {from}.
     *
     * Starting from leftmost {from} parameter, resolves {to} to an absolute path.
     *
     * If {to} isn't already absolute, {from} arguments are prepended in right to left order,
     * until an absolute path is found. If after using all {from} paths still no absolute path is found,
     * the current working directory is used as well. The resulting path is normalized,
     * and trailing slashes are removed unless the path gets resolved to the root directory.
     *
     * @param paths A sequence of paths or path segments.
     * @returns The resulting path after performing the resolve operation.
     */
    static absolute(...paths) {
        return (0, misc_1.normalPath)(nodePath.resolve(...paths));
    }
    /**
     * Check if the path exists.
     * @param path The path to evaluate.
     * @returns `true` if the path exists, `false` otherwise.
     */
    static exists(path) {
        return fs.existsSync(path);
    }
    /**
     * Read the contents of the directory.
     * @param dirpath The path to evaluate.
     * @returns The contents of the directory.
     */
    static readdir(dirpath) {
        return fs.readdirSync(dirpath);
    }
    /**
     * If the path exists, read the contents of the directory; otherwise, return `undefined`.
     * @param dirpath The path to evaluate.
     * @returns The contents of the directory if the path exists, `undefined` otherwise.
     */
    static tryReaddir(dirpath) {
        try {
            return Util.readdir(dirpath);
        }
        catch {
            return undefined;
        }
    }
    /**
     * Create a directory.
     * @param dirpath The path to the directory you want to create.
     */
    static mkdir(dirpath, opts) {
        fs.mkdirSync(dirpath, {
            recursive: opts?.recursive ?? true,
            mode: opts?.mode ?? "0777",
        });
    }
    /**
     * Create a temporary directory.
     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
     * @param prefix The prefix for the directory to be created, default `wingtemp`.
     * @returns The created directory path.
     */
    static mkdtemp(prefix) {
        if (prefix == undefined) {
            prefix = "wingtemp";
        }
        const dirpath = fs.mkdtempSync(nodePath.join(os.tmpdir(), prefix));
        return (0, misc_1.normalPath)(dirpath);
    }
    /**
     * Read the entire contents of a file.
     * @param filepath The path of the file to be read.
     * @param options The `encoding` can be set to specify the character encoding. And the `flag` can be set to specify the attributes.
     * If a flag is not provided, it defaults to `"r"`.
     * @returns The contents of the `filepath`.
     */
    static readFile(filepath, options) {
        const buf = fs.readFileSync(filepath, options);
        return buf.toString();
    }
    /**
     * If the file exists and can be read successfully, read the entire contents;
     * otherwise, return `undefined`.
     * @param filepath The path of the file to be read.
     * @param options The `encoding` can be set to specify the character encoding, or the `flag` can be set to specify the attributes.
     * @returns The contents of the `filepath`, `undefined` otherwise.
     */
    static tryReadFile(filepath, options) {
        try {
            return Util.readFile(filepath, options);
        }
        catch {
            return undefined;
        }
    }
    /**
     * Read the contents of the file and convert it to JSON.
     * @param filepath The file path of the JSON file.
     * @returns The JSON object contained in the file.
     * @throws Will throw if the content is not in valid JSON format.
     */
    static readJson(filepath) {
        const text = Util.readFile(filepath);
        return JSON.parse(text);
    }
    /**
     * Retrieve the contents of the file and convert it to JSON
     * if the file exists and can be parsed successfully, otherwise, return `undefined`.
     * @param filepath The file path of the JSON file.
     * @returns The JSON object contained in the file, `undefined` otherwise.
     * @throws Will throw if the content is not in valid JSON format.
     */
    static tryReadJson(filepath) {
        try {
            return Util.readJson(filepath);
        }
        catch {
            return undefined;
        }
    }
    /**
     * Convert all YAML objects from a single file into JSON objects.
     * @param filepath The file path of the YAML file.
     * @returns The JSON objects converted from YAML objects in the file.
     * @throws Will throw if the content is not in valid YAML format.
     */
    static readYaml(filepath) {
        const text = Util.readFile(filepath);
        const yamlDocs = yaml.parseAllDocuments(text);
        return yamlDocs.map((doc) => {
            if (doc.contents && doc.contents.toJSON) {
                return doc.contents.toJSON();
            }
            else {
                throw new Error(`Unexpected document structure: ${doc}`);
            }
        });
    }
    /**
     * Convert all YAML objects from a single file into JSON objects
     * if the file exists and can be parsed successfully, `undefined` otherwise.
     * @param filepath The file path of the YAML file.
     * @returns The JSON objects converted from YAML objects in the file, `undefined` otherwise.
     * @throws Will throw if the content is not in valid YAML format.
     */
    static tryReadYaml(filepath) {
        try {
            return Util.readYaml(filepath);
        }
        catch {
            return undefined;
        }
    }
    /**
     * Writes data to a file, replacing the file if it already exists.
     * @param filepath The file path that needs to be written.
     * @param data The data to write.
     * @param options The `encoding` can be set to specify the character encoding. And the `flag` can be set to specify the attributes.
     * If a flag is not provided, it defaults to `"w"`.
     */
    static writeFile(filepath, data, options) {
        fs.writeFileSync(filepath, data, options);
    }
    /**
     * Writes JSON to a file, replacing the file if it already exists.
     * @param filepath The file path that needs to be written.
     * @param obj The JSON object to be dumped.
     */
    static writeJson(filepath, obj) {
        const text = JSON.stringify(obj, null, 2);
        fs.writeFileSync(filepath, text);
    }
    /**
     * Writes multiple YAML objects to a file, replacing the file if it already exists.
     * @param filepath The file path that needs to be written.
     * @param objs The YANL objects to be dumped.
     */
    static writeYaml(filepath, ...objs) {
        const contents = objs.map((o) => yaml.stringify(o, { aliasDuplicateObjects: false }));
        fs.writeFileSync(filepath, contents.join("---\n"));
    }
    /**
     * Appends new data to the end of an existing file
     * @param filepath The file path that needs to be appended.
     * @param data The text to be appended to the file.
     * @param options The `encoding` can be set to specify the character encoding. And the `flag` can be set to specify the attributes.
     * If a flag is not provided, it defaults to `"w"`.
     */
    static appendFile(filepath, data, options) {
        fs.appendFileSync(filepath, data, options);
    }
    /**
     * Remove files and directories (modeled on the standard POSIX `rm`utility). Returns `undefined`.
     * @param path The path to the file or directory you want to remove.
     */
    static remove(path, opts) {
        fs.rmSync(path, {
            force: opts?.force ?? true,
            recursive: opts?.recursive ?? true,
        });
    }
    /**
     * Checks if the given path is a directory and exists.
     * @param path The path to check.
     * @returns `true` if the path is an existing directory, `false` otherwise.
     */
    static isDir(path) {
        try {
            return fs.statSync(path).isDirectory();
        }
        catch {
            return false;
        }
    }
    /**
     * Gets the stats of the given path.
     * @param path The path to get stats for.
     * @returns The stats of the path, formatted as a `Metadata` object.
     */
    static metadata(path) {
        return this._metadata(fs.statSync(path));
    }
    /**
     * Gets the stats of the given path without following symbolic links.
     * @param path The path to get stats for.
     * @returns The stats of the path, formatted as a `Metadata` object.
     */
    static symlinkMetadata(path) {
        return this._metadata(fs.lstatSync(path));
    }
    /**
     * Set the permissions of the file, directory, etc.
     * Expects a permission string like `"755"` or `"644"`.
     * @param path The path of the file or directory.
     * @param permissions The mode to set as a string.
     */
    static setPermissions(path, permissions) {
        fs.chmodSync(path, parseInt(permissions, 8));
    }
    /**
     * Extracts the extension (without the leading dot) from the path, if possible.
     * @param path The path to get extension for.
     * @returns The file extension without the leading dot, or `nil` if:
     *          - The file name starts with a dot (hidden files).
     *          - There is no dot in the file name.
     *          - The dot is the last character in the file name.
     */
    static extension(path) {
        const ext = nodePath.extname(path);
        return !ext || path === ext || path.endsWith(".")
            ? undefined
            : ext.slice(1);
    }
    /**
     * Creates a symbolic link.
     * @param target The path to the target file or directory.
     * @param path The path to the symbolic link to be created.
     * @param type The type of the target. It can be `FILE`, `DIRECTORY`, or `JUNCTION` (Windows only).
     *             Defaults to `FILE` if not specified.
     */
    static symlink(target, path, type = SymlinkType.FILE) {
        fs.symlinkSync(target, path, type);
    }
    /**
     * Match files using the patterns the shell uses.
     *
     * Built with the great `glob` package, based on https://www.npmjs.com/package/glob
  
     * @param pattern The pattern to match.
     * @param options Glob options.
     * @returns List of matching files.
     */
    static glob(pattern, options = {}) {
        return glob.sync(pattern, options);
    }
    /**
     * Calculate an MD5 content hash of all the files that match a glob pattern.
     *
     * @param dir The root directory.
     * @param globPattern The glob pattern to match (defaults to all files and subdirectories).
     * @returns An md5 hash of the file contents.
     */
    static md5(dir, globPattern = "**/*") {
        const hash = crypto.createHash("md5");
        const files = this.glob(globPattern, { nodir: true, cwd: dir });
        for (const f of files) {
            const data = fs.readFileSync(this.join(dir, f));
            hash.update(data);
        }
        return hash.digest("hex");
    }
    /**
     * @internal
     */
    static _toInflightType() {
        return core_1.InflightClient.forType(__filename, this.name);
    }
    /**
     * Returns the `Metadata` object based on the given `fs.Stats` object.
     * @param stats The `fs.Stats` object.
     * @returns The `Metadata` object.
     */
    static _metadata(stats) {
        return {
            fileType: this._fileType(stats),
            size: stats.size,
            permissions: this._formatPermissions(stats.mode),
            accessed: std_1.Datetime.fromDate(stats.atime),
            modified: std_1.Datetime.fromDate(stats.mtime),
            created: std_1.Datetime.fromDate(stats.birthtime),
        };
    }
    /**
     * Returns the type of the file based on the given `fs.Stats` object.
     * @param stats The `fs.Stats` object.
     * @returns The type of the file.
     */
    static _fileType(stats) {
        switch (true) {
            case stats.isFile():
                return FileType.FILE;
            case stats.isDirectory():
                return FileType.DIRECTORY;
            case stats.isSymbolicLink():
                return FileType.SYMLINK;
            default:
                return FileType.OTHER;
        }
    }
    /**
     * Converts a numeric mode into a string representation of its permissions.
     * For example, this will convert the numeric mode `33279` into a `"755"` string.
     * @param mode The numeric mode to convert.
     * @returns A string representation of the permissions.
     */
    static _formatPermissions(mode) {
        const octalString = mode.toString(8);
        return octalString.substring(octalString.length - 3);
    }
}
exports.Util = Util;
_a = JSII_RTTI_SYMBOL_1;
Util[_a] = { fqn: "@winglang/sdk.fs.Util", version: "0.0.0" };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvZnMvZnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLCtDQUFpQztBQUNqQyx1Q0FBeUI7QUFDekIsdUNBQXlCO0FBQ3pCLCtDQUFpQztBQUNqQywyQ0FBNkI7QUFDN0IsMkNBQTZCO0FBQzdCLGtDQUF5QztBQUN6Qyx5Q0FBNEM7QUFDNUMsZ0NBQXdDO0FBb0V4Qzs7R0FFRztBQUNILElBQVksUUFlWDtBQWZELFdBQVksUUFBUTtJQUNsQixpQ0FBaUM7SUFDakMseUJBQWEsQ0FBQTtJQUViLDhCQUE4QjtJQUM5QixtQ0FBdUIsQ0FBQTtJQUV2QixrQ0FBa0M7SUFDbEMsK0JBQW1CLENBQUE7SUFFbkI7OztPQUdHO0lBQ0gsMkJBQWUsQ0FBQTtBQUNqQixDQUFDLEVBZlcsUUFBUSx3QkFBUixRQUFRLFFBZW5CO0FBRUQ7O0dBRUc7QUFDSCxJQUFZLFdBU1g7QUFURCxXQUFZLFdBQVc7SUFDckIsMkNBQTJDO0lBQzNDLDRCQUFhLENBQUE7SUFFYixnREFBZ0Q7SUFDaEQsZ0NBQWlCLENBQUE7SUFFakIsMkVBQTJFO0lBQzNFLG9DQUFxQixDQUFBO0FBQ3ZCLENBQUMsRUFUVyxXQUFXLDJCQUFYLFdBQVcsUUFTdEI7QUE2RUQ7Ozs7R0FJRztBQUNILE1BQWEsSUFBSTtJQUNmOzs7O09BSUc7SUFDSSxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsS0FBZTtRQUNuQyxPQUFPLElBQUEsaUJBQVUsRUFBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQztJQUM3QyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLE1BQU0sQ0FBQyxPQUFPLENBQUMsSUFBWTtRQUNoQyxPQUFPLElBQUEsaUJBQVUsRUFBQyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7SUFDNUMsQ0FBQztJQUVE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QUMsS0FBSyxDQUFDLEtBQUssQ0FBQztZQUN4QyxRQUFRLEVBQUUsY0FBUSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDO1lBQ3hDLE9BQU8sRUFBRSxjQUFRLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUM7U0FDNUMsQ0FBQztJQUNKLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ssTUFBTSxDQUFDLFNBQVMsQ0FBQyxLQUFlO1FBQ3RDLFFBQVEsSUFBSSxFQUFFLENBQUM7WUFDYixLQUFLLEtBQUssQ0FBQyxNQUFNLEVBQUU7Z0JBQ2pCLE9BQU8sUUFBUSxDQUFDLElBQUksQ0FBQztZQUN2QixLQUFLLEtBQUssQ0FBQyxXQUFXLEVBQUU7Z0JBQ3RCLE9BQU8sUUFBUSxDQUFDLFNBQVMsQ0FBQztZQUM1QixLQUFLLEtBQUssQ0FBQyxjQUFjLEVBQUU7Z0JBQ3pCLE9BQU8sUUFBUSxDQUFDLE9BQU8sQ0FBQztZQUMxQjtnQkFDRSxPQUFPLFFBQVEsQ0FBQyxLQUFLLENBQUM7UUFDMUIsQ0FBQztJQUNILENBQUM7SUFFRDs7Ozs7T0FLRztJQUNLLE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQyxJQUFZO1FBQzVDLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDckMsT0FBTyxXQUFXLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDdkQsQ0FBQzs7QUE3Wkgsb0JBOFpDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgY3J5cHRvIGZyb20gXCJjcnlwdG9cIjtcbmltcG9ydCAqIGFzIGZzIGZyb20gXCJmc1wiO1xuaW1wb3J0ICogYXMgb3MgZnJvbSBcIm9zXCI7XG5pbXBvcnQgKiBhcyBub2RlUGF0aCBmcm9tIFwicGF0aFwiO1xuaW1wb3J0ICogYXMgZ2xvYiBmcm9tIFwiZ2xvYlwiO1xuaW1wb3J0ICogYXMgeWFtbCBmcm9tIFwieWFtbFwiO1xuaW1wb3J0IHsgSW5mbGlnaHRDbGllbnQgfSBmcm9tIFwiLi4vY29yZVwiO1xuaW1wb3J0IHsgbm9ybWFsUGF0aCB9IGZyb20gXCIuLi9zaGFyZWQvbWlzY1wiO1xuaW1wb3J0IHsgRGF0ZXRpbWUsIEpzb24gfSBmcm9tIFwiLi4vc3RkXCI7XG5cbi8qKlxuICogQ3VzdG9tIHNldHRpbmdzIGZvciByZWFkaW5nIGZyb20gYSBmaWxlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVhZEZpbGVPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSBjaGFyYWN0ZXIgZW5jb2RpbmcgdXRpbGl6ZWQgZm9yIGZpbGUgcmVhZGluZy5cbiAgICogQGRlZmF1bHQgXCJ1dGYtOFwiXG4gICAqL1xuICByZWFkb25seSBlbmNvZGluZz86IEJ1ZmZlckVuY29kaW5nO1xuICAvKipcbiAgICogVGhlIGBmbGFnYCBjYW4gYmUgc2V0IHRvIHNwZWNpZnkgdGhlIGF0dHJpYnV0ZXMuXG4gICAqIEBkZWZhdWx0IFwiclwiLlxuICAgKi9cbiAgcmVhZG9ubHkgZmxhZz86IHN0cmluZztcbn1cblxuLyoqXG4gKiBDdXN0b20gc2V0dGluZ3MgZm9yIHdyaXRpbmcgdG8gYSBmaWxlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgV3JpdGVGaWxlT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgY2hhcmFjdGVyIGVuY29kaW5nIHV0aWxpemVkIGZvciBmaWxlIHdyaXRpbmcuXG4gICAqIEBkZWZhdWx0IFwidXRmLThcIlxuICAgKi9cbiAgcmVhZG9ubHkgZW5jb2Rpbmc/OiBCdWZmZXJFbmNvZGluZztcbiAgLyoqXG4gICAqIFRoZSBgZmxhZ2AgY2FuIGJlIHNldCB0byBzcGVjaWZ5IHRoZSBhdHRyaWJ1dGVzLlxuICAgKiBAZGVmYXVsdCBcIndcIi5cbiAgICovXG4gIHJlYWRvbmx5IGZsYWc/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogQ3VzdG9tIHNldHRpbmdzIGZvciBjcmVhdGluZyBkaXJlY3RvcnlcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNa2Rpck9wdGlvbnMge1xuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgcGFyZW50IGZvbGRlcnMgc2hvdWxkIGJlIGNyZWF0ZWQuXG4gICAqIElmIGEgZm9sZGVyIHdhcyBjcmVhdGVkLCB0aGUgcGF0aCB0byB0aGUgZmlyc3QgY3JlYXRlZCBmb2xkZXIgd2lsbCBiZSByZXR1cm5lZC5cbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgcmVhZG9ubHkgcmVjdXJzaXZlPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIEEgZmlsZSBtb2RlLiBUaGUgc3RyaW5nIHdpbGwgYmUgcGFyc2VkIGFzIGFuIG9jdGFsIGludGVnZXIuXG4gICAqIEBkZWZhdWx0IFwiMDc3N1wiXG4gICAqL1xuICByZWFkb25seSBtb2RlPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIEN1c3RvbSBzZXR0aW5ncyBmb3IgcmVtb3ZpbmcgZmlsZXMgYW5kIGRpcmVjdG9yaWVzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVtb3ZlT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBXaGVuIGB0cnVlYCwgZXhjZXB0aW9ucyB3aWxsIGJlIGlnbm9yZWQgaWYgYHBhdGhgIGRvZXMgbm90IGV4aXN0LlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICByZWFkb25seSBmb3JjZT86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHBlcmZvcm0gYSByZWN1cnNpdmUgZGlyZWN0b3J5IHJlbW92YWwuIEluXG4gICAqIHJlY3Vyc2l2ZSBtb2RlLCBvcGVyYXRpb25zIGFyZSByZXRyaWVkIG9uIGZhaWx1cmUuXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHJlYWRvbmx5IHJlY3Vyc2l2ZT86IGJvb2xlYW47XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgdHlwZSBvZiBhIGZpbGUgc3lzdGVtIG9iamVjdC5cbiAqL1xuZXhwb3J0IGVudW0gRmlsZVR5cGUge1xuICAvKiogUmVwcmVzZW50cyBhIHJlZ3VsYXIgZmlsZS4gKi9cbiAgRklMRSA9IFwiRmlsZVwiLFxuXG4gIC8qKiBSZXByZXNlbnRzIGEgZGlyZWN0b3J5LiAqL1xuICBESVJFQ1RPUlkgPSBcIkRpcmVjdG9yeVwiLFxuXG4gIC8qKiBSZXByZXNlbnRzIGEgc3ltYm9saWMgbGluay4gKi9cbiAgU1lNTElOSyA9IFwiU3ltbGlua1wiLFxuXG4gIC8qKlxuICAgKiBSZXByZXNlbnRzIGFueSB0eXBlIG9mIGZpbGUgc3lzdGVtIG9iamVjdCB0aGF0IGlzIG5vdCBgRklMRWAsIGBESVJFQ1RPUllgIG9yIGBTWU1MSU5LYC5cbiAgICogVGhpcyBpbmNsdWRlcyBzb2NrZXRzLCBGSUZPcyAobmFtZWQgcGlwZXMpLCBibG9jayBkZXZpY2VzLCBhbmQgY2hhcmFjdGVyIGRldmljZXMuXG4gICAqL1xuICBPVEhFUiA9IFwiT3RoZXJcIixcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSB0eXBlIG9mIHRoZSB0YXJnZXQgZm9yIGNyZWF0aW5nIHN5bWJvbGljIGxpbmtzLlxuICovXG5leHBvcnQgZW51bSBTeW1saW5rVHlwZSB7XG4gIC8qKiBTeW1ib2xpYyBsaW5rIHRoYXQgcG9pbnRzIHRvIGEgZmlsZS4gKi9cbiAgRklMRSA9IFwiZmlsZVwiLFxuXG4gIC8qKiBTeW1ib2xpYyBsaW5rIHRoYXQgcG9pbnRzIHRvIGEgZGlyZWN0b3J5LiAqL1xuICBESVJFQ1RPUlkgPSBcImRpclwiLFxuXG4gIC8qKiBXaW5kb3dzLXNwZWNpZmljOiBTeW1ib2xpYyBsaW5rIHRoYXQgcG9pbnRzIHRvIGEgZGlyZWN0b3J5IGp1bmN0aW9uLiAqL1xuICBKVU5DVElPTiA9IFwianVuY3Rpb25cIixcbn1cblxuLyoqXG4gKiBNZXRhZGF0YSBvZiBhIGZpbGUgc3lzdGVtIG9iamVjdC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNZXRhZGF0YSB7XG4gIC8qKiBUaGUgdHlwZSBvZiBmaWxlLiAqL1xuICByZWFkb25seSBmaWxlVHlwZTogRmlsZVR5cGU7XG4gIC8qKiBUaGUgc2l6ZSBvZiB0aGUgZmlsZSBpbiBieXRlcy4gKi9cbiAgcmVhZG9ubHkgc2l6ZTogbnVtYmVyO1xuICAvKiogVGhlIHBlcm1pc3Npb25zIG9mIHRoZSBmaWxlLiAqL1xuICByZWFkb25seSBwZXJtaXNzaW9uczogc3RyaW5nO1xuICAvKiogVGhlIGRhdGUgYW5kIHRpbWUgdGhlIGZpbGUgd2FzIGxhc3QgYWNjZXNzZWQuICovXG4gIHJlYWRvbmx5IGFjY2Vzc2VkOiBEYXRldGltZTtcbiAgLyoqIFRoZSBkYXRlIGFuZCB0aW1lIHRoZSBmaWxlIHdhcyBsYXN0IG1vZGlmaWVkLiAqL1xuICByZWFkb25seSBtb2RpZmllZDogRGF0ZXRpbWU7XG4gIC8qKiBUaGUgZGF0ZSBhbmQgdGltZSB0aGUgZmlsZSB3YXMgY3JlYXRlZC4gKi9cbiAgcmVhZG9ubHkgY3JlYXRlZDogRGF0ZXRpbWU7XG59XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgYGdsb2JgLCBiYXNlZCBvbiBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9nbG9iXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgR2xvYk9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnkgaW4gd2hpY2ggdG8gc2VhcmNoLlxuICAgKlxuICAgKiBAZGVmYXVsdCBwcm9jZXNzLmN3ZCgpXG4gICAqL1xuICByZWFkb25seSBjd2Q/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEluY2x1ZGUgYC5kb3RgIGZpbGVzIGluIG5vcm1hbCBtYXRjaGVzIGFuZCBnbG9ic3RhciBtYXRjaGVzLiBOb3RlIHRoYXQgYW4gZXhwbGljaXQgZG90IGluIGFcbiAgICogcG9ydGlvbiBvZiB0aGUgcGF0dGVybiB3aWxsIGFsd2F5cyBtYXRjaCBkb3QgZmlsZXMuXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICByZWFkb25seSBkb3Q/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBEbyBub3QgbWF0Y2ggZGlyZWN0b3JpZXMsIG9ubHkgZmlsZXMuIChOb3RlOiB0byBtYXRjaCBvbmx5IGRpcmVjdG9yaWVzLCBwdXQgYSBgL2AgYXQgdGhlIGVuZCBvZlxuICAgKiB0aGUgcGF0dGVybi4pXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICByZWFkb25seSBub2Rpcj86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEFuIGFycmF5IG9mIGdsb2IgcGF0dGVybnMgdG8gZXhjbHVkZSBmcm9tIG1hdGNoZXMuIFRvIGlnbm9yZSBhbGwgY2hpbGRyZW4gd2l0aGluIGEgZGlyZWN0b3J5LFxuICAgKiBhcyB3ZWxsIGFzIHRoZSBlbnRyeSBpdHNlbGYsIGFwcGVuZCAnLyoqJyB0byB0aGUgaWdub3JlIHBhdHRlcm4uXG4gICAqIEBkZWZhdWx0IFtdXG4gICAqL1xuICByZWFkb25seSBpZ25vcmU/OiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogRm9sbG93IHN5bWxpbmtlZCBkaXJlY3RvcmllcyB3aGVuIGV4cGFuZGluZyBgKipgIHBhdHRlcm5zLiBUaGlzIGNhbiByZXN1bHQgaW4gYSBsb3Qgb2ZcbiAgICogZHVwbGljYXRlIHJlZmVyZW5jZXMgaW4gdGhlIHByZXNlbmNlIG9mIGN5Y2xpYyBsaW5rcywgYW5kIG1ha2UgcGVyZm9ybWFuY2UgcXVpdGUgYmFkLlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcmVhZG9ubHkgZm9sbG93PzogYm9vbGVhbjtcblxuICAvKipcbiAgICogU2V0IHRvIGB0cnVlYCB0byBhbHdheXMgcmVjZWl2ZSBhYnNvbHV0ZSBwYXRocyBmb3IgbWF0Y2hlZCBmaWxlcy4gU2V0IHRvIGBmYWxzZWAgdG8gYWx3YXlzXG4gICAqIHJlY2VpdmUgcmVsYXRpdmUgcGF0aHMgZm9yIG1hdGNoZWQgZmlsZXMuXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICByZWFkb25seSBhYnNvbHV0ZT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFNwZWNpZnkgYSBudW1iZXIgdG8gbGltaXQgdGhlIGRlcHRoIG9mIHRoZSBkaXJlY3RvcnkgdHJhdmVyc2FsIHRvIHRoaXMgbWFueSBsZXZlbHMgYmVsb3cgdGhlXG4gICAqIGN3ZC5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBubyBsaW1pdFxuICAgKi9cbiAgcmVhZG9ubHkgbWF4RGVwdGg/OiBudW1iZXI7XG59XG5cbi8qKlxuICogVGhlIGZzIGNsYXNzIGlzIHVzZWQgZm9yIGludGVyYWN0aW5nIHdpdGggdGhlIGZpbGUgc3lzdGVtLlxuICogQWxsIGZpbGUgcGF0aHMgbXVzdCBiZSBQT1NJWCBmaWxlIHBhdGhzICgvIGluc3RlYWQgb2YgXFwpLFxuICogYW5kIHdpbGwgYmUgbm9ybWFsaXplZCB0byB0aGUgdGFyZ2V0IHBsYXRmb3JtIGlmIHJ1bm5pbmcgb24gV2luZG93cy5cbiAqL1xuZXhwb3J0IGNsYXNzIFV0aWwge1xuICAvKipcbiAgICogSm9pbiBhbGwgYXJndW1lbnRzIHRvZ2V0aGVyIGFuZCBub3JtYWxpemUgdGhlIHJlc3VsdGluZyBwYXRoLlxuICAgKiBAcGFyYW0gcGF0aHMgVGhlIGFycmF5IG9mIHBhdGggbmVlZCB0byBqb2luLlxuICAgKiBAcmV0dXJucyBUaGUgcmVzdWx0aW5nIHBhdGggYWZ0ZXIgam9pbmluZyBhbGwgdGhlIHBhdGhzLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBqb2luKC4uLnBhdGhzOiBzdHJpbmdbXSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIG5vcm1hbFBhdGgobm9kZVBhdGguam9pbiguLi5wYXRocykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSBuYW1lIG9mIHRoZSBkaXJlY3RvcnkgZnJvbSBhIGdpdmVuIGZpbGUgcGF0aC5cbiAgICogQHBhcmFtIHBhdGggVGhlIHBhdGggdG8gZXZhbHVhdGUuXG4gICAqIEByZXR1cm5zIFRoZSBkaXJlY3RvcnkgbmFtZSBvZiB0aGUgcGF0aC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZGlybmFtZShwYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBub3JtYWxQYXRoKG5vZGVQYXRoLmRpcm5hbWUocGF0aCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSBmaW5hbCBzZWdtZW50IG9mIGEgZ2l2ZW4gZmlsZSBwYXRoLlxuICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byBldmFsdWF0ZS5cbiAgICogQHJldHVybnMgVGhlIGxhc3QgcG9ydGlvbiBvZiBhIHBhdGguXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGJhc2VuYW1lKHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIG5vZGVQYXRoLmJhc2VuYW1lKHBhdGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNvbHZlIHRoZSByZWxhdGl2ZSBwYXRoIGZyb20ge2Zyb219IHRvIHt0b30gYmFzZWQgb24gdGhlIGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnkuXG4gICAqIEF0IHRpbWVzIHdlIGhhdmUgdHdvIGFic29sdXRlIHBhdGhzLCBhbmQgd2UgbmVlZCB0byBkZXJpdmUgdGhlIHJlbGF0aXZlIHBhdGggZnJvbSBvbmUgdG8gdGhlIG90aGVyLlxuICAgKiBAcmV0dXJucyBUaGUgcmVsYXRpdmUgcGF0aCBmcm9tIHtmcm9tfSB0byB7dG99LlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWxhdGl2ZShmcm9tOiBzdHJpbmcsIHRvOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBub3JtYWxQYXRoKG5vZGVQYXRoLnJlbGF0aXZlKGZyb20sIHRvKSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHJpZ2h0LW1vc3QgcGFyYW1ldGVyIGlzIGNvbnNpZGVyZWQge3RvfS4gT3RoZXIgcGFyYW1ldGVycyBhcmUgY29uc2lkZXJlZCBhbiBhcnJheSBvZiB7ZnJvbX0uXG4gICAqXG4gICAqIFN0YXJ0aW5nIGZyb20gbGVmdG1vc3Qge2Zyb219IHBhcmFtZXRlciwgcmVzb2x2ZXMge3RvfSB0byBhbiBhYnNvbHV0ZSBwYXRoLlxuICAgKlxuICAgKiBJZiB7dG99IGlzbid0IGFscmVhZHkgYWJzb2x1dGUsIHtmcm9tfSBhcmd1bWVudHMgYXJlIHByZXBlbmRlZCBpbiByaWdodCB0byBsZWZ0IG9yZGVyLFxuICAgKiB1bnRpbCBhbiBhYnNvbHV0ZSBwYXRoIGlzIGZvdW5kLiBJZiBhZnRlciB1c2luZyBhbGwge2Zyb219IHBhdGhzIHN0aWxsIG5vIGFic29sdXRlIHBhdGggaXMgZm91bmQsXG4gICAqIHRoZSBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5IGlzIHVzZWQgYXMgd2VsbC4gVGhlIHJlc3VsdGluZyBwYXRoIGlzIG5vcm1hbGl6ZWQsXG4gICAqIGFuZCB0cmFpbGluZyBzbGFzaGVzIGFyZSByZW1vdmVkIHVubGVzcyB0aGUgcGF0aCBnZXRzIHJlc29sdmVkIHRvIHRoZSByb290IGRpcmVjdG9yeS5cbiAgICpcbiAgICogQHBhcmFtIHBhdGhzIEEgc2VxdWVuY2Ugb2YgcGF0aHMgb3IgcGF0aCBzZWdtZW50cy5cbiAgICogQHJldHVybnMgVGhlIHJlc3VsdGluZyBwYXRoIGFmdGVyIHBlcmZvcm1pbmcgdGhlIHJlc29sdmUgb3BlcmF0aW9uLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBhYnNvbHV0ZSguLi5wYXRoczogc3RyaW5nW10pOiBzdHJpbmcge1xuICAgIHJldHVybiBub3JtYWxQYXRoKG5vZGVQYXRoLnJlc29sdmUoLi4ucGF0aHMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgcGF0aCBleGlzdHMuXG4gICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIHRvIGV2YWx1YXRlLlxuICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHBhdGggZXhpc3RzLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZXhpc3RzKHBhdGg6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmcy5leGlzdHNTeW5jKHBhdGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWQgdGhlIGNvbnRlbnRzIG9mIHRoZSBkaXJlY3RvcnkuXG4gICAqIEBwYXJhbSBkaXJwYXRoIFRoZSBwYXRoIHRvIGV2YWx1YXRlLlxuICAgKiBAcmV0dXJucyBUaGUgY29udGVudHMgb2YgdGhlIGRpcmVjdG9yeS5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZGRpcihkaXJwYXRoOiBzdHJpbmcpOiBBcnJheTxzdHJpbmc+IHtcbiAgICByZXR1cm4gZnMucmVhZGRpclN5bmMoZGlycGF0aCk7XG4gIH1cblxuICAvKipcbiAgICogSWYgdGhlIHBhdGggZXhpc3RzLCByZWFkIHRoZSBjb250ZW50cyBvZiB0aGUgZGlyZWN0b3J5OyBvdGhlcndpc2UsIHJldHVybiBgdW5kZWZpbmVkYC5cbiAgICogQHBhcmFtIGRpcnBhdGggVGhlIHBhdGggdG8gZXZhbHVhdGUuXG4gICAqIEByZXR1cm5zIFRoZSBjb250ZW50cyBvZiB0aGUgZGlyZWN0b3J5IGlmIHRoZSBwYXRoIGV4aXN0cywgYHVuZGVmaW5lZGAgb3RoZXJ3aXNlLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyB0cnlSZWFkZGlyKGRpcnBhdGg6IHN0cmluZyk6IEFycmF5PHN0cmluZz4gfCB1bmRlZmluZWQge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gVXRpbC5yZWFkZGlyKGRpcnBhdGgpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgZGlyZWN0b3J5LlxuICAgKiBAcGFyYW0gZGlycGF0aCBUaGUgcGF0aCB0byB0aGUgZGlyZWN0b3J5IHlvdSB3YW50IHRvIGNyZWF0ZS5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWtkaXIoZGlycGF0aDogc3RyaW5nLCBvcHRzPzogTWtkaXJPcHRpb25zKTogdm9pZCB7XG4gICAgZnMubWtkaXJTeW5jKGRpcnBhdGgsIHtcbiAgICAgIHJlY3Vyc2l2ZTogb3B0cz8ucmVjdXJzaXZlID8/IHRydWUsXG4gICAgICBtb2RlOiBvcHRzPy5tb2RlID8/IFwiMDc3N1wiLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHRlbXBvcmFyeSBkaXJlY3RvcnkuXG4gICAqIEdlbmVyYXRlcyBzaXggcmFuZG9tIGNoYXJhY3RlcnMgdG8gYmUgYXBwZW5kZWQgYmVoaW5kIGEgcmVxdWlyZWQgcHJlZml4IHRvIGNyZWF0ZSBhIHVuaXF1ZSB0ZW1wb3JhcnkgZGlyZWN0b3J5LlxuICAgKiBAcGFyYW0gcHJlZml4IFRoZSBwcmVmaXggZm9yIHRoZSBkaXJlY3RvcnkgdG8gYmUgY3JlYXRlZCwgZGVmYXVsdCBgd2luZ3RlbXBgLlxuICAgKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBkaXJlY3RvcnkgcGF0aC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWtkdGVtcChwcmVmaXg/OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmIChwcmVmaXggPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwcmVmaXggPSBcIndpbmd0ZW1wXCI7XG4gICAgfVxuICAgIGNvbnN0IGRpcnBhdGggPSBmcy5ta2R0ZW1wU3luYyhub2RlUGF0aC5qb2luKG9zLnRtcGRpcigpLCBwcmVmaXgpKTtcbiAgICByZXR1cm4gbm9ybWFsUGF0aChkaXJwYXRoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkIHRoZSBlbnRpcmUgY29udGVudHMgb2YgYSBmaWxlLlxuICAgKiBAcGFyYW0gZmlsZXBhdGggVGhlIHBhdGggb2YgdGhlIGZpbGUgdG8gYmUgcmVhZC5cbiAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGBlbmNvZGluZ2AgY2FuIGJlIHNldCB0byBzcGVjaWZ5IHRoZSBjaGFyYWN0ZXIgZW5jb2RpbmcuIEFuZCB0aGUgYGZsYWdgIGNhbiBiZSBzZXQgdG8gc3BlY2lmeSB0aGUgYXR0cmlidXRlcy5cbiAgICogSWYgYSBmbGFnIGlzIG5vdCBwcm92aWRlZCwgaXQgZGVmYXVsdHMgdG8gYFwiclwiYC5cbiAgICogQHJldHVybnMgVGhlIGNvbnRlbnRzIG9mIHRoZSBgZmlsZXBhdGhgLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkRmlsZShmaWxlcGF0aDogc3RyaW5nLCBvcHRpb25zPzogUmVhZEZpbGVPcHRpb25zKTogc3RyaW5nIHtcbiAgICBjb25zdCBidWYgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZXBhdGgsIG9wdGlvbnMpO1xuICAgIHJldHVybiBidWYudG9TdHJpbmcoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB0aGUgZmlsZSBleGlzdHMgYW5kIGNhbiBiZSByZWFkIHN1Y2Nlc3NmdWxseSwgcmVhZCB0aGUgZW50aXJlIGNvbnRlbnRzO1xuICAgKiBvdGhlcndpc2UsIHJldHVybiBgdW5kZWZpbmVkYC5cbiAgICogQHBhcmFtIGZpbGVwYXRoIFRoZSBwYXRoIG9mIHRoZSBmaWxlIHRvIGJlIHJlYWQuXG4gICAqIEBwYXJhbSBvcHRpb25zIFRoZSBgZW5jb2RpbmdgIGNhbiBiZSBzZXQgdG8gc3BlY2lmeSB0aGUgY2hhcmFjdGVyIGVuY29kaW5nLCBvciB0aGUgYGZsYWdgIGNhbiBiZSBzZXQgdG8gc3BlY2lmeSB0aGUgYXR0cmlidXRlcy5cbiAgICogQHJldHVybnMgVGhlIGNvbnRlbnRzIG9mIHRoZSBgZmlsZXBhdGhgLCBgdW5kZWZpbmVkYCBvdGhlcndpc2UuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHRyeVJlYWRGaWxlKFxuICAgIGZpbGVwYXRoOiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IFJlYWRGaWxlT3B0aW9uc1xuICApOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gVXRpbC5yZWFkRmlsZShmaWxlcGF0aCwgb3B0aW9ucyk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkIHRoZSBjb250ZW50cyBvZiB0aGUgZmlsZSBhbmQgY29udmVydCBpdCB0byBKU09OLlxuICAgKiBAcGFyYW0gZmlsZXBhdGggVGhlIGZpbGUgcGF0aCBvZiB0aGUgSlNPTiBmaWxlLlxuICAgKiBAcmV0dXJucyBUaGUgSlNPTiBvYmplY3QgY29udGFpbmVkIGluIHRoZSBmaWxlLlxuICAgKiBAdGhyb3dzIFdpbGwgdGhyb3cgaWYgdGhlIGNvbnRlbnQgaXMgbm90IGluIHZhbGlkIEpTT04gZm9ybWF0LlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkSnNvbihmaWxlcGF0aDogc3RyaW5nKTogSnNvbiB7XG4gICAgY29uc3QgdGV4dCA9IFV0aWwucmVhZEZpbGUoZmlsZXBhdGgpO1xuICAgIHJldHVybiBKU09OLnBhcnNlKHRleHQpIGFzIEpzb247XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmUgdGhlIGNvbnRlbnRzIG9mIHRoZSBmaWxlIGFuZCBjb252ZXJ0IGl0IHRvIEpTT05cbiAgICogaWYgdGhlIGZpbGUgZXhpc3RzIGFuZCBjYW4gYmUgcGFyc2VkIHN1Y2Nlc3NmdWxseSwgb3RoZXJ3aXNlLCByZXR1cm4gYHVuZGVmaW5lZGAuXG4gICAqIEBwYXJhbSBmaWxlcGF0aCBUaGUgZmlsZSBwYXRoIG9mIHRoZSBKU09OIGZpbGUuXG4gICAqIEByZXR1cm5zIFRoZSBKU09OIG9iamVjdCBjb250YWluZWQgaW4gdGhlIGZpbGUsIGB1bmRlZmluZWRgIG90aGVyd2lzZS5cbiAgICogQHRocm93cyBXaWxsIHRocm93IGlmIHRoZSBjb250ZW50IGlzIG5vdCBpbiB2YWxpZCBKU09OIGZvcm1hdC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgdHJ5UmVhZEpzb24oZmlsZXBhdGg6IHN0cmluZyk6IEpzb24gfCB1bmRlZmluZWQge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gVXRpbC5yZWFkSnNvbihmaWxlcGF0aCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGFsbCBZQU1MIG9iamVjdHMgZnJvbSBhIHNpbmdsZSBmaWxlIGludG8gSlNPTiBvYmplY3RzLlxuICAgKiBAcGFyYW0gZmlsZXBhdGggVGhlIGZpbGUgcGF0aCBvZiB0aGUgWUFNTCBmaWxlLlxuICAgKiBAcmV0dXJucyBUaGUgSlNPTiBvYmplY3RzIGNvbnZlcnRlZCBmcm9tIFlBTUwgb2JqZWN0cyBpbiB0aGUgZmlsZS5cbiAgICogQHRocm93cyBXaWxsIHRocm93IGlmIHRoZSBjb250ZW50IGlzIG5vdCBpbiB2YWxpZCBZQU1MIGZvcm1hdC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZFlhbWwoZmlsZXBhdGg6IHN0cmluZyk6IEpzb25bXSB7XG4gICAgY29uc3QgdGV4dCA9IFV0aWwucmVhZEZpbGUoZmlsZXBhdGgpO1xuICAgIGNvbnN0IHlhbWxEb2NzID0geWFtbC5wYXJzZUFsbERvY3VtZW50cyh0ZXh0KTtcbiAgICByZXR1cm4geWFtbERvY3MubWFwKChkb2MpID0+IHtcbiAgICAgIGlmIChkb2MuY29udGVudHMgJiYgZG9jLmNvbnRlbnRzLnRvSlNPTikge1xuICAgICAgICByZXR1cm4gZG9jLmNvbnRlbnRzLnRvSlNPTigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGRvY3VtZW50IHN0cnVjdHVyZTogJHtkb2N9YCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBhbGwgWUFNTCBvYmplY3RzIGZyb20gYSBzaW5nbGUgZmlsZSBpbnRvIEpTT04gb2JqZWN0c1xuICAgKiBpZiB0aGUgZmlsZSBleGlzdHMgYW5kIGNhbiBiZSBwYXJzZWQgc3VjY2Vzc2Z1bGx5LCBgdW5kZWZpbmVkYCBvdGhlcndpc2UuXG4gICAqIEBwYXJhbSBmaWxlcGF0aCBUaGUgZmlsZSBwYXRoIG9mIHRoZSBZQU1MIGZpbGUuXG4gICAqIEByZXR1cm5zIFRoZSBKU09OIG9iamVjdHMgY29udmVydGVkIGZyb20gWUFNTCBvYmplY3RzIGluIHRoZSBmaWxlLCBgdW5kZWZpbmVkYCBvdGhlcndpc2UuXG4gICAqIEB0aHJvd3MgV2lsbCB0aHJvdyBpZiB0aGUgY29udGVudCBpcyBub3QgaW4gdmFsaWQgWUFNTCBmb3JtYXQuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHRyeVJlYWRZYW1sKGZpbGVwYXRoOiBzdHJpbmcpOiBKc29uW10gfCB1bmRlZmluZWQge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gVXRpbC5yZWFkWWFtbChmaWxlcGF0aCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogV3JpdGVzIGRhdGEgdG8gYSBmaWxlLCByZXBsYWNpbmcgdGhlIGZpbGUgaWYgaXQgYWxyZWFkeSBleGlzdHMuXG4gICAqIEBwYXJhbSBmaWxlcGF0aCBUaGUgZmlsZSBwYXRoIHRoYXQgbmVlZHMgdG8gYmUgd3JpdHRlbi5cbiAgICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdG8gd3JpdGUuXG4gICAqIEBwYXJhbSBvcHRpb25zIFRoZSBgZW5jb2RpbmdgIGNhbiBiZSBzZXQgdG8gc3BlY2lmeSB0aGUgY2hhcmFjdGVyIGVuY29kaW5nLiBBbmQgdGhlIGBmbGFnYCBjYW4gYmUgc2V0IHRvIHNwZWNpZnkgdGhlIGF0dHJpYnV0ZXMuXG4gICAqIElmIGEgZmxhZyBpcyBub3QgcHJvdmlkZWQsIGl0IGRlZmF1bHRzIHRvIGBcIndcImAuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHdyaXRlRmlsZShcbiAgICBmaWxlcGF0aDogc3RyaW5nLFxuICAgIGRhdGE6IHN0cmluZyxcbiAgICBvcHRpb25zPzogV3JpdGVGaWxlT3B0aW9uc1xuICApOiB2b2lkIHtcbiAgICBmcy53cml0ZUZpbGVTeW5jKGZpbGVwYXRoLCBkYXRhLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZXMgSlNPTiB0byBhIGZpbGUsIHJlcGxhY2luZyB0aGUgZmlsZSBpZiBpdCBhbHJlYWR5IGV4aXN0cy5cbiAgICogQHBhcmFtIGZpbGVwYXRoIFRoZSBmaWxlIHBhdGggdGhhdCBuZWVkcyB0byBiZSB3cml0dGVuLlxuICAgKiBAcGFyYW0gb2JqIFRoZSBKU09OIG9iamVjdCB0byBiZSBkdW1wZWQuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHdyaXRlSnNvbihmaWxlcGF0aDogc3RyaW5nLCBvYmo6IEpzb24pOiB2b2lkIHtcbiAgICBjb25zdCB0ZXh0ID0gSlNPTi5zdHJpbmdpZnkob2JqLCBudWxsLCAyKTtcbiAgICBmcy53cml0ZUZpbGVTeW5jKGZpbGVwYXRoLCB0ZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZXMgbXVsdGlwbGUgWUFNTCBvYmplY3RzIHRvIGEgZmlsZSwgcmVwbGFjaW5nIHRoZSBmaWxlIGlmIGl0IGFscmVhZHkgZXhpc3RzLlxuICAgKiBAcGFyYW0gZmlsZXBhdGggVGhlIGZpbGUgcGF0aCB0aGF0IG5lZWRzIHRvIGJlIHdyaXR0ZW4uXG4gICAqIEBwYXJhbSBvYmpzIFRoZSBZQU5MIG9iamVjdHMgdG8gYmUgZHVtcGVkLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyB3cml0ZVlhbWwoZmlsZXBhdGg6IHN0cmluZywgLi4ub2JqczogSnNvbltdKTogdm9pZCB7XG4gICAgY29uc3QgY29udGVudHMgPSBvYmpzLm1hcCgobykgPT5cbiAgICAgIHlhbWwuc3RyaW5naWZ5KG8sIHsgYWxpYXNEdXBsaWNhdGVPYmplY3RzOiBmYWxzZSB9KVxuICAgICk7XG4gICAgZnMud3JpdGVGaWxlU3luYyhmaWxlcGF0aCwgY29udGVudHMuam9pbihcIi0tLVxcblwiKSk7XG4gIH1cblxuICAvKipcbiAgICogQXBwZW5kcyBuZXcgZGF0YSB0byB0aGUgZW5kIG9mIGFuIGV4aXN0aW5nIGZpbGVcbiAgICogQHBhcmFtIGZpbGVwYXRoIFRoZSBmaWxlIHBhdGggdGhhdCBuZWVkcyB0byBiZSBhcHBlbmRlZC5cbiAgICogQHBhcmFtIGRhdGEgVGhlIHRleHQgdG8gYmUgYXBwZW5kZWQgdG8gdGhlIGZpbGUuXG4gICAqIEBwYXJhbSBvcHRpb25zIFRoZSBgZW5jb2RpbmdgIGNhbiBiZSBzZXQgdG8gc3BlY2lmeSB0aGUgY2hhcmFjdGVyIGVuY29kaW5nLiBBbmQgdGhlIGBmbGFnYCBjYW4gYmUgc2V0IHRvIHNwZWNpZnkgdGhlIGF0dHJpYnV0ZXMuXG4gICAqIElmIGEgZmxhZyBpcyBub3QgcHJvdmlkZWQsIGl0IGRlZmF1bHRzIHRvIGBcIndcImAuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGFwcGVuZEZpbGUoXG4gICAgZmlsZXBhdGg6IHN0cmluZyxcbiAgICBkYXRhOiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IFdyaXRlRmlsZU9wdGlvbnNcbiAgKTogdm9pZCB7XG4gICAgZnMuYXBwZW5kRmlsZVN5bmMoZmlsZXBhdGgsIGRhdGEsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBmaWxlcyBhbmQgZGlyZWN0b3JpZXMgKG1vZGVsZWQgb24gdGhlIHN0YW5kYXJkIFBPU0lYIGBybWB1dGlsaXR5KS4gUmV0dXJucyBgdW5kZWZpbmVkYC5cbiAgICogQHBhcmFtIHBhdGggVGhlIHBhdGggdG8gdGhlIGZpbGUgb3IgZGlyZWN0b3J5IHlvdSB3YW50IHRvIHJlbW92ZS5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVtb3ZlKHBhdGg6IHN0cmluZywgb3B0cz86IFJlbW92ZU9wdGlvbnMpOiB2b2lkIHtcbiAgICBmcy5ybVN5bmMocGF0aCwge1xuICAgICAgZm9yY2U6IG9wdHM/LmZvcmNlID8/IHRydWUsXG4gICAgICByZWN1cnNpdmU6IG9wdHM/LnJlY3Vyc2l2ZSA/PyB0cnVlLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gcGF0aCBpcyBhIGRpcmVjdG9yeSBhbmQgZXhpc3RzLlxuICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBwYXRoIGlzIGFuIGV4aXN0aW5nIGRpcmVjdG9yeSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGlzRGlyKHBhdGg6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnMuc3RhdFN5bmMocGF0aCkuaXNEaXJlY3RvcnkoKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgc3RhdHMgb2YgdGhlIGdpdmVuIHBhdGguXG4gICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIHRvIGdldCBzdGF0cyBmb3IuXG4gICAqIEByZXR1cm5zIFRoZSBzdGF0cyBvZiB0aGUgcGF0aCwgZm9ybWF0dGVkIGFzIGEgYE1ldGFkYXRhYCBvYmplY3QuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG1ldGFkYXRhKHBhdGg6IHN0cmluZyk6IE1ldGFkYXRhIHtcbiAgICByZXR1cm4gdGhpcy5fbWV0YWRhdGEoZnMuc3RhdFN5bmMocGF0aCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHN0YXRzIG9mIHRoZSBnaXZlbiBwYXRoIHdpdGhvdXQgZm9sbG93aW5nIHN5bWJvbGljIGxpbmtzLlxuICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byBnZXQgc3RhdHMgZm9yLlxuICAgKiBAcmV0dXJucyBUaGUgc3RhdHMgb2YgdGhlIHBhdGgsIGZvcm1hdHRlZCBhcyBhIGBNZXRhZGF0YWAgb2JqZWN0LlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBzeW1saW5rTWV0YWRhdGEocGF0aDogc3RyaW5nKTogTWV0YWRhdGEge1xuICAgIHJldHVybiB0aGlzLl9tZXRhZGF0YShmcy5sc3RhdFN5bmMocGF0aCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgcGVybWlzc2lvbnMgb2YgdGhlIGZpbGUsIGRpcmVjdG9yeSwgZXRjLlxuICAgKiBFeHBlY3RzIGEgcGVybWlzc2lvbiBzdHJpbmcgbGlrZSBgXCI3NTVcImAgb3IgYFwiNjQ0XCJgLlxuICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCBvZiB0aGUgZmlsZSBvciBkaXJlY3RvcnkuXG4gICAqIEBwYXJhbSBwZXJtaXNzaW9ucyBUaGUgbW9kZSB0byBzZXQgYXMgYSBzdHJpbmcuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHNldFBlcm1pc3Npb25zKHBhdGg6IHN0cmluZywgcGVybWlzc2lvbnM6IHN0cmluZyk6IHZvaWQge1xuICAgIGZzLmNobW9kU3luYyhwYXRoLCBwYXJzZUludChwZXJtaXNzaW9ucywgOCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3RzIHRoZSBleHRlbnNpb24gKHdpdGhvdXQgdGhlIGxlYWRpbmcgZG90KSBmcm9tIHRoZSBwYXRoLCBpZiBwb3NzaWJsZS5cbiAgICogQHBhcmFtIHBhdGggVGhlIHBhdGggdG8gZ2V0IGV4dGVuc2lvbiBmb3IuXG4gICAqIEByZXR1cm5zIFRoZSBmaWxlIGV4dGVuc2lvbiB3aXRob3V0IHRoZSBsZWFkaW5nIGRvdCwgb3IgYG5pbGAgaWY6XG4gICAqICAgICAgICAgIC0gVGhlIGZpbGUgbmFtZSBzdGFydHMgd2l0aCBhIGRvdCAoaGlkZGVuIGZpbGVzKS5cbiAgICogICAgICAgICAgLSBUaGVyZSBpcyBubyBkb3QgaW4gdGhlIGZpbGUgbmFtZS5cbiAgICogICAgICAgICAgLSBUaGUgZG90IGlzIHRoZSBsYXN0IGNoYXJhY3RlciBpbiB0aGUgZmlsZSBuYW1lLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBleHRlbnNpb24ocGF0aDogc3RyaW5nKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBleHQgPSBub2RlUGF0aC5leHRuYW1lKHBhdGgpO1xuICAgIHJldHVybiAhZXh0IHx8IHBhdGggPT09IGV4dCB8fCBwYXRoLmVuZHNXaXRoKFwiLlwiKVxuICAgICAgPyB1bmRlZmluZWRcbiAgICAgIDogZXh0LnNsaWNlKDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzeW1ib2xpYyBsaW5rLlxuICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSBwYXRoIHRvIHRoZSB0YXJnZXQgZmlsZSBvciBkaXJlY3RvcnkuXG4gICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIHRvIHRoZSBzeW1ib2xpYyBsaW5rIHRvIGJlIGNyZWF0ZWQuXG4gICAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlIG9mIHRoZSB0YXJnZXQuIEl0IGNhbiBiZSBgRklMRWAsIGBESVJFQ1RPUllgLCBvciBgSlVOQ1RJT05gIChXaW5kb3dzIG9ubHkpLlxuICAgKiAgICAgICAgICAgICBEZWZhdWx0cyB0byBgRklMRWAgaWYgbm90IHNwZWNpZmllZC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgc3ltbGluayhcbiAgICB0YXJnZXQ6IHN0cmluZyxcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgdHlwZTogU3ltbGlua1R5cGUgPSBTeW1saW5rVHlwZS5GSUxFXG4gICk6IHZvaWQge1xuICAgIGZzLnN5bWxpbmtTeW5jKHRhcmdldCwgcGF0aCwgdHlwZSk7XG4gIH1cblxuICAvKipcbiAgICogTWF0Y2ggZmlsZXMgdXNpbmcgdGhlIHBhdHRlcm5zIHRoZSBzaGVsbCB1c2VzLlxuICAgKlxuICAgKiBCdWlsdCB3aXRoIHRoZSBncmVhdCBgZ2xvYmAgcGFja2FnZSwgYmFzZWQgb24gaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZ2xvYlxuXG4gICAqIEBwYXJhbSBwYXR0ZXJuIFRoZSBwYXR0ZXJuIHRvIG1hdGNoLlxuICAgKiBAcGFyYW0gb3B0aW9ucyBHbG9iIG9wdGlvbnMuXG4gICAqIEByZXR1cm5zIExpc3Qgb2YgbWF0Y2hpbmcgZmlsZXMuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGdsb2IocGF0dGVybjogc3RyaW5nLCBvcHRpb25zOiBHbG9iT3B0aW9ucyA9IHt9KTogc3RyaW5nW10ge1xuICAgIHJldHVybiBnbG9iLnN5bmMocGF0dGVybiwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIGFuIE1ENSBjb250ZW50IGhhc2ggb2YgYWxsIHRoZSBmaWxlcyB0aGF0IG1hdGNoIGEgZ2xvYiBwYXR0ZXJuLlxuICAgKlxuICAgKiBAcGFyYW0gZGlyIFRoZSByb290IGRpcmVjdG9yeS5cbiAgICogQHBhcmFtIGdsb2JQYXR0ZXJuIFRoZSBnbG9iIHBhdHRlcm4gdG8gbWF0Y2ggKGRlZmF1bHRzIHRvIGFsbCBmaWxlcyBhbmQgc3ViZGlyZWN0b3JpZXMpLlxuICAgKiBAcmV0dXJucyBBbiBtZDUgaGFzaCBvZiB0aGUgZmlsZSBjb250ZW50cy5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbWQ1KGRpcjogc3RyaW5nLCBnbG9iUGF0dGVybjogc3RyaW5nID0gXCIqKi8qXCIpIHtcbiAgICBjb25zdCBoYXNoID0gY3J5cHRvLmNyZWF0ZUhhc2goXCJtZDVcIik7XG4gICAgY29uc3QgZmlsZXMgPSB0aGlzLmdsb2IoZ2xvYlBhdHRlcm4sIHsgbm9kaXI6IHRydWUsIGN3ZDogZGlyIH0pO1xuICAgIGZvciAoY29uc3QgZiBvZiBmaWxlcykge1xuICAgICAgY29uc3QgZGF0YSA9IGZzLnJlYWRGaWxlU3luYyh0aGlzLmpvaW4oZGlyLCBmKSk7XG4gICAgICBoYXNoLnVwZGF0ZShkYXRhKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFzaC5kaWdlc3QoXCJoZXhcIik7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIF90b0luZmxpZ2h0VHlwZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiBJbmZsaWdodENsaWVudC5mb3JUeXBlKF9fZmlsZW5hbWUsIHRoaXMubmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYE1ldGFkYXRhYCBvYmplY3QgYmFzZWQgb24gdGhlIGdpdmVuIGBmcy5TdGF0c2Agb2JqZWN0LlxuICAgKiBAcGFyYW0gc3RhdHMgVGhlIGBmcy5TdGF0c2Agb2JqZWN0LlxuICAgKiBAcmV0dXJucyBUaGUgYE1ldGFkYXRhYCBvYmplY3QuXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBfbWV0YWRhdGEoc3RhdHM6IGZzLlN0YXRzKTogTWV0YWRhdGEge1xuICAgIHJldHVybiB7XG4gICAgICBmaWxlVHlwZTogdGhpcy5fZmlsZVR5cGUoc3RhdHMpLFxuICAgICAgc2l6ZTogc3RhdHMuc2l6ZSxcbiAgICAgIHBlcm1pc3Npb25zOiB0aGlzLl9mb3JtYXRQZXJtaXNzaW9ucyhzdGF0cy5tb2RlKSxcbiAgICAgIGFjY2Vzc2VkOiBEYXRldGltZS5mcm9tRGF0ZShzdGF0cy5hdGltZSksXG4gICAgICBtb2RpZmllZDogRGF0ZXRpbWUuZnJvbURhdGUoc3RhdHMubXRpbWUpLFxuICAgICAgY3JlYXRlZDogRGF0ZXRpbWUuZnJvbURhdGUoc3RhdHMuYmlydGh0aW1lKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHR5cGUgb2YgdGhlIGZpbGUgYmFzZWQgb24gdGhlIGdpdmVuIGBmcy5TdGF0c2Agb2JqZWN0LlxuICAgKiBAcGFyYW0gc3RhdHMgVGhlIGBmcy5TdGF0c2Agb2JqZWN0LlxuICAgKiBAcmV0dXJucyBUaGUgdHlwZSBvZiB0aGUgZmlsZS5cbiAgICovXG4gIHByaXZhdGUgc3RhdGljIF9maWxlVHlwZShzdGF0czogZnMuU3RhdHMpOiBGaWxlVHlwZSB7XG4gICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICBjYXNlIHN0YXRzLmlzRmlsZSgpOlxuICAgICAgICByZXR1cm4gRmlsZVR5cGUuRklMRTtcbiAgICAgIGNhc2Ugc3RhdHMuaXNEaXJlY3RvcnkoKTpcbiAgICAgICAgcmV0dXJuIEZpbGVUeXBlLkRJUkVDVE9SWTtcbiAgICAgIGNhc2Ugc3RhdHMuaXNTeW1ib2xpY0xpbmsoKTpcbiAgICAgICAgcmV0dXJuIEZpbGVUeXBlLlNZTUxJTks7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gRmlsZVR5cGUuT1RIRVI7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgbnVtZXJpYyBtb2RlIGludG8gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgaXRzIHBlcm1pc3Npb25zLlxuICAgKiBGb3IgZXhhbXBsZSwgdGhpcyB3aWxsIGNvbnZlcnQgdGhlIG51bWVyaWMgbW9kZSBgMzMyNzlgIGludG8gYSBgXCI3NTVcImAgc3RyaW5nLlxuICAgKiBAcGFyYW0gbW9kZSBUaGUgbnVtZXJpYyBtb2RlIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwZXJtaXNzaW9ucy5cbiAgICovXG4gIHByaXZhdGUgc3RhdGljIF9mb3JtYXRQZXJtaXNzaW9ucyhtb2RlOiBudW1iZXIpOiBzdHJpbmcge1xuICAgIGNvbnN0IG9jdGFsU3RyaW5nID0gbW9kZS50b1N0cmluZyg4KTtcbiAgICByZXR1cm4gb2N0YWxTdHJpbmcuc3Vic3RyaW5nKG9jdGFsU3RyaW5nLmxlbmd0aCAtIDMpO1xuICB9XG59XG4iXX0=