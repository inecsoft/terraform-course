"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.scanDirForPlatformFile = exports.loadPlatformSpecificValues = exports.filterParametersBySchema = exports.extractFieldsFromSchema = exports.parseValuesObjectFromString = void 0;
const fs_1 = require("fs");
const path = __importStar(require("path"));
const toml = __importStar(require("toml"));
const yaml = __importStar(require("yaml"));
/**
 * Creates a JSON object from a comma-separated list of values.
 * Where the key is the path and the value is the value.
 *
 * I.E. "foo/bar=123,foo/baz=456" would result in:
 * {
 * "foo": {
 *  "bar": "123",
 *  "baz": "456"
 *  }
 * }
 *
 * @param values a comma-separated list of values
 * @returns a JSON object with all values
 */
function parseValuesObjectFromString(values) {
    const result = {}; // Adjusted type for nested structures
    const valuesList = values.split(",");
    valuesList.forEach((v) => {
        const [paramPath, value] = v.split("=");
        const pathParts = paramPath.split("/");
        let tempObject = result; // Start with the result object
        pathParts.forEach((part, index) => {
            // If we're at the last part, assign the value
            if (index === pathParts.length - 1) {
                tempObject[part] = value;
            }
            else {
                // Otherwise, initialize the part if it doesn't exist, or use the existing object
                if (!tempObject[part])
                    tempObject[part] = {};
                tempObject = tempObject[part];
            }
        });
    });
    return result;
}
exports.parseValuesObjectFromString = parseValuesObjectFromString;
/**
 * Extracts all fields from a JSON schema.
 *
 * @param schema the schema to extract fields from
 * @returns a set of all fields in the schema
 */
function extractFieldsFromSchema(schema) {
    const fields = new Set();
    if (schema.properties) {
        for (const key of Object.keys(schema.properties)) {
            fields.add(key);
        }
    }
    return fields;
}
exports.extractFieldsFromSchema = extractFieldsFromSchema;
function filterParametersBySchema(fields, parameters) {
    const filtered = {};
    for (const field of fields) {
        if (parameters.hasOwnProperty(field)) {
            filtered[field] = parameters[field];
        }
    }
    return filtered;
}
exports.filterParametersBySchema = filterParametersBySchema;
/**
 * Loads platform-specific values that were passed in via CLI arguments and
 * from a values file. CLI arguments take precedence over values file.
 *
 * I.E. if the cli provided values such as --value "foo/bar=123" and the values file
 * contained:
 *
 * ```yaml
 * foo:
 *  bar: 456
 *  baz: 789
 * ```
 *
 * The resulting values object would be:
 * {
 *  "foo": {
 *    "bar": "123",
 *    "baz": "789"
 *  }
 * }
 *
 * @returns a JSON object with all platform-specific values
 */
function loadPlatformSpecificValues() {
    const cliValues = parseValuesObjectFromString(process.env.WING_VALUES ?? "");
    if (process.env.WING_VALUES_FILE === undefined ||
        process.env.WING_VALUES_FILE === "") {
        return cliValues;
    }
    const file = path.isAbsolute(process.env.WING_VALUES_FILE)
        ? process.env.WING_VALUES_FILE
        : path.join(process.cwd(), process.env.WING_VALUES_FILE);
    if (!(0, fs_1.existsSync)(file)) {
        return cliValues;
    }
    const data = (0, fs_1.readFileSync)(file, "utf-8");
    const fileExtension = path.extname(file);
    const fileValues = (() => {
        switch (fileExtension) {
            case ".yaml":
            case ".yml":
                return yaml.parse(data);
            case ".json":
                return JSON.parse(data);
            case ".toml":
                return toml.parse(data);
            default:
                throw new Error(`Unsupported file extension: ${fileExtension} (expected .yml, .json, or .toml)`);
        }
    })();
    return { ...fileValues, ...cliValues };
}
exports.loadPlatformSpecificValues = loadPlatformSpecificValues;
/**
 * Scans a directory for any platform files.
 *
 * @param dir the directory to scan
 * @returns the path to any platform files
 */
function scanDirForPlatformFile(dir) {
    const result = [];
    if (!(0, fs_1.existsSync)(dir)) {
        return result;
    }
    const files = (0, fs_1.readdirSync)(dir);
    for (const file of files) {
        if (file === "wplatform.js" || file.endsWith(".wplatform.js")) {
            result.push(path.join(dir, file));
        }
    }
    return result;
}
exports.scanDirForPlatformFile = scanDirForPlatformFile;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wbGF0Zm9ybS91dGlsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsMkJBQTJEO0FBQzNELDJDQUE2QjtBQUM3QiwyQ0FBNkI7QUFDN0IsMkNBQTZCO0FBRTdCOzs7Ozs7Ozs7Ozs7OztHQWNHO0FBQ0gsU0FBZ0IsMkJBQTJCLENBQUMsTUFBYztJQUN4RCxNQUFNLE1BQU0sR0FBUSxFQUFFLENBQUMsQ0FBQyxzQ0FBc0M7SUFFOUQsTUFBTSxVQUFVLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNyQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUU7UUFDdkIsTUFBTSxDQUFDLFNBQVMsRUFBRSxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3hDLE1BQU0sU0FBUyxHQUFHLFNBQVMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDdkMsSUFBSSxVQUFVLEdBQUcsTUFBTSxDQUFDLENBQUMsK0JBQStCO1FBRXhELFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLEVBQUU7WUFDaEMsOENBQThDO1lBQzlDLElBQUksS0FBSyxLQUFLLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUM7Z0JBQ25DLFVBQVUsQ0FBQyxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUM7WUFDM0IsQ0FBQztpQkFBTSxDQUFDO2dCQUNOLGlGQUFpRjtnQkFDakYsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUM7b0JBQUUsVUFBVSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztnQkFDN0MsVUFBVSxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNoQyxDQUFDO1FBQ0gsQ0FB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QixDQUFDLEdBQVc7SUFDaEQsTUFBTSxNQUFNLEdBQWEsRUFBRSxDQUFDO0lBRTVCLElBQUksQ0FBQyxJQUFBLGVBQVUsRUFBQyxHQUFHLENBQUMsRUFBRSxDQUFDO1FBQ3JCLE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7SUFFRCxNQUFNLEtBQUssR0FBRyxJQUFBLGdCQUFXLEVBQUMsR0FBRyxDQUFDLENBQUM7SUFDL0IsS0FBSyxNQUFNLElBQUksSUFBSSxLQUFLLEVBQUUsQ0FBQztRQUN6QixJQUFJLElBQUksS0FBSyxjQUFjLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxlQUFlLENBQUMsRUFBRSxDQUFDO1lBQzlELE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUNwQyxDQUFDO0lBQ0gsQ0FBQztJQUVELE9BQU8sTUFBTSxDQUFDO0FBQ2hCLENBQUM7QUFmRCx3REFlQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGV4aXN0c1N5bmMsIHJlYWRGaWxlU3luYywgcmVhZGRpclN5bmMgfSBmcm9tIFwiZnNcIjtcbmltcG9ydCAqIGFzIHBhdGggZnJvbSBcInBhdGhcIjtcbmltcG9ydCAqIGFzIHRvbWwgZnJvbSBcInRvbWxcIjtcbmltcG9ydCAqIGFzIHlhbWwgZnJvbSBcInlhbWxcIjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgSlNPTiBvYmplY3QgZnJvbSBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIHZhbHVlcy5cbiAqIFdoZXJlIHRoZSBrZXkgaXMgdGhlIHBhdGggYW5kIHRoZSB2YWx1ZSBpcyB0aGUgdmFsdWUuXG4gKlxuICogSS5FLiBcImZvby9iYXI9MTIzLGZvby9iYXo9NDU2XCIgd291bGQgcmVzdWx0IGluOlxuICoge1xuICogXCJmb29cIjoge1xuICogIFwiYmFyXCI6IFwiMTIzXCIsXG4gKiAgXCJiYXpcIjogXCI0NTZcIlxuICogIH1cbiAqIH1cbiAqXG4gKiBAcGFyYW0gdmFsdWVzIGEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgdmFsdWVzXG4gKiBAcmV0dXJucyBhIEpTT04gb2JqZWN0IHdpdGggYWxsIHZhbHVlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VWYWx1ZXNPYmplY3RGcm9tU3RyaW5nKHZhbHVlczogc3RyaW5nKSB7XG4gIGNvbnN0IHJlc3VsdDogYW55ID0ge307IC8vIEFkanVzdGVkIHR5cGUgZm9yIG5lc3RlZCBzdHJ1Y3R1cmVzXG5cbiAgY29uc3QgdmFsdWVzTGlzdCA9IHZhbHVlcy5zcGxpdChcIixcIik7XG4gIHZhbHVlc0xpc3QuZm9yRWFjaCgodikgPT4ge1xuICAgIGNvbnN0IFtwYXJhbVBhdGgsIHZhbHVlXSA9IHYuc3BsaXQoXCI9XCIpO1xuICAgIGNvbnN0IHBhdGhQYXJ0cyA9IHBhcmFtUGF0aC5zcGxpdChcIi9cIik7XG4gICAgbGV0IHRlbXBPYmplY3QgPSByZXN1bHQ7IC8vIFN0YXJ0IHdpdGggdGhlIHJlc3VsdCBvYmplY3RcblxuICAgIHBhdGhQYXJ0cy5mb3JFYWNoKChwYXJ0LCBpbmRleCkgPT4ge1xuICAgICAgLy8gSWYgd2UncmUgYXQgdGhlIGxhc3QgcGFydCwgYXNzaWduIHRoZSB2YWx1ZVxuICAgICAgaWYgKGluZGV4ID09PSBwYXRoUGFydHMubGVuZ3RoIC0gMSkge1xuICAgICAgICB0ZW1wT2JqZWN0W3BhcnRdID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPdGhlcndpc2UsIGluaXRpYWxpemUgdGhlIHBhcnQgaWYgaXQgZG9lc24ndCBleGlzdCwgb3IgdXNlIHRoZSBleGlzdGluZyBvYmplY3RcbiAgICAgICAgaWYgKCF0ZW1wT2JqZWN0W3BhcnRdKSB0ZW1wT2JqZWN0W3BhcnRdID0ge307XG4gICAgICAgIHRlbXBPYmplY3QgPSB0ZW1wT2JqZWN0W3BhcnRdO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEV4dHJhY3RzIGFsbCBmaWVsZHMgZnJvbSBhIEpTT04gc2NoZW1hLlxuICpcbiAqIEBwYXJhbSBzY2hlbWEgdGhlIHNjaGVtYSB0byBleHRyYWN0IGZpZWxkcyBmcm9tXG4gKiBAcmV0dXJucyBhIHNldCBvZiBhbGwgZmllbGRzIGluIHRoZSBzY2hlbWFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RGaWVsZHNGcm9tU2NoZW1hKHNjaGVtYTogYW55KTogU2V0PHN0cmluZz4ge1xuICBjb25zdCBmaWVsZHMgPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuICBpZiAoc2NoZW1hLnByb3BlcnRpZXMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzY2hlbWEucHJvcGVydGllcykpIHtcbiAgICAgIGZpZWxkcy5hZGQoa2V5KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmllbGRzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyUGFyYW1ldGVyc0J5U2NoZW1hKFxuICBmaWVsZHM6IFNldDxzdHJpbmc+LFxuICBwYXJhbWV0ZXJzOiBhbnlcbik6IGFueSB7XG4gIGNvbnN0IGZpbHRlcmVkOiBhbnkgPSB7fTtcblxuICBmb3IgKGNvbnN0IGZpZWxkIG9mIGZpZWxkcykge1xuICAgIGlmIChwYXJhbWV0ZXJzLmhhc093blByb3BlcnR5KGZpZWxkKSkge1xuICAgICAgZmlsdGVyZWRbZmllbGRdID0gcGFyYW1ldGVyc1tmaWVsZF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZpbHRlcmVkO1xufVxuXG4vKipcbiAqIExvYWRzIHBsYXRmb3JtLXNwZWNpZmljIHZhbHVlcyB0aGF0IHdlcmUgcGFzc2VkIGluIHZpYSBDTEkgYXJndW1lbnRzIGFuZFxuICogZnJvbSBhIHZhbHVlcyBmaWxlLiBDTEkgYXJndW1lbnRzIHRha2UgcHJlY2VkZW5jZSBvdmVyIHZhbHVlcyBmaWxlLlxuICpcbiAqIEkuRS4gaWYgdGhlIGNsaSBwcm92aWRlZCB2YWx1ZXMgc3VjaCBhcyAtLXZhbHVlIFwiZm9vL2Jhcj0xMjNcIiBhbmQgdGhlIHZhbHVlcyBmaWxlXG4gKiBjb250YWluZWQ6XG4gKlxuICogYGBgeWFtbFxuICogZm9vOlxuICogIGJhcjogNDU2XG4gKiAgYmF6OiA3ODlcbiAqIGBgYFxuICpcbiAqIFRoZSByZXN1bHRpbmcgdmFsdWVzIG9iamVjdCB3b3VsZCBiZTpcbiAqIHtcbiAqICBcImZvb1wiOiB7XG4gKiAgICBcImJhclwiOiBcIjEyM1wiLFxuICogICAgXCJiYXpcIjogXCI3ODlcIlxuICogIH1cbiAqIH1cbiAqXG4gKiBAcmV0dXJucyBhIEpTT04gb2JqZWN0IHdpdGggYWxsIHBsYXRmb3JtLXNwZWNpZmljIHZhbHVlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gbG9hZFBsYXRmb3JtU3BlY2lmaWNWYWx1ZXMoKSB7XG4gIGNvbnN0IGNsaVZhbHVlcyA9IHBhcnNlVmFsdWVzT2JqZWN0RnJvbVN0cmluZyhwcm9jZXNzLmVudi5XSU5HX1ZBTFVFUyA/PyBcIlwiKTtcblxuICBpZiAoXG4gICAgcHJvY2Vzcy5lbnYuV0lOR19WQUxVRVNfRklMRSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgcHJvY2Vzcy5lbnYuV0lOR19WQUxVRVNfRklMRSA9PT0gXCJcIlxuICApIHtcbiAgICByZXR1cm4gY2xpVmFsdWVzO1xuICB9XG5cbiAgY29uc3QgZmlsZSA9IHBhdGguaXNBYnNvbHV0ZShwcm9jZXNzLmVudi5XSU5HX1ZBTFVFU19GSUxFKVxuICAgID8gcHJvY2Vzcy5lbnYuV0lOR19WQUxVRVNfRklMRVxuICAgIDogcGF0aC5qb2luKHByb2Nlc3MuY3dkKCksIHByb2Nlc3MuZW52LldJTkdfVkFMVUVTX0ZJTEUpO1xuICBpZiAoIWV4aXN0c1N5bmMoZmlsZSkpIHtcbiAgICByZXR1cm4gY2xpVmFsdWVzO1xuICB9XG4gIGNvbnN0IGRhdGEgPSByZWFkRmlsZVN5bmMoZmlsZSwgXCJ1dGYtOFwiKTtcblxuICBjb25zdCBmaWxlRXh0ZW5zaW9uID0gcGF0aC5leHRuYW1lKGZpbGUpO1xuICBjb25zdCBmaWxlVmFsdWVzID0gKCgpID0+IHtcbiAgICBzd2l0Y2ggKGZpbGVFeHRlbnNpb24pIHtcbiAgICAgIGNhc2UgXCIueWFtbFwiOlxuICAgICAgY2FzZSBcIi55bWxcIjpcbiAgICAgICAgcmV0dXJuIHlhbWwucGFyc2UoZGF0YSk7XG4gICAgICBjYXNlIFwiLmpzb25cIjpcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICBjYXNlIFwiLnRvbWxcIjpcbiAgICAgICAgcmV0dXJuIHRvbWwucGFyc2UoZGF0YSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFVuc3VwcG9ydGVkIGZpbGUgZXh0ZW5zaW9uOiAke2ZpbGVFeHRlbnNpb259IChleHBlY3RlZCAueW1sLCAuanNvbiwgb3IgLnRvbWwpYFxuICAgICAgICApO1xuICAgIH1cbiAgfSkoKTtcbiAgcmV0dXJuIHsgLi4uZmlsZVZhbHVlcywgLi4uY2xpVmFsdWVzIH07XG59XG5cbi8qKlxuICogU2NhbnMgYSBkaXJlY3RvcnkgZm9yIGFueSBwbGF0Zm9ybSBmaWxlcy5cbiAqXG4gKiBAcGFyYW0gZGlyIHRoZSBkaXJlY3RvcnkgdG8gc2NhblxuICogQHJldHVybnMgdGhlIHBhdGggdG8gYW55IHBsYXRmb3JtIGZpbGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FuRGlyRm9yUGxhdGZvcm1GaWxlKGRpcjogc3RyaW5nKTogc3RyaW5nW10ge1xuICBjb25zdCByZXN1bHQ6IHN0cmluZ1tdID0gW107XG5cbiAgaWYgKCFleGlzdHNTeW5jKGRpcikpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgY29uc3QgZmlsZXMgPSByZWFkZGlyU3luYyhkaXIpO1xuICBmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcbiAgICBpZiAoZmlsZSA9PT0gXCJ3cGxhdGZvcm0uanNcIiB8fCBmaWxlLmVuZHNXaXRoKFwiLndwbGF0Zm9ybS5qc1wiKSkge1xuICAgICAgcmVzdWx0LnB1c2gocGF0aC5qb2luKGRpciwgZmlsZSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG4iXX0=