"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Util = exports.Stdio = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const child_process_1 = require("child_process");
const crypto_1 = require("crypto");
const util_1 = require("util");
const nanoid_1 = require("nanoid");
const ulid_1 = require("ulid");
const uuid_1 = require("uuid");
const child_process_2 = require("./child-process");
const core_1 = require("../core");
const std_1 = require("../std");
const execPromise = (0, util_1.promisify)(child_process_1.exec);
const execFilePromise = (0, util_1.promisify)(child_process_1.execFile);
/**
 * Describes what to do with a standard I/O stream for a child process.
 */
var Stdio;
(function (Stdio) {
    /**
     * The child inherits from the corresponding parent descriptor.
     */
    Stdio["INHERIT"] = "inherit";
    /**
     * A new pipe should be arranged to connect the parent and child processes.
     */
    Stdio["PIPED"] = "pipe";
    /**
     * This stream will be ignored. This is the equivalent of attaching the stream to /dev/null.
     */
    Stdio["NULL"] = "ignore";
})(Stdio || (exports.Stdio = Stdio = {}));
/**
 * Utility functions.
 */
class Util {
    /**
     * Executes a command in the shell and returns its standard output.
     * @param command The command string to execute in the shell.
     * @param opts `ShellOptions`, such as the working directory and environment variables.
     * @returns The standard output of the shell command.
     * @throws An error if the shell command execution fails or returns a non-zero exit code.
     */
    static async shell(command, opts) {
        const shellOpts = {
            windowsHide: true,
            cwd: opts?.cwd,
            env: opts?.inheritEnv === true
                ? { ...process.env, ...opts?.env }
                : { ...opts?.env },
        };
        const createErrorMessage = (error) => {
            if (error.stderr) {
                return `Error executing command "${command}". Exited with error: ${error.stderr}`;
            }
            return `Error executing command "${command}". Exited with error code: ${error.code}`;
        };
        try {
            const { stdout } = await execPromise(command, shellOpts);
            return stdout.toString();
        }
        catch (error) {
            const errorMessage = createErrorMessage(error);
            if (opts?.throw !== false) {
                throw new Error(errorMessage);
            }
            return errorMessage;
        }
    }
    /**
     * Execute a program with the given arguments, wait for it to finish, and
     * return its outputs.
     * @param program The program to execute.
     * @param args An array of arguments to pass to the program.
     * @param opts `ExecOptions`, such as the working directory and environment variables.
     * @returns A struct containing `stdout`, `stderr` and exit `status` of the executed program.
     */
    static async exec(program, args, opts) {
        const execOpts = {
            windowsHide: true,
            shell: false,
            cwd: opts?.cwd,
            env: opts?.inheritEnv === true
                ? { ...process.env, ...opts?.env }
                : { ...opts?.env },
        };
        try {
            const { stdout, stderr } = await execFilePromise(program, args, execOpts);
            return {
                stdout: stdout.toString(),
                stderr: stderr.toString(),
                status: 0,
            };
        }
        catch (error) {
            if (error.code === "ENOENT") {
                throw new Error(`Program not found: ${error.message}`);
            }
            else {
                return {
                    stdout: error.stdout.toString(),
                    stderr: error.stderr.toString(),
                    status: error.code,
                };
            }
        }
    }
    /**
     * Execute a program with the given arguments, and return a `ChildProcess`
     * object that can be used to interact with the process while it is running.
     * @param program - The program to execute.
     * @param args - An array of arguments to pass to the program.
     * @param opts - Spawn options including working directory, environment variables, and stdio configurations.
     * @returns The `ChildProcess` instance associated with the spawned process.
     * @inflight
     */
    static spawn(program, args, opts) {
        return new child_process_2.ChildProcess(program, args, opts);
    }
    /**
     * Returns the value of an environment variable. Throws if not found or empty.
     * @param name The name of the environment variable.
     */
    static env(name) {
        const value = Util.tryEnv(name);
        if (!value) {
            throw new Error(`Environment variable ${name} not found.`);
        }
        return value;
    }
    /**
     * Returns the value of an environment variable. Returns `nil` if not found or empty.
     * @param name The name of the environment variable.
     * @returns The value of the environment variable or `nil`.
     */
    static tryEnv(name) {
        return process.env[name];
    }
    /**
     * Sets the given name and value as an environment variable.
     * @param name The name of the environment variable.
     * @param value The value of the environment variable.
     */
    static setEnv(name, value) {
        process.env[name] = value;
    }
    /**
     * Converts a string from UTF-8 to base64.
     * @param stringToEncode The name of the UTF-8 string to encode.
     * @param url If `true`, a URL-safe base64 string is returned.
     * @returns The base64 string.
     */
    static base64Encode(stringToEncode, url) {
        return Buffer.from(stringToEncode).toString(url ? "base64url" : "base64");
    }
    /**
     * Converts a string from base64 to UTF-8.
     * @param stringToDecode base64 string to decode.
     * @param url If `true`, the source is expected to be a URL-safe base64 string.
     * @returns The UTF-8 string.
     */
    static base64Decode(stringToDecode, url) {
        return Buffer.from(stringToDecode, url ? "base64url" : "base64").toString("utf8");
    }
    /**
     * Suspends execution for a given duration.
     * @param delay The time to suspend execution.
     * @inflight
     */
    static async sleep(delay) {
        return new Promise((resolve) => setTimeout(resolve, delay.seconds * 1000));
    }
    /**
     * Run a predicate repeatedly, waiting until it returns true or until the timeout elapses.
     * If the timeout elapses, the function throws an error.
     *
     * Alternatively, you can pass `throws: false` to suppress the error, and instead return a boolean
     * indicating whether the predicate returned true within the timeout.
     *
     * @param predicate The function that will be evaluated.
     * @param props Timeout and interval values, default to one 1m timeout and 0.1sec interval.
     * @throws Will throw if the given predicate throws.
     * @returns True if predicate is truthful within timeout.
     * @inflight
     */
    static async waitUntil(predicate, props = {}) {
        const timeout = props.timeout ?? std_1.Duration.fromMinutes(1);
        const interval = props.interval ?? std_1.Duration.fromSeconds(0.1);
        const f = predicate;
        let elapsed = 0;
        while (elapsed < timeout.seconds) {
            if (await f()) {
                return true;
            }
            // not taking account the real elapsed time just the sum of intervals till timeout
            // it might be that predicate takes a long time and it is not considered inside timeout
            elapsed += interval.seconds;
            await this.sleep(interval);
        }
        if (props.throws !== false) {
            throw new Error("Timeout elapsed");
        }
        return false;
    }
    /**
     * Computes the SHA256 hash of the given data.
     * @param data - The string to be hashed.
     */
    static sha256(data) {
        return (0, crypto_1.createHash)("sha256").update(data).digest("hex");
    }
    /**
     * Generates a version 4 UUID.
     */
    static uuidv4() {
        return (0, uuid_1.v4)();
    }
    /**
     * Generates a unique ID using the nanoid library.
     # @link https://github.com/ai/nanoid
     * @param options - Optional options object for generating the ID.
     */
    static nanoid(options) {
        const size = options?.size ?? 21;
        const nano = options?.alphabet
            ? (0, nanoid_1.customAlphabet)(options.alphabet, size)
            : undefined;
        return nano ? nano(size) : (0, nanoid_1.nanoid)(size);
    }
    /**
     * Generates universally unique lexicographically sortable identifier.
     # @link https://github.com/ulid/javascript
     * @param options - Optional options object for generating the ID.
     */
    static ulid(options) {
        const seed = options?.seed;
        return (0, ulid_1.ulid)(seed);
    }
    /**
     * Returns a string identifying the operating system platform.
     * @returns The operating system platform
     * @example "linux", "darwin", "win32"
     */
    static os() {
        return process.platform;
    }
    /**
     * @internal
     */
    static _toInflightType() {
        return core_1.InflightClient.forType(__filename, this.name);
    }
    constructor() { }
}
exports.Util = Util;
_a = JSII_RTTI_SYMBOL_1;
Util[_a] = { fqn: "@winglang/sdk.util.Util", version: "0.0.0" };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsL3V0aWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxpREFBK0M7QUFDL0MsbUNBQW9DO0FBQ3BDLCtCQUFpQztBQUNqQyxtQ0FBZ0Q7QUFDaEQsK0JBQTRCO0FBQzVCLCtCQUEwQjtBQUMxQixtREFBK0M7QUFDL0Msa0NBQXlDO0FBQ3pDLGdDQUE2QztBQUU3QyxNQUFNLFdBQVcsR0FBRyxJQUFBLGdCQUFTLEVBQUMsb0JBQUksQ0FBQyxDQUFDO0FBQ3BDLE1BQU0sZUFBZSxHQUFHLElBQUEsZ0JBQVMsRUFBQyx3QkFBUSxDQUFDLENBQUM7QUFFNUM7O0dBRUc7QUFDSCxJQUFZLEtBYVg7QUFiRCxXQUFZLEtBQUs7SUFDZjs7T0FFRztJQUNILDRCQUFtQixDQUFBO0lBQ25COztPQUVHO0lBQ0gsdUJBQWMsQ0FBQTtJQUNkOztPQUVHO0lBQ0gsd0JBQWUsQ0FBQTtBQUNqQixDQUFDLEVBYlcsS0FBSyxxQkFBTCxLQUFLLFFBYWhCO0FBK0lEOztHQUVHO0FBQ0gsTUFBYSxJQUFJO0lBQ2Y7Ozs7OztPQU1HO0lBQ0ksTUFBTSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQ3ZCLE9BQWUsRUFDZixJQUFtQjtRQUVuQixNQUFNLFNBQVMsR0FBRztZQUNoQixXQUFXLEVBQUUsSUFBSTtZQUNqQixHQUFHLEVBQUUsSUFBSSxFQUFFLEdBQUc7WUFDZCxHQUFHLEVBQ0QsSUFBSSxFQUFFLFVBQVUsS0FBSyxJQUFJO2dCQUN2QixDQUFDLENBQUMsRUFBRSxHQUFHLE9BQU8sQ0FBQyxHQUFHLEVBQUUsR0FBRyxJQUFJLEVBQUUsR0FBRyxFQUFFO2dCQUNsQyxDQUFDLENBQUMsRUFBRSxHQUFHLElBQUksRUFBRSxHQUFHLEVBQUU7U0FDdkIsQ0FBQztRQUVGLE1BQU0sa0JBQWtCLEdBQUcsQ0FBQyxLQUFVLEVBQVUsRUFBRTtZQUNoRCxJQUFJLEtBQUssQ0FBQyxNQUFN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QyxTQUFTLENBQUM7UUFDZCxPQUFPLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFBLGVBQU0sRUFBQyxJQUFJLENBQUMsQ0FBQztJQUMxQyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBcUI7UUFDdEMsTUFBTSxJQUFJLEdBQUcsT0FBTyxFQUFFLElBQUksQ0FBQztRQUMzQixPQUFPLElBQUEsV0FBSSxFQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3BCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksTUFBTSxDQUFDLEVBQUU7UUFDZCxPQUFPLE9BQU8sQ0FBQyxRQUFRLENBQUM7SUFDMUIsQ0FBQztJQUVEOztPQUVHO0lBQ0ksTUFBTSxDQUFDLGVBQWU7UUFDM0IsT0FBTyxxQkFBYyxDQUFDLE9BQU8sQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3ZELENBQUM7SUFDRCxnQkFBdUIsQ0FBQzs7QUE1UDFCLG9CQTZQQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGV4ZWMsIGV4ZWNGaWxlIH0gZnJvbSBcImNoaWxkX3Byb2Nlc3NcIjtcbmltcG9ydCB7IGNyZWF0ZUhhc2ggfSBmcm9tIFwiY3J5cHRvXCI7XG5pbXBvcnQgeyBwcm9taXNpZnkgfSBmcm9tIFwidXRpbFwiO1xuaW1wb3J0IHsgbmFub2lkLCBjdXN0b21BbHBoYWJldCB9IGZyb20gXCJuYW5vaWRcIjtcbmltcG9ydCB7IHVsaWQgfSBmcm9tIFwidWxpZFwiO1xuaW1wb3J0IHsgdjQgfSBmcm9tIFwidXVpZFwiO1xuaW1wb3J0IHsgQ2hpbGRQcm9jZXNzIH0gZnJvbSBcIi4vY2hpbGQtcHJvY2Vzc1wiO1xuaW1wb3J0IHsgSW5mbGlnaHRDbGllbnQgfSBmcm9tIFwiLi4vY29yZVwiO1xuaW1wb3J0IHsgRHVyYXRpb24sIElJbmZsaWdodCB9IGZyb20gXCIuLi9zdGRcIjtcblxuY29uc3QgZXhlY1Byb21pc2UgPSBwcm9taXNpZnkoZXhlYyk7XG5jb25zdCBleGVjRmlsZVByb21pc2UgPSBwcm9taXNpZnkoZXhlY0ZpbGUpO1xuXG4vKipcbiAqIERlc2NyaWJlcyB3aGF0IHRvIGRvIHdpdGggYSBzdGFuZGFyZCBJL08gc3RyZWFtIGZvciBhIGNoaWxkIHByb2Nlc3MuXG4gKi9cbmV4cG9ydCBlbnVtIFN0ZGlvIHtcbiAgLyoqXG4gICAqIFRoZSBjaGlsZCBpbmhlcml0cyBmcm9tIHRoZSBjb3JyZXNwb25kaW5nIHBhcmVudCBkZXNjcmlwdG9yLlxuICAgKi9cbiAgSU5IRVJJVCA9IFwiaW5oZXJpdFwiLFxuICAvKipcbiAgICogQSBuZXcgcGlwZSBzaG91bGQgYmUgYXJyYW5nZWQgdG8gY29ubmVjdCB0aGUgcGFyZW50IGFuZCBjaGlsZCBwcm9jZXNzZXMuXG4gICAqL1xuICBQSVBFRCA9IFwicGlwZVwiLFxuICAvKipcbiAgICogVGhpcyBzdHJlYW0gd2lsbCBiZSBpZ25vcmVkLiBUaGlzIGlzIHRoZSBlcXVpdmFsZW50IG9mIGF0dGFjaGluZyB0aGUgc3RyZWFtIHRvIC9kZXYvbnVsbC5cbiAgICovXG4gIE5VTEwgPSBcImlnbm9yZVwiLFxufVxuXG4vKipcbiAqIE91dHB1dCBvZiBhIGZpbmlzaGVkIHByb2Nlc3MuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgT3V0cHV0IHtcbiAgLyoqXG4gICAqIFRoZSBzdGFuZGFyZCBvdXRwdXQgb2YgYSBmaW5pc2hlZCBwcm9jZXNzLlxuICAgKi9cbiAgcmVhZG9ubHkgc3Rkb3V0OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgc3RhbmRhcmQgZXJyb3Igb2YgYSBmaW5pc2hlZCBwcm9jZXNzLlxuICAgKi9cbiAgcmVhZG9ubHkgc3RkZXJyOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBBIHByb2Nlc3MncyBleGl0IHN0YXR1cy5cbiAgICovXG4gIHJlYWRvbmx5IHN0YXR1czogbnVtYmVyO1xufVxuXG4vKipcbiAqIEJhc2UgY29tbWFuZCBvcHRpb25zLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENvbW1hbmRPcHRpb25zIHtcbiAgLyoqXG4gICAqIFBhdGggdG8gYSBkaXJlY3RvcnkgdG8gcnVuIHRoZSBjb21tYW5kIGluLlxuICAgKiBAZGVmYXVsdCAtIHRoZSBkZWZhdWx0IHdvcmtpbmcgZGlyZWN0b3J5IG9mIHRoZSBob3N0XG4gICAqL1xuICByZWFkb25seSBjd2Q/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBFbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gICAqIEBkZWZhdWx0IC0gbm8gZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gICAqL1xuICByZWFkb25seSBlbnY/OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xuICAvKipcbiAgICogV2hldGhlciB0byBpbmhlcml0IGVudmlyb25tZW50IHZhcmlhYmxlcyBmcm9tIHRoZSBob3N0J3MgZW52aXJvbm1lbnQuXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICByZWFkb25seSBpbmhlcml0RW52PzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIGB1dGlsLmV4ZWMoKWBcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFeGVjT3B0aW9ucyBleHRlbmRzIENvbW1hbmRPcHRpb25zIHt9XG5cbi8qKlxuICogQWRkaXRpb25hbCBvcHRpb25zIGZvciBgdXRpbC5zaGVsbCgpYFxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNoZWxsT3B0aW9ucyBleHRlbmRzIENvbW1hbmRPcHRpb25zIHtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gdGhyb3cgYW4gZXJyb3Igb24gY29tbWFuZCBleGVjdXRpb24gZmFpbHVyZS5cbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgcmVhZG9ubHkgdGhyb3c/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgYHV0aWwuc3Bhd24oKWBcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTcGF3bk9wdGlvbnMgZXh0ZW5kcyBDb21tYW5kT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBDb25maWd1cmF0aW9uIGZvciB0aGUgcHJvY2VzcydzIHN0YW5kYXJkIGlucHV0IHN0cmVhbS5cbiAgICogQGRlZmF1bHQgLSBTdGRpby5JTkhFUklUXG4gICAqL1xuICByZWFkb25seSBzdGRpbj86IFN0ZGlvO1xuICAvKipcbiAgICogQ29uZmlndXJhdGlvbiBmb3IgdGhlIHByb2Nlc3MncyBzdGFuZGFyZCBvdXRwdXQgc3RyZWFtLlxuICAgKiBAZGVmYXVsdCAtIFN0ZGlvLklOSEVSSVRcbiAgICovXG4gIHJlYWRvbmx5IHN0ZG91dD86IFN0ZGlvO1xuICAvKipcbiAgICogQ29uZmlndXJhdGlvbiBmb3IgdGhlIHByb2Nlc3MncyBzdGFuZGFyZCBlcnJvciBzdHJlYW0uXG4gICAqIEBkZWZhdWx0IC0gU3RkaW8uSU5IRVJJVFxuICAgKi9cbiAgcmVhZG9ubHkgc3RkZXJyPzogU3RkaW87XG59XG5cbi8qKlxuICogUHJvcGVydGllcyBmb3IgYHV0aWwud2FpdFVudGlsYC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBXYWl0VW50aWxQcm9wcyB7XG4gIC8qKlxuICAgKiBUaGUgdGltZW91dCBmb3Iga2VlcCB0cnlpbmcgcHJlZGljYXRlXG4gICAqIEBkZWZhdWx0IDFtXG4gICAqL1xuICByZWFkb25seSB0aW1lb3V0PzogRHVyYXRpb247XG4gIC8qKlxuICAgKiBJbnRlcnZhbCBiZXR3ZWVuIHByZWRpY2F0ZSByZXRyaWVzXG4gICAqIEBkZWZhdWx0IDAuMXNcbiAgICovXG4gIHJlYWRvbmx5IGludGVydmFsPzogRHVyYXRpb247XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHRocm93IGFuIGVycm9yIGlmIHRoZSB0aW1lb3V0IGVsYXBzZXMuXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHJlYWRvbmx5IHRocm93cz86IGJvb2xlYW47XG59XG5cbi8qKlxuICogQSBwcmVkaWNhdGUgd2l0aCBhbiBpbmZsaWdodCBcImhhbmRsZVwiIG1ldGhvZCB0aGF0IGNhbiBiZSBwYXNzZWQgdG9cbiAqIGB1dGlsLmJ1c3lXYWl0YC5cbiAqIEBpbmZsaWdodCBgQHdpbmdsYW5nL3Nkay51dGlsLklQcmVkaWNhdGVIYW5kbGVyQ2xpZW50YFxuICovXG5leHBvcnQgaW50ZXJmYWNlIElQcmVkaWNhdGVIYW5kbGVyIGV4dGVuZHMgSUluZmxpZ2h0IHt9XG5cbi8qKlxuICogSW5mbGlnaHQgY2xpZW50IGZvciBgSVByZWRpY2F0ZUhhbmRsZXJgLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIElQcmVkaWNhdGVIYW5kbGVyQ2xpZW50IHtcbiAgLyoqXG4gICAqIFRoZSBQcmVkaWNhdGUgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWRcbiAgICogQGluZmxpZ2h0XG4gICAqL1xuICBoYW5kbGUoKTogUHJvbWlzZTxib29sZWFuPjtcbn1cblxuLyoqXG4gKiBPcHRpb25zIHRvIGdlbmVyYXRpbmcgYSB1bmlxdWUgSURcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOYW5vaWRPcHRpb25zIHtcbiAgLyoqXG4gICAqIFNpemUgb2YgSURcbiAgICogQGRlZmF1bHQgMjFcbiAgICovXG4gIHJlYWRvbmx5IHNpemU/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBDaGFyYWN0ZXJzIHRoYXQgbWFrZSB1cCB0aGUgYWxwaGFiZXQgdG8gZ2VuZXJhdGUgdGhlIElELCBsaW1pdGVkIHRvIDI1NiBjaGFyYWN0ZXJzIG9yIGZld2VyLlxuICAgKi9cbiAgcmVhZG9ubHkgYWxwaGFiZXQ/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogT3B0aW9ucyB0byBnZW5lcmF0ZSB1bml2ZXJzYWxseSB1bmlxdWUgbGV4aWNvZ3JhcGhpY2FsbHkgc29ydGFibGUgaWRlbnRpZmllcnMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVWxpZE9wdGlvbnMge1xuICAvKipcbiAgICogWW91IGNhbiBhbHNvIGlucHV0IGEgc2VlZCB0aW1lIHdoaWNoIHdpbGwgY29uc2lzdGVudGx5IGdpdmUgeW91IHRoZSBzYW1lIHN0cmluZyBmb3IgdGhlIHRpbWUgY29tcG9uZW50LiBUaGlzIGlzIHVzZWZ1bCBmb3IgbWlncmF0aW5nIHRvIHVsaWQuXG4gICAqIEBkZWZhdWx0IERhdGUubm93KClcbiAgICovXG4gIHJlYWRvbmx5IHNlZWQ/OiBudW1iZXI7XG59XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBVdGlsIHtcbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGEgY29tbWFuZCBpbiB0aGUgc2hlbGwgYW5kIHJldHVybnMgaXRzIHN0YW5kYXJkIG91dHB1dC5cbiAgICogQHBhcmFtIGNvbW1hbmQgVGhlIGNvbW1hbmQgc3RyaW5nIHRvIGV4ZWN1dGUgaW4gdGhlIHNoZWxsLlxuICAgKiBAcGFyYW0gb3B0cyBgU2hlbGxPcHRpb25zYCwgc3VjaCBhcyB0aGUgd29ya2luZyBkaXJlY3RvcnkgYW5kIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAgICogQHJldHVybnMgVGhlIHN0YW5kYXJkIG91dHB1dCBvZiB0aGUgc2hlbGwgY29tbWFuZC5cbiAgICogQHRocm93cyBBbiBlcnJvciBpZiB0aGUgc2hlbGwgY29tbWFuZCBleGVjdXRpb24gZmFpbHMgb3IgcmV0dXJucyBhIG5vbi16ZXJvIGV4aXQgY29kZS5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgYXN5bmMgc2hlbGwoXG4gICAgY29tbWFuZDogc3RyaW5nLFxuICAgIG9wdHM/OiBTaGVsbE9wdGlvbnNcbiAgKTogUHJvbWlzZTxTdHJpbmc+IHtcbiAgICBjb25zdCBzaGVsbE9wdHMgPSB7XG4gICAgICB3aW5kb3dzSGlkZTogdHJ1ZSxcbiAgICAgIGN3ZDogb3B0cz8uY3dkLFxuICAgICAgZW52OlxuICAgICAgICBvcHRzPy5pbmhlcml0RW52ID09PSB0cnVlXG4gICAgICAgICAgPyB7IC4uLnByb2Nlc3MuZW52LCAuLi5vcHRzPy5lbnYgfVxuICAgICAgICAgIDogeyAuLi5vcHRzPy5lbnYgfSxcbiAgICB9O1xuXG4gICAgY29uc3QgY3JlYXRlRXJyb3JNZXNzYWdlID0gKGVycm9yOiBhbnkpOiBzdHJpbmcgPT4ge1xuICAgICAgaWYgKGVycm9yLnN0ZGVycikge1xuICAgICAgICByZXR1cm4gYEVycm9yIGV4ZWN1dGluZyBjb21tYW5kIFwiJHtjb21tYW5kfVwiLiBFeGl0ZWQgd2l0aCBlcnJvcjogJHtlcnJvci5zdGRlcnJ9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBgRXJyb3IgZXhlY3V0aW5nIGNvbW1hbmQgXCIke2NvbW1hbmR9XCIuIEV4aXRlZCB3aXRoIGVycm9yIGNvZGU6ICR7ZXJyb3IuY29kZX1gO1xuICAgIH07XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBzdGRvdXQgfSA9IGF3YWl0IGV4ZWNQcm9taXNlKGNvbW1hbmQsIHNoZWxsT3B0cyk7XG4gICAgICByZXR1cm4gc3Rkb3V0LnRvU3RyaW5nKCk7XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gY3JlYXRlRXJyb3JNZXNzYWdlKGVycm9yKTtcblxuICAgICAgaWYgKG9wdHM/LnRocm93ICE9PSBmYWxzZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVycm9yTWVzc2FnZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZSBhIHByb2dyYW0gd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzLCB3YWl0IGZvciBpdCB0byBmaW5pc2gsIGFuZFxuICAgKiByZXR1cm4gaXRzIG91dHB1dHMuXG4gICAqIEBwYXJhbSBwcm9ncmFtIFRoZSBwcm9ncmFtIHRvIGV4ZWN1dGUuXG4gICAqIEBwYXJhbSBhcmdzIEFuIGFycmF5IG9mIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBwcm9ncmFtLlxuICAgKiBAcGFyYW0gb3B0cyBgRXhlY09wdGlvbnNgLCBzdWNoIGFzIHRoZSB3b3JraW5nIGRpcmVjdG9yeSBhbmQgZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICAgKiBAcmV0dXJucyBBIHN0cnVjdCBjb250YWluaW5nIGBzdGRvdXRgLCBgc3RkZXJyYCBhbmQgZXhpdCBgc3RhdHVzYCBvZiB0aGUgZXhlY3V0ZWQgcHJvZ3JhbS5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgYXN5bmMgZXhlYyhcbiAgICBwcm9ncmFtOiBzdHJpbmcsXG4gICAgYXJnczogQXJyYXk8c3RyaW5nPixcbiAgICBvcHRzPzogRXhlY09wdGlvbnNcbiAgKTogUHJvbWlzZTxPdXRwdXQ+IHtcbiAgICBjb25zdCBleGVjT3B0cyA9IHtcbiAgICAgIHdpbmRvd3NIaWRlOiB0cnVlLFxuICAgICAgc2hlbGw6IGZhbHNlLFxuICAgICAgY3dkOiBvcHRzPy5jd2QsXG4gICAgICBlbnY6XG4gICAgICAgIG9wdHM/LmluaGVyaXRFbnYgPT09IHRydWVcbiAgICAgICAgICA/IHsgLi4ucHJvY2Vzcy5lbnYsIC4uLm9wdHM/LmVudiB9XG4gICAgICAgICAgOiB7IC4uLm9wdHM/LmVudiB9LFxuICAgIH07XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBzdGRvdXQsIHN0ZGVyciB9ID0gYXdhaXQgZXhlY0ZpbGVQcm9taXNlKHByb2dyYW0sIGFyZ3MsIGV4ZWNPcHRzKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0ZG91dDogc3Rkb3V0LnRvU3RyaW5nKCksXG4gICAgICAgIHN0ZGVycjogc3RkZXJyLnRvU3RyaW5nKCksXG4gICAgICAgIHN0YXR1czogMCxcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgaWYgKGVycm9yLmNvZGUgPT09IFwiRU5PRU5UXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcm9ncmFtIG5vdCBmb3VuZDogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdGRvdXQ6IGVycm9yLnN0ZG91dC50b1N0cmluZygpLFxuICAgICAgICAgIHN0ZGVycjogZXJyb3Iuc3RkZXJyLnRvU3RyaW5nKCksXG4gICAgICAgICAgc3RhdHVzOiBlcnJvci5jb2RlLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlIGEgcHJvZ3JhbSB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHMsIGFuZCByZXR1cm4gYSBgQ2hpbGRQcm9jZXNzYFxuICAgKiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBpbnRlcmFjdCB3aXRoIHRoZSBwcm9jZXNzIHdoaWxlIGl0IGlzIHJ1bm5pbmcuXG4gICAqIEBwYXJhbSBwcm9ncmFtIC0gVGhlIHByb2dyYW0gdG8gZXhlY3V0ZS5cbiAgICogQHBhcmFtIGFyZ3MgLSBBbiBhcnJheSBvZiBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgcHJvZ3JhbS5cbiAgICogQHBhcmFtIG9wdHMgLSBTcGF3biBvcHRpb25zIGluY2x1ZGluZyB3b3JraW5nIGRpcmVjdG9yeSwgZW52aXJvbm1lbnQgdmFyaWFibGVzLCBhbmQgc3RkaW8gY29uZmlndXJhdGlvbnMuXG4gICAqIEByZXR1cm5zIFRoZSBgQ2hpbGRQcm9jZXNzYCBpbnN0YW5jZSBhc3NvY2lhdGVkIHdpdGggdGhlIHNwYXduZWQgcHJvY2Vzcy5cbiAgICogQGluZmxpZ2h0XG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHNwYXduKFxuICAgIHByb2dyYW06IHN0cmluZyxcbiAgICBhcmdzOiBBcnJheTxzdHJpbmc+LFxuICAgIG9wdHM/OiBTcGF3bk9wdGlvbnNcbiAgKTogQ2hpbGRQcm9jZXNzIHtcbiAgICByZXR1cm4gbmV3IENoaWxkUHJvY2Vzcyhwcm9ncmFtLCBhcmdzLCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiBhbiBlbnZpcm9ubWVudCB2YXJpYWJsZS4gVGhyb3dzIGlmIG5vdCBmb3VuZCBvciBlbXB0eS5cbiAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGVudmlyb25tZW50IHZhcmlhYmxlLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBlbnYobmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCB2YWx1ZSA9IFV0aWwudHJ5RW52KG5hbWUpO1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRW52aXJvbm1lbnQgdmFyaWFibGUgJHtuYW1lfSBub3QgZm91bmQuYCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiBhbiBlbnZpcm9ubWVudCB2YXJpYWJsZS4gUmV0dXJucyBgbmlsYCBpZiBub3QgZm91bmQgb3IgZW1wdHkuXG4gICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZS5cbiAgICogQHJldHVybnMgVGhlIHZhbHVlIG9mIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZSBvciBgbmlsYC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgdHJ5RW52KG5hbWU6IHN0cmluZyk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52W25hbWVdO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGdpdmVuIG5hbWUgYW5kIHZhbHVlIGFzIGFuIGVudmlyb25tZW50IHZhcmlhYmxlLlxuICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGUuXG4gICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhlIGVudmlyb25tZW50IHZhcmlhYmxlLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBzZXRFbnYobmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKSB7XG4gICAgcHJvY2Vzcy5lbnZbbmFtZV0gPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIHN0cmluZyBmcm9tIFVURi04IHRvIGJhc2U2NC5cbiAgICogQHBhcmFtIHN0cmluZ1RvRW5jb2RlIFRoZSBuYW1lIG9mIHRoZSBVVEYtOCBzdHJpbmcgdG8gZW5jb2RlLlxuICAgKiBAcGFyYW0gdXJsIElmIGB0cnVlYCwgYSBVUkwtc2FmZSBiYXNlNjQgc3RyaW5nIGlzIHJldHVybmVkLlxuICAgKiBAcmV0dXJucyBUaGUgYmFzZTY0IHN0cmluZy5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgYmFzZTY0RW5jb2RlKHN0cmluZ1RvRW5jb2RlOiBzdHJpbmcsIHVybD86IGJvb2xlYW4pOiBzdHJpbmcge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzdHJpbmdUb0VuY29kZSkudG9TdHJpbmcodXJsID8gXCJiYXNlNjR1cmxcIiA6IFwiYmFzZTY0XCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgc3RyaW5nIGZyb20gYmFzZTY0IHRvIFVURi04LlxuICAgKiBAcGFyYW0gc3RyaW5nVG9EZWNvZGUgYmFzZTY0IHN0cmluZyB0byBkZWNvZGUuXG4gICAqIEBwYXJhbSB1cmwgSWYgYHRydWVgLCB0aGUgc291cmNlIGlzIGV4cGVjdGVkIHRvIGJlIGEgVVJMLXNhZmUgYmFzZTY0IHN0cmluZy5cbiAgICogQHJldHVybnMgVGhlIFVURi04IHN0cmluZy5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgYmFzZTY0RGVjb2RlKHN0cmluZ1RvRGVjb2RlOiBzdHJpbmcsIHVybD86IGJvb2xlYW4pOiBzdHJpbmcge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzdHJpbmdUb0RlY29kZSwgdXJsID8gXCJiYXNlNjR1cmxcIiA6IFwiYmFzZTY0XCIpLnRvU3RyaW5nKFxuICAgICAgXCJ1dGY4XCJcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1c3BlbmRzIGV4ZWN1dGlvbiBmb3IgYSBnaXZlbiBkdXJhdGlvbi5cbiAgICogQHBhcmFtIGRlbGF5IFRoZSB0aW1lIHRvIHN1c3BlbmQgZXhlY3V0aW9uLlxuICAgKiBAaW5mbGlnaHRcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgYXN5bmMgc2xlZXAoZGVsYXk6IER1cmF0aW9uKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5LnNlY29uZHMgKiAxMDAwKSk7XG4gIH1cblxuICAvKipcbiAgICogUnVuIGEgcHJlZGljYXRlIHJlcGVhdGVkbHksIHdhaXRpbmcgdW50aWwgaXQgcmV0dXJucyB0cnVlIG9yIHVudGlsIHRoZSB0aW1lb3V0IGVsYXBzZXMuXG4gICAqIElmIHRoZSB0aW1lb3V0IGVsYXBzZXMsIHRoZSBmdW5jdGlvbiB0aHJvd3MgYW4gZXJyb3IuXG4gICAqXG4gICAqIEFsdGVybmF0aXZlbHksIHlvdSBjYW4gcGFzcyBgdGhyb3dzOiBmYWxzZWAgdG8gc3VwcHJlc3MgdGhlIGVycm9yLCBhbmQgaW5zdGVhZCByZXR1cm4gYSBib29sZWFuXG4gICAqIGluZGljYXRpbmcgd2hldGhlciB0aGUgcHJlZGljYXRlIHJldHVybmVkIHRydWUgd2l0aGluIHRoZSB0aW1lb3V0LlxuICAgKlxuICAgKiBAcGFyYW0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXZhbHVhdGVkLlxuICAgKiBAcGFyYW0gcHJvcHMgVGltZW91dCBhbmQgaW50ZXJ2YWwgdmFsdWVzLCBkZWZhdWx0IHRvIG9uZSAxbSB0aW1lb3V0IGFuZCAwLjFzZWMgaW50ZXJ2YWwuXG4gICAqIEB0aHJvd3MgV2lsbCB0aHJvdyBpZiB0aGUgZ2l2ZW4gcHJlZGljYXRlIHRocm93cy5cbiAgICogQHJldHVybnMgVHJ1ZSBpZiBwcmVkaWNhdGUgaXMgdHJ1dGhmdWwgd2l0aGluIHRpbWVvdXQuXG4gICAqIEBpbmZsaWdodFxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBhc3luYyB3YWl0VW50aWwoXG4gICAgcHJlZGljYXRlOiBJUHJlZGljYXRlSGFuZGxlcixcbiAgICBwcm9wczogV2FpdFVudGlsUHJvcHMgPSB7fVxuICApOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCB0aW1lb3V0ID0gcHJvcHMudGltZW91dCA/PyBEdXJhdGlvbi5mcm9tTWludXRlcygxKTtcbiAgICBjb25zdCBpbnRlcnZhbCA9IHByb3BzLmludGVydmFsID8/IER1cmF0aW9uLmZyb21TZWNvbmRzKDAuMSk7XG4gICAgY29uc3QgZiA9IHByZWRpY2F0ZSBhcyBhbnk7XG4gICAgbGV0IGVsYXBzZWQgPSAwO1xuICAgIHdoaWxlIChlbGFwc2VkIDwgdGltZW91dC5zZWNvbmRzKSB7XG4gICAgICBpZiAoYXdhaXQgZigpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgLy8gbm90IHRha2luZyBhY2NvdW50IHRoZSByZWFsIGVsYXBzZWQgdGltZSBqdXN0IHRoZSBzdW0gb2YgaW50ZXJ2YWxzIHRpbGwgdGltZW91dFxuICAgICAgLy8gaXQgbWlnaHQgYmUgdGhhdCBwcmVkaWNhdGUgdGFrZXMgYSBsb25nIHRpbWUgYW5kIGl0IGlzIG5vdCBjb25zaWRlcmVkIGluc2lkZSB0aW1lb3V0XG4gICAgICBlbGFwc2VkICs9IGludGVydmFsLnNlY29uZHM7XG4gICAgICBhd2FpdCB0aGlzLnNsZWVwKGludGVydmFsKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLnRocm93cyAhPT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRpbWVvdXQgZWxhcHNlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBTSEEyNTYgaGFzaCBvZiB0aGUgZ2l2ZW4gZGF0YS5cbiAgICogQHBhcmFtIGRhdGEgLSBUaGUgc3RyaW5nIHRvIGJlIGhhc2hlZC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgc2hhMjU2KGRhdGE6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGNyZWF0ZUhhc2goXCJzaGEyNTZcIikudXBkYXRlKGRhdGEpLmRpZ2VzdChcImhleFwiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSB2ZXJzaW9uIDQgVVVJRC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgdXVpZHY0KCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHY0KCk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgdW5pcXVlIElEIHVzaW5nIHRoZSBuYW5vaWQgbGlicmFyeS5cbiAgICMgQGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2FpL25hbm9pZFxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IGZvciBnZW5lcmF0aW5nIHRoZSBJRC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbmFub2lkKG9wdGlvbnM/OiBOYW5vaWRPcHRpb25zKTogc3RyaW5nIHtcbiAgICBjb25zdCBzaXplID0gb3B0aW9ucz8uc2l6ZSA/PyAyMTtcbiAgICBjb25zdCBuYW5vID0gb3B0aW9ucz8uYWxwaGFiZXRcbiAgICAgID8gY3VzdG9tQWxwaGFiZXQob3B0aW9ucy5hbHBoYWJldCwgc2l6ZSlcbiAgICAgIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiBuYW5vID8gbmFubyhzaXplKSA6IG5hbm9pZChzaXplKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgdW5pdmVyc2FsbHkgdW5pcXVlIGxleGljb2dyYXBoaWNhbGx5IHNvcnRhYmxlIGlkZW50aWZpZXIuXG4gICAjIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS91bGlkL2phdmFzY3JpcHRcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbCBvcHRpb25zIG9iamVjdCBmb3IgZ2VuZXJhdGluZyB0aGUgSUQuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHVsaWQob3B0aW9ucz86IFVsaWRPcHRpb25zKTogc3RyaW5nIHtcbiAgICBjb25zdCBzZWVkID0gb3B0aW9ucz8uc2VlZDtcbiAgICByZXR1cm4gdWxpZChzZWVkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIGlkZW50aWZ5aW5nIHRoZSBvcGVyYXRpbmcgc3lzdGVtIHBsYXRmb3JtLlxuICAgKiBAcmV0dXJucyBUaGUgb3BlcmF0aW5nIHN5c3RlbSBwbGF0Zm9ybVxuICAgKiBAZXhhbXBsZSBcImxpbnV4XCIsIFwiZGFyd2luXCIsIFwid2luMzJcIlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBvcygpOiBzdHJpbmcge1xuICAgIHJldHVybiBwcm9jZXNzLnBsYXRmb3JtO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBfdG9JbmZsaWdodFR5cGUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gSW5mbGlnaHRDbGllbnQuZm9yVHlwZShfX2ZpbGVuYW1lLCB0aGlzLm5hbWUpO1xuICB9XG4gIHByaXZhdGUgY29uc3RydWN0b3IoKSB7fVxufVxuIl19