"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestRunner = void 0;
const terraform_output_1 = require("cdktf/lib/terraform-output");
const tokens_1 = require("cdktf/lib/tokens");
const function_1 = require("./function");
const core = __importStar(require("../core"));
const std = __importStar(require("../std"));
const OUTPUT_TEST_RUNNER_FUNCTION_IDENTIFIERS = "WING_TEST_RUNNER_FUNCTION_IDENTIFIERS";
/**
 * Tf-Azure implementation of `cloud.TestRunner`.
 *
 * @inflight `@winglang/sdk.cloud.ITestRunnerClient`
 */
class TestRunner extends std.TestRunner {
    constructor(scope, id, props = {}) {
        super(scope, id, props);
        // This output is created so the CLI's `wing test` command can obtain a list
        // of all names of test functions by running `terraform output`.
        const output = new terraform_output_1.TerraformOutput(this, "TestFunctionIdentifiers", {
            value: tokens_1.Lazy.stringValue({
                produce: () => {
                    return JSON.stringify([
                        ...this.getTestFunctionIdentifiers().entries(),
                    ]);
                },
            }),
        });
        output.overrideLogicalId(OUTPUT_TEST_RUNNER_FUNCTION_IDENTIFIERS);
    }
    onLift(host, ops) {
        if (!(host instanceof function_1.Function)) {
            throw new Error("TestRunner can only be bound by tfgcp.Function for now");
        }
        const { region, projectId } = core.App.of(this);
        const testFunctions = this.getTestFunctionIdentifiers();
        host.addEnvironment(this.envTestFunctionIdentifiers(), JSON.stringify([...testFunctions.entries()]));
        host.addEnvironment(this.projectEnv(), projectId);
        host.addEnvironment(this.regionEnv(), region);
        super.onLift(host, ops);
    }
    /** @internal */
    _preSynthesize() {
        // add a dependency on each test function
        for (const test of this.findTests()) {
            if (test._fn) {
                this.node.addDependency(test._fn);
            }
        }
        super._preSynthesize();
    }
    getTestFunctionIdentifiers() {
        const arns = new Map();
        for (const test of this.findTests()) {
            if (test._fn) {
                if (!(test._fn instanceof function_1.Function)) {
                    throw new Error(`Unsupported test function type, ${test._fn.node.path} was not a tfgcp.Function`);
                }
                arns.set(test.node.path, test._fn.functionName);
            }
        }
        return arns;
    }
    /** @internal */
    _toInflight() {
        return core.InflightClient.for(__dirname, __filename, "TestRunnerClient", [
            `process.env["${this.envTestFunctionIdentifiers()}"]`,
            `process.env["${this.projectEnv()}"]`,
            `process.env["${this.regionEnv()}"]`,
        ]);
    }
    envTestFunctionIdentifiers() {
        return `TEST_RUNNER_FUNCTIONS_${this.node.addr.slice(-8)}`;
    }
    regionEnv() {
        return `REGION_${this.node.addr.slice(-8)}`;
    }
    projectEnv() {
        return `PROJECT_${this.node.addr.slice(-8)}`;
    }
}
exports.TestRunner = TestRunner;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVzdC1ydW5uZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvdGFyZ2V0LXRmLWdjcC90ZXN0LXJ1bm5lci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGlFQUE2RDtBQUM3RCw2Q0FBd0M7QUFHeEMseUNBQXFEO0FBQ3JELDhDQUFnQztBQUNoQyw0Q0FBOEI7QUFFOUIsTUFBTSx1Q0FBdUMsR0FDM0MsdUNBQXVDLENBQUM7QUFFMUM7Ozs7R0FJRztBQUNILE1BQWEsVUFBVyxTQUFRLEdBQUcsQ0FBQyxVQUFVO0lBQzVDLFlBQVksS0FBZ0IsRUFBRSxFQUFVLEVBQUUsUUFBNkIsRUFBRTtRQUN2RSxLQUFLLENBQUMsS0FBSyxFQUFFLEVBQUUsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUN4Qiw0RUFBNEU7UUFDNUUsZ0VBQWdFO1FBQ2hFLE1BQU0sTUFBTSxHQUFHLElBQUksa0NBQWUsQ0FBQyxJQUFJLEVBQUUseUJBQXlCLEVBQUU7WUFDbEUsS0FBSyxFQUFFLGFBQUksQ0FBQyxXQUFXLENBQUM7Z0JBQ3RCLE9BQU8sRUFBRSxHQUFHLEVBQUU7b0JBQ1osT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDO3dCQUNwQixHQUFHLElBQUksQ0FBQywwQkFBMEIsRUFBRSxDQUFDLE9BQU8sRUFBRTtxQkFDL0MsQ0FBQyxDQUFDO2dCQUNMLENBQUM7YUFDRixDQUFDO1NBQ0gsQ0FBQyxDQUFDO1FBRUgsTUFBTSxDQUFDLGlCQUFpQixDQUFDLHVDQUF1QyxDQUFDLENBQUM7SUFDcEUsQ0FBQztJQUVNLE1BQU0sQ0FBQyxJQUF1QixFQUFFLEdBQWE7UUFDbEQsSUFBSSxDQUFDLENBQUMsSUFBSSxZQUFZLG1CQUFXLENBQUMsRUFBRSxDQUFDO1lBQ25DLE1BQU0sSUFBSSxLQUFLLENBQUMsd0RBQXdELENBQUMsQ0FBQztRQUM1RSxDQUFDO1FBQ0QsTUFBTSxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQVcsQ0FBQztRQUMxRCxNQUFNLGFBQWEsR0FBRyxJQUFJLENBQUMsMEJBQTBCLEVBQUUsQ0FBQztRQUN4RCxJQUFJLENBQUMsY0FBYyxDQUNqQixJQUFJLENBQUMsMEJBQTBCLEVBQUUsRUFDakMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEdBQUcsYUFBYSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FDN0MsQ0FBQztRQUVGLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxFQUFFLFNBQVMsQ0FBQyxDQUFDO1FBQ2xELElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBRTlDLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQzFCLENBQUM7SUFFRCxnQkFBZ0I7SUFDVCxjQUFjO1FBQ25CLHlDQUF5QztRQUN6QyxLQUFLLE1BQU0sSUFBSSxJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUUsRUFBRSxDQUFDO1lBQ3BDLElBQUksSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO2dCQUNiLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNwQyxDQUFDO1FBQ0gsQ0FBQztRQUVELEtBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQztJQUN6QixDQUFDO0lBRU8sMEJBQTBCO1FBQ2hDLE1BQU0sSUFBSSxHQUFHLElBQUksR0FBRyxFQUFrQixDQUFDO1FBQ3ZDLEtBQUssTUFBTSxJQUFJLElBQUksSUFBSSxDQUFDLFNBQVMsRUFBRSxFQUFFLENBQUM7WUFDcEMsSUFBSSxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7Z0JBQ2IsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsWUFBWSxtQkFBVyxDQUFDLEVBQUUsQ0FBQztvQkFDdkMsTUFBTSxJQUFJLEtBQUssQ0FDYixtQ0FBbUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSwyQkFBMkIsQ0FDakYsQ0FBQztnQkFDSixDQUFDO2dCQUNELElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUcsSUFBSSxDQUFDLEdBQW1CLENBQUMsWUFBWSxDQUFDLENBQUM7WUFDbkUsQ0FBQztRQUNILENBQUM7UUFDRCxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRCxnQkFBZ0I7SUFDVCxXQUFXO1FBQ2hCLE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsU0FBUyxFQUFFLFVBQVUsRUFBRSxrQkFBa0IsRUFBRTtZQUN4RSxnQkFBZ0IsSUFBSSxDQUFDLDBCQUEwQixFQUFFLElBQUk7WUFDckQsZ0JBQWdCLElBQUksQ0FBQyxVQUFVLEVBQUUsSUFBSTtZQUNyQyxnQkFBZ0IsSUFBSSxDQUFDLFNBQVMsRUFBRSxJQUFJO1NBQ3JDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFTywwQkFBMEI7UUFDaEMsT0FBTyx5QkFBeUIsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztJQUM3RCxDQUFDO0lBRU8sU0FBUztRQUNmLE9BQU8sVUFBVSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO0lBQzlDLENBQUM7SUFFTyxVQUFVO1FBQ2hCLE9BQU8sV0FBVyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO0lBQy9DLENBQUM7Q0FDRjtBQWxGRCxnQ0FrRkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUZXJyYWZvcm1PdXRwdXQgfSBmcm9tIFwiY2RrdGYvbGliL3RlcnJhZm9ybS1vdXRwdXRcIjtcbmltcG9ydCB7IExhenkgfSBmcm9tIFwiY2RrdGYvbGliL3Rva2Vuc1wiO1xuaW1wb3J0IHsgQ29uc3RydWN0IH0gZnJvbSBcImNvbnN0cnVjdHNcIjtcbmltcG9ydCB7IEFwcCBhcyBHQ1BBcHAgfSBmcm9tIFwiLi9hcHBcIjtcbmltcG9ydCB7IEZ1bmN0aW9uIGFzIEdjcEZ1bmN0aW9uIH0gZnJvbSBcIi4vZnVuY3Rpb25cIjtcbmltcG9ydCAqIGFzIGNvcmUgZnJvbSBcIi4uL2NvcmVcIjtcbmltcG9ydCAqIGFzIHN0ZCBmcm9tIFwiLi4vc3RkXCI7XG5cbmNvbnN0IE9VVFBVVF9URVNUX1JVTk5FUl9GVU5DVElPTl9JREVOVElGSUVSUyA9XG4gIFwiV0lOR19URVNUX1JVTk5FUl9GVU5DVElPTl9JREVOVElGSUVSU1wiO1xuXG4vKipcbiAqIFRmLUF6dXJlIGltcGxlbWVudGF0aW9uIG9mIGBjbG91ZC5UZXN0UnVubmVyYC5cbiAqXG4gKiBAaW5mbGlnaHQgYEB3aW5nbGFuZy9zZGsuY2xvdWQuSVRlc3RSdW5uZXJDbGllbnRgXG4gKi9cbmV4cG9ydCBjbGFzcyBUZXN0UnVubmVyIGV4dGVuZHMgc3RkLlRlc3RSdW5uZXIge1xuICBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wczogc3RkLlRlc3RSdW5uZXJQcm9wcyA9IHt9KSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkLCBwcm9wcyk7XG4gICAgLy8gVGhpcyBvdXRwdXQgaXMgY3JlYXRlZCBzbyB0aGUgQ0xJJ3MgYHdpbmcgdGVzdGAgY29tbWFuZCBjYW4gb2J0YWluIGEgbGlzdFxuICAgIC8vIG9mIGFsbCBuYW1lcyBvZiB0ZXN0IGZ1bmN0aW9ucyBieSBydW5uaW5nIGB0ZXJyYWZvcm0gb3V0cHV0YC5cbiAgICBjb25zdCBvdXRwdXQgPSBuZXcgVGVycmFmb3JtT3V0cHV0KHRoaXMsIFwiVGVzdEZ1bmN0aW9uSWRlbnRpZmllcnNcIiwge1xuICAgICAgdmFsdWU6IExhenkuc3RyaW5nVmFsdWUoe1xuICAgICAgICBwcm9kdWNlOiAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFtcbiAgICAgICAgICAgIC4uLnRoaXMuZ2V0VGVzdEZ1bmN0aW9uSWRlbnRpZmllcnMoKS5lbnRyaWVzKCksXG4gICAgICAgICAgXSk7XG4gICAgICAgIH0sXG4gICAgICB9KSxcbiAgICB9KTtcblxuICAgIG91dHB1dC5vdmVycmlkZUxvZ2ljYWxJZChPVVRQVVRfVEVTVF9SVU5ORVJfRlVOQ1RJT05fSURFTlRJRklFUlMpO1xuICB9XG5cbiAgcHVibGljIG9uTGlmdChob3N0OiBzdGQuSUluZmxpZ2h0SG9zdCwgb3BzOiBzdHJpbmdbXSk6IHZvaWQge1xuICAgIGlmICghKGhvc3QgaW5zdGFuY2VvZiBHY3BGdW5jdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRlc3RSdW5uZXIgY2FuIG9ubHkgYmUgYm91bmQgYnkgdGZnY3AuRnVuY3Rpb24gZm9yIG5vd1wiKTtcbiAgICB9XG4gICAgY29uc3QgeyByZWdpb24sIHByb2plY3RJZCB9ID0gY29yZS5BcHAub2YodGhpcykgYXMgR0NQQXBwO1xuICAgIGNvbnN0IHRlc3RGdW5jdGlvbnMgPSB0aGlzLmdldFRlc3RGdW5jdGlvbklkZW50aWZpZXJzKCk7XG4gICAgaG9zdC5hZGRFbnZpcm9ubWVudChcbiAgICAgIHRoaXMuZW52VGVzdEZ1bmN0aW9uSWRlbnRpZmllcnMoKSxcbiAgICAgIEpTT04uc3RyaW5naWZ5KFsuLi50ZXN0RnVuY3Rpb25zLmVudHJpZXMoKV0pXG4gICAgKTtcblxuICAgIGhvc3QuYWRkRW52aXJvbm1lbnQodGhpcy5wcm9qZWN0RW52KCksIHByb2plY3RJZCk7XG4gICAgaG9zdC5hZGRFbnZpcm9ubWVudCh0aGlzLnJlZ2lvbkVudigpLCByZWdpb24pO1xuXG4gICAgc3VwZXIub25MaWZ0KGhvc3QsIG9wcyk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHB1YmxpYyBfcHJlU3ludGhlc2l6ZSgpOiB2b2lkIHtcbiAgICAvLyBhZGQgYSBkZXBlbmRlbmN5IG9uIGVhY2ggdGVzdCBmdW5jdGlvblxuICAgIGZvciAoY29uc3QgdGVzdCBvZiB0aGlzLmZpbmRUZXN0cygpKSB7XG4gICAgICBpZiAodGVzdC5fZm4pIHtcbiAgICAgICAgdGhpcy5ub2RlLmFkZERlcGVuZGVuY3kodGVzdC5fZm4pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN1cGVyLl9wcmVTeW50aGVzaXplKCk7XG4gIH1cblxuICBwcml2YXRlIGdldFRlc3RGdW5jdGlvbklkZW50aWZpZXJzKCk6IE1hcDxzdHJpbmcsIHN0cmluZz4ge1xuICAgIGNvbnN0IGFybnMgPSBuZXcgTWFwPHN0cmluZywgc3RyaW5nPigpO1xuICAgIGZvciAoY29uc3QgdGVzdCBvZiB0aGlzLmZpbmRUZXN0cygpKSB7XG4gICAgICBpZiAodGVzdC5fZm4pIHtcbiAgICAgICAgaWYgKCEodGVzdC5fZm4gaW5zdGFuY2VvZiBHY3BGdW5jdGlvbikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgVW5zdXBwb3J0ZWQgdGVzdCBmdW5jdGlvbiB0eXBlLCAke3Rlc3QuX2ZuLm5vZGUucGF0aH0gd2FzIG5vdCBhIHRmZ2NwLkZ1bmN0aW9uYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgYXJucy5zZXQodGVzdC5ub2RlLnBhdGgsICh0ZXN0Ll9mbiBhcyBHY3BGdW5jdGlvbikuZnVuY3Rpb25OYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFybnM7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHB1YmxpYyBfdG9JbmZsaWdodCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBjb3JlLkluZmxpZ2h0Q2xpZW50LmZvcihfX2Rpcm5hbWUsIF9fZmlsZW5hbWUsIFwiVGVzdFJ1bm5lckNsaWVudFwiLCBbXG4gICAgICBgcHJvY2Vzcy5lbnZbXCIke3RoaXMuZW52VGVzdEZ1bmN0aW9uSWRlbnRpZmllcnMoKX1cIl1gLFxuICAgICAgYHByb2Nlc3MuZW52W1wiJHt0aGlzLnByb2plY3RFbnYoKX1cIl1gLFxuICAgICAgYHByb2Nlc3MuZW52W1wiJHt0aGlzLnJlZ2lvbkVudigpfVwiXWAsXG4gICAgXSk7XG4gIH1cblxuICBwcml2YXRlIGVudlRlc3RGdW5jdGlvbklkZW50aWZpZXJzKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGBURVNUX1JVTk5FUl9GVU5DVElPTlNfJHt0aGlzLm5vZGUuYWRkci5zbGljZSgtOCl9YDtcbiAgfVxuXG4gIHByaXZhdGUgcmVnaW9uRW52KCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGBSRUdJT05fJHt0aGlzLm5vZGUuYWRkci5zbGljZSgtOCl9YDtcbiAgfVxuXG4gIHByaXZhdGUgcHJvamVjdEVudigpOiBzdHJpbmcge1xuICAgIHJldHVybiBgUFJPSkVDVF8ke3RoaXMubm9kZS5hZGRyLnNsaWNlKC04KX1gO1xuICB9XG59XG4iXX0=